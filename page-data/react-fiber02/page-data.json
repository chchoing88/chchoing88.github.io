{"componentChunkName":"component---src-templates-post-tsx","path":"/react-fiber02/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">이글</a>을 번역 및 분석 한 글입니다. 잘못된 번역 및 생략된 번역이 있을 수 있습니다.</p>\n<h1 id=\"inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react\" style=\"position:relative;\"><a href=\"#inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react\" aria-label=\"inside fiber in depth overview of the new reconciliation algorithm in react permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inside Fiber: in-depth overview of the new reconciliation algorithm in React</h1>\n<p>React 는 유저인터페이스를 만들기 위한 라이브러리 입니다. React 의 코어는 component 의 state 변화를 추적하고 해당 state 를 화면에 갱신해주는 것입니다. 우리는 React 안에서 이러한 프로세스를 <strong>reconciliation</strong> 으로 알고있습니다.</p>\n<p>우리는 setState 메서드를 호출하고 프레임워크가 state 또는 props 가 변했는지 체크하고 UI 에 그려진 component 를 다시 렌더링 합니다.</p>\n<p>React 의 문서는 React 엘리먼트, 라이프사이클 메서드 그리고 render 메서드 그리고 children 컴포넌트에 적용된 diffing 알고리즘 역활에 대해 좋은 설명을 제공하고 있습니다. render 메서드를 통해 리턴된 immutable 한 React elements 트리들이 공통적으로 \"vitual DOM\" 으로 알고있습니다. 이 용어는 초기에 사람들에게 React 을 설명하는 데 도움이되었습니다. 하지만 그것은 혼란을 야기하기도합니다. 그리고 React 문서 어디에도 사용하지 않습니다.</p>\n<p>이 글에서는 \"vitual DOM\"을 React element 들의 트리 라고 부르겠습니다.</p>\n<p>React element 들의 트리외에도 프레임워크 에는 state 를 유지하는 용도로 항상 내부 instance 들의 트리를 가지고 있습니다.(components, DOM nodes, 기타등등..)\n16 버전부터는 React 가 내부 인스턴스 트리와 Fiber 라는 코드 이름을 관리하는 알고리즘을 새로운 구현 했습니다.</p>\n<h2 id=\"setting-the-background\" style=\"position:relative;\"><a href=\"#setting-the-background\" aria-label=\"setting the background permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Setting the background</h2>\n<p>여기 아주 간단한 어플리케이션이 있습니다. 이것을 이 시리즈에서 계속 사용할 예정입니다. 간단하게 숫자를 증가시키는 button 하나가 있습니다.</p>\n<p><img src=\"./button-example01.gif\" alt=\"button-example01.gif\"></p>\n<p>그리고 여기 구현된 코드가 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ClickCounter</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> count<span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">handleClick</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">handleClick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">state</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> count<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token operator\">&lt;</span>button key<span class=\"token operator\">=</span><span class=\"token string\">\"1\"</span> onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n        Update counter\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n      <span class=\"token operator\">&lt;</span>span key<span class=\"token operator\">=</span><span class=\"token string\">\"2\"</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><a href=\"https://stackblitz.com/edit/react-t4rdmh?source=post_page---------------------------\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기서</a> 동작해볼 수 있습니다. 보는것과 같이 <code class=\"language-text\">render</code> 메서드에서 2 개의 child elements 인 <code class=\"language-text\">button</code> 과 <code class=\"language-text\">span</code> 을 반환하는 간단한 component 입니다.\n<code class=\"language-text\">button</code> 을 클릭하자마자 component 의 state 는 내부 handler 에 의해 업데이트가 됩니다. 그 결과로 <code class=\"language-text\">span</code> elemen에 text 가 업데이트가 됩니다.</p>\n<p>React 는 <code class=\"language-text\">reconciliation</code> 동안 다양한 수행을 합니다. 예를 들면 첫 렌더링 과 state 가 update 동안 높은 수준의 React 수행 작업이 있습니다.</p>\n<ul>\n<li>ClickCounter 의 state 안 있는 count 프로퍼티가 업데이트가 됩니다.</li>\n<li>ClickCounter 의 children 과 그것들의 props 들을 비교, 탐색합니다.</li>\n<li>span element 위해 props 를 update 합니다.</li>\n</ul>\n<p>라이프 사이클 메소드를 호출하거나 refs 를 업데이트하는 것과 같은 <code class=\"language-text\">reconciliation</code> 중에 수행되는 다른 작업이 있습니다.\n이런 모든 작업들은 Fiber 아키텍쳐에서 일괄적으로 \"work\" 라고 부릅니다. 이런 work 타입은 대게 React <code class=\"language-text\">element</code> 의 타입과 관계가 있습니다. 예를 들면 class component 는 React 가 instance 를 만들게 해주어야 합니다. 반면에 함수 컴포넌트 들의 경우에는 그렇지 않아도 됩니다. 알다시피 React 안에는 여러 종류의 <code class=\"language-text\">element</code> 들이 있습니다. 예를 들어, class 컴포넌트 , 함수 컴포넌트, host 컴포넌트 (DOM nodes) , 포탈 등등. 이런 React 타입은 <code class=\"language-text\">createElement</code> 함수의 첫번째 매개변수에 의해 정의 됩니다.\n이 <code class=\"language-text\">createElement</code> 함수는 <code class=\"language-text\">render</code> 메서드안에서 <code class=\"language-text\">element</code> 를 생성하기 위해 사용됩니다.</p>\n<p>활동의 탐구와 주요 fiber 알고리즘을 탐구하기 전에 먼저 React 에서 내부적으로 사용하는 데이터 구조에 익숙해 지도록합시다.</p>\n<h2 id=\"from-react-elements-to-fiber-nodes\" style=\"position:relative;\"><a href=\"#from-react-elements-to-fiber-nodes\" aria-label=\"from react elements to fiber nodes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>From React Elements to Fiber nodes</h2>\n<p>React 의 모든 컴포넌트들은 우리가 render 메서드에서 리턴되는 view 라고 불리우거나 또는 템플릿이라고 UI 표현을 가지고 있습니다. 여기 우리의 <code class=\"language-text\">ClickCounter</code> 컴포넌트를 위한 템플릿이 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">onClick</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>{this.onClick}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Update counter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>2<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>{this.state.count}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<h3 id=\"react-elements\" style=\"position:relative;\"><a href=\"#react-elements\" aria-label=\"react elements permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Elements</h3>\n<p>오직 템플릿은 JSX 컴파일러를 통해 거치면 React element 들이 잔뜩 생깁니다. 이것은 React 컴포넌트의 render 메서드에서 리턴되는 것으로 HTML 이 아닙니다. 우리는 JSX 를 사용하지 않을거라서 <code class=\"language-text\">ClickCounter</code> 컴포넌트의 render 메서드는 다음과 같이 작성될 수 있을 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ClickCounter</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>\n            React<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>\n                <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n                <span class=\"token punctuation\">{</span>\n                    key<span class=\"token operator\">:</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span>\n                    onClick<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onClick\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                <span class=\"token string\">'Update counter'</span>\n            <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            React<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>\n                <span class=\"token string\">'span'</span><span class=\"token punctuation\">,</span>\n                <span class=\"token punctuation\">{</span>\n                    key<span class=\"token operator\">:</span> <span class=\"token string\">'2'</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>count\n            <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">render</code> 메서드 안에서 <code class=\"language-text\">React.createElement</code> 를 호출하는 것은 2 개의 데이터 구조를 생성할 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n        $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span>react<span class=\"token punctuation\">.</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n        key<span class=\"token operator\">:</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span>\n        props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            children<span class=\"token operator\">:</span> <span class=\"token string\">'Update counter'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token function-variable function\">onClick</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n        $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span>react<span class=\"token punctuation\">.</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        type<span class=\"token operator\">:</span> <span class=\"token string\">'span'</span><span class=\"token punctuation\">,</span>\n        key<span class=\"token operator\">:</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">,</span>\n        props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            children<span class=\"token operator\">:</span> <span class=\"token number\">0</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>여기서 <code class=\"language-text\">$$typeof</code> 의 프로퍼티를 React 가 추가해서 React elements 요소로 고유하게 식별됨을 알 수 있습니다.\n그리고 나서 element 의 설명인 <code class=\"language-text\">type</code>, <code class=\"language-text\">key</code> 그리고 <code class=\"language-text\">props</code> 를 가지고 있습니다. 이 값들은 <code class=\"language-text\">React.createElement</code> 에 전달되는 값입니다. 주의할점은 어떻게 React 가 text 컨텐츠를 <code class=\"language-text\">span</code> 과 <code class=\"language-text\">button</code> 의 children 에 표현하는가 입니다. 그리고 어떻게 click handler 가 button element props 의 한 부분이 되었는가 입니다. React element 의 ref 같은 다른 필드들은 이 글에서 벗어나는 것들입니다.</p>\n<p><code class=\"language-text\">ClickCounter</code> 를 위한 React element 는 어떤 <code class=\"language-text\">props</code> 나 <code class=\"language-text\">key</code> 를 가지고 있지 않습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span>react<span class=\"token punctuation\">.</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    key<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    ref<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    type<span class=\"token operator\">:</span> ClickCounter\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"fiber-nodes\" style=\"position:relative;\"><a href=\"#fiber-nodes\" aria-label=\"fiber nodes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fiber nodes</h3>\n<p><strong>reconciliation</strong> 하는 동안에 render 메서드에서 리턴된 React element 들로 부터 나온 data를 fiber node 트리들에 합쳐지게 됩니다. 그래서 모든 React element 들은 해당하는 fiber node 를 지니게 됩니다. fibers 은 React element 들과 다르게 매 render 마다 재 생성되지 않습니다. 이것은 변할 수 있는 components 와 DOM 을 가지고 있는 data 구조입니다.</p>\n<p>우리는 이전에 React element 타입이 프레임워크의 다른 수행을 요한다고 했었다. 우리의 샘플 어플리케이션에서 <code class=\"language-text\">ClickCounter</code> 클래스 컴포넌트는 라이프 사이클 메서드 과 <code class=\"language-text\">render</code> 메서드를 호출한다. 반면에 <code class=\"language-text\">span</code> host 컴포넌트(DOM node)는 DOM 변화를 수행하게 됩니다. 따라서 각 React element 는 수행해야 할 작업을 설명하는 해당 타입에 맞게 Fiber node 로 변환됩니다.</p>\n<p><strong>Fiber 는 해야 할 작업을 나타내는 데이터 구조로 생각할 수 있습니다. 즉 작업 단위입니다. Fiber 의 아키텍쳐는 작업을 추적, 스케쥴, 일지정지, 중단 할수 있는 편리한 방법을 제공합니다.</strong></p>\n<p>React element 가 fiber node 로 처음 변환되면, React 는 element 부터 나온 data 를 <a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js?source=post_page---------------------------#L414\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">createFiberFromTypeAndProps</a> 에서 사용해서 fiber 를 생성하게 됩니다.</p>\n<p>결과 업데이트에서 React는 fiber 노드를 재사용하고 해당 React element 의 데이터를 사용하여 필요한 프로퍼티들을 업데이트 합니다.\nReact 는 또한 node 를 key props 를 기반으로 계층안에서 움직이거나 만약 관련 React element 가 render 메서드를 통해 더이상 리턴되지 않는다면 node 를 삭제할 필요가 있을것이다.</p>\n<blockquote>\n<p><a href=\"https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactChildFiber.js?source=post_page---------------------------#L239\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ChildReconciler</a> 함수를 통해서 모든 활성화된 모든 리스트들과 React 동작을 위한 fiber nodes 들에 관련한 함수들을 확인할 수 있습니다.</p>\n</blockquote>\n<p>React 는 각 element 에 대한 fiber 를 생성하고 그들의 elements 의 트리를 가지고 있기 때문에 우리는 fiber nodes 트리를 가질 수 있습니다. 우리 샘플 케이스의 경우에는 다음과 같이 표현할 수 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 555px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/ho_blog/static/38e8980311513636963103623b684072/cd039/fiberNode01.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.91891891891892%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABeUlEQVQoz3WRS0vDQBSF8/fcuRPUjY+FLgRBFBR0oVLsokV8oLhREEF3IqJ7oYtqjVSL2kpp2uY1iW2meYyZZB5OWqkoelYnw/0499xIUxl5fu9pduuh3nC479EAMUIY44z/FI649c7bUFhN00zTFEYaWc1PZ+XJtFx9NbilUV3lNkim2Q+c0BiFMMSe8II0DINSKrluYGoaQoEOWpvnSubsLXtcWj9+ubypcxeGPsIxJZTHPHZ4x+W+gAEAiqJgjCXGaOhD7Fovz2WxxfDq7eh6YXC5sHXyzD1AgMo/UJKMsfduI+gIb1mW2DxJ7i9GKbNh2NBhuVKrKoYB7J2rZuqwtHJQvMjpYiAmEaWkO5ko6fxVjwkl3yQSCRqCAFrqeCo/tHY3sJDLnJa7tX8f8TuZdS+EwzBwnd5Dqx3nmpWiqrke4X/pG+6dN46wY+meY0PbWNx/mtmWxzbujq6VXq//4f4fRYGAO22wdPA4t/s4kb4/uq79CX8CRVvqYWlSt/AAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"fiber tree\"\n        title=\"fiber tree\"\n        src=\"/ho_blog/static/38e8980311513636963103623b684072/cd039/fiberNode01.png\"\n        srcset=\"/ho_blog/static/38e8980311513636963103623b684072/12f09/fiberNode01.png 148w,\n/ho_blog/static/38e8980311513636963103623b684072/e4a3f/fiberNode01.png 295w,\n/ho_blog/static/38e8980311513636963103623b684072/cd039/fiberNode01.png 555w\"\n        sizes=\"(max-width: 555px) 100vw, 555px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>모든 fiber 노드들은 linked list 로 연결이 되어있습니다. fiber node 에 <code class=\"language-text\">child</code>, <code class=\"language-text\">sibling</code> 그리고 <code class=\"language-text\">return</code> 이라는 프로퍼티를 사용해서 연결이 되어있습니다.\n왜 이런 방식으로 작업이 되었는지 좀 더 설명을 원한다면 다음 글을 먼저 읽어 보십시요 <a href=\"https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7?source=post_page---------------------------\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">The how and why on React’s usage of linked list in Fiber</a></p>\n<h3 id=\"current-and-work-in-progress-trees\" style=\"position:relative;\"><a href=\"#current-and-work-in-progress-trees\" aria-label=\"current and work in progress trees permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Current and work in progress trees</h3>\n<p>첫번째 렌더링 이후에 React 는 UI 렌더링에 필요한 어플리케이션의 state 를 반영한 fiber 트리를 갖게 된다. 이 트리는 대게 <strong>current</strong>라고 불리운다. ( 한번 그려진 녀석들을 반영한 트리를 current 라고 함 ). React 가 current 를 tree 를 update 시작하면 그것은 <strong>workInProgress</strong> 트리 라고 불리운다. 이것은 스크린에 뿌려지게 될 미래의 state 를 반영합니다.</p>\n<p>모든 작업은 <code class=\"language-text\">workInProgress</code> 트리의 fiber 에서 수행됩니다. React 가 <code class=\"language-text\">current</code> 트리를 살펴보면서 기존의 각 fiber 노드에 대해 <code class=\"language-text\">workInProgress</code> 트리를 구성하는 alternate(대체) 노드를 만듭니다. 이 노드는 <code class=\"language-text\">render</code> 메서드에서 리턴된 React element 에서 나온 data 를 사용해서 만들게 됩니다. 업데이트가 처리되고 모든 관련 작업이 완료되면, React 는 스크린에 뿌려질 alternate 트리를 가지고 있을 것입니다. 이 <code class=\"language-text\">workInProgress</code> 트리가 render 되고나면 그것은 다시 <code class=\"language-text\">current</code> 트리가 됩니다.</p>\n<p>React 코어의 원리중 하나는 일관성입니다. <a href=\"https://overreacted.io/ko/react-as-a-ui-runtime/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기참조</a>. React 는 항상 DOM 을 한번에 update 합니다. 부분적인 결과는 표시되지 않습니다. <code class=\"language-text\">workInProgress</code>트리는 사용자에게 표시되지 않는 \"초안\"으로 사용되며, 그래서 React 는 맨 먼저 모든 컴포넌트들을 처리한 뒤에 그것들의 변화를 스크린에 반영할 수 있습니다. 여기 그러한 함수 중 하나의 시그니처 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// updateHostComponent</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateHostComponent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">current<span class=\"token punctuation\">,</span> workInProgress<span class=\"token punctuation\">,</span> renderExpirationTime</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>각 fiber 노드는 <strong>alternate</strong> 필드에 있는 다른 트리로 부터 나온 해당 fiber node에 대응하는 fiber 참조값을 보유 하고 있습니다. <code class=\"language-text\">current</code> 트리의 노드는 <code class=\"language-text\">workInProgress</code> 트리의 노드를 가리키고 그 반대의 경우도 마찬가지입니다.</p>\n<h3 id=\"side-effects\" style=\"position:relative;\"><a href=\"#side-effects\" aria-label=\"side effects permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Side-effects</h3>\n<p>우리는 React 컴포넌트를 state 와 props 를 사용해서 UI 표현을 계산하는 함수라고 생각 할 수 있습니다. DOM 을 변경하거나 라이프 사이클 메소드를 호출하는 것과 같은 다른 모든 활동은 side-effect 또는 단순히 effect 로 간주되어야합니다. Effect 는 <a href=\"https://reactjs.org/docs/hooks-overview.html?source=post_page---------------------------#%EF%B8%8F-effect-hook\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">문서</a>에도 언급되어 있습니다.</p>\n<blockquote>\n<p>우리는 데이터 가져 오기, 구독 또는 수동으로 이전 React component 에서 나온 <strong>DOM 을 변경</strong> 했을 것입니다. 우리는 이 작업들을 \"side effect\" 또는 짧게 \"effect\" 라고 불렀습니다. 왜냐하면 그것들은 다른 컴포넌트에 영향을 미칠수 있고 렌더링 동안에 수행 할 수 없기 때문입니다.</p>\n</blockquote>\n<p>대부분의 state 및 props 업데이트가 side-effects 을 일으키는 방법을 확인할 수 있습니다. effects 를 적용하는 것이 일종의 작업의 타입이기 때문에 fiber 노드는 업데이트 외에도 효과를 추적하는 편리한 메커니즘입니다. 각 fiber 노드는 그것과 연관된 effects 를 가질 수 있습니다. 그것들을 effectTag 필드에 인코딩됩니다.</p>\n<p>따라서 Fiber 에 있는 effects 는 기본적으로 업데이트가 처리 된 후 인스턴스에 대해 수행해야하는 <a href=\"https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js?source=post_page---------------------------\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">작업</a>을 정의합니다. host component 들 (DOM 요소)의 경우 작업은 요소 추가, 업데이트 또는 제거로 구성됩니다. 클래스 컴포넌트의 경우 React 는 ref 를 업데이트하고 <code class=\"language-text\">componentDidMount</code> 및 <code class=\"language-text\">componentDidUpdate</code> 라이프 사이클 메소드를 호출해야 할 수 있습니다. 다른 유형의 fiber 들에 해당하는 다른 effects 도 있습니다.</p>\n<h3 id=\"effects-list\" style=\"position:relative;\"><a href=\"#effects-list\" aria-label=\"effects list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Effects list</h3>\n<p>React 프로세스는 업데이트를 신속하게 처리하고 몇 가지 흥미로운 기술을 사용하여 그 수준의 성능을 달성합니다. <strong>그 중 하나는 신속한 반복을 위해 effect 가 있는 fiber 노드의 선형 목록을 작성하는 것입니다.</strong> 선형 목록 반복은 트리보다 훨씬 빠르며 side-effects 없는 노드에 시간을 할애 할 필요가 없습니다.</p>\n<p>이 리스트의 목표는 DOM 업데이트 또는 이와 관련된 다른 effects 가있는 노드를 표시하는 것입니다. 이 목록은 <code class=\"language-text\">finishedWork</code> 트리의 하위 집합이며 <code class=\"language-text\">current</code> 및 <code class=\"language-text\">workInProgress</code> 트리에서 사용되는 <code class=\"language-text\">child</code> 속성 대신 <code class=\"language-text\">nextEffect</code> 속성을 사용하여 연결됩니다.</p>\n<p>Dan Abramov 는 effects list 에 대한 비유를 제시했습니다. 그는 크리스마스 트리에 모든 effectful 한 노드를 묶어놓은 \"크리스마스 불빛\"이 감겨져있는 것으로 생각하는 것을 좋아합니다. 이것을 시각화하기 위해 강조 표시된 노드가 할 일이있는 다음과 같은 fiber 노드 트리를 상상해 봅시다. 예를 들어, 우리의 업데이트로 인해 <code class=\"language-text\">c2</code>가 DOM 에 삽입되고, <code class=\"language-text\">d2</code>와 <code class=\"language-text\">c1</code>이 속성을 변경하고, <code class=\"language-text\">b2</code>는 라이프 사이클 메소드를 실행합니다. 이 effect list 는 React 가 나중에 다른 노드를 건너 뛸 수 있도록 그들을 연결합니다 :</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 475px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/ho_blog/static/c5d667a728acff34d14b041891dd2d73/466da/updateFiberTree.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAACNklEQVQoz21Sy2oUQRTtnR/hSsGNfxBREF250Y1Z6MqVq0Q0opBVjEoQRRAZN4IoClloUHDjLGNghM4DTUbQOJkxJpN5dfWjunu6q6rr4a2anslrilrU455zzz33Wnzze/LqejJ7h/gOkUpIqQ4seDn8aJbF7PfBtSPB2NHgh42bQdhCKqMySRTnQ8L3s1gyQuzXV1WzAw8/evd7/PHiytKWol3h+cp1leepblcBlxCHWSxz0KeWR64+XD43Ufqy2IYrF0YtYOJYRZFmgR2GitIB3jIRHLYQso7IWi0kbHiFOhJUBIFWlKZ55p4GGbZZ4XJ6/xQtzREKvyzNZMrkELPADsBHUQ+s6xGNKp4+40+cwPOzccCCzZ0I4UYnTOKkn1hKsYcJISs/gR7X5TR1Hd+EGbqKHd0bCWfOpzuVTKcQB5IbcJYpxwEIE7KDmU5i+pRt2PjW8fDuSVz9udHOqvUw44A3ycG5XDbYaAwAz/yIDfyXGeV+Q7VqpIPGnq9emix9nN/WYWAJJNOGMSaheqVwTJ99+DP5sry87hldXPVLJM3OzcLa6PTK529NDe44WqwGEyJdHd1EyeiUfXp84W3xH7SyjrVB+WyE2KtVtytVHgUKuYNWW7p0hKB7LE7K687SatP1iEJ/kV3Mtsq5PaSbzJyNbx/Lii8G3en3GfBApj3AKvIVU8nrGzDw8dOLeZNoEheu4KkRas/pu+B7wP05kJpUf9CFN/GTC+mnB7t5eoO4f/0H5cA+V3QdyX0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"updateFiberTree\"\n        title=\"updateFiberTree\"\n        src=\"/ho_blog/static/c5d667a728acff34d14b041891dd2d73/466da/updateFiberTree.png\"\n        srcset=\"/ho_blog/static/c5d667a728acff34d14b041891dd2d73/12f09/updateFiberTree.png 148w,\n/ho_blog/static/c5d667a728acff34d14b041891dd2d73/e4a3f/updateFiberTree.png 295w,\n/ho_blog/static/c5d667a728acff34d14b041891dd2d73/466da/updateFiberTree.png 475w\"\n        sizes=\"(max-width: 475px) 100vw, 475px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>여기서 effects 를 가진 노드들이 어떻게 연결되어있는지 볼수 있습니다. 이런 노드들을 탐색할때 React 는 어디서 list 의 시작인지 알기 위해서 <code class=\"language-text\">firstEffect</code> 포인터를 사용합니다.\n그래서 위 다이어그램은 아래처럼 선형 리스트로 표현될 수 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/ho_blog/static/cef15871ce25c3c451ff4ff7633ed42a/3d4b6/effectList.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 14.18918918918919%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAvklEQVQI12P4////u/cfHjx8+OnzVyD7z9+/z5+/ePz4yc+fv4Dcr1+/Pnr0+MWLl//B4M3bdw8fPvr85SuEy/B9SdHf98//AbU9vf5tftbPvTP+/voJ5P48vvLrtJjft08A2f++fvi+rvH7ivI/718Aub/vnf02N/3H1h6GTxV6fx5f+f/79+9rBz4WKn2bnQJU+v/vn++raz4k8/w6sfL/v79/3zz60ubyqdbk77Mb///+/nV248c8uS8TggCc5ZkrityUCAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"effectList\"\n        title=\"effectList\"\n        src=\"/ho_blog/static/cef15871ce25c3c451ff4ff7633ed42a/fcda8/effectList.png\"\n        srcset=\"/ho_blog/static/cef15871ce25c3c451ff4ff7633ed42a/12f09/effectList.png 148w,\n/ho_blog/static/cef15871ce25c3c451ff4ff7633ed42a/e4a3f/effectList.png 295w,\n/ho_blog/static/cef15871ce25c3c451ff4ff7633ed42a/fcda8/effectList.png 590w,\n/ho_blog/static/cef15871ce25c3c451ff4ff7633ed42a/3d4b6/effectList.png 712w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>보시다시피 React 는 children 부터 parents 까지 순서대로 효과를 적용합니다.</p>\n<h3 id=\"root-of-the-fiber-tree\" style=\"position:relative;\"><a href=\"#root-of-the-fiber-tree\" aria-label=\"root of the fiber tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Root of the fiber tree</h3>\n<p>모든 React 애플리케이션에는 컨테이너 역할을 하는 하나 또는 이상의 DOM 요소가 있습니다. 여기서는 ID 가 <code class=\"language-text\">container</code>인 div 가 이 경우에 해당됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> domContainer <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#container'</span><span class=\"token punctuation\">)</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>React<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>ClickCounter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> domContainer<span class=\"token punctuation\">)</span></code></pre></div>\n<p>React 는 각 컨테이너들에 대한 <a href=\"https://github.com/facebook/react/blob/0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74/packages/react-reconciler/src/ReactFiberRoot.js?source=post_page---------------------------#L31\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">fiber root</a> 객체를 만듭니다. DOM 요소에 대한 참조를 사용하여 액세스 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// DOM 레퍼런스에 접근해서 fiberRoot에 접근 할 수있다.</span>\n<span class=\"token keyword\">const</span> fiberRoot <span class=\"token operator\">=</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#container'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>_reactRootContainer<span class=\"token punctuation\">.</span>_internalRoot</code></pre></div>\n<p>이 fiber root 는 React 가 fiber tree 에 대한 참조를 보유하고있는 곳입니다. 그 fiber tree 참조 값은 fiber root 의 <code class=\"language-text\">current</code> 속성에 저장됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// #container 의 Fiber node 이다.</span>\n<span class=\"token keyword\">const</span> hostRootFiberNode <span class=\"token operator\">=</span> fiberRoot<span class=\"token punctuation\">.</span>current</code></pre></div>\n<p>fiber 트리는 <code class=\"language-text\">HostRoot</code> 인 <a href=\"https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/shared/ReactWorkTags.js?source=post_page---------------------------#L34\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">특별한 타입</a>의 fiber 노드로 시작합니다. 그것은 내부적으로 생성이 되고 가장 최상위 컴포넌트의 부모 역할을 합니다.\n이것은 <code class=\"language-text\">HostRoot</code>에서 <code class=\"language-text\">stateNode</code> 속성을 통해 <code class=\"language-text\">FiberRoot</code>로 연결되는 링크가 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// fiberRoot.current === hostRootFiberNode, #container 의 Fiber node</span>\n<span class=\"token comment\">// hostRootFiberNode.stateNode === fiberRoot</span>\nfiberRoot<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span>stateNode <span class=\"token operator\">===</span> fiberRoot <span class=\"token comment\">// true</span></code></pre></div>\n<p>fiber root 를 통해 최상위 <code class=\"language-text\">HostRoot</code> fiber 노드에 액세스하여 fiber 트리를 탐색 할 수 있습니다. 또는 다음과 같이 구성 요소 인스턴스에서 개별 fiber 노드를 가져올 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 컴포넌트 인스턴스에서 fiber node를 가져올 수 있다.</span>\ncompInstance<span class=\"token punctuation\">.</span>_reactInternalFiber</code></pre></div>\n<h3 id=\"fiber-node-structure\" style=\"position:relative;\"><a href=\"#fiber-node-structure\" aria-label=\"fiber node structure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fiber node structure</h3>\n<p>그렇다면 <code class=\"language-text\">ClickCounter</code> 컴포넌트에서 생성된 fiber nodes 의 구조를 살펴보자.\n이 fiber node에 <code class=\"language-text\">child</code>, <code class=\"language-text\">sibling</code>, <code class=\"language-text\">return</code> 속성을 지니고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n    stateNode<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClickCounter</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 함수형 컴포넌트는 null이 들어간다.</span>\n    type<span class=\"token operator\">:</span> ClickCounter<span class=\"token punctuation\">,</span>\n    alternate<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    key<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    updateQueue<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    memoizedState<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>count<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    pendingProps<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    memoizedProps<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    tag<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n    effectTag<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n    nextEffect<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그리고 <code class=\"language-text\">span</code> DOM element :</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n    stateNode<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HTMLSpanElement</span><span class=\"token punctuation\">,</span>\n    type<span class=\"token operator\">:</span> <span class=\"token string\">\"span\"</span><span class=\"token punctuation\">,</span>\n    alternate<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    key<span class=\"token operator\">:</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">,</span>\n    updateQueue<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    memoizedState<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    pendingProps<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>children<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    memoizedProps<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>children<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    tag<span class=\"token operator\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span>\n    effectTag<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n    nextEffect<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>fiber node 에 꽤 많은 필드들이 있습니다. 여기서 이전 섹션에서 봤던 필드 <code class=\"language-text\">alternate</code>, <code class=\"language-text\">effetTag</code> 그리고 <code class=\"language-text\">nextEffects</code> 의 목적을 설명했었다. 그렇다면 나머지들은 왜 이것들이 필요한지 봅시다.</p>\n<h4 id=\"statenode\" style=\"position:relative;\"><a href=\"#statenode\" aria-label=\"statenode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>stateNode</h4>\n<p>컴포넌트의 클래스 인스턴스 DOM 노드 또는 fiber node 와 관련된 다른 React element 타입의 참조값을 지니고 있다.\n일반적으로 이 프로퍼티는 fiber 와 관련된 local state 를 유지하는데 사용된다고 말할 수 있습니다.</p>\n<h4 id=\"type\" style=\"position:relative;\"><a href=\"#type\" aria-label=\"type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>type</h4>\n<p>이 fiber 와 관련된 함수나 클래스를 정의한다. 클래스 컴포넌트들의 경우 type 은 생성자 함수를 가리키고 DOM element 들의 경우에는 특별한 HTML 태그를 가리킨다. 이 필드는 fiber 노드가 어떤 엘리먼트와 관련있는지 이해하는데 종종 사용된다.</p>\n<h4 id=\"tag\" style=\"position:relative;\"><a href=\"#tag\" aria-label=\"tag permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>tag</h4>\n<p><a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">fiber 의 타입</a>을 정의한다. 그것은 어떤 일을 해야하는지를 결정하기 위한 reconciliation 알고리즘으로 사용된다. 이전에 언급했듯이, 작업은 React element 의 타입에따라 달라집니다. 함수 <a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js?source=post_page---------------------------#L414\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">createFiberFromTypeAndProps</a> React element 를 관련된 fiber 노드 타입과 매핑시켜준다.\n우리 어플리케이션 안에서 <code class=\"language-text\">ClickCounter</code> 컴포넌트의 <code class=\"language-text\">tag</code> 프로퍼티는 <code class=\"language-text\">1</code> 이다. 이것은 <code class=\"language-text\">ClassComponent</code>를 뜻하고 <code class=\"language-text\">span</code> 엘리먼트의 <code class=\"language-text\">5</code>의 경우에는 <code class=\"language-text\">HostComponent</code>를 가리킨다.</p>\n<h4 id=\"updatequeue\" style=\"position:relative;\"><a href=\"#updatequeue\" aria-label=\"updatequeue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>updateQueue</h4>\n<p>state 업데이트들, 콜백함수들과 DOM update 들의 queue.</p>\n<h4 id=\"memoizedstate\" style=\"position:relative;\"><a href=\"#memoizedstate\" aria-label=\"memoizedstate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>memoizedState</h4>\n<p>결과를 만드는데 사용된 fiber 의 State. 업데이트 처리 할 때 memoizedState는 현재 화면에 렌더링 된 state 를 반영합니다.</p>\n<h4 id=\"memoizedprops\" style=\"position:relative;\"><a href=\"#memoizedprops\" aria-label=\"memoizedprops permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>memoizedProps</h4>\n<p>이전 렌더링 동안 출력을 생성하는 데 사용 된 fiber 의 Props.</p>\n<h4 id=\"pendingprops\" style=\"position:relative;\"><a href=\"#pendingprops\" aria-label=\"pendingprops permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>pendingProps</h4>\n<p>React element 들의 새로운 데이터로 업데이트된 Props 그리고 child components 또는 DOM elements 에 적용해야합니다.</p>\n<h4 id=\"key\" style=\"position:relative;\"><a href=\"#key\" aria-label=\"key permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>key</h4>\n<p>React 가 어떤 아이템이 변경되었는지, list 에서 추가되었거나 삭제되었는지 알아챌수 있게 해주는 children 그룹에 포함된 특별한 식별자. 여기에 설명 된 React 의 \"목록 및 키\"기능과 관련이 있습니다.</p>\n<p>완성된 fiber node 는 <a href=\"https://github.com/facebook/react/blob/6e4f7c788603dac7fccd227a4852c110b072fe16/packages/react-reconciler/src/ReactFiber.js?source=post_page---------------------------#L78\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기</a>서 확인해볼수 있다. 여기서는 위의 설명에서 여러 필드를 생략했습니다.\n특히, 이전 글에서 설명한 트리 데이터 구조를 구성하는 포인터인 <code class=\"language-text\">child</code>, <code class=\"language-text\">siblig</code> 그리고 <code class=\"language-text\">return</code> 을 건너 뛰었습니다. 그리고 <code class=\"language-text\">expiredTime</code>, <code class=\"language-text\">childExpirationTime</code> 및 <code class=\"language-text\">mode</code> 와 같은 카테고리는 <code class=\"language-text\">Sceduler</code>에만 해당됩니다.</p>\n<h2 id=\"general-algorithm\" style=\"position:relative;\"><a href=\"#general-algorithm\" aria-label=\"general algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>General algorithm</h2>\n<p>React 는 <strong>렌더링</strong>과 <strong>커밋</strong>의 두 가지 주요 단계로 작업을 수행합니다.</p>\n<p>첫 번째 <code class=\"language-text\">렌더링</code> 단계에서 React 는 <code class=\"language-text\">setState</code> 또는 <code class=\"language-text\">React.render</code>를 통해 예약 된 component들에 업데이트를 적용하고 UI 에서 업데이트해야 하는 항목을 파악합니다.</p>\n<p>초기 렌더링 인 경우 React 는 <code class=\"language-text\">render</code> 메소드에서 반환 된 각 요소에 대해 새 fiber 노드를 만듭니다. 다음 업데이트에서는 기존 React 요소의 fiber 가 다시 사용되고 업데이트됩니다.</p>\n<p><strong>단계의 결과는 side-effects 마크를 가진 fiber 노드의 트리입니다.</strong> 이 effects 는 다음 <code class=\"language-text\">커밋</code> 단계에서 수행해야하는 작업을 설명합니다.</p>\n<p>이 <code class=\"language-text\">커밋</code> 단계에서 React 는 effects 로 표시된 fiber 트리를 가져 와서 인스턴스에 적용합니다. effects 목록을 검토하면서 DOM 업데이트 및 사용자가 볼 수있는 기타 변경 사항을 수행합니다.</p>\n<p><strong>첫 번째 <code class=\"language-text\">렌더링</code> 단계에서 작업을 비동기 적으로 수행 할 수 있다는 것을 이해하는 것이 중요합니다.</strong></p>\n<p>React 는 사용 가능한 시간에 따라 하나 이상의 fiber 노드를 처리 할 수 있습니다. 그런 다음 작업을 숨기고 일부 이벤트에 양보합니다. 그런 다음 중단 된 부분부터 계속됩니다.</p>\n<p>그러나 때로는 완료된 작업을 무시하고 처음부터 다시 시작해야 할 수도 있습니다. 이러한 일시 중지는 이 단계에서 수행 한 작업으로 인해 DOM 업데이트와 같은 사용자가 볼 수있는 변경 사항이 발생하지 않음으로 인해 가능합니다.\n<strong>반대로 다음 커밋 단계는 항상 동기식입니다.</strong></p>\n<p>이는 이 단계에서 수행 된 작업이 사용자에게 표시되는 변경 사항 (예 : DOM 업데이트.) 이기 때문에 React 가 단일 패스로 이를 수행해야합니다.</p>\n<p>라이프 사이클 메소드 호출은 React 가 수행하는 작업의 한 유형입니다.\n일부 메서드는 <code class=\"language-text\">렌더링</code> 단계에서 호출되고 다른 메서드는 <code class=\"language-text\">커밋</code> 단계에서 호출됩니다. 첫 번째 <code class=\"language-text\">렌더링</code> 단계를 수행 할 때 호출되는 라이프 사이클 목록은 다음과 같습니다.</p>\n<ul>\n<li>[UNSAFE_]componentWillMount (deprecated)</li>\n<li>[UNSAFE_]componentWillReceiveProps (deprecated)</li>\n<li>getDerivedStateFromProps</li>\n<li>shouldComponentUpdate</li>\n<li>[UNSAFE_]componentWillUpdate (deprecated)</li>\n<li>render</li>\n</ul>\n<p>보는 것과 같이 <code class=\"language-text\">렌더링</code> 단계에서 실행되는 일부 몇몇 레거시 라이프 사이클 메서드는 버젼 16.3 에서 <code class=\"language-text\">UNSAFE</code>라고 표시됩니다. 그것들은 문서에서 레거시 라이프 사이클이라고 불리워집니다. 그것들은 미래에 16.x 에서 지원이 중단되며 UNSAFE 접두사가 없는 해당 항목은 17.0 에서 제거됩니다. 이 변경 사항과 제안 된 마이그레이션 경로에 대한 자세한 내용은 <a href=\"https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html?source=post_page---------------------------\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기</a>를 참조하십시오.</p>\n<p>이것에 대한 이유가 궁금하십니까?</p>\n<p><code class=\"language-text\">렌더링</code> 단계에서는 DOM 업데이트와 같은 부작용이 발생하지 않으므로 React 는 구성 요소를 비동기 적으로 업데이트를 처리할 수 있음을 알았습니다. (잠재적으로 여러 스레드에서 업데이트를 처리 할 수도 있습니다.) 그러나 <code class=\"language-text\">UNSAFE</code> 로 표시된 라이프 사이클은 종종 오해되고 미묘하게 오용되었습니다. 개발자는 새로운 비동기 렌더링 방식에 문제를 일으킬 수있는 부작용이있는 코드를 이러한 메서드에 넣는 경향이 있었습니다. UNSAFE 접두사가 없는 항목만 제거되지만 곧 나오는 동시 모드 (선택 해제 할 수 있음)에 여전히 문제가 발생할 수 있습니다.</p>\n<p>두 번째 <code class=\"language-text\">커밋 단계</code>에서 실행 된 라이프 사이클 메소드 목록은 다음과 같습니다.</p>\n<ul>\n<li>getSnapshotBeforeUpdate</li>\n<li>componentDidMount</li>\n<li>componentDidUpdate</li>\n<li>componentWillUnmount</li>\n</ul>\n<p>이러한 메소드는 동기적인 <code class=\"language-text\">커밋</code> 단계에서 실행되기 때문에 부작용이 포함되어 DOM 에 접할 수 있습니다.\n자 이제 우리는 tree 를 탐색하고 작업을 수행하는 데 사용되는 일반화 된 알고리즘을 살펴볼 배경을 가지고 있습니다.</p>\n<h2 id=\"render-phase\" style=\"position:relative;\"><a href=\"#render-phase\" aria-label=\"render phase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Render phase</h2>\n<p>reconciliation 알고리즘은 항상 <a href=\"https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1132\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">renderRoot</a> 함수를 사용하여 최상위 <code class=\"language-text\">HostRoot</code> fiber 노드에서 시작합니다. 그러나, React 는 완료되지 않은 작업이있는 노드를 찾을 때까지 이미 처리 된 fiber 노드에서 벗어납니다 (건너 뜁니다). 예를 들어, 컴퍼넌트 트리의 <code class=\"language-text\">setState</code> 를 깊게 들어가있는 component 에서 호출하면, React 는 위에서부터 시작 합니다만, <code class=\"language-text\">setState</code> 메소드를 호출 한 컴퍼넌트에 도착할 때까지, 부모를 신속하게 스킵합니다.</p>\n<h3 id=\"main-steps-of-the-work-loop\" style=\"position:relative;\"><a href=\"#main-steps-of-the-work-loop\" aria-label=\"main steps of the work loop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Main steps of the work loop</h3>\n<p>모든 fiber 노드는 <a href=\"https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1136\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">작업 루프</a>에서 처리됩니다. 다음은 루프의 동기 부분 구현입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">workLoop</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">isYieldy</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isYieldy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextUnitOfWork <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>nextUnitOfWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 코드에서 <code class=\"language-text\">nextUnitOfWork</code>는 할 일이 있는 <code class=\"language-text\">workInProgress</code> 트리에서 fiber 노드에 대한 참조를 보유합니다. React 가 Fibers 트리를 탐색하면서 이 변수를 사용하여 완료되지 않은 다른 fiber 노드가 있는지를 확인합니다. 현재 fiber 처리 된 후 변수는 트리의 다음 fiber 노드에 대한 참조 또는 null 을 포함합니다. 이 경우 React 는 작업 루프를 종료하고 변경 사항을 커밋 할 준비가 됩니다.</p>\n<p>트리를 탐색하고 작업을 시작하거나 완료하는 데 사용되는 4 가지 주요 기능이 있습니다.</p>\n<ul>\n<li><a href=\"https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1056\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">performUnitOfWork</a></li>\n<li><a href=\"https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js?source=post_page---------------------------#L1489\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">beginWork</a></li>\n<li><a href=\"https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L879\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">completeUnitOfWork</a></li>\n<li><a href=\"https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberCompleteWork.js?source=post_page---------------------------#L532\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">completeWork</a></li>\n</ul>\n<p>그들이 어떻게 사용되는지를 보여주기 위해 다음과 같은 fiber 트리 탐색 애니메이션을 살펴보십시오. 데모 용으로 이러한 함수의 단순화 된 구현을 사용했습니다. 각 기능은 fiber 노드를 처리하고 React 가 트리 아래로 가면서 현재 활성화 된 fiber 노드가 변경된 것을 볼 수 있습니다. 비디오에서 알고리즘이 한 브랜치에서 다른 브랜치로 어떻게 이동하는지 명확하게 볼 수 있습니다. parents 에 가기 전에 먼저 children 위한 일을 마칩니다.</p>\n<p><img src=\"./fiberTraversing.gif\" alt=\"fiber Traversing\"></p>\n<blockquote>\n<p>곧은 수직 연결은 sibling 를 의미하는 반면 구부러진 연결은 children 를 나타냅니다. b1 에는 자식이없고 b2 에는 자식 c1 이 하나 있습니다.</p>\n</blockquote>\n<p>다음은 재생을 일시 중지하고 현재 노드와 기능 상태를 검사 할 수있는 비디오에 대한 <a href=\"https://vimeo.com/302222454?source=post_page---------------------------\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">링크</a>입니다. 개념적으로, 당신은 \"시작\"을 구성 요소로 \"들어가는 것\"으로, \"완료\"는 \"단계적으로\" 수행하는 것으로 생각할 수 있습니다. 이 함수들이하는 일을 설명하면서 <a href=\"https://stackblitz.com/edit/js-ntqfil?file=index.js&#x26;source=post_page---------------------------\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">예제</a>와 구현을 가지고 놀 수도 있습니다.</p>\n<p><code class=\"language-text\">performUnitOfWork</code>와 <code class=\"language-text\">beginWork</code>의 처음 두 함수를 살펴 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// while 문에서 계속 반복하는 함수</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">workInProgress</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// children에 대한 포인터 또는 null</span>\n  <span class=\"token keyword\">let</span> next <span class=\"token operator\">=</span> <span class=\"token function\">beginWork</span><span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>next <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 더 이상의 자식이 없을때 completeUnitOfWork -> completeWork를 수행</span>\n    <span class=\"token comment\">// completeUnitOfWork는 sibling이 있을때 return sibling 후 다시 beginWork 진행</span>\n    <span class=\"token comment\">// sibling도 없을 시에 부모로 올라가서 completeUnitOfWork 내부에 있는 completeWork를 수행</span>\n    next <span class=\"token operator\">=</span> <span class=\"token function\">completeUnitOfWork</span><span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> next\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">beginWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">workInProgress</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'work performed for '</span> <span class=\"token operator\">+</span> workInProgress<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> workInProgress<span class=\"token punctuation\">.</span>child\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">performUnitOfWork</code> 함수는 <code class=\"language-text\">workInProgress</code> 트리에서 fiber 노드를 받고 <code class=\"language-text\">beginWork</code> 함수를 호출하여 작업을 시작합니다. 이 기능은 fiber 대해 수행해야하는 모든 작업을 시작하는 기능입니다. 이 증명을 위해, 우리는 단순히 작업이 완료되었음을 나타내기 위해 fiber 의 이름을 기록합니다. <strong><code class=\"language-text\">beginWork</code> 함수는 항상 루프에서 처리 할 다음 child 에 대한 포인터 또는 null 을 반환합니다.</strong></p>\n<p>다음 자식이 있으면 <code class=\"language-text\">workLoop</code> 함수의 <code class=\"language-text\">nextUnitOfWork</code> 변수에 할당됩니다. 그러나 자식이 없으면 React 는 분기의 끝에 도달 했으므로 현재 노드를 완료 할 수 있음을 알게됩니다. <strong>노드가 완성되면 siblings 를 위한 작업을 수행 한 후 그 부모에게 역 추적해야합니다.</strong> 이 작업은 <code class=\"language-text\">completeUnitOfWork</code> 함수에서 수행됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 여기서 들어오는 workInProgress는 child가 없어서 들어온것이다.</span>\n<span class=\"token comment\">// 더 이상의 child가 없다는건 현재 깊이의 끝에 도달했다는 것이고 이 fiber를 completeWork를 수행한다.</span>\n<span class=\"token comment\">// workInProgress를 받아서 sibling을 찾아보고 찾는다면 다시  performUnitOfWork를 수행한다.</span>\n<span class=\"token comment\">// child와 sibling이 없다면 부모로 올라가서 completeWork를 수행하게 된다.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">completeUnitOfWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">workInProgress</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> returnFiber <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>return\n    <span class=\"token keyword\">let</span> siblingFiber <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>sibling\n\n    nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token function\">completeWork</span><span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>siblingFiber <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// If there is a sibling, return it</span>\n      <span class=\"token comment\">// to perform work for this sibling</span>\n      <span class=\"token comment\">// 형제가 있으면 형제를 리턴한다.</span>\n      <span class=\"token keyword\">return</span> siblingFiber\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>returnFiber <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// If there's no more work in this returnFiber,</span>\n      <span class=\"token comment\">// continue the loop to complete the parent.</span>\n      <span class=\"token comment\">// 부모가 있으면 작업 트리를 부모로 할당해서 completeWork를 유도한다.</span>\n      workInProgress <span class=\"token operator\">=</span> returnFiber\n      <span class=\"token keyword\">continue</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// We've reached the root.</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">completeWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">workInProgress</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'work completed for '</span> <span class=\"token operator\">+</span> workInProgress<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>함수의 요지가 커다란 <code class=\"language-text\">while</code>루프 라는 것을 알 수 있습니다. React 는 <code class=\"language-text\">workInProgress</code> 노드에 children 이 없을 때 이 함수(<code class=\"language-text\">completeUnitOfWork</code>)로 들어갑니다. 현재 fiber 에 대한 작업을 마친 후 sibling 가 있는지 확인합니다. 발견되면 React 가 함수를 종료하고 형제에게 포인터를 반환합니다. <code class=\"language-text\">nextUnitOfWork</code> 변수에 할당되고 React 가 이 sibling 로 시작하는 분기에 대한 작업을 수행합니다. 이 시점에서 React 는 이전 siblings 를 위한 작업만 완료했다는 것을 이해하는 것이 중요합니다. 상위 노드에 대한 작업을 완료하지 않았습니다. <strong>자식 노드로 시작하는 모든 분기가 완료되면 부모 노드와 백 트랙에 대한 작업이 완료됩니다.</strong></p>\n<p>구현에서 볼 수 있듯이 <code class=\"language-text\">performUnitOfWork</code> 와 <code class=\"language-text\">completeUnitOfWork</code> 는 모두 반복 작업을 위해 주로 사용되는 반면, 주요 작업은 <code class=\"language-text\">beginWork</code> 및 <code class=\"language-text\">completeWork</code> 함수에서 수행됩니다. 이 시리즈의 다음 기사에서는 <code class=\"language-text\">ClickCounter</code> component 및 <code class=\"language-text\">span</code> 노드에 대해 React 가 <code class=\"language-text\">beginWork</code> 및 <code class=\"language-text\">completeWork</code> 함수 에 수행되는 것에 대해 알아 봅니다.</p>\n<h2 id=\"commit-phase\" style=\"position:relative;\"><a href=\"#commit-phase\" aria-label=\"commit phase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Commit phase</h2>\n<p>이 단계는 <a href=\"https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L2306\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">completeRoot</a> 함수로 시작합니다. 여기서 React 는 DOM 을 업데이트하고 사전 및 사후 mutation 라이프 사이클 메소드를 호출합니다.</p>\n<p>React 가 이 단계에 이르면 2 개의 tree 와 effects list 가 있습니다. 첫 번째 tree 는 현재 화면에 렌더링 된 상태를 나타냅니다. 그런 다음 <code class=\"language-text\">렌더링</code> 단계 동안 만들어진 <code class=\"language-text\">alternate</code> 트리가 있습니다. 소스에서 <code class=\"language-text\">finishedWork</code> 또는 <code class=\"language-text\">workInProgress</code> 라고하며 화면에 반영 되어야하는 상태를 나타냅니다. 이 <code class=\"language-text\">alternate</code> 트리는 <code class=\"language-text\">child</code> 및 <code class=\"language-text\">sibling</code> 포인터를 통해 current 트리와 비슷하게 연결됩니다.</p>\n<p>그런 다음 effects list - <code class=\"language-text\">nextEffect</code> 포인터를 통해 연결된 <code class=\"language-text\">finishedWork</code> 트리의 노드 하위 집합입니다. effects list 은 <code class=\"language-text\">렌더링 단계(render phase)</code>를 실행 한 결과임을 기억하십시오. 렌더링의 전체 포인트는 삽입, 업데이트 또는 삭제해야 할 노드와 어느 components가 라이프 사이클 메소드 호출이 필요한지를 결정하는 것이 었습니다. 이것이 effects list 에서 우리에게 알려줍니다. <strong>그리고 그것은 정확히 커밋 단계에서 반복되는 노드 집합입니다.</strong></p>\n<blockquote>\n<p>디버깅을 위해 <code class=\"language-text\">current</code> 트리는 fiber 루트의 <code class=\"language-text\">current</code> 속성을 통해 액세스 할 수 있습니다. <code class=\"language-text\">finishedWork</code> 트리는 <code class=\"language-text\">current</code> 트리의 <code class=\"language-text\">HostFiber</code> 노드의 <code class=\"language-text\">alternate</code> 프로퍼티를 통해 엑세스 할 수 있습니다.</p>\n</blockquote>\n<p>커밋 단계에서 실행되는 주요 기능은 <code class=\"language-text\">commitRoot</code>입니다. 기본적으로 다음과 같은 작업을 수행합니다.</p>\n<ul>\n<li><code class=\"language-text\">Snapshot</code> effect 태그가 지정된 노드에서 <code class=\"language-text\">getSnapshotBeforeUpdate</code> 라이프 사이클 메소드를 호출합니다.</li>\n<li><code class=\"language-text\">Deletion</code> effect 태그가 지정된 노드에서 <code class=\"language-text\">componentWillUnmount</code> 라이프 사이클 메소드를 호출합니다.</li>\n<li>모든 DOM 삽입, 업데이트 및 삭제를 수행합니다.</li>\n<li>완성 된 <code class=\"language-text\">작업 트리(finishedWork)</code>를 현재로 설정합니다.</li>\n<li><code class=\"language-text\">Placement</code> effect 태그가 지정된 노드에서 <code class=\"language-text\">componentDidMount</code> 라이프 사이클 메소드 호출</li>\n<li><code class=\"language-text\">Update</code> effect 태그가 지정된 노드에서 <code class=\"language-text\">componentDidUpdate</code> 라이프 사이클 메서드를 호출합니다.</li>\n</ul>\n<p>pre-mutation 메소드인 <code class=\"language-text\">getSnapshotBeforeUpdate</code> 를 호출 한 후, React 는 트리 내의 모든 side-effects 커밋합니다. 두 단계에 걸쳐 <code class=\"language-text\">커밋</code>을 진행합니다. 첫 번째 단계는 모든 DOM (host) 삽입, 업데이트, 삭제 및 참조 해제를 수행합니다.\n그런 다음 React 는 <code class=\"language-text\">workInProgress</code> 트리를 <code class=\"language-text\">current</code> 트리로 표시하기 위해 <code class=\"language-text\">finishedWork</code> 트리를 <code class=\"language-text\">FiberRoot</code> 에 할당합니다.</p>\n<p>이 작업은 커밋 단계의 첫 번째 단계 이후에 완료되며, 따라서 <code class=\"language-text\">componentWillUnmount</code> 동안에는 이전 트리는 current 이지만 두 번째 단계 이전에는 finished work 트리가 <code class=\"language-text\">componentDidMount / Update</code> 동안 current 상태가 됩니다.\n두 번째 단계에서는 React 가 다른 모든 라이프 사이클 메소드 및 ref 콜백을 호출합니다. 이러한 메소드는 별도의 단계로 실행되므로 전체 트리에서 모든 배치, 업데이트 및 삭제는 이미 호출되었습니다.</p>\n<p>위에서 설명한 단계를 실행하는 함수의 요지는 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">commitRoot</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">root<span class=\"token punctuation\">,</span> finishedWork</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">commitBeforeMutationLifecycles</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">commitAllHostEffects</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  root<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> finishedWork\n  <span class=\"token function\">commitAllLifeCycles</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>각 하위 함수는 effects list 을 반복하고 effect 의 type 을 확인하는 루프를 구현합니다. 함수의 목적과 관련된 효과를 발견하면 그것을 적용합니다.</p>\n<h2 id=\"pre-mutation-lifecycle-methods\" style=\"position:relative;\"><a href=\"#pre-mutation-lifecycle-methods\" aria-label=\"pre mutation lifecycle methods permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pre-mutation lifecycle methods</h2>\n<p>예를 들어, effects tree 를 반복하고 노드에 <code class=\"language-text\">Snapshot effect</code>가 있는지 확인하는 코드는 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">commitBeforeMutationLifecycles</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> effectTag <span class=\"token operator\">=</span> nextEffect<span class=\"token punctuation\">.</span>effectTag\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>effectTag <span class=\"token operator\">&amp;</span> Snapshot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> current <span class=\"token operator\">=</span> nextEffect<span class=\"token punctuation\">.</span>alternate\n      <span class=\"token function\">commitBeforeMutationLifeCycles</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> nextEffect<span class=\"token punctuation\">)</span> <span class=\"token comment\">// C 대문자?</span>\n    <span class=\"token punctuation\">}</span>\n    nextEffect <span class=\"token operator\">=</span> nextEffect<span class=\"token punctuation\">.</span>nextEffect\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>클래스 구성 요소의 경우이 effect 는 <code class=\"language-text\">getSnapshotBeforeUpdate</code> 라이프 사이클 메소드를 호출하는 것을 의미합니다.</p>\n<h2 id=\"dom-updates\" style=\"position:relative;\"><a href=\"#dom-updates\" aria-label=\"dom updates permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DOM updates</h2>\n<p><a href=\"https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L376\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">commitAllHostEffects</a> 는 React 가 DOM 업데이트를 수행하는 함수입니다. 이 함수는 기본적으로 노드에 대해 수행해야하는 작업 유형을 정의하고 실행합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> nextEffect<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">commitAllHostEffects</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>primaryEffectTag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> Placement<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">commitPlacement</span><span class=\"token punctuation\">(</span>nextEffect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">...</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">case</span> PlacementAndUpdate<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">commitPlacement</span><span class=\"token punctuation\">(</span>nextEffect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">commitWork</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> nextEffect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">...</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">case</span> Update<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">commitWork</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> nextEffect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">...</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">case</span> Deletion<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">commitDeletion</span><span class=\"token punctuation\">(</span>nextEffect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">...</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React 가 <code class=\"language-text\">commitDeletion</code> 함수에서 삭제 프로세스의 일부로 <code class=\"language-text\">componentWillUnmount</code> 메소드를 호출한다는 것은 흥미롭습니다.</p>\n<h2 id=\"post-mutation-lifecycle-methods\" style=\"position:relative;\"><a href=\"#post-mutation-lifecycle-methods\" aria-label=\"post mutation lifecycle methods permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Post-mutation lifecycle methods</h2>\n<p><a href=\"https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L465\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">commitAllLifecycles</a> 는 React 가 나머지 모든 라이프 사이클 메소드 인 <code class=\"language-text\">componentDidUpdate</code> 및 <code class=\"language-text\">componentDidMount</code> 를 호출하는 함수입니다.</p>","excerpt":"이글을 번역 및 분석 한 글입니다. 잘못된 번역 및 생략된 번역이 있을 수 있습니다. Inside Fiber: in-depth overview of the new reconciliation algorithm in React React…","tableOfContents":"<ul>\n<li>\n<p><a href=\"/ho_blog/react-fiber02/#inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react\">Inside Fiber: in-depth overview of the new reconciliation algorithm in React</a></p>\n<ul>\n<li><a href=\"/ho_blog/react-fiber02/#setting-the-background\">Setting the background</a></li>\n<li>\n<p><a href=\"/ho_blog/react-fiber02/#from-react-elements-to-fiber-nodes\">From React Elements to Fiber nodes</a></p>\n<ul>\n<li><a href=\"/ho_blog/react-fiber02/#react-elements\">React Elements</a></li>\n<li><a href=\"/ho_blog/react-fiber02/#fiber-nodes\">Fiber nodes</a></li>\n<li><a href=\"/ho_blog/react-fiber02/#current-and-work-in-progress-trees\">Current and work in progress trees</a></li>\n<li><a href=\"/ho_blog/react-fiber02/#side-effects\">Side-effects</a></li>\n<li><a href=\"/ho_blog/react-fiber02/#effects-list\">Effects list</a></li>\n<li><a href=\"/ho_blog/react-fiber02/#root-of-the-fiber-tree\">Root of the fiber tree</a></li>\n<li><a href=\"/ho_blog/react-fiber02/#fiber-node-structure\">Fiber node structure</a></li>\n</ul>\n</li>\n<li><a href=\"/ho_blog/react-fiber02/#general-algorithm\">General algorithm</a></li>\n<li>\n<p><a href=\"/ho_blog/react-fiber02/#render-phase\">Render phase</a></p>\n<ul>\n<li><a href=\"/ho_blog/react-fiber02/#main-steps-of-the-work-loop\">Main steps of the work loop</a></li>\n</ul>\n</li>\n<li><a href=\"/ho_blog/react-fiber02/#commit-phase\">Commit phase</a></li>\n<li><a href=\"/ho_blog/react-fiber02/#pre-mutation-lifecycle-methods\">Pre-mutation lifecycle methods</a></li>\n<li><a href=\"/ho_blog/react-fiber02/#dom-updates\">DOM updates</a></li>\n<li><a href=\"/ho_blog/react-fiber02/#post-mutation-lifecycle-methods\">Post-mutation lifecycle methods</a></li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/react-fiber02/"},"frontmatter":{"title":"React Fiber part2","date":"Jul 19, 2019","tags":["undefined"],"keywords":["Merlin Tech Blog","Merlin.ho"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/react-fiber02/","series":[],"lastmod":"0001-01-01"}}}