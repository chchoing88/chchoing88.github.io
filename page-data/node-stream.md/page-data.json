{"componentChunkName":"component---src-templates-post-tsx","path":"/node-stream.md/","result":{"data":{"markdownRemark":{"html":"<p>gulp 플러그인을 만들기 위한 사전 작업으로 node의 stream 공부한걸 정리 해보았습니다. 잘못 된 부분이 있을시 피드백 부탁드립니다.</p>\n<h2 id=\"stream\" style=\"position:relative;\"><a href=\"#stream\" aria-label=\"stream permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stream</h2>\n<p>스트리밍 데이터 작업을 위한 인터페이스 입니다. 즉, 한곳에서 다른 곳으로 데이터가 흐를 수 있게 만들어주는 통로라고 생각하면 됩니다.</p>\n<p>node.js 에는 스트림 타입이 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">Writable</code>: streams to which data can be written (for example, fs.createWriteStream()).</li>\n<li><code class=\"language-text\">Readable</code>: streams from which data can be read (for example, fs.createReadStream()).</li>\n<li><code class=\"language-text\">Duplex</code>: streams that are both Readable and Writable (for example, net.Socket).</li>\n<li><code class=\"language-text\">Transform</code>: Duplex streams that can modify or transform the data as it is written and read (for example, zlib.createDeflate()).</li>\n</ul>\n<h3 id=\"object-mode\" style=\"position:relative;\"><a href=\"#object-mode\" aria-label=\"object mode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object mode</h3>\n<p>Node.js API로 작성된 모든 스트림은 문자열 및 버퍼 (또는 Uint8Array) 오브젝트에서만 독점적으로 작동합니다. 그러나 스트림 구현이 다른 유형의 JavaScript 값과 함께 작동 할 수 있습니다 (스트림을 특수 목적으로하는 null 제외). 이러한 스트림은 \"개체 모드\"에서 작동하는 것으로 간주됩니다.</p>\n<p>스트림이 작성 될 때 objectMode 옵션을 사용하여 스트림 인스턴스가 오브젝트 모드로 전환됩니다. 기존 스트림을 객체 모드로 전환하는 것은 안전하지 않습니다.</p>\n<h2 id=\"readable-stream\" style=\"position:relative;\"><a href=\"#readable-stream\" aria-label=\"readable stream permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Readable Stream</h2>\n<p>readable 스트림은 2가지 작업 모드를 지원합니다. 기본적으로는 paused 모드를 default 모드로 하고 있습니다. 이 둘의 모드는 언제든 바뀔 수 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">flowing</code> : flowing 모드는 push 모드라고 합니다.</li>\n<li><code class=\"language-text\">paused</code> : paused 모드는 pull 모드라고 합니다.</li>\n</ul>\n<p><code class=\"language-text\">flowing</code> 모드에서는 기본 시스템에서 데이터를 자동으로 읽고 EventEmitter 인터페이스를 통해 이벤트를 사용하여 가능한 한 빨리 응용 프로그램에 제공합니다.</p>\n<p><code class=\"language-text\">pause</code> 모드에서는 <code class=\"language-text\">stream.read()</code> 메소드를 명시 적으로 호출하여 스트림에서 데이터 청크를 읽습니다.</p>\n<p>그리고 <code class=\"language-text\">writable</code> 스트림에 연결 됩니다.</p>\n<p><code class=\"language-text\">push</code> 모드의 장점은 <code class=\"language-text\">consumer</code> 가 데이터를 가져오는 코드를 컨트롤 하지 않고 데이터 소비하는 관점에서만 생각하면 된다는 것입니다. 단점은 <code class=\"language-text\">source</code> 측이 데이터 생산 속도가 <code class=\"language-text\">consumer</code> 데이터 처리 속도보다 빠를 때 문제가 생깁니다.</p>\n<p><code class=\"language-text\">paused</code> 모드의 장점은 <code class=\"language-text\">consumer</code> 의 데이터 처리 속도에 맞춰서 <code class=\"language-text\">source</code> 데이터를 가져올 수 있다는 것이지만 단점은 <code class=\"language-text\">consumer</code> 가 <code class=\"language-text\">source</code> 데이터 생산 동안 기다려야 하고 반대로 <code class=\"language-text\">consumer</code> 가 데이터를 처리 하고 있는 동안엔 <code class=\"language-text\">source</code> 데이터를 가져올 수 없으므로 <code class=\"language-text\">waiting</code> 시간이 많아 진다는 것입니다.</p>\n<p>위 같은 장단점을 보완하기 위해선 버퍼가 필요합니다.</p>\n<h2 id=\"buffer\" style=\"position:relative;\"><a href=\"#buffer\" aria-label=\"buffer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Buffer</h2>\n<p>버퍼는 <code class=\"language-text\">consumer</code> 와 <code class=\"language-text\">source</code> 데이터의 처리 속도의 차이로 인해 생겨난 것입니다.\n버퍼가 없는 상황에서 실제로 <code class=\"language-text\">consumer</code> 는 <code class=\"language-text\">source</code> 데이터 처리 속도 직접적으로 제어 하긴 힘듭니다.</p>\n<p>따라서 스트림에 버퍼를 하나 두어 <code class=\"language-text\">source</code> 에 빠른 데이터 처리에 임시로 저장 해두는 공간을 마련해 둡니다.\n<code class=\"language-text\">consumer</code> 쪽은 <code class=\"language-text\">source</code> 속도와 상관없이 버퍼에 있는 데이터를 가져다 쓰면 되는 것입니다.</p>\n<p>이때, <code class=\"language-text\">soucre</code> 속도 보다 <code class=\"language-text\">consumer</code> 속도가 빠르게 되면 <code class=\"language-text\">buffering</code> ( 데이터 수집중.. ) 이라는 현상이 발생하는 것입니다.</p>\n<p><strong>source — push (일단 던지고) —> buffer에 쌓이고 —> pull(내가 원할 때 받고) —> consumer</strong></p>\n<p><code class=\"language-text\">source</code> 데이터가 <code class=\"language-text\">push</code>를 지속적으로 하면 buffer는 무한정 늘어 날 가능성이 있다. 이때를 대비해서 <code class=\"language-text\">backpressure</code> 기법을 사용한다. ( <code class=\"language-text\">highWaterMark</code> 속성을 사용해서 버퍼의 데이터 양을 조절 )</p>\n<p><code class=\"language-text\">buffer</code>가 꽉 찼을 때는 <code class=\"language-text\">pause</code>를 통해 <code class=\"language-text\">source</code>가 데이터 생산을 잠시 중단하고, 버퍼가 <code class=\"language-text\">drain</code> 되었을 때( 다시 쓸 준비가 되었을 때 ) 는 <code class=\"language-text\">resume</code> 을 통해 <code class=\"language-text\">source</code>가 데이터 생산을 재개하게 만들어 준다.</p>\n<p>nodejs는 외부 자원(http, fs) 에서 쏟아지는 데이터 양(push : 일방적으로 보내는)을 조절하기 위해 다음과 같은 일을 <code class=\"language-text\">pipe</code> 에서 진행 해줍니다.</p>\n<ul>\n<li><code class=\"language-text\">consumer</code> 가 원할 때 <code class=\"language-text\">source</code> 데이터를 <code class=\"language-text\">push</code> 해준다. ( 즉, <code class=\"language-text\">consumer</code>가 데이터를 달라고 요청 )</li>\n<li>쓰는 스트림의 버퍼 양에 따라서 <code class=\"language-text\">source</code> 데이터를 <code class=\"language-text\">pause/resume</code> 해준다.</li>\n<li><code class=\"language-text\">resume</code> 되면 <code class=\"language-text\">flowing</code> 읽기 모드</li>\n<li><code class=\"language-text\">pause</code> 되면 <code class=\"language-text\">pause</code> 읽기 모드</li>\n</ul>\n<h2 id=\"관련-스트림-이벤트\" style=\"position:relative;\"><a href=\"#%EA%B4%80%EB%A0%A8-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%9D%B4%EB%B2%A4%ED%8A%B8\" aria-label=\"관련 스트림 이벤트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>관련 스트림 이벤트</h2>\n<ul>\n<li><code class=\"language-text\">readable 이벤트</code> : 스트림에서 읽을 수 있는 데이터가 있을때 발생한다. 또한 이벤트 end 가 발생되기 전 스트림의 끝에 다 달았을 때도 한번 발생한다.</li>\n<li><code class=\"language-text\">drain 이벤트</code> : 쓰기 스트림의 <code class=\"language-text\">stream.write(chunk)</code> 를 호출해서 <code class=\"language-text\">false</code> 가 리턴이 되면, 다시 스트림에 데이터를 쓸 적절한 시기 때 이벤트가 발생된다.</li>\n</ul>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://iximiuz.com/en/posts/nodejs-readable-streams-distilled/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://iximiuz.com/en/posts/nodejs-readable-streams-distilled/</a></li>\n<li><a href=\"https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7</a></li>\n<li><a href=\"http://jeonghwan-kim.github.io/node/2017/08/12/node-stream-you-need-to-know-3.html#%EC%93%B0%EA%B8%B0-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://jeonghwan-kim.github.io/node/2017/08/12/node-stream-you-need-to-know-3.html#%EC%93%B0%EA%B8%B0-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0</a></li>\n<li><a href=\"https://velog.io/@devzunky/TIL-no.95-Node.js-Buffer#stream\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@devzunky/TIL-no.95-Node.js-Buffer#stream</a></li>\n</ul>","excerpt":"gulp 플러그인을 만들기 위한 사전 작업으로 node의 stream 공부한걸 정리 해보았습니다. 잘못 된 부분이 있을시 피드백 부탁드립니다. Stream…","tableOfContents":"<ul>\n<li>\n<p><a href=\"/ho_blog/node-stream.md/#stream\">Stream</a></p>\n<ul>\n<li><a href=\"/ho_blog/node-stream.md/#object-mode\">Object mode</a></li>\n</ul>\n</li>\n<li><a href=\"/ho_blog/node-stream.md/#readable-stream\">Readable Stream</a></li>\n<li><a href=\"/ho_blog/node-stream.md/#buffer\">Buffer</a></li>\n<li><a href=\"/ho_blog/node-stream.md/#%EA%B4%80%EB%A0%A8-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%9D%B4%EB%B2%A4%ED%8A%B8\">관련 스트림 이벤트</a></li>\n<li><a href=\"/ho_blog/node-stream.md/#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>","fields":{"slug":"/node-stream.md/"},"frontmatter":{"title":"node stream 에 관하여","date":"Jun 05, 2020","tags":["undefined"],"keywords":["Merlin Tech Blog","Merlin.ho"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/node-stream.md/","series":[],"lastmod":"0001-01-01"}}}