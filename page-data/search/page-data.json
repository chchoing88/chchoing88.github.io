{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## 동적 프로그래밍\n\n- 동적 프로그래밍은 재귀와 상반되는 기법으로 알려져 있습니다. 재귀에서는 위에서 아래로 내려가면서 점차 작아지는 문제를 모두 해결하는 방식인 반면, 동적프로그래밍에서는 아래에서 위로 해결하면서 결과를 모아 큰 전체 문제를 해결하는 방식입니다.\n- 재귀 기법으로 해결할 수 있는 대부분의 프로그래밍 문제는 동적 프로그래밍으로도 해결할 수 있습니다.\n\n### 피보나치 예제\n\n피보나치는 이전의 두 숫자를 더해서 다음 숫자를 만들 수 있습니다.\n재귀를 이용해서 다음과 같이 구현할 수 있습니다.\n\n```typescript\nfunction recurFib(n) {\n  if(n < 2) {\n    return n;\n  } else {\n    return recurFib(n-1) + recurFib(n-2);\n  }\n}\n```\n\n이미 계산한 값을 컴파일러가 기억할 수 있다면 더 효율성을 높일 수 있습니다.\n동적 프로그래밍에서는 가장 간단한 하위 문제부터 해결하면서 좀 더 복잡한 상위 문제로 나아갑니다.\n\n```typescript\nfunction dynFib(n) {\n  // 초기화\n  const val = new Array(n).fill(0);\n\n  if(n === 1 || n === 2) {\n    return 1;\n  } else if(n > 2) {\n    val[1] = 1;\n    val[2] = 1;\n    for (let i = 3; i <= n; i++) {\n      val[i] = val[i-1] + val[i-2];\n    }\n  }\n\n  return val[n]\n}\n```\n\n반복 기법을 이용해서도 피보나치를 계산 할 수 있다.\n\n```typescript\nfunction iterFib(n) {\n  let last = 1; // 첫번째\n  let nextLast = 1; // 두번째\n  let result = 1;\n\n  for(let i = 3; i <= n; i++) {\n    result = last + nextLast;\n    last = nextLast;\n    nextLast = result;\n  }\n\n  return result;\n}\n```\n\n### 가장 긴 공통 문자열 찾기\n\n- 두 개의 문자열에서 가장 긴 공통 문자열을 찾는 문제입니다.\n- 이차원 배열을 이용해서 각 문자열을 비교하고 두 배열의 같은 위치에서 같은 문자를 발견하면 이차원 배열의 해당 행과 열에 위치한 요소를 1 증가시킵니다.\n- 문자열을 비교하면서 얼마나 많은 글자가 일치했는지 변수에 저장합니다.\n- 알고리즘이 끝나면 일치한 횟수를 저장한 변수와 인덱스 변수를 이용해 가장 긴 공통 문자열을 반환합니다.\n\n```typescript\nfunction Isc (word1: string, word2: string) {\n  const icsArr: number[][] = [];\n  let max = 0;\n  let index = 0;\n\n  // 초기화\n  for (let i = 0; i <= word1.length; i++) {\n    icsArr[i] = [];\n    for (let j = 0; j <= word2.length; j++) {\n      icsArr[i][j] = 0;\n    }\n  }\n  \n\n  // 계산\n  // i === 0 || j === 0 인 곳은 0으로 셋팅해준다\n  for (let i = 1; i <= word1.length; i++) {\n    for (let j = 1; j <= word2.length; j++) {\n      if(word1[i-1] === word2[j-1]) {\n        // 단어가 같으면 카운트를 해줍니다.\n        icsArr[i][j] = icsArr[i-1][j-1] + 1;\n\n        // 카운트 한 값이 max 보다 크다면 max 값을 업데이트 하고\n        // 그 인덱스를 index에 저장해둔다\n        if(max < icsArr[i][j]) {\n          max = icsArr[i][j];\n          index = i;\n        }\n      }\n    }\n  }\n\n  // 출력\n  if(max === 0) {\n    return '';\n  }\n\n  if(max > 0) {\n    let str = '';\n    console.log(icsArr)\n    // index - max : 연속된 max 값을 가지는 해당 index에 max를 빼면 시작 인덱스를 얻을 수 있다\n    for (let i = index-max; i <= max; i++) {\n      str += word1[i];\n    }\n    return str;\n  }\n}\n\nconsole.log(Isc('abbcc', 'dbbcc'))\n//              a, b, b, c, c\n// 0: (6)   [0, 0, 0, 0, 0, 0]\n// 1: (6) d [0, 0, 0, 0, 0, 0]\n// 2: (6) b [0, 0, 1, 1, 0, 0]\n// 3: (6) b [0, 0, 1, 2, 0, 0]\n// 4: (6) c [0, 0, 0, 0, 3, 1]\n// 5: (6) c [0, 0, 0, 0, 1, 4]\n```\n\n### 배낭 문제\n\n## 탐욕 알고리즘\n\n- 문제를 해결하는 좋은 해결책을 찾아가는 기법입니다.\n","excerpt":"동적 프로그래밍 동적 프로그래밍은 재귀와 상반되는 기법으로 알려져 있습니다. 재귀에서는 위에서 아래로 내려가면서 점차 작아지는 문제를 모두 해결하는 방식인 반면, 동적프로그래밍에서는 아래에서 위로 해결하면서 결과를 모아 큰 전체 문제를 해결하는 방식…","fields":{"slug":"/advanced/"},"frontmatter":{"date":"May 01, 2020","title":"[algorithms] advanced","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 검색 알고리즘\n\n- 리스트에서는 순차 검색(sequential search)과 이진 검색(binary search) 두 가지 방법으로 데이터를 검색할 수 있습니다.\n- 리스트의 항목이 임의의 순서로 저장되어 있을 때는 순차 검색을 사용합니다.\n- 리스트의 항목이 정렬되어 있을 때는 이진 검색을 이용합니다.\n- 이진 검색이 순차 검색보다 효율성을 좋지만, 이진 검색을 수행하려면 리스트의 데이터를 정렬하는 데도 시간을 소비함을 감안해야 합니다.\n\n## 순차 검색\n\n- 리스트에서 데이터를 찾는 가장 단순한 방법 입니다. 리스트의 처음 요소부터 찾는 요소가 발견 될때까지 계속 다음 요소를 찾는 것입니다.\n\n```typescript\nfunction seqSearch(arr: number[], data: number) {\n  for (let i = 0; i < arr.length; ++i) {\n    if(arr[i] === data) {\n      return true;\n    }\n  }\n  return false;\n}\n```\n\n- 참과 거짓이 아니라 발견된 위치를 반환하도록 순차 검색 함수를 고칠 수 있습니다.\n\n```typescript\nfunction seqSearch(arr: number[], data: number) {\n  for (let i = 0; i < arr.length; ++i) {\n    if(arr[i] === data) {\n      return i;\n    }\n  }\n  return -1;\n}\n```\n\n- Array.indexOf() 함수보다 속도가 느리므로 실용성은 없습니다.\n\n### 최솟값과 최댓값 검색\n\n배열에서 최솟값을 찾는 알고리즘\n\n1. 배열의 첫 번째 요소를 최솟값으로 간주해 변수에 저장한다.\n2. 배열의 두 번째 요소부터 루프를 돌면서 현재 최솟값과 크기를 비교한다.\n3. 배열 요소가 현재 최솟값보다 작다면 현재 요소를 새로운 최솟값으로 간주하고 변수에 저장한다.\n\n```typescript\nfunction findMin(arr: number[]) {\n  let min = arr[0]\n\n  for(let i = 1; i < arr.length; ++i) {\n    if( arr[i] < min ) {\n      min = arr[i];\n    }\n  }\n\n  return min;\n}\n```\n\n최댓값을 찾는 로직도 다를 바 없다.\n\n```typescript\nfunction findMax(arr: number[]) {\n  let max = arr[0]\n\n  for(let i = 1; i < arr.length; ++i) {\n    if( arr[i] > max ) {\n      max = arr[i];\n    }\n  }\n\n  return max;\n}\n```\n\n### 자체 정렬 데이터\n\n- 자주 검색하는 데이터를 데이터 집합의 앞부분에 저장함으로써 검색 속도를 높일 수 있는 기법입니다.\n- 프로그램이 실행되면서 자체적으로 정렬되는 데이터를 자체 정렬 데이터 (self-organized data)라 합니다.\n\n```typescript\nfunction seqSearch(arr: number[], data: number) {\n  \n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] === data) {\n      // if( i > 0 ) {\n        // 찾는 데이터가 가장 첫번째에 있지 않다면 하나씩 앞으로 옮긴다.\n        // swap(arr, i, i-1);\n      if(i > (arr.length * 0.2)) {\n        // 데이터 집합의 시작지점으로부터 20 퍼센트에 해당하지 않는 데이터면 위치를 바꾸는 방식을 이용\n          swap(arr, i , 0)\n      }\n      return true\n    }\n  }\n  return falses\n}\n\nfunction swap(arr: number[], index: number, index1: number) {\n  const temp = arr[index]\n  arr[index] = arr[index1]\n  arr[index1] = temp\n}\n```\n\n## 이진 검색\n\n- 데이터가 정렬된 상황에서는 순차 검색보다는 이진 검색이 더 효율적이다.\n- 숫자를 선택할 때 상대방의 대답에 따라 제시한 숫자보다 큰쪽이나 작은 쪽 범위에서 중간값(midpoint)을 다시 제시하는 방법을 활용할 수 있습니다.\n\n```typescript\nfunction binSearch(arr: number[], data: number) {\n let upperBound = arr.length - 1; // 상위 경계 (높은 수)\n let lowerBound = 0; // 하위 경계 (낮은수)\n\n while(lowerBound <= upperBound) { // 상위 경계가 크다면 계속 돕니다.\n  const mid = Math.floor((upperBound + lowerBound) / 2);\n  if(arr[mid] < data) {\n    // 물리적인 중간값을 설정하고 이 중간값보다 찾는 값이 크다면 하위 경계를 중간값 + 1 로 셋팅합니다.\n    lowerBound = mid + 1;\n  } else if(arr[mid] > data) {\n    // 물리적인 중간값을 설정하고 이 중간값보다 찾는 값이 작다면 상위 경계를 중간값 - 1 로 셋팅합니다.\n    upperBound = mid - 1;\n  } else {\n    // 그 외 arr[mid] 값이 data 와 같다면 해당 인덱스를 반환합니다.\n    return mid\n  }\n }\n  \n  return -1; // 발견하지 못한다면ㄴ\n}\n```\n","excerpt":"검색 알고리즘 리스트에서는 순차 검색(sequential search)과 이진 검색(binary search) 두 가지 방법으로 데이터를 검색할 수 있습니다. 리스트의 항목이 임의의 순서로 저장되어 있을 때는 순차 검색을 사용합니다. 리스트의 항목이…","fields":{"slug":"/searchAlgorithms/"},"frontmatter":{"date":"May 01, 2020","title":"[algorithms] Search","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## XXS(cross-site scripting)\n\nOWASP라는 단체에서는 다음과 같이 정의를 하고 있습니다.\n\n\"Cross-Site Scripting (XSS) 공격은 주입타입의 공격으로 악의적인 스크립트가 다른 신뢰 받는 웹 사이트에 삽입되어 지면서 발생합니다.\n공격자가 웹 응용 프로그램을 사용하여 악성 코드를 보낼 때 XSS 공격이 발생합니다. 일반적으로 브라우저 측 스크립트 형태로 다른 최종 사용자에게 제공됩니다.\n\n이러한 공격이 성공할 수있는 결함은 매우 광범위하며 웹 응용 프로그램이 사용자의 입력을 유효성을 검사하지 않거나 인코딩하지 않고 생성 된 출력이 사용하는 모든 곳에서 발생합니다.\n\n공격자는 XSS를 사용하여 의심없는 사용자에게 악의적인 스크립트를 보낼 수 있습니다. 최종 사용자의 브라우저는 스크립트를 신뢰할 수 없다는 것을 알 수 없으며 스크립트를 실행할 것입니다. 스크립트는 신뢰할 수 있는 소스에서 온 것으로 생각하기 때문에 악성 스크립트는 쿠키, 세션 토큰 또는 브라우저가 보유하고 해당 사이트에서 사용하는 기타 민감한 정보에 액세스 할 수 있습니다. 이 스크립트는 HTML 페이지의 내용을 다시 작성할 수도 있습니다.\"\n\nXXS의 취약점은 애플리케이션이 신뢰할 수 없는 데이터를 가져와 적저한 검증이나 제한 없이 웹브라우저로 보낼 때 발생이 됩니다.\n\n### 가장 일반적인 공격 패턴\n\n1. 게시판에 특정 스크립트를 작성한 뒤 불특정 다수가 보도록 유도\n2. 스크립트가 시작하여 열람자의 쿠키 값을 가로챔\n3. 가로챈 쿠키 값을 웹 프록시 등을 이용하여 재전송\n4. 공격자는 열람자의 정보로 로그인\n\n### 저장 XSS 공격\n\n- 웹 서버에 악성 스크립트를 영구적으로 저장해 놓는 방법입니다.\n- 게시판, 사용자 프로필 및 코멘트 필드 등에 악성 스크립트를 심어 놓으면 사용자가 사이트를 방문했을때 사용자 스크립트가 실행되면서 공격합니다.\n\n### 반사 XSS 공격\n\n- 검색 결과, 에러 메시지 등 서버가 외부에서 입력받은 값을 받아 브라우저에게 응답할때 전송하는 과정에서 입력되는 변수의 위험한 문자를 사용자에게 그대로 돌려주면서 발생합니다.\n- 사용자가 서버로 입력 한 값을, 서버는 요청한 사용자의 브라우저로 악성스크립트를 반사 시킵니다.\n- 즉, 사용자가 악성 스크립트가 포함한 링크를 클릭한 순간 바로 악성 스크립트가 사용자의 브라우저에서 실행됩니다.\n\n요청 URL\n\n```http\nhttp://www.server.com/search/?q<script>alert(document.cookie)</script>&x=0&y=0\n```\n\n응답 HTML\n\n```html\n<html>\n  <body>\n    <div>\n      Search: \"<script>alert(document.cookie)</script>\"\n    </div>\n  </body>\n</html>\n```\n\n위 응답을 브라우저에서 실행할 경우 alert가 실행이 됩니다.\n\n### DOM 기반 XSS 공격\n\n- W3C9에서는 DOM을 ‘프로그램 및 스크립트가 문서의 컨텐츠, 구조 및 형식을 동적으로 접근 및 업데이트할 수 있도록 하는 언어 중립적인 인터페이스이다’라고 정의되어 있습니다. 따라서 DOM은 HTML 문서를 계층적으로 보면서 컨텐츠를 동적으로 변경할 수 있다.\n- 피해자의 브라우저가 HTML 페이지를 구문 분석할 때마다 공격 스크립트가 DOM 생성의 일부로 실행되면서 공격합니다.\n- 페이지 자체는 변하지 않으나, 페이지에 포함되어 있는 브라우저측 코드가 DOM 환경에서 악성코드로 실행됩니다.\n- 저장 XSS 및 반사 XSS 공격의 악성 페이로드가 서버 측 애플리케이션 취약점으로 인해, 응답 페이지에 악성 스크립트가 포함되면서 공격하는것인 반면, DOM 기반은 XSS는 서버와 관계없이 브라우저에서 발생하는 것이 차이점 입니다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n\n  <script>\n    var pos = document.URL.indexOf(\"name=\") + 5;\n    document.write(document.URL.substring(pos, document.URL.length));\n  </script>\n</body>\n\n</html>\n```\n\n위 페이지에서 name 변수에 다음과 같이 변수를 입력하면\n\n```http\nhttp://www.server.com/page.html?name=merlin\n```\n\n정상적으로 동작합니다. 하지만 DOM 기반 XSS 공격을 위해서 다음과 같이 입력하면 브라우저에서 script 의 내용이 실행되게 됩니다.\n\n```http\nhttp://www.server.com/page.html?name=<script>alert(document.cookie)</script>\n```\n\n모던 브라우저에서는 주소줄에 `<` `>` 는 인코딩되서 표현되기 때문에 실행이 되지 않습니다.\n\n### 그 외 방법\n\n- DOM의 이벤트 속성을 사용하는 방법\n\n```html\n<img src=\"#\" onerror=\"alert('XSS')\">\n```\n\n- 자바스크립트 링크 및 내용 난독화 (HTML 인코드한 태그를 삽입하여 자바스크립트 실행)\n\n```html\n<a href=\"javascript:alert('XSS')\"> XSS </a>\n\n<a href=\"&#x6A;&#x61;&#x76;&#x61;&#x73;&#xA;&#x63;&#x72;&#x69;&#x70;&#x74;&#xA;&#x3A;&#xA;&#x61;&#x6C;&#x65;&#x72;&#x74;&#xA;&#x28;&#x27;&#x58;&#x53;&#x53;&#x27;&#x29;\">XSS</a>\n```\n\n## CSRF(Cross-Site Request Forgery)\n\nCSRF (Cross-Site Request Forgery)는 최종 사용자가 현재 인증 된 웹 응용 프로그램에서 원치 않는 동작을 실행하도록 하는 공격입니다.\nCSRF 공격은 공격자가 위조 된 요청에 대한 응답을 볼 수 있는 방법이 없기 때문에 데이터 도난이 아닌 상태 변경 요청을 대상으로 합니다.\n\n공격자는 전자 메일이나 채팅을 통해 링크를 보내는 등의 사회 공학의 도움을 받아 웹 응용 프로그램 사용자가 자신이 선택한 작업을 실행하도록 속일 수 있습니다.\n피해자가 일반 사용자 인 경우 CSRF 공격이 성공하면 사용자는 자금 이체, 전자 메일 주소 변경 등과 같은 상태 변경 요청을 수행 할 수 있습니다. 피해자가 관리 계정 인 경우 CSRF는 전체 웹 응용 프로그램을 손상시킬 수 있습니다.\n\n즉, A 라는 사용자가 example.com에 로그인 된 채로 (유효한 session id를 쿠키로 가지고 있는) 있다면 B(악당) 이 `<img src=http://example.com/api/logout />` 이러한 페이지를 A 라는 사용자에게 넘겨서 A 사용자가 보게 된다면 example로 요청이 들어갈때 session id 쿠키와 함께 요청이 들어간다. 그러면 유효한 요청이 되어서 A 사용자도 모르게 로그아웃이 되는 것이다.  여기서는 단순 로그아웃 요청이지만 이 요청은 악의적인 데이터 수집, 수정, 삭제가 될 수 있습니다.\n\nCSRF는 피해자가 악의적인 요청을 제출하도록 속이는 공격입니다. 피해자를 대신하여 원하지 않는 기능을 수행하기 위해 피해자의 신분과 특권을 상속합니다. 대부분의 사이트에서 브라우저 요청에는 사용자 세션 쿠키, IP 주소, Windows 도메인 자격 증명 등 사이트와 관련된 자격 증명이 자동으로 포함됩니다. 따라서 사용자가 현재 사이트에 인증 된 경우 사이트는 피해자가 보낸 위조 된 요청과 피해자가 보낸 합법적 인 요청을 구분할 방법이 없습니다.\n\nCSRF 공격은 대상의 전자 메일 주소 또는 암호 변경 또는 무언가 구매와 같이 서버에서 상태를 변경하는 기능을 대상으로합니다. 공격자가 응답을받지 않기 때문에 피해자가 데이터를 검색하도록 강요해도 공격자에게 도움이되지 않습니다. 따라서 CSRF 공격은 상태 변경 요청을 대상으로합니다.\n\n취약한 사이트 자체에 CSRF 공격을 저장하는 것이 때때로 가능합니다. 이러한 취약점을 \"저장된 CSRF 결함\"이라고합니다. HTML을 허용하는 필드에 IMG 또는 IFRAME 태그를 저장하거나보다 복잡한 사이트 간 스크립팅 공격을 수행하면됩니다. 공격이 사이트에 CSRF 공격을 저장할 수 있으면 공격의 심각성이 증폭됩니다. 특히, 피해자가 인터넷의 임의의 임의 페이지보다 공격이 포함 된 페이지를 볼 가능성이 높기 때문에 가능성이 높아집니다. 피해자가 이미 사이트에서 인증을 받았기 때문에 가능성도 높아집니다.\n\n### GET 시나리오 예제\n\n어플리케이션에서 주로 GET 요청을 사용하여 어떤 액션을 취하게끔 한다고 한다면 다음과 같은 요청으로 송금을 할 수 있습니다.\n\n```http\nGET http://bank.com/transfer.do?acct=BOB&amount=100 HTTP/1.1\n```\n\n이제 Maria(Attacker)가 Alice 계정에서 100,000원을 자신의 계정으로 이체할 URL을 구성할 수 있습니다.\n\n```http\nGET http://bank.com/transfer.do?acct=MARIA&amount=100000\n```\n\n이제 Alice가 은행 응용 프로그램에 로그인을 할 때 이 URL을 로드하도록 속여야 합니다.\n\n- 원치 않는 HTML 컨텐츠가 담긴 이메일\n- 온라인 뱅킹을하는 동안 피해자가 방문 할 가능성이있는 페이지에 익스플로잇 URL 또는 스크립트를 심기\n\n익스플로잇 URL은 일반 링크로 위장하여 피해자가 클릭하도록 권장합니다.\n\n```html\n<a href=\"http://bank.com/transfer.do?acct=MARIA&amount=100000\">View my Pictures!</a>\n```\n\n또는 0x0 가짜 이미지로 :\n\n```html\n<img src=\"http://bank.com/transfer.do?acct=MARIA&amount=100000\" width=\"0\" height=\"0\" border=\"0\">\n```\n\n이 이미지 태그가 이메일에 포함 된 경우 Alice는 아무것도 볼 수 없습니다. \n그러나 브라우저 는 전송이 이루어 졌음을 시각적으로 표시하지 않고 bank.com에 요청을 계속 제출합니다.\n\n### POST 시나리오 예제\n\nGET과 POST 공격의 유일한 차이점은 피해자가 공격을 실행하는 방법입니다. 은행에서 현재 POST를 사용하고 취약한 요청이 다음과 같이 가정합니다.\n\n```http\nPOST http://bank.com/transfer.do HTTP/1.1\n\nacct=BOB&amount=100\n```\n\n이러한 요청은 표준 A 또는 IMG 태그를 사용하여 전달할 수 없지만 FORM 태그를 사용하여 전달할 수 있습니다.\n\n```html\n<form action=\"http://bank.com/transfer.do\" method=\"POST\">\n\n<input type=\"hidden\" name=\"acct\" value=\"MARIA\"/>\n<input type=\"hidden\" name=\"amount\" value=\"100000\"/>\n<input type=\"submit\" value=\"View my pictures\"/>\n\n</form>\n```\n\n이 양식을 사용하려면 제출 버튼을 클릭해야하지만 JavaScript를 사용하여 자동으로 실행할 수도 있습니다.\n\n```html\n<body onload=\"document.forms[0].submit()\">\n\n<form></form>\n```\n\n### 다른 HTTP 메소드 시나리오\n\n최신 웹 애플리케이션 API는 PUT 또는 DELETE와 같은 다른 HTTP 메소드를 자주 사용합니다. 취약한 은행이 JSON 블록을 인수로 취하는 PUT을 사용한다고 가정 해 봅시다.\n\n```http\nPUT http://bank.com/transfer.do HTTP/1.1\n\n{ \"acct\":\"BOB\", \"amount\":100 }\n```\n\n이러한 요청은 익스플로잇 페이지에 임베드 된 JavaScript로 실행될 수 있습니다.\n\n```html\n<script>\nfunction put() {\n    var x = new XMLHttpRequest();\n    x.open(\"PUT\",\"http://bank.com/transfer.do\",true);\n    x.setRequestHeader(\"Content-Type\", \"application/json\");\n    x.send(JSON.stringify({\"acct\":\"BOB\", \"amount\":100})); \n}\n</script>\n\n<body onload=\"put()\">\n```\n\n다행스럽게도이 요청은 동일한 출처 정책 제한으로 인해 최신 웹 브라우저에서 실행 되지 않습니다. 이 제한은 대상 웹 사이트가 다음 헤더와 함께 CORS 를 사용하여 공격자 (또는 모든 사람)의 출처에서 교차 출처 요청을 명시 적으로 열지 않는 한 기본적으로 사용됩니다.\n\n## 출처\n\n- [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf)\n- [https://owasp.org/www-community/attacks/xss/](https://owasp.org/www-community/attacks/xss/)","excerpt":"XXS(cross-site scripting) OWASP라는 단체에서는 다음과 같이 정의를 하고 있습니다. \"Cross-Site Scripting (XSS) 공격은 주입타입의 공격으로 악의적인 스크립트가 다른 신뢰 받는 웹 사이트에 삽입되어 지면서 …","fields":{"slug":"/javascript-security.md/"},"frontmatter":{"date":"Apr 30, 2020","title":"xxs 와 csrf","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 버블 정렬\n\n- 버블 정렬은 가장 느린 정렬 알고리즘 가운데 하나 입니다.\n- 배열의 데이터를 정렬할 때 배열의 한쪽 끝에서 다른 쪽 끝으로 버블처럼 값이 떠오른다는 의미에서 버블 정렬이라는 이름이 유래했습니다.\n- 어떤 데이터 집합을 오름차순으로 정렬하면 큰 값은 배열의 오른쪽으로 이동해야 하고 작은 값은 배열의 왼쪽으로 이동해야 합니다.\n- 배열의 데이터를 여러 번 반복적으로 탐색하면서 인접한 값을 서로 비교해 왼쪽 값이 오른쪽 값보다 크다면 두 값을 서로 바꿔야 합니다.\n- 한번 버블 정렬 될때마다 맨 끝의 숫자가 정렬이 된것 입니다.\n- 맨 마지막 element를 빼고 다시 버블 정렬을 시작한다. 남은 element가 1개 이상일때까지 반복한다.\n\n```typescript\n// 배열을 생성하는 테스트 베드 클래스\n\nclass CArray {\n  dataStore: number[];\n  numElements: number;\n  pos: number;\n\n  constructor(numElements: number) {\n    this.pos = 0; // 빈공간\n    this.dataStore = [];\n    this.numElements = numElements;\n\n    for (let i = 0; i < numElements; i++) {\n      this.dataStore[i] = i;\n    }\n    this.pos = numElements;\n  }\n\n  setData() {\n    for (let i = 0; i < this.numElements; i++) {\n      // Math.random() : 0 ~ 1\n      // 0 ~ 1 * 101 => 1 ~ 100 임의수 생성\n      this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1));\n    }\n  }\n\n  clear() {\n    this.dataStore.forEach((i) => (i = 0));\n    this.pos = 0;\n  }\n\n  insert(element: number) {\n    this.dataStore[this.pos++] = element;\n  }\n\n  toString() {\n    let retstr = \"\";\n    this.dataStore.forEach((i, index) => {\n      retstr += `${i} `;\n      if (index > 0 && index % 10 === 0) {\n        retstr += `\\n`;\n      }\n    });\n\n    return retstr;\n  }\n\n  swap(arr: any[], index1: number, index2: number) {\n    const temp = arr[index1];\n    arr[index1] = arr[index2];\n    arr[index2] = temp;\n  }\n\n  // 버블 정렬\n  // 한번 버블 정렬 될때마다 맨 끝의 숫자가 정렬이 된것이다.\n  // 맨 마지막 element를 빼고 다시 버블 정렬을 시작한다.\n  // 남은 element가 1개 이상일때까지 반복한다.\n  bubbleSort() {\n    for (let outer = this.dataStore.length - 1; outer > 1; outer--) {\n      for (let i = 0; i < outer; i++) {\n        if (this.dataStore[i] > this.dataStore[i + 1]) {\n          this.swap(this.dataStore, i, i + 1);\n        }\n      }\n    }\n  }\n}\n```\n\n## 선택 정렬\n\n- 선택 정렬은 배열의 처음 요소부터 차례로 값을 비교합니다.\n- 모든 요소의 비교가 끝난 시점에는 가장 작은 요소가 배열의 첫번째로 옵니다.\n- 다음에는 두 번째 자리에 올 요소를 정렬하는 식입니다. 배열의 마지막 요소가 자기 위치로 올 때까지 반복합니다.\n- 외부 루프는 배열의 첫 번째 요소에서 마지막 요소를 반복합니다. 내부 루프는 배열 요소의 두 번째 요소에서 마지막 요소를 반복하면서 외부 루프가 가리키는 현재 요소보다 작은 요소가 있는지 확입합니다.\n- 즉, 첫번째 자리를 기준으로 가장 작은 숫자가 오게 만들고, 두번째 자리는 그 이후 숫자에서 가장 작은 숫자가 오게 만듭니다.\n\n```typescript\n// 선택 정렬\n// 첫번째 자리에 제일 작은 숫자가 오게 한 다음\n// 두번째 자리에 제일 작은 숫자가 오도록 계속 정렬한다.\nselectionSort() {\n  for (let pos = 0; pos < this.dataStore.length - 1; pos++) {\n    // minPos 작은 수가 저장되어있는 index\n    let minPos = pos;\n    for (let i = pos + 1; i < this.dataStore.length; i++) {\n      if (this.dataStore[i] < this.dataStore[minPos]) {\n        minPos = i;\n      }\n    }\n    this.swap(this.dataStore, pos, minPos);\n  }\n}\n```\n\n## 삽입 정렬\n\n- 사람이 자료를 숫자나 문자순으로 정렬할 때 사용하는 방법과 비슷하다.\n- 외부 루프는 배열의 요소를 하나씩 반복하며, 내부 루프는 외부 루프에서 선택한 요소를 배열의 다음 요소와 비교한다. 외부 루프에서 선택한 요소가 내부 요소에서 선택한 요소보다 작으면 배열 요소를 오른쪽으로 시프트해서 내부 루프 요소를 삽입할 공간을 마련한다.\n- 두번째 원소부터 앞에 있는 원소들과 비교해서 정렬을 하는 방법이 삽입 정렬입니다.\n\n```typescript\n// 삽입 정렬\n// 두번째 요소부터 시작해서 ( 첫번째 요소는 자동 삽입 되었다고 생각하고 )\n// 선택된 요소 왼쪽에 있는 요소들을 전부 비교해서 자신이 있어야 할 자리를 선정합니다.\n// 이때 무조건 전부 비교하지 않고 하나씩 정렬해서 넣기 때문에 이전 요소가 큰지 안큰지만 보면 된다.\ninsertionSort() {\n  for (let pos = 1; pos < this.dataStore.length; pos++) {\n    // pos 이전 요소들 확인\n    const targetElement = this.dataStore[pos];\n    let tempPos = pos;\n    while (tempPos > 0 && this.dataStore[tempPos - 1] > targetElement) {\n      // 이전 요소가 더 크다면 하나씩 땡긴다.\n      this.dataStore[tempPos] = this.dataStore[tempPos - 1];\n      tempPos = tempPos - 1;\n    }\n\n    this.dataStore[tempPos] = targetElement;\n  }\n}\n```\n\n## 쉘 정렬\n\n- 쉘 정렬의 핵심은 삽입 정렬 처럼 근접한 요소가 아니라 멀리 떨어진 요소와 현재 요소를 비교한다는 점이다.\n- 삽입 정렬에 비해 좀 더 효율적으로 멀리 떨어진 요소를 제자리로 이동시킬 수 있다.\n- 데이터 집합의 각 요소를 반복해서 작업하면서 각 요소 간의 거리는 점점 줄어든다. 마지막에는 결국 인접한 요소를 비교한다.\n- 쉘 정렬에서는 가장 먼저 요소가 얼마나 멀리 떨어져 있는가를 가리키는 갭 시퀀스를 정의해야 한다.\n- 정적 시퀀스로는 마신 시우라(Marcin Ciura)가 소개한 갭 시퀀스를 이용한다. 마신 시우라 갭 시퀀스는 701, 301, 132, 57, 23, 10, 4, 1 이다.\n- 동적 시퀀스로는 로버드 세지윅(Robert Sedgewick) 은 쉘 정렬에서 사용할 갭 시퀀스를 동적으로 계산합니다.\n\n```javascript\n// 동적 시퀀스 공식\n\nconst N = this.dataStore.length;\nlet h = 1\n// 초기 시퀀스 h 값\nwhile(h < N/3) {\n  h = 3 * h + 1;\n}\n// 시퀀스 한번 루프 돌고 나서...\n// 다음 시퀀스 구하는 공식\nh = (h-1) / 3;\n\n// ex N = 10 => [4, 1] 시퀀스\n```\n\n```typescript\nshellSort() {\n  const N = this.dataStore.length;\n  let h = 1;\n  // 초기 시퀀스 설정\n  while (h < N / 3) {\n    h = 3 * h + 1;\n  }\n\n  // 시퀀스 별로 정렬\n  while (h >= 1) {\n    // 시퀀스 부터 시작해서 하나씩 오른쪽으로 이동해서 확인한다.\n    for (let i = h; i < N; i++) {\n      // 왼쪽 시퀀스 사이즈 만큼 떨어진 값과 비교한다.\n      // 왼쪽에 시퀀스 만큼 떨어진 값이 크다면 바꾸고 다시 왼쪽 시퀀스 만큼 떨어진 값과 비교한다.\n      for (\n          let j = i; // 초기 시퀀스 설정\n          j >= h && this.dataStore[j] < this.dataStore[j - h]; // j 값이 시퀀스 만큼 있고 왼쪽 값이 작다면ㄴ\n          j = j - h // 시퀀스 만큼 떨어진 왼쪽 값 확인\n        ) {\n          this.swap(this.dataStore, j, j - h);\n        }ㄴ\n    }\n\n    // 다음 시퀀스 구하는 공식\n    h = (h - 1) / 3;\n  }\n}\n```\n\n## 머지 정렬\n\n- 정렬된 서브리스트를 서로 합병하여(머지) 최종적으로 정렬된 큰 리스트를 만드는 과정에서 유래 했습니다.\n- 쉽게는 두 개의 정렬된 서브배열을 준비한 다음 두 배열을 비교하면서 가장 작은 요소를 세 번째 배열로 삽입합니다.\n- 이때, 머지 정렬은 별도의 서브 배열의 저장공간이 필요합니다.\n- 함수가 호출될때마다 절반씩 잘라서 재귀적으로 함수를 호출하고 맨 끝에 작은 조각부터 2개씩 병합해서 정렬된 배열을 머지해 나가는 방법 입니다.\n- 시간 복잡도는 O(n log n) 이 됩니다.\n- 파티션이 낱개가 될 때 까지 쪼개지니 n번 호출에 한번 호출당 검색해야 할 데이터 양이 절반씩 줄어드니 log n 입니다.\n\n### 하양식 머지 정렬\n\n- 머지 정렬은 보통 재귀 알고리즘으로 구현해야 하지만 자바스크립트 언어가 처리할 수 있는 것보다 더 깊은 재귀가 필요하므로 자바스크립트에서는 하양식이 아닌 상향식 머지 정렬 기법을 이용해야 합니다.\n\n### 상향식 머지 졍렬\n\n- 비재귀 또는 반복 방식으로 구현한 머지 정렬을 상향식 머지 정렬이라고 합니다.\n- 상향식 머지 정렬에서는 먼저 정렬할 데이터를 한 개의 요소를 갖는 여러 배열로 분할합니다. 그리고 이들 배열의 left 배열과 right 배열을 합치면서 최종적으로 정렬된 데이터를 포함하는 하나의 배열이 만들어질 때까지 이 과정을 반복합니다.\n- 제일 먼저 분할을 진행하고 2의 배수의 배열들을 머지하면서 최종 머지 합니다.\n\n```typescript\n// 가장 먼저 배열을 하나씩 쪼개서 (상향식)\n// 쪼갠 배열들을 머지 시켜야 합니다.\nmergeSort() {\n  let step = 1; // 쪼갤 단위\n  // 쪼갤 단위가 dataStore 보다 짧을때 계속 수행\n  while (step < this.dataStore.length) {\n    // 처음 시작 left, right 그룹의 배열의 시작 인덱스\n    let leftStart = 0;\n    let rightStart = step;\n\n    // left, right 를 step 으로 쌍을 만들 수 있을 때\n    while (rightStart + step <= this.dataStore.length) {\n      this.mergeArray(\n        this.dataStore,\n        leftStart,\n        leftStart + step - 1,\n        rightStart,\n        rightStart + step - 1\n      );\n      // 그다음 leftStart, rightStart\n      leftStart = rightStart + step;\n      rightStart = leftStart + step;\n    }\n    // 나머지 left, right 쌍을 만들 수 없을 때\n    if (rightStart < this.dataStore.length) {\n      this.mergeArray(\n        this.dataStore,\n        leftStart,\n        leftStart + step - 1,\n        rightStart,\n        this.dataStore.length - 1\n      );\n    }\n\n    step = step * 2;\n  }\n}\n\n// 두 정렬된 그룹의 배열의 각 첫번째 요소를 가지고\n// 작은수 부터 배치하여 머지합니다.\nmergeArray(\n  arr: number[],\n  leftStart: number,\n  leftStop: number,\n  rightStart: number,\n  rightStop: number\n) {\n  // 임시 배열 복사 생성\n  const tempArray = arr.map((item) => item);\n\n  let part1 = leftStart;\n  let part2 = rightStart;\n\n  // 다시 arr에 정렬된것을 할당\n  for (let i = leftStart; i <= rightStop; i++) {\n    if (part2 > rightStop) {\n      // part2 가 rightStop 보다 커진다면 우측 배열은 정렬이 끝난 것이다\n      arr[i] = tempArray[part1];\n      part1++;\n    } else if (part1 > leftStop) {\n      // part1 이 rightStart가 같아지거나 커진다면 왼쪽 배열은 정렬이 끝난 것이다\n      arr[i] = tempArray[part2];\n      part2++;\n    } else {\n      if (tempArray[part1] <= tempArray[part2]) {\n        arr[i] = tempArray[part1];\n        part1++;\n      } else {\n        arr[i] = tempArray[part2];\n        part2++;\n      }\n    }\n  }\n}\n```\n\n## 퀵 정렬\n\n- 리스트를 두 개의 서브리스트로 나누는 피벗을 선택합니다.\n- 피벗을 기준으로 작은 값은 피벗의 왼쪽으로 큰 값은 피벗의 오른쪽으로 오도록 모든 요소를 정렬시킵니다.\n- 피벗을 기준으로 분류된 각각의 서브리스트에 1, 2번 과정을 반복한다.\n- 왼쪽 부분이 피벗보다 크다면 잠시 멈췄다가 오른쪽 부분을 살펴 봅니다. 오른쪽 수가 피벗보다 작다면 잠시 멈춰서 멈췄던 왼쪽 값과 오른쪽 값을 스왑시킵니다.\n- 위 동작은 start point 와 end point가 교차 되면 한번 정렬이 완성된것입니다.\n- 이 순서를 재귀적으로 호출합니다. 왼쪽 배열부터 정렬을 해서 합쳐오면 다시 오른쪽 부분을 정렬해서 최종적으로 합칩니다.\n- 시간 복잡도는 O(n log n) 이 됩니다.\n\n```typescript\n// 퀵 정렬\n// 피벗을 기준으로 왼쪽과 오른쪽을 나눠서 정렬을 시작합니다\nquickSort() {\n  this.dataStore = this.qSort(this.dataStore);\n}\n\nqSort(list: number[]): number[] {\n  // 정렬할 데이터가 없으면 빈 배열을 리턴합니다\n  if (list.length === 0) {\n    return [];\n  }\n\n  if (list.length === 1) {\n    return list;\n  }\n\n  const [lesser, greater, pivot] = this.partition(list);\n  const sortLesser = this.qSort(lesser);\n  const sortGreater = this.qSort(greater);\n\n  return sortLesser.concat(pivot, sortGreater);\n}\n\npartition(list: number[]): number[][] {\n  // 물리적으로 가운데 값을 피벗으로 잡는다\n  const pivot = Math.floor((list.length - 1) / 2);\n  const lesser: number[] = [];\n  const greater: number[] = [];\n\n  for (let i = 0; i < list.length; i++) {\n    if (i !== pivot) {\n      if (list[i] < list[pivot]) {\n        lesser.push(list[i]);\n      } else {\n        greater.push(list[i]);\n      }\n    }\n  }\n\n  return [lesser, greater, [list[pivot]]];\n}\n```\n","excerpt":"버블 정렬 버블 정렬은 가장 느린 정렬 알고리즘 가운데 하나 입니다. 배열의 데이터를 정렬할 때 배열의 한쪽 끝에서 다른 쪽 끝으로 버블처럼 값이 떠오른다는 의미에서 버블 정렬이라는 이름이 유래했습니다. 어떤 데이터 집합을 오름차순으로 정렬하면 큰 …","fields":{"slug":"/sort/"},"frontmatter":{"date":"Apr 28, 2020","title":"[algorithms] Sort","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이 글은 벨로퍼트님의 `리액트를 다루는 기술` 책의 SSR 부분을 핵심만 요약한 글입니다.\nSSR의 흐름을 알기 쉽게 보기 위해서 정리합니다.\n\n## 정의\n\nSSR은 `Server Side Rendering` 으로 서버에서 HTML 코드를 만들어서 응답으로 보내주는 형식을 말합니다.\n기존의 SPA의 경우에는 `Client Side Rendering` 을 사용하고 있고 SSR과 CSR은 장단점을 지니고 있습니다.\n\n## 기본 요약\n\n1. `index.server.js` 를 만들어 `ReactDOMServer.rednerToString` 으로 JSX를 마크업으로 만들어 줍니다.\n2. 서버 코드에서 응답으로 만들어진 마크업을 전달합니다.\n3. 빌드 된 JS, CSS 파일은 파일명이 매번 바뀌기 때문에 `asset-manifest.json` 파일을 참고해서 만들 마크업에 link, script 태그를 이어줍니다.\n4. `Router` 는 `StaticRouter`의 `location props`를 가지고 라우팅 처리를 합니다.\n\n## 데이터 로딩 요약\n\nSSR에서는 라이프 사이클 메서드가 동작하지 않고, 데이터가 바뀐다고 해도 re-Rendering이 되지 않으므로\n마크업을 만들어서 응답하기 전에 필요한 API 데이터를 미리 다 불러와야 합니다.\n\n### redux-thunk\n\n- 불려져야 하는 API 함수 (`promise`) 들을 Preload 컴포넌트를 이용해 `React Context`에 하나하나 쌓아 둡니다.\n- 마크업을 만들기 전에 해당 `Promise.all` 을 이용해서 promise 들을 실행시키며 이 `promise` 들은 `redux reduce` 에서 api 호출 및 저장이 됩니다.\n- 최종 마크업을 만들어 줍니다.\n- `redux thunk`(액션함수)를 `dispatch` 의 인자로 넘기면 `promise`가 반환됩니다.\n\n1. `PreloadContext` 를 만들어 줍니다.\n2. `Preload` 컴포넌트는 초기 데이터를 받아야 할 리턴이 `promise`인 함수를 `props`로 받아 해당 `Context state`에 넣어두는 로직을 구성합니다.\n3. 각 컨테이너 컴포넌트에서 `Preload`가 필요한 곳에 넣어줍니다.\n4. 이때, 라이프 사이클에서 마운트 에서 호출하던 (`useEffect, componentDidMount`) API 호출은 데이터가 유효하면 호출하지 않도록 분기를 쳐 둡니다.\n5. JSX를 만들고 나서 `ReactDOMServer.renderToStaticMarkup()` 메서드를 활용해서 초기 데이터를 불러오게끔 하는 렌더링을 진행합니다.\n6. `Promise.all()`로 `PreLoadContext`의 `promise list` 들을 실행합니다.\n7. 마지막으로 `ReactDOMServer.renderToString()`으로 마지막 최종 렌더링을 진행해서 응답해줍니다.\n\n### redux-saga\n\n- saga도 똑같이 `Preload` 컴포넌트를 사용합니다.\n- 유효성 검사 후 에 null 처리 할 곳에 `Preload` 컴포넌트를 사용합니다.\n- 서버 코드 내에서 `sagaMiddleware.run(rootSaga).toPromise()` 를 이용해서 saga Task들을 promise로 만들어줍니다.\n- 서버 코드 내에서 `store.dispatch(END)` 코드를 넣어서 saga가 액션을 모니터링 하는것을 방지합니다.\n- `thunk` 에서 `Promise.all()` 하는 곳 바로 위에 `await sagaMiddleware.run(rootSaga).toPromise()` 넣어주고 진행 중이던 사가들이 모두 끝날때 까지 기다려줍니다.\n\n## 서버 사이드 렌더링과 코드 스플리팅\n\n이 부분이 중요한 이유는 서버 사이드 렌더링해서 전부 렌더링이 진행 된 이후 클라이언트 사이드에서 js가 다 불러져 온 뒤로 다시 비동기로 컴포넌트를 불러올때 깜빡임이 발생 하기 때문입니다.\n\n- `Loadable Components`를 사용할 것을 권장하고 있습니다.\n- 서버 유틸 함수, 웹팩 플러그인, babel 플러그인을 제공합니다.\n- 페이지 컴포넌트를 `loadable()` 메서드로 감싸서 Route에 적용합니다.\n- 웹팩과 바벨을 설정하면 `loadable-stats.json` 이라는 파일이 만들어 집니다.\n- `loadable-stats.json` 이 파일은 각 컴포넌트 코드가 어떤 청크파일에 들어가 있는지에 대한 정보를 가지고 있다고 보면 됩니다.\n- 서버 사이드 렌더링을 할 때 이 파일을 참고하여 어떤 컴포넌트가 렌더링 되었는지에 따라 어떤 파일들을 사전에 불러와야 할지 설정할 수 있습니다.\n\n## loadableReady & hydrate\n\n- `Loadable Component`를 사용하면 성능 최적화를 위해 js 파일을 모두 불러오는데 이때 모든 js 파일이 로딩되고 나서 렌더링을 할 수있도록 하는 것이 `loadableReady` 입니다.\n- 추가로 `render()` 메서드가 아닌 `hydrate()` 메서드가 존재하는데 이것은 기존에 존재하는 UI에 이벤트만 연동하여 성능을 최적화 시켜줍니다. 하지만 기존에 존재하는 UI 와 `hydrate()` 메서드에서 비교하려는 컴포넌트랑 다르면 에러가 뜬다는 사실이 있습니다.\n","excerpt":"이 글은 벨로퍼트님의  책의 SSR 부분을 핵심만 요약한 글입니다.\nSSR의 흐름을 알기 쉽게 보기 위해서 정리합니다. 정의 SSR은  으로 서버에서 HTML 코드를 만들어서 응답으로 보내주는 형식을 말합니다.\n기존의 SPA의 경우에는  을 사용하고…","fields":{"slug":"/react-ssr.md/"},"frontmatter":{"date":"Apr 23, 2020","title":"react SSR","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 그래프 정의\n\n- 그래프는 정점과 간선으로 이루어져 있다. (지도로 치면 각 마을은 정점이며 도로가 간선이다.)\n- 간선은 (v1, v2)와 같은 쌍으로 정의하며, 여기서 v1, v2는 그래프의 정점이다.\n- 정점은 무게(weight) 또는 비용(cost)을 포함할 수 있다.\n- 간선에서 정점의 순서를 따지는 그래프를 방향성 그래프(directed graph 또는 digraph)라 한다.\n- 방향성 그래프에서는 화살표로 간선을 표시하고 정점간 흐름을 의미한다.\n- 방향성이 없는 그래프를 무방향성 그래프(unordered graph) 또는 그래프라고 한다.\n- 경로의 길이는 경로의 첫 번째 정점에서 마지막 정점까지의 간선 수를 의미한다.\n- 경로는 정점 자신으로 향하는 경로 즉, 루프도 퍼함한다. 이때 루프의 길이는 0 이다.\n- 첫 번째 정점에서 마지막 정점으로 도달하는 하나 이상의 간선으로 이루어졌으며 경로가 같은 상황을 사이클(cycle)이라 한다.\n- 한 정점이 다른 정점과 연결되어 있고, 다른 정점도 한 정점과 연결되어 있으면 두 정점은 서로 강하게(strongly) 연결되어 있다고 말한다.\n\n## 정점 표현 (Vertex 클래스)\n\n- 정점을 식별할 수 있는 데이터 멤버와 정점을 방문했는지 여부를 확인할 수 있는 데이터 멤버가 필요. (label, wasVisited)\n- Graph 클래스가 사용할 정점은 배열에 저장할 것이다.\n\n## 간선 표현\n\n- 그래프의 구조를 표현하는 것은 간선\n- 실제 정보는 간선에 저장된다.\n- 인접 리스트 (adjacency list) 또는 인접 리스트 배열(array of adjacency list)이라 불리는 방법으로 그래프의 간선을 표현할 것이다.\n- 인접 리스트에서는 인접한 각 정점의 배열 리스트에 정점을 인덱스로 이용해 간선을 저장한다. 예를 들어 정점 2가 정점 0, 1, 3, 4로 연결되고 인덱스는 2에 저장되어 있다고 가정하면 인덱스 2에는 정점 0, 1, 3, 4의 정보가 들어있을 것이다.\n- 간선을 구현하는 또 다른 방법으로 인접 행렬(adjacency matrix) 이라는 방식도 있다. 인접 행렬이란 두 정점 간의 간선이 존재하는지 여부를 알려주는 요소를 포함하는 이차원 배열이다.\n\n## 그래프 구현\n\n- Graph 클래스는 그래프의 정점수를 나타내는 배열 길이를 이용해 그래프의 간선 수, 정점 수 정보를 유지한다.\n- 배열의 각 요소를 for문으로 반복하면서 각 요소에 인접 정점을 저장할 서브 배열을 추가한 다음 각 요소를 빈 문자열로 초기화 함.\n\n```typescript\nclass Graph {\n  vertices: number;\n  edges: number;\n  adj: number[][];\n\n  constructor(v: number) {\n    this.vertices = v;\n    this.edges = 0;\n\n    this.adj = new Array(v);\n    for (let i = 0; i < this.adj.length; i++) {\n      this.adj[i] = [];\n    }\n  }\n\n  addEdge(v: number, w: number) {\n    this.adj[v].push(w);\n    this.adj[w].push(v); // 순환 참조를 안시키려면 주석을 해야한다.\n    this.edges++;\n  }\n\n  showGraph() {\n    console.log(\"this.adj\", this.adj);\n    this.adj.forEach((verticeList, index) => {\n      console.log(`${index} -> `);\n      verticeList.forEach((vertice) => {\n        if (vertice !== undefined) {\n          console.log(`${vertice}`);\n        }\n      });\n      console.log(\"\\n\");\n    });\n  }\n}\n```\n\n### 프로그램 결과\n\n- 정점 0에는 정점 1,2로 연결되는 간선이\n- 정점 1에는 정점 0,3으로 연결되는 간선이\n- 정점 2에는 정점 0,4로 연결되는 간선이\n- 정점 3에는 정점 1로 연결되는 간선이\n- 정점 4에는 정점 2로 연결되는 간선이 있다.\n\n## 그래프 검색\n\n- 깊이 우선 검색 (depth first search)\n- 너비 우선 검색 (breadth first search)\n- 그래프는 사실 child 노드라고 하기 보다 인접한 노드라고 하는게 정확합니다.\n\n### 깊이 우선 검색 (DFS)\n\n- 한 정점에서 시작해 마지막 정점이 나올 때까지 모든 경로를 탐색한 다음 다시 이전 경로로 거슬로ㅓ 올라가 다음 경로를 찾기를 반복해 더 이상 방문할 경로가 없을 때까지 탐색 수행\n- 이진 트리 검색중에 inorder, preorder, postorder 가 깊이 우선 검색에 해당됩니다.\n- child 노드를 끝까지 파고난 다음에 (마지막 노드까지 갔다가 다시 올라와서 형제 노드들을 방문) 그 다음 줄기를 검색하고 또 다시 그 다음 줄기를 검색하는 방식입니다.\n- 깊이 우선 검색은 Stack을 이용해서 구현합니다.\n- 스택에 일단 루트 노드를 넣고 먼저 스택에서 노드를 하나 꺼내서 그 해당 child 노드를 전부 스택에 넣고 꺼낸 노드는 출력을 하는 것입니다.\n- 여기서 child 노드를 스택에 넣을 때는 한번 넣었던 child 노드는 넣지 않습니다.\n- 특히 DFS를 구현할때 재귀 호출을 이용하면 코드가 간결해 집니다.\n\n```typescript\nclass Graph {\n  vertices: number;\n  edges: number;\n  adj: number[][];\n  marked: boolean[];\n\n  constructor(v: number) {\n    this.vertices = v;\n    this.edges = 0;\n\n    this.adj = new Array(v);\n    for (let i = 0; i < this.adj.length; i++) {\n      this.adj[i] = [];\n    }\n\n    // 탐색을 했는지 안했는지 확인하기 위해서\n    this.marked = [];\n    for (let i = 0; i < this.adj.length; i++) {\n      this.marked[i] = false;\n    }\n  }\n\n  addEdge(v: number, w: number) {\n    this.adj[v].push(w);\n    this.adj[w].push(v); // 순환 참조를 안시키려면 주석을 해야한다.\n    this.edges++;\n  }\n\n  showGraph() {\n    console.log(\"this.adj\", this.adj);\n    this.adj.forEach((verticeList, index) => {\n      console.log(`${index} -> `);\n      verticeList.forEach((vertice) => {\n        if (vertice !== undefined) {\n          console.log(`${vertice}`);\n        }\n      });\n      console.log(\"\\n\");\n    });\n  }\n\n  // 재귀는 곧 돌아와서 다시 할일이 있기 때문에 사용한다.\n  // 순서 0 -> true, this.adj[0] = 1, this.dfs(1), 1 -> true,...\n  dfs(v: number) {\n    this.marked[v] = true;\n    if (this.marked[v] !== undefined) {\n      console.log(`Visited vertex: ${v}`);\n    }\n\n    for (let w of this.adj[v]) {\n      // 이미 방문 했던 vertex는 무시한다.\n      if (!this.marked[w]) {\n        this.dfs(w);\n      }\n    }\n  }\n}\n\n```\n\n### 너비 우선 검색 (BFS)\n\n- 첫 번째 정점에서 시작해 가능한 한 첫 번째 정점과 가까운 정점을 방문한다.\n- 기본적으로 너비 우선 검색은 그래프를 계층(layer)별로 탐색한다. 즉, 첫 번째 정점에서 가장 가까운 계층을 먼저 탐색한 다음 시작 정점에서 점점 멀리 있는 계층을 검색하는 방식이다.\n- 너비 우선 검색에서는 배열 대신 큐를 이용해 방문한 정점을 저장한다.\n- 시작점에서 먼저 자신의 child 노드들을 다 방문 한 뒤에 그 다음의 자식의 자식을 방문을 해서 레벨 단위로 검색을 하는 것입니다.\n- 넓이 우선 검색은 Queue를 이용해서 구현합니다.\n- 일단 시작할 노드를 큐에 넣고 큐에서 하나 꺼내서 해당 노드의 child 노드를 큐에 넣고 꺼낸 노드는 출력하면 됩니다.\n- 여기서 child 노드를 큐에 넣을때 한번 넣었던 child 노드는 다시 큐에 넣지 않습니다.\n\n```typescript\nbfs(s: number) {\n    const queue = [] as number[];\n    this.marked[s] = true;\n    queue.push(s);\n\n    while (queue.length > 0) {\n      const v = queue.shift(); // 큐에서 가져옴\n      if (v !== undefined) {\n        console.log(`Visited vertex: ${v}`);\n\n        for (let w of this.adj[v]) {\n          if (!this.marked[w]) {\n            // 이미 방문하지 않았던 w 정점에 대해서\n            this.edgesTo[w] = v; // 경로를 찾을때 간선 정보를 겹치지 않게 유지할 배열\n            this.marked[w] = true; // 정점에 도달\n            queue.push(w); // 방문한 정점에서 가장 인접한 레벨의 정점들을 큐에 넣어둔다.\n          }\n        }\n      }\n    }\n  }\n// 0 -> [1,2], 1 -> [0,3], 2 -> [0,4], 3 -> [1], 4 -> [2]\n// 0,1,2,3,4\n```\n\n## 최단 경로 찾기\n\n- 정점 간의 최단 경로를 찾는 것이다.\n- `너비 우선 검색`을 수행하면 자동으로 한 정점에서 연결된 다른 정점으로 도달하는 최단 경로를 찾게 된다.\n- 정점 A에서 정점 D로 도달하는 최단 경로를 찾는다고 할 때 1개의 간선 경로를 찾아보고 없으면 2개의 간선 경로를 찾아보는 식으로 반복 검색을 수행할 수 있다.\n- 한 정점에서 다른 정점으로 연결하는 간선 정보를 유지할 배열이 필요 (`this.edgesTo`) : 겹치지 않게 간선 정보를 유지하는 것으로 보인다.\n\n```typescript\npathTo(v: number) {\n  const source = 0;\n  // 너비 우선 검색을 우선 실행한다.\n  // 간선 정보 수집 및 marked 수집.\n  this.bfs(0);\n\n  if (!this.hasPathTo(v)) {\n    return undefined;\n  }\n\n  const path = [];\n  for (let i = v; i !== source; i = this.edgesTo[i]) {\n    // 여기서 this.edgesTo는 다음과 같다.\n    // const g = new Graph(5)\n    // g.addEdge(0, 1)\n    // g.addEdge(0, 2)\n    // g.addEdge(1, 3)\n    // g.addEdge(2, 4)\n    // 1 - 0, 2 - 0, 3 - 1, 4 - 2 간선 정보\n    path.push(i);\n  }\n  path.push(source);\n  return path;\n}\n\nhasPathTo(v: number) {\n  return this.marked[v];\n}\n\n// const path = g.pathTo(4) : 정점 0에서 정점 4로 도달하는 최단 경로를 보여줌.\n// 0, 2, 4\n```\n\n## 위상 정렬\n\n- 위상 정렬(Topological sorting)은 방향성 그래프의 모든 방향성 간선이 왼쪽에서 오른쪽 정점을 가리키도록 모든 정점을 배치하는 방법이다. 즉, 순서가 정해져 있는 작업을 차례대로 나열할때 사용한다.\n- 이와 같은 구조는 선수 제약 일정 관리에서 찾아볼 수 있으며, 예를 들면 물리1을 이수하지 않은 학생은 물리2를 이수 할 수 없도록 하는것과 같다.\n- 위상 정렬 알고리즘은 깊이 우선 검색 알고리즘과 비슷하다. 다만, 방문한 정점을 즉시 출력했던 깊이 우선 검색과 달리 위상 정렬 알고리즘에서는 우선 현재 정점과 인접한 모든 정점을 방문한 다음 인접 리스트를 모두 확인하고 현재 정점을 스택으로 푸시한다.\n- topSort() 함수로 정렬 과정을 설정한 다음, 헬퍼 함수인 topSortHelper() 함수를 호출한다.\n- 핵심 기능은 재귀 함수인 topSortHelper() 함수에서 수행한다.\n- topSortHelper() 함수는 현재 방문한 정점으로 표시한 다음 현재 정점의 인접 리스트에 있는 각각의 인접 정점을 재귀적으로 방문하면서 방문한 것으로 표시한다.\n- 위상 정렬은 DAG(Directed Acyclic Graph: 사이클이 없는 방향성이 있는 그래프) 에만 적용이 가능합니다. 즉, 사이클이 발생하면 위상정렬을 할 수 없습니다.\n- 위상 정렬은 여러개의 답이 존재 할 수 있습니다.\n\n```typescript\naddEdge(v: number, w: number) {\n  this.adj[v].push(w);\n  // DAG에만 적용이 가능\n  //this.adj[w].push(v); // 순환 참조를 안시키려면 주석을 해야한다.\n  this.edges++;\n}\n\ntopSort() {\n  const stack: number[] = [];\n  const visited = [];\n  for (let i = 0; i < this.vertices; i++) {\n    visited[i] = false;\n  }\n\n  for (let i = 0; i < this.vertices; i++) {\n    if (visited[i] == false) {\n      this.topSortHelper(i, visited, stack);\n    }\n  }\n  let length = stack.length;\n  for (let i = 0; i < length; i++) {\n    console.log(stack.pop());\n  }\n}\n\ntopSortHelper(v: number, visited: boolean[], stack: number[]) {\n  visited[v] = true;\n  for (var w of this.adj[v]) {\n    if (!visited[w]) {\n      this.topSortHelper(w, visited, stack);\n    }\n  }\n  stack.push(v);\n}\n\n// const g = new Graph(6);\n// g.addEdge(1,2);\n// g.addEdge(2,5);\n// g.addEdge(1,3);\n// g.addEdge(1,4);\n// g.addEdge(0,1);\n// 0 -> 1 -> 4 -> 3 -> 2 -> 5\n```\n\n## 정리\n\n- 그래프의 깊이를 먼저 탐색하기 위해선 재귀를 활용해서 가장 깊이 있는 뎁스 까지 내려갔다가 끝나면 남아있던 형제 정점에서 다시 탐색을 시작한다.\n- 그래프의 너비를 먼저 탐색하기 위해선 현재 정점에 인접한(자식 뎁스)를 큐에 넣고 큐에서 하나씩 빼서 방문하게 만든다.\n","excerpt":"그래프 정의 그래프는 정점과 간선으로 이루어져 있다. (지도로 치면 각 마을은 정점이며 도로가 간선이다.) 간선은 (v1, v2)와 같은 쌍으로 정의하며, 여기서 v1, v2는 그래프의 정점이다. 정점은 무게(weight) 또는 비용(cost)을 포…","fields":{"slug":"/graph/"},"frontmatter":{"date":"Apr 20, 2020","title":"[algorithms] graph Hashing","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 트리 정의\n\n- 트리는 에지로 연결된 노드의 집합입니다. 예를 들면 회사의 조직도를 들수 있습니다.\n- 각각의 상자가 노드며 상자를 연결하는 선이 에지이다.\n- 트리의 최상위 노드를 `루트(root)` 노드라고 한다.\n- 한 노드가 아래 노드와 연결되어 있을때 위에 있는 노드를 `부모(parent)` 노드라 한다.\n- 부모 노드 아래에 있는 모든 노드를 `자식(child)` 노드라고 한다.\n- 한 노드는 0개 이상의 노드와 연결 될 수 있다.\n- 자식 노드가 없는 노드를 `리프(leaf)` 노드라 부른다.\n- 이진 트리는 모든 노드의 자식 노드 수가 2개 이하인 특수한 노드를 가리킨다.\n- 한 노드에서 다른 노드로 도달하는데 사용한 에지의 모음을 `경로(path)`라 한다.\n- 트리는 레벨로 구분할 수 있으며, 트리에 있는 레벨의 수를 트리의 `깊이(depth)` 라고 한다.\n- 트리의 각 노드는 값을 갖는데, 노드의 값을 키 값이라고도 표현한다.\n\n## 이진 검색 트리 (BST)\n\n- 자식중에 작은 값은 왼쪽 노드에, 큰 값을 오른쪽 노드에 저장한다.\n- 이진 검색트리는 단어, 문자열도 저장할 수 있다.\n\n## 이진 검색 트리 탐색\n\n- BST 클래스에서는 `중위(inorder)`, `전위(preorder)`, `후위(postorder)`라는 세 가지 탐색 방법을 사용한다.\n- 중위 탐색에서는 노드의 오름차순 키(수치가 점점 커지는) 값으로 BST 클래스의 모든 노드를 방문한다. (왼쪽 -> 부모 -> 오른쪽 순)\n- 전위 탐색에서는 먼저 루트 노드를 방문한 다음 루트 왼쪽 자식을 중심으로 하는 서브트리를 같은 방식으로 방문하며, 마지막으로 루트 노드의 오른쪽 자식을 중심으로 하는 서브트리를 방문한다. (부모 -> 왼쪽 -> 오른쪽)\n- 후위 탐색에서는 루트 노드의 왼쪽 자식을 중심으로 하는 서브트리를 먼저 방문한 다음, 루트 노드의 오른쪽 자식을 중심으로 하는 서브트리를 방문하며, 마지막으로 루트 노드를 방문한다. (왼쪽 -> 오른쪽 -> 부모)\n- 재귀를 이용하면 깔끔하게 중위 탐색을 구현할 수 있다.\n\n## BST 검색\n\n- 특정값 검색 : 현재 노드와 검색 대상 노드의 값을 비교 검색 결과에 따라 왼쪽/오른쪽 탐색할지 결정할 수 있다.\n- 최솟값 검색 : 더 이상 왼쪽 자식 노드가 없을 때까지 BST의 왼쪾 에지를 탐색하면 최솟값을 찾을 수 있다.\n- 최댓값 검색 : 가장 오른쪽에 저장된 자식 노드에 저장된 값이 BST의 최댓값이다.\n\n## 이진 검색 트리 구현\n\n```typescript\nclass BSTNode<T> {\n  data: T;\n  left: BSTNode<T> | null;\n  right: BSTNode<T> | null;\n\n  constructor(data: T, left: BSTNode<T> | null, right: BSTNode<T> | null) {\n    this.data = data;\n    this.left = left;\n    this.right = right;\n  }\n\n  show() {\n    return this.data;\n  }\n}\n\nclass BST<T> {\n  root: BSTNode<T> | null;\n\n  constructor() {\n    this.root = null;\n  }\n\n  insert(data: T) {\n    // 루트 노드를 current 노드로 설정\n    // 삽입할 노드의 값이 current 노드의 값보다 작으면 왼쪽 자식으로 크다면 오른쪽 자식으로 삽입\n    // current 노드의 값 보다 작으면서 왼쪽 자식이 null이면 왼쪽 자식에 삽입 그렇지 않다면 왼쪽 자식을 current로 바꾼후 다시 루프\n    // 반대로 current 노드의 값 보다 크면서 오른쪽 자식이 null이면 오른쪽 자식에 삽입 그렇지 않다면 오른쪽 자식을 current로 바꾼후 다시 루프\n    const bstNode = new BSTNode<T>(data, null, null);\n    if (this.root === null) {\n      this.root = bstNode;\n    } else {\n      let current = this.root;\n\n      while (true) {\n        if (data < current.data) {\n          // 삽입할 데이터가 작으면 왼쪽\n          if (current.left === null) {\n            current.left = bstNode;\n            break;\n          } else {\n            current = current.left;\n          }\n        } else {\n          // 삽입할 데이터가 크면 오른쪽\n          if (current.right === null) {\n            current.right = bstNode;\n            break;\n          } else {\n            current = current.right;\n          }\n        }\n      }\n    }\n  }\n\n  inOrder(node: BSTNode<T> | null) {\n    // 중위 탐색 (왼쪽 -> 부모 -> 오른쪽) 오름 차순 탐색\n    // 부모 기준으로 왼쪽 시도후 부모 시도 그리고 나서 부모의 오른쪽 시도\n    if (node !== null) {\n      this.inOrder(node.left); // 부모 노드의 왼쪽부터 출력 시도\n      console.log(node.data + \" \"); // 부모 자신 출력\n      this.inOrder(node.right); // 부모 노드의 오른쪽 출력 시도\n    }\n  }\n\n  preOrder(node: BSTNode<T> | null) {\n    // 전위 탐색 (부모 -> 왼쪽 -> 오른쪽) 부모를 기준으로 부모 먼저 시도 후 왼쪽 시도 그리고 다 끝났으면 오른쪽 시도\n    if (node !== null) {\n      console.log(node.data + \" \");\n      this.inOrder(node.left); // 부모 노드의 왼쪽부터 출력 시도\n      this.inOrder(node.right); // 부모 노드의 오른쪽 출력 시도\n    }\n  }\n  postOrder(node: BSTNode<T> | null) {\n    // 후위 탐색 (왼쪽 -> 오른쪽 -> 부모) 부모를 기준으로 왼쪽 시도 그리고 다 끝났으면 오른쪽 시도 후 마지막으로 부모 시도\n    if (node !== null) {\n      this.inOrder(node.left); // 부모 노드의 왼쪽부터 출력 시도\n      this.inOrder(node.right); // 부모 노드의 오른쪽 출력 시도\n      console.log(node.data + \" \");\n    }\n  }\n\n  // 최솟값\n  getMin() {\n    let current = this.root;\n    if (current === null) {\n      return null;\n    }\n\n    while (!(current.left === null)) {\n      current = current.left;\n    }\n\n    return current.data;\n  }\n\n  // 최댓값\n  getMax() {\n    let current = this.root;\n    if (current === null) {\n      return null;\n    }\n\n    while (!(current.right === null)) {\n      current = current.right;\n    }\n\n    return current.data;\n  }\n\n  // 특정값 검색\n  find(data: T) {\n    let current = this.root;\n\n    while (current && current.data !== data) {\n      if (data < current.data) {\n        current = current.left;\n      } else if (data > current.data) {\n        current = current.right;\n      }\n    }\n\n    if (current === null) {\n      return null;\n    }\n\n    return current;\n  }\n\n  getSmallest(node: BSTNode<T>) {\n    let current = node;\n\n    while (!(current.left === null)) {\n      current = current.left;\n    }\n\n    return current;\n  }\n\n  remove(data: T) {\n    this.root = this.removeNode(this.root, data);\n  }\n\n  removeNode(node: BSTNode<T> | null, data: T) {\n    if (node === null) {\n      return null;\n    }\n    // 재귀\n    if (data === node.data) {\n      // 자식이 없는 노드\n      if (node.left === null && node.right === null) {\n        return null;\n      }\n      // 왼쪽 자식이 없는 노드\n      if (node.left === null) {\n        return node.right;\n      }\n\n      // 오른쪽 자식이 없는 노드\n      if (node.right === null) {\n        return node.left;\n      }\n\n      // 두 자식이 있는 노드\n      // 가장 오른쪽에서 작은 노드를 찾는다.\n      const tempNode = this.getSmallest(node.right);\n      // 찾은 노드의 데이터를 삭제하고자 하는 노드와 교체한다.\n      node.data = tempNode.data;\n      // 찾은 노드를 null 처리 한다.\n      // node.right 가 그대로 리턴된다.\n      node.right = this.removeNode(node.right, tempNode.data);\n      return node;\n    } else if (data < node.data) {\n      node.left = this.removeNode(node.left, data);\n      return node;\n    } else {\n      node.right = this.removeNode(node.right, data);\n      return node;\n    }\n  }\n}\n```\n","excerpt":"트리 정의 트리는 에지로 연결된 노드의 집합입니다. 예를 들면 회사의 조직도를 들수 있습니다. 각각의 상자가 노드며 상자를 연결하는 선이 에지이다. 트리의 최상위 노드를  노드라고 한다. 한 노드가 아래 노드와 연결되어 있을때 위에 있는 노드를  노…","fields":{"slug":"/binaryTree/"},"frontmatter":{"date":"Apr 19, 2020","title":"[algorithms] binaryTree Hashing","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이 글은 setState가 왜 비동기 인가를 알아보다가 아래와 같은 글이 있어서 이해한 내용만 정리한 글입니다.\n아래 글을 모두 번역하지 않았음을 알립니다.\n\n[https://github.com/facebook/react/issues/11527](https://github.com/facebook/react/issues/11527)\n\n브라우저 클릭 핸들러에 있고 Child 및 Parent 호출 setState 모두에있는 경우 Child를 두 번 다시 렌더링하지 않고 더티로 표시 한 다음 브라우저 이벤트를 종료 전에 다시 렌더링하는 것을 선호합니다.\n\n왜 재조정을 기다리지 않고 setState를 즉시 업데이트 하면서 배치 (일괄작업) 이랑 똑같은 일을 할 수 없는지 물을 것입니다.\n\n## 내부적으로 일관성을 보장해야 한다\n\nstate가 동기적으로 업데이트 된다고 했을때 props는 그렇지 않습니다. 부모 컴포넌트가 렌더링이 될때까지 props 값을 알 수 없습니다.\n\n상태를 몇 개의 구성 컴포넌트에서 공유하려면 상위 상태로 이동해야합니다.\n\n```javascript\n-this.setState({ value: this.state.value + 1 });\n+this.props.onIncrement(); // Does the same thing in a parent\n```\n\n자식 컴포넌트에서 다음과 같은 코드가 있다고 했을 때,\n\n```javascript\nconsole.log(this.props.value) // 0\nthis.props.onIncrement();\nconsole.log(this.props.value) // 0\nthis.props.onIncrement();\nconsole.log(this.props.value) // 0\n```\n\n부모를 다시 렌더링하지 않고 즉시 this.props를 플러시 할 수 없습니다. 이럴 경우 일괄처리를  할 수 없습니다.\n\n즉, 위 코드가 정상적으로 동작하려면 onIncrement() 시마다 부모가 호출되어야 하고 이 경우에는 부모가 2번이나 호출이 되어야 한다는 것이다. 그럼 경우에 따라 성능 저하가 일어날 수도 있을 것이다.\n\n그래서 React는 this.state, this.props 업데이트는 오직 reconciliation 이후에 진행됩니다. 이것은 state를 안전하게 부모로 올릴 수 있습니다.\n\n## 동시성 있게 업데이트가 가능해야 한다\n\n\"비동기 렌더링\"을 설명하는 한 가지 방법은 React가 이벤트 처리기, 네트워크 응답, 애니메이션 등의 발신 위치에 따라 setState () 호출에 다른 우선 순위를 할당 할 수 있다는 것입니다.\n\n예를 들면  타이핑 할 시에, TextBox에 있는 setState() 호출은 즉시 반영이 되도록 필요합니다. 하지만 타이핑시에 새로운 메시지를 받았다고 가정했을때 새로운 new MessageBubble 을 렌더링 하는것을 특정 임계값 까지 지연시키는 게 쓰레드 블락으로 인해 타이핑이 버벅거리는것 보다 아마 나을 것입니다.\n\n특정 업데이트가 \"낮은 우선 순위\"를 갖도록하면 렌더링이 몇 밀리 초의 작은 덩어리로 분할되어 사용자에게 눈에 띄지 않게 될 수 있습니다.\n\n비동기 렌더링은 단지 성능 때문만은 아닙니다.\n\n예를 들면 화면전환을 생각해 봅시다. 이때 새로운 스크린이 렌더링 되는동안 스피너가 돈다고 생각해봅시다.\n\n충분히 네비게이션이 빠르다면 스피너는 즉시 사라지는 깜빡임 현상이 나타날 것입니다. 이것은 사용자 경험상 안좋은 경험이 될 수 있습니다.\n\n만약 다른 비동기 의존성을 지닌 여러 레벨의 컴포넌트를 가지고 있다고 했을때 스피너는 한 번에 하나씩 짧게 깜박이는 일련의 스피너로 끝납니다.\n\n이것은 시각적으로 불쾌하며 모든 DOM 리플 로우로 인해 앱 속도가 느려집니다.\n\n조정 코드를 직접 작성하지 않고 업데이트가 특정 임계 값 (예 : 1 초)을 초과 한 경우 스피너를 표시하도록 선택하고 그렇지 않으면 완전히 새로운 하위 트리의 비동기 종속성이 발생할 때 React가 완벽한 전환을 수행하도록 할 수 있다고 상상해보십시오.\n\n또한 기다리는 동안에 이전 화면을 유지 합니다.\n\n이 말은 즉, ui의 업데이트를 일관성 있게 한다는 뜻인거 같습니다. 일관성없는 UI를 피하기 위해 백그라운드에서 만들어지고 한번에 업데이트 한다.\n","excerpt":"이 글은 setState가 왜 비동기 인가를 알아보다가 아래와 같은 글이 있어서 이해한 내용만 정리한 글입니다.\n아래 글을 모두 번역하지 않았음을 알립니다. https://github.com/facebook/react/issues/11527 브라우저…","fields":{"slug":"/why-setState-async.md/"},"frontmatter":{"date":"Apr 07, 2020","title":"setState가 비동기 인 이유","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nReact SPA 구축시 뒤로가기 눌렀을때 이전 상태를 유지하도록 해야하는 일이 생겼었다. 이때, 어떻게 구축 했었는지를 기록해보자.\n\n별도의 써드파티의 state management는 사용하지 않았다.\n\n## 1차 도전 (Context)\n\nhistory 의 정보는 어느 컴포넌트에나 적용이 될 수 있어야 하기 때문에 Context가 떠올랐습니다.\n\nhistory 정보에 필요했던 것들은 다음과 같았습니다.\n\n- preItemsCount : 해당 페이지의 items들을 몇개까지 불러왔는지 파악.\n- scrollTop : 해당 페이지의 어느 스크롤까지 위치 했었는지 파악.\n- pageName : 어느 페이지의 정보인지 파악.\n\n추가적으로 어느 히스토리를 사용해야 할지 currentIndex 도 두었었지만 이것은 해당 컴포넌트에게 어느 히스토리를 사용할지 맡겨두기로 했습니다. ( 처음엔 이 currentIndex 가 변할때마다 자꾸 렌더링이 시도 되는 현상 때문에 고생했습니다. )\n\n```typescript\nimport React, { createContext, Dispatch, useReducer, useContext } from \"react\";\n\ntype HistoryContextProviderProps = {\n  children: React.ReactNode;\n};\nexport interface IHistoryItem {\n  preItemsCount: number;\n  scrollTop: number;\n  pageName: string;\n}\nexport interface IHistoryState {\n  historyList: IHistoryItem[];\n  // currentIndex: number;\n}\n\ntype Action = { type: \"PUSH\"; historyItem: IHistoryItem } | { type: \"POP\" };\nexport type HistoryDispatch = Dispatch<Action>;\n\nconst HistoryStateContext = createContext<IHistoryState>({\n  historyList: []\n  // currentIndex: -1\n});\n\nconst HistoryDispatchContext = createContext<HistoryDispatch | undefined>(\n  undefined\n);\n\nfunction historyReducer(state: IHistoryState, action: Action) {\n  switch (action.type) {\n    case \"PUSH\":\n      return {\n        ...state,\n        historyList: state.historyList.concat([action.historyItem])\n        // currentIndex: state.currentIndex + 1\n      };\n    case \"POP\":\n      return {\n        ...state\n        // currentIndex: state.currentIndex < 0 ? -1 : state.currentIndex - 1\n      };\n    default:\n      return state;\n  }\n}\n\nexport function HistoryContextProvider({\n  children\n}: HistoryContextProviderProps) {\n  const [historyState, dispatch] = useReducer(historyReducer, {\n    historyList: []\n    // currentIndex: -1\n  });\n\n  return (\n    <HistoryDispatchContext.Provider value={dispatch}>\n      <HistoryStateContext.Provider value={historyState}>\n        {children}\n      </HistoryStateContext.Provider>\n    </HistoryDispatchContext.Provider>\n  );\n}\n\nexport function useHistoryState() {\n  const state = useContext(HistoryStateContext);\n  return state;\n}\n\nexport function useHistoryDispatch() {\n  const dispatch = useContext(HistoryDispatchContext);\n  if (!dispatch) throw new Error(\"HistoryDispatchContext value not found\");\n  return dispatch;\n}\n```\n\n## 1차 도전의 문제\n\n위 코드는 나름 잘 동작은 하였지만 제가 생각한대로 동작하지 않았습니다.\n\n이유는 다음과 같았습니다.\n\ncurrentIndex 도 마찬가지지만 이 history Context의 historyList 에 컴포넌트가 unmount 될시에 적제가 되도록 작성해 두었습니다.\n그리곤 페이지 이동이 끝난 상태에서 historyList를 참고하도록 하였습니다.\n\n하지만 Context의 상태 값을 변경 한다는 것은 Consumer 들이 다시 리 렌더링을 뜻하는 것이고, 마운트 될때 Context의 상태 변경 해둔 것이 마운트 된 이후에 historyList에 적용 과 리 렌더링이 되면서 예상과는 다르게 움직 였었습니다.\n\n정리하면 다음과 같은 문제가 발생했습니다.\n\n- 불필요한 리 렌더링\n- 2번 리렌더링 (페이지 이동 + Context 상태변경)이 되면서 같은 페이지에서 다른 history를 참고 하고 있음\n\n## 2차 도전 (static store + Context)\n\n1차 문제를 해결하기 위해서 Context 상태 변경에 의한 렌더링을 피해야만 된다는 생각을 했습니다.\n\n그래서 history store를 **유일한 객체**로 만들어야 겠다는 생각을 했고, 이 객체가 변해도 React가 반응하지 않아야 되도록 별도의 store를 만들었습니다.\n\n또한 이 history store 의 메서드와 프로퍼티들을 props로 타고 내려 보내는 것이 아닌 필요한 곳에 쉽게 사용할 수 있도록 Context를 혼합 했습니다.\n\n다음은 history store 객체 입니다.\n\n```typescript\nexport interface IHistoryItem {\n  preItemsCount: number;\n  scrollTop: number;\n  pageName: string;\n}\n\nclass HistoryStore {\n  historyList: IHistoryItem[];\n  // currentIndex: number;\n\n  constructor() {\n    this.historyList = [];\n    // this.currentIndex = -1;\n  }\n\n  // get currentHistory() {\n  //   if (this.currentIndex < 0) {\n  //     return null;\n  //   }\n  //   return this.historyList[this.currentIndex - 1];\n  // }\n\n  getRecentPageHistory(pageName: string) {\n    const matchPageNameHistoryList = this.historyList.filter(\n      history => history.pageName === pageName\n    );\n    if (matchPageNameHistoryList.length > -1) {\n      return matchPageNameHistoryList[matchPageNameHistoryList.length - 1];\n    }\n\n    return null;\n  }\n\n  isMatchPageNameHistory(pageName: string) {\n    return this.historyList.some(history => history.pageName === pageName);\n  }\n\n  pushHistory(historyItem: IHistoryItem) {\n    this.historyList.push(historyItem);\n    // this.currentIndex = this.currentIndex + 1;\n  }\n}\n\nexport default HistoryStore;\n```\n\n초반에는 `currentIndex` 를 두어서 위에서 했던 것처럼 컴포넌트들이 어떤 히스토리를 봐야 하는지 알려주는 지표로써 사용을 하려고 했지만 후반부에는 그것 보다는 현재 접속한 pageName에서 historyList 에서 일치된 가장 최근 pageName의 history를 빼와서 적용하도록 하였습니다.\n\n다음은 이런 히스토리를 다양한 뎁스의 컴포넌트에서 사용할 수 있도록 Context를 수정하였습니다.\n\n```typescript\nimport React, { createContext, useContext } from \"react\";\n\nimport HistoryStore from \"staticStore/HistoryStore\";\n\ntype HistoryContextProviderProps = {\n  children: React.ReactNode;\n};\n\nconst historyStore = new HistoryStore();\n\nconst HistoryStateContext = createContext<HistoryStore>(historyStore);\n\nexport function HistoryContextProvider({\n  children\n}: HistoryContextProviderProps) {\n  return (\n    <HistoryStateContext.Provider value={historyStore}>\n      {children}\n    </HistoryStateContext.Provider>\n  );\n}\n\nexport function useHistoryStore() {\n  const state = useContext(HistoryStateContext);\n  return state;\n}\n```\n\nContext는 훨씬 간단해 졌습니다.\n\n## 정리\n\n생각을 하다하다 몇번의 도전만에 예상대로 움직이긴 했습니다. 이 방법 말고도 React SPA에서 react-router-dom의 location props의 state를 이용해볼까도 생각했지만 복잡한 state를 location에 다루기에는 투머치(?) 한 생각이 들어서 따로 빼는 방식을 생각해보았습니다.\n\n추가적으로 다른 방식들이 있는지 고민을 추가적으로 해보아야 겠습니다.\n","excerpt":"React SPA 구축시 뒤로가기 눌렀을때 이전 상태를 유지하도록 해야하는 일이 생겼었다. 이때, 어떻게 구축 했었는지를 기록해보자. 별도의 써드파티의 state management는 사용하지 않았다. 1차 도전 (Context) history 의 …","fields":{"slug":"/react-history.md/"},"frontmatter":{"date":"Apr 04, 2020","title":"React 뒤로가기 시 이전 상태 유지를 위한 history","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n가로 스크롤 구현을 위해 react + typescript + iscroll 썼던 느낀점을 정리하고자 합니다.\n\n## 1. iscroll + typescript\n\n첫번째로 맞닥뜨린 문제는 iscroll의 type의 정의가 제대로 안되어 있다는 점이 였습니다.\n[https://www.npmjs.com/package/@types/iscroll](https://www.npmjs.com/package/@types/iscroll) 과 같이 타입이 존재합니다.\n\n하지만 그 타입이 제대로 정의 되어 있지 않습니다.\n\n따라서 `import IScroll from \"iscroll\";` 로 모듈을 `import` 할 시에 모듈이 아니라는 에러가 나게 됩니다.\n\n이는 `@types/iscroll` 에 `export` 구문이 보이지 않아서 모듈로 인식을 못하고 있는 것처럼 보였습니다.\n(추측이지만 모듈로써 사용하기 보단 script 태그 방식으로 사용하도록 타입이 설계 되어 있는 거 같습니다.)\n\n하여 폭풍 검색해보니 [https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18554](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18554) 이런 글을 만났었습니다.\n\n해서 `/src/types/iscroll.d.ts` 파일에 해당 문구를 넣어주었습니다. 참고로 typescript config시 `\"baseUrl\": \"./src\"` 를 추가했었습니다.\n\n그리고 실행하면 에러가 사라집니다.\n\n## 2. iscroll 위치 조정\n\n새로 고침시 url에 따른 처음 스크롤 위치 조정 또는 탭(메뉴)를 클릭시 클릭한 메뉴가 가운데 오도록 하게 스크롤의 위치를 움직일 필요가 있었다.\n\n정리하면 다음과 같다.\n\n1. 새로고침시 해당되는 메뉴가 가운데 오도록 해야한다.\n2. 메뉴 클릭시 클릭당한 메뉴가 가운데 오도록 해야한다.\n\n1번의 경우에는 iscroll 인스턴스를 생성하기 전에 미리 위치를 계산해서 option 값으로 `startX` 값을 넣는 방식이 가장 좋아 보였습니다.\n\n2번의 경우에는 메뉴 클릭시 해당 위치 값을 계산해서 iscroll의 `scrollTo` 메서드를 사용하도록 했습니다.\n\n여기서 중요한것은 어느 상황에서나 미리 움직여야 할 위치 값을 구하는것이 중요했습니다.\n\n준비할 수 있는 값은 두가지 였습니다.\n\n1. 가로 스크롤을 감싸고 있는 wrapper element\n2. 타게팅이 되는 메뉴 리스트의 index 값\n\n힌트가 되는 값들을 가지고 내가 움직여야 할 위치를 구하는 코드는 다음과 같습니다.\n\n```typescript\nexport function scrollMoveTo(\n  wrapperElement: HTMLDivElement,\n  currentIndex: number\n) {\n  let startX = 0;\n\n  if (currentIndex > -1) {\n    const wrapperWidth = wrapperElement.offsetWidth;\n    const wrapperMidPos = wrapperWidth / 2;\n    const wrapperLeftOffset = wrapperElement.offsetLeft;\n\n    const $elemCurrentMenu = wrapperElement.children[0].children[\n      currentIndex\n    ] as HTMLLIElement; // div > ul > li를 구하기 위해서...\n    // 여기에 if 분기를 추가하면 더 좋을 듯 싶습니다.\n    const $elemMenuWrapperWidth = (wrapperElement\n      .children[0] as HTMLUListElement).offsetWidth;\n    const currenttMidWidth = $elemCurrentMenu.offsetWidth / 2;\n    const currentLeftOffset = $elemCurrentMenu.offsetLeft;\n    const maxWidth = $elemMenuWrapperWidth - wrapperWidth;\n\n    startX =\n      wrapperLeftOffset - currentLeftOffset + wrapperMidPos - currenttMidWidth;\n\n    if (startX > 0) {\n      startX = 0;\n    } else if (startX < -maxWidth) {\n      startX = -maxWidth;\n    }\n  }\n\n  return startX;\n}\n```\n\n코드에서 계산하는 것은 다음과 같습니다.\n\n1. wrapper element의 가운데 위치를 구합니다.\n2. wrapper의 children에서 해당 index의 element를 구합니다. (target element)\n3. wrapper element 의 offset left 값과 target element 의 offset left 의 차이를 구합니다. (wrapper element에서 부터 target element가 얼마만큼 떨어져 있는지 알기 위해서)\n4. wrapper element의 중간 값에 target element left 값이 얼마만큼 다가가야 하는지 구합니다.\n5. targetl element의 width의 반값 만큼 다시 이동을 시켜줍니다.\n\n## 커스텀 훅\n\niscroll을 관리 하는 커스텀 훅을 만들어 보았습니다.\n\n```typescript\nimport React, { useEffect, useRef } from \"react\";\nimport IScroll from \"iscroll\";\nimport { scrollMoveTo } from \"utils\";\n\nfunction useIScroll(\n  ref: React.RefObject<HTMLDivElement>,\n  currentIndex: number\n) {\n  const iScroll = useRef<IScroll | null>(null);\n  const initIndex = useRef<number>(currentIndex);\n\n  useEffect(() => {\n    if (!iScroll.current) {\n      // wrapper width\n      // console.dir(ref.current);\n      if (ref.current) {\n        const wrapperElement = ref.current;\n        const wrapperId = wrapperElement.id;\n\n        const startX = scrollMoveTo(wrapperElement, initIndex.current);\n\n        iScroll.current = new IScroll(`#${wrapperId}`, {\n          scrollX: true,\n          startX,\n          scrollY: false,\n          disablePointer: true,\n          disableTouch: false,\n          disableMouse: false,\n          preventDefault: false\n        });\n      }\n    }\n\n    return () => {\n      if (iScroll.current) {\n        iScroll.current.destroy();\n        iScroll.current = null;\n      }\n    };\n  }, [ref]);\n\n  return iScroll.current;\n}\n\nexport default useIScroll;\n```\n\n위 코드에서 주의 할 점은 `useEffect` 시에 `new IScroll` 가 마운트시에 한번만 호출 할 수 있도록 변하는 값 (여기서는 `currentIndex`) 을 useEffect의 디펜던시로 넣어 두면 안된다는 점이였습니다.\n\n그래서 `currentIndex` 값을 받아서 `useRef` 로 초반 값으로 넣어두고 변하지 않도록 처리 했습니다.\n","excerpt":"가로 스크롤 구현을 위해 react + typescript + iscroll 썼던 느낀점을 정리하고자 합니다. 1. iscroll + typescript 첫번째로 맞닥뜨린 문제는 iscroll의 type의 정의가 제대로 안되어 있다는 점이 였습니다.…","fields":{"slug":"/hello-iscroll.md/"},"frontmatter":{"date":"Apr 04, 2020","title":"hello-iScroll","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 해싱 개요\n\n- 해싱은 데이터를 단시간에 삽입하거나 저장된 데이터를 가져올 때 주로 사용하는 기법이다.\n- 해싱은 해시 테이블이라는 자료 구조를 이용한다.\n- 해싱을 이용하면 데이터를 빠르게 삽입하고, 삭제하고, 가져올 수 있지만, 최솟값이나 최댓값 찾기 등 검색 동작은 효율이 떨어진다.\n- 검색이 필요한 상황이라면 이진 탐색 트리 같은 자료구조를 사용하는 것이 좋다.\n- 해시 테이블 자료구조는 배열을 이용한다.\n- 키(key)라 불리는 데이터 요소로 배열에 저장된 데이터 요소를 참조할 수 있다.\n- 해시 함수는 각 키를 자체 배열 요소로 저장한다. 되도록 키가 한 곳에 집중되지 않도록 저장하는 것이 좋다.\n- 해시 함수에서는 두 키의 해시 결과(해시 함수 수행 결과)가 같은 값일 때도 있다. 이를 충돌(collision) 이라 한다.\n- 해시 테이블에 사용할 배열의 크기는 소수(prime number) 여야 한다.\n\n## 해시 테이블 클래스\n\n### 심플 해싱\n\n- 정수키를 가진 해시 테이블이라면 배열의 크기로 나눈 나머지를 반환(모듈로:modulo 연산)하는 해시 함수를 이용할 수 있다. 이때, 키가 모두 0으로 끝나며 배열의 크기가 10인 상황(320 % 10)에서는 이런 간단한 해시 함수를 사용할 수 없다. 따라서 배열의 길이는 소수로 만들어 주는 것이 유리하다.\n\n- 해싱 결과 값이 항상 테이블 범위 안에 있게 하기 위해선 다음과 같이 모듈로 연산을 해야 한다. (n % table.length)\n\n```typescript\nclass HashTable {\n  table: string[];\n\n  constructor() {\n    this.table = new Array(137);\n  }\n\n  simpleHash(data: string) {\n    // 각 문자의 아스키 값의 합을 얻어 해시 값을 계산한다.\n    const total = data.split(\"\").reduce((acc, char) => {\n      return acc + char.charCodeAt(0);\n    }, 0);\n\n    console.log(`Hash value: ${data} -> ${total}`);\n    // 계산 결과가 항상 해당 테이블 범위 안에 있게 하기 위해 모듈러 연산을 사용한다.\n    return total % this.table.length;\n  }\n\n  // 배열에 실제로 저장된 이름을 출력한다.\n  showDistro() {\n    this.table\n      .filter(data => {\n        return !!data;\n      })\n      .forEach((data, index) => console.log(`${index}: ${data}`));\n  }\n\n  // 실제 해시테이블에 데이터를 저장할 수 있도록 한다.\n  put(key: string, data: string) {\n    // const pos = this.simpleHash(data);\n    const pos = this.betterHash(key);\n    this.table[pos] = data;\n  }\n\n  get(key: string) {\n    return this.table[this.betterHash(key)];\n  }\n}\n```\n\n### 호너의 메소드 해시 함수\n\n호너의 메소드를 이용하려면 결과에 소수를 곱하는 과정을 추가해야 한다.\n\n```typescript\n// 호너의 메서드 알고리즘을 사용해서 충돌이 안나게끔 해싱 함수를 만들자.\n  betterHash(data: string) {\n    const H = 37;\n    const total = data.split(\"\").reduce((acc, char) => {\n      return H * acc + char.charCodeAt(0);\n    }, 0);\n    console.log(`Hash value: ${data} -> ${total}`);\n\n    const hashKey = total % this.table.length;\n    return hashKey;\n  }\n```\n\n## 충돌 처리\n\n모든 키가 해시 테이블에 저장될 수 있게 충돌을 처리하는 분리된 체인, 선형 조사 라는 두가지 충돌 해결 방법을 설명합니다.\n\n### 분리된 체인\n\n해시된 키를 저장할 배열을 만든 다음 해시 테이블의 각 배열 요소에 빈 배열을 할당하는 방식이다. 즉, 2차 배열을 만드는 것이다.\n\n```javascript\nconst tables = [\n  60: [David], // key: David, data: David\n  68: [Jennifer],\n  69: [Mike],\n  70: [Donnie, Jonathan]\n  78: [Cynthia, Danny]\n  88: [Raymond, Clayton]\n]\n```\n\n```typescript\nclass HashTable {\n  table: string[][];\n\n  constructor() {\n    this.table = new Array(137);\n    // 충돌처리 - 분리된 체인\n    for (let i = 0; i < this.table.length; i++) {\n      this.table[i] = new Array();\n    }\n  }\n\n  simpleHash(data: string) {\n    // 각 문자의 아스키 값의 합을 얻어 해시 값을 계산한다.\n    const total = data.split(\"\").reduce((acc, char) => {\n      return acc + char.charCodeAt(0);\n    }, 0);\n\n    console.log(`Hash value: ${data} -> ${total}`);\n    // 계산 결과가 항상 해당 테이블 범위 안에 있게 하기 위해 모듈러 연산을 사용한다.\n    return total % this.table.length;\n  }\n\n  // 호너의 메서드 알고리즘을 사용해서 충돌이 안나게끔 해싱 함수를 만들자.\n  betterHash(data: string) {\n    const H = 37;\n    const total = data.split(\"\").reduce((acc, char) => {\n      return H * acc + char.charCodeAt(0);\n    }, 0);\n    console.log(`Hash value: ${data} -> ${total}`);\n\n    const hashKey = total % this.table.length;\n    return hashKey;\n  }\n\n  // 배열에 실제로 저장된 이름을 출력한다.\n  showDistro() {\n    this.table\n      .filter((dataList) => {\n        return !!dataList[0];\n      })\n      .forEach((data, index) => console.log(`${index}: ${data}`));\n  }\n\n  put(key: string, data: string) {\n    // const pos = this.simpleHash(data);\n    const pos = this.betterHash(key);\n    // this.table[pos] = data;\n    const tableKeyPoint = this.table[pos];\n    const tableKeyPointLength = tableKeyPoint.length;\n\n    if (tableKeyPointLength === 0) {\n      tableKeyPoint[0] = data;\n    } else {\n      tableKeyPoint[tableKeyPointLength - 1] = data;\n    }\n  }\n\n  get(key: string) {\n    return this.table[this.betterHash(key)];\n  }\n}\n```\n\n### 선형 조사\n\n선형 조사는 오픈 주소법 해싱(open-addressing hashing)이라 불리는 일반적인 해싱 기법이다.\n오픈 주소법에는 충돌이 발생하면 해시 테이블의 다음 요소가 비어 있는지 확인한 후 다음 요소가 비어 있으면 비어 있는 요소에 키를 저장합니다.\n\n대부분의 해시 테이블에는 비어 있는 공간이 많이 있으므로 비어있는 공간을 이용해 키를 저장한다는 것이 선형 조사 기법의 핵심입니다.\n\n```javascript\n// key 저장\nconst tables = [\n  60: David, // key: David, data: David\n  68: Jennifer,\n  69: Mike,\n  70: Donnie, //Jonathan\n  71: Jonathan,\n  78: Cynthia, //Danny]\n  79: Danny,\n  88: Raymond, Clayton\n  89: Clayton\n]\n// Data 저장\nconst values = [\n  60: David, // key: David, data: David\n  68: Jennifer,\n  69: Mike,\n  70: Donnie, //Jonathan\n  71: Jonathan,\n  78: Cynthia, //Danny]\n  79: Danny,\n  88: Raymond, Clayton\n  89: Clayton\n]\n```\n\n```typescript\nclass HashTable {\n  table: string[][];\n\n  constructor() {\n    this.table = new Array(137); // 해싱된 키를 저장하고\n    // 선형 조사\n    this.values = []; // values에 키에 해당하는 데이터를 저장한다.\n  }\n  put(key: string, data: string) {\n      // const pos = this.simpleHash(data);\n      const pos = this.betterHash(key);\n\n      if(this.table[pos] === undefined) {\n        this.table[pos] = key;\n        this.values[pos] = data;\n      } else {\n        while(this.table[pos] !== undefined) {\n          pos++;\n        }\n        this.table[pos] = key;\n        this.values[pos] = data;\n      }\n    }\n\n  get(key: string) {\n    const pos = this.betterHash(key);\n    if(pos > -1) {\n      for(let i = pos; this.table[pos] !== undefined; i++) {\n        if(this.table[pos] === key) {\n          return this.values[pos];\n        }\n      }\n    }\n    return undefined;\n  }\n}\n```\n","excerpt":"해싱 개요 해싱은 데이터를 단시간에 삽입하거나 저장된 데이터를 가져올 때 주로 사용하는 기법이다. 해싱은 해시 테이블이라는 자료 구조를 이용한다. 해싱을 이용하면 데이터를 빠르게 삽입하고, 삭제하고, 가져올 수 있지만, 최솟값이나 최댓값 찾기 등 검…","fields":{"slug":"/hashing/"},"frontmatter":{"date":"Mar 30, 2020","title":"[algorithms] Hashing","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 연결 리스트\n\n- 배열로 작업했을때 느리다고 판단되면 대안으로 연결 리스트를 사용할 수 있다.\n- 일차원 배열을 사용한 곳에서는 대부분 배열을 연결 리스트로 바꿀 수 있다.\n- 임의의 요소에 접근해야 할 때는 연결 리스트보다 배열이 좋다.\n- 노드(node) 라 불리는 객체가 모여 연결 리스트를 구성한다.\n- 각 노드는 객체 레퍼런스를 통해 리스트의 다른 노드와 연결된다.\n- 다른 노드를 참조하는 레퍼런스를 링크(link)라 한다.\n\n## 동작\n\n- 연결 리스트는 다른 요소와의 관계를 통해 원하는 요소를 참조할 수 있다.\n- 헤더라 불리는 특별한 노드를 이용해 연결 리스트의 시작을 표현한다.\n- 새 노드를 추가하려면 삽입하려는 노드의 이전 노드 링크가 새 노드를 가리키도록 바꿔야 하고 새 노드의 링크는 이전 노드가 가리키던 노드를 가리키도록 설정해야 한다.\n- 노드를 삭제하는 일은 삭제하려는 노드의 이전에 있는 노드 링크를 삭제하려는 노드가 가리키는 노드로 바꾼 다음, 삭제하려는 노드의 링크를 Null로 설정하면 노드가 삭제된다.\n\n## 설계\n\n1. Node 클래스\n\nNode 클래스는 노드의 데이터를 저장하는 element와 연결 리스트의 다음 노드 링크를 저장하는 next, 두 가지 프로퍼티를 포함한다.\n\n```javascript\nfunction Node(element) {\n  this.element = element;\n  this.next = null;\n}\n```\n\n2. LinkedList 클래스\n\n새 노드 삽입, 기존 노드 삭제, 리스트의 특정 데이터 검색 등의 기능 제공한다. 리스트의 헤드를 나타내는 노드에 해당하는 한개의 프로퍼티를 포함한다.\n\n## 연결 리스트 코드 (단방향)\n\n```typescript\n// LinkedNode\nclass LinkedNode<T> {\n  element: T;\n  next: LinkedNode<T> | null;\n\n  constructor(element: T) {\n    this.element = element;\n    this.next = null;\n  }\n}\n\n// LinkedList\nclass LinkedList {\n  head: LinkedNode<string>;\n\n  constructor() {\n    this.head = new LinkedNode(\"head\");\n  }\n\n  find(item: string) {\n    let currNode = this.head;\n    //\n    while (currNode.next && currNode.element !== item) {\n      currNode = currNode.next;\n    }\n\n    if (currNode.element === item) {\n      return currNode;\n    }\n\n    throw new Error(\"해당 노드를 찾을 수 없습니다.\");\n  }\n\n  findPrevious(item: string) {\n    let currNode = this.head;\n    // 현재 노드 다음 element가 item과 일치할 때까지 링크를 타고 이동시킨다.\n    while (currNode.next && currNode.next.element !== item) {\n      currNode = currNode.next;\n    }\n\n    if (currNode.next?.element === item) {\n      return currNode;\n    }\n\n    throw new Error(\"해당 이전 노드를 찾을 수 없습니다.\");\n  }\n\n  // 어떤 노드를 추가할 것이고, 어느 노드 앞에 추가할지를 지정해야 한다.\n  insert(newElement: string, item: string) {\n    const newNode = new LinkedNode(newElement);\n    const currentNode = this.find(item);\n    newNode.next = currentNode.next;\n    currentNode.next = newNode;\n  }\n\n  remove(item: string) {\n    const removeNode = this.find(item);\n    const previousRemoveNode = this.findPrevious(item);\n\n    previousRemoveNode.next = removeNode.next;\n  }\n\n  // 전체 연결 리스트 보여주기\n  display() {\n    let currNode = this.head;\n    console.log(currNode.element);\n\n    while (currNode.next) {\n      console.log(currNode.next.element);\n      currNode = currNode.next;\n    }\n  }\n}\n\n```\n\n## 연결 리스트 코드 (양방향)\n\n연결 리스트를 양방향으로 구현한다면 역방향으로 노드 탐색과 삭제할때 편리하지만 노드를 추가할 때는 더 많은 작업을 수행 해야 한다.\n\n```typescript\n// LinkedNode\nclass LinkedNode<T> {\n  element: T;\n  next: LinkedNode<T> | null;\n  previous: LinkedNode<T> | null;\n\n  constructor(element: T) {\n    this.element = element;\n    this.next = null;\n    this.previous = null // 양방향을 위한 이전 노드 가리키기\n  }\n}\n\n\nclass LinkedList {\n  head: LinkedNode<string>;\n  tail: LinkedNode<string>;\n\n  constructor() {\n    this.head = new LinkedNode(\"head\");\n    this.tail = this.head; // 꼬리 부분도 저장해 둔다.\n  }\n\n  // (...) 이전 코드\n\n  // 어떤 노드를 추가할 것이고, 어느 노드 앞에 추가할지를 지정해야 한다.\n  insert(newElement: string, item: string) {\n    const newNode = new LinkedNode(newElement);\n    const currentNode = this.find(item);\n    newNode.next = currentNode.next;\n    newNode.previous = currentNode; // 추가\n    currentNode.next = newNode;\n    this.tail = newNode;\n  }\n\n  remove(item: string) {\n    const removeNode = this.find(item);\n    const previousRemoveNode = removeNode.previous;\n    const nextRemoveNode = removeNode.next;\n    // const previousRemoveNode = this.findPrevious(item);\n    // previousRemoveNode.next = removeNode.next;\n    if (previousRemoveNode) {\n      previousRemoveNode.next = removeNode.next;\n    }\n\n    if (nextRemoveNode) {\n      nextRemoveNode.previous = previousRemoveNode;\n    }\n\n    if (!nextRemoveNode && previousRemoveNode) {\n      this.tail = previousRemoveNode;\n    }\n\n    removeNode.next = null;\n    removeNode.previous = null;\n  }\n\n  displayReverse() {\n    let currNode = this.tail;\n    console.log(currNode.element);\n\n    while (currNode.previous) {\n      console.log(currNode.previous.element);\n      currNode = currNode.previous;\n    }\n  }\n}\n```\n\n## 연결 리스트 코드 (순환형)\n\n순환형 연결 리스트에서는 헤드의 next 프로퍼티가 자신을 가리킨다는 것입니다.\n순환형 연결 리스트에서는 노드의 끝을 지나 계속 탐색하면 결국 역받향에 있는 노드로 이동 할 수 있습니다.\n\n```typescript\n// 순환과 양방향의 합성 \n\nclass LinkedList {\n  head: LinkedNode<string>;\n  tail: LinkedNode<string>;\n\n  constructor() {\n    this.head = new LinkedNode(\"head\");\n    this.tail = this.head;\n    this.tail.next = this.head;\n    this.head.previous = this.tail;\n  }\n\n  find(item: string) {\n    let currNode = this.head;\n    //\n    while (currNode.next && currNode.element !== item) {\n      currNode = currNode.next;\n    }\n\n    if (currNode.element === item) {\n      return currNode;\n    }\n\n    throw new Error(\"해당 노드를 찾을 수 없습니다.\");\n  }\n\n  findPrevious(item: string) {\n    let currNode = this.head;\n    // 현재 노드 다음 element가 item과 일치할 때까지 링크를 타고 이동시킨다.\n    while (currNode.next && currNode.next.element !== item) {\n      currNode = currNode.next;\n    }\n\n    if (currNode.next?.element === item) {\n      return currNode;\n    }\n\n    throw new Error(\"해당 이전 노드를 찾을 수 없습니다.\");\n  }\n\n  // 어떤 노드를 추가할 것이고, 어느 노드 앞에 추가할지를 지정해야 한다.\n  insert(newElement: string, item: string) {\n    const newNode = new LinkedNode(newElement);\n    const currentNode = this.find(item);\n    newNode.next = currentNode.next;\n    newNode.previous = currentNode; // 추가\n    currentNode.next = newNode;\n\n    this.head.previous = newNode;\n    this.tail = newNode;\n  }\n\n  remove(item: string) {\n    const removeNode = this.find(item);\n    const previousRemoveNode = removeNode.previous;\n    const nextRemoveNode = removeNode.next;\n    // const previousRemoveNode = this.findPrevious(item);\n    // previousRemoveNode.next = removeNode.next;\n    if (previousRemoveNode) {\n      previousRemoveNode.next = removeNode.next;\n    }\n\n    if (nextRemoveNode) {\n      nextRemoveNode.previous = previousRemoveNode;\n    }\n\n    if (!nextRemoveNode && previousRemoveNode) {\n      this.head.previous = previousRemoveNode;\n      this.tail = previousRemoveNode;\n    }\n\n    removeNode.next = null;\n    removeNode.previous = null;\n  }\n\n  // 전체 연결 리스트 보여주기\n  display() {\n    let currNode = this.head;\n    console.log(currNode.element);\n\n    while (currNode.next && !(currNode.next.element === \"head\")) {\n      console.log(currNode.next.element);\n      currNode = currNode.next;\n    }\n  }\n\n  displayReverse() {\n    let currNode = this.tail;\n    console.log(currNode.element);\n\n    while (currNode.previous && !(currNode.previous === this.tail)) {\n      console.log(currNode.previous.element);\n      currNode = currNode.previous;\n    }\n  }\n}\n\n```\n","excerpt":"연결 리스트 배열로 작업했을때 느리다고 판단되면 대안으로 연결 리스트를 사용할 수 있다. 일차원 배열을 사용한 곳에서는 대부분 배열을 연결 리스트로 바꿀 수 있다. 임의의 요소에 접근해야 할 때는 연결 리스트보다 배열이 좋다. 노드(node) 라 불…","fields":{"slug":"/linkedList/"},"frontmatter":{"date":"Mar 29, 2020","title":"[algorithms] Linked List","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 큐의 동작\n\n- 큐에 요소를 삽입하는 동작을 인큐(enqueue)\n- 큐에서 요소를 삭제하는 동작을 데큐(dequeue)\n- 인큐는 큐에 끝부분에 요소를 추가하며, 데큐는 큐의 앞부분에서 요소를 삭제한다.\n- 피크(peek)는 큐의 앞부분에 있는 요소를 확인할 수 있다. 또한 요소를 반환하지는 않는다.\n- length 프로퍼티를 이용하면 큐에 얼마나 많은 요소가 저장되어 있는지 확인 할 수 있다.\n\n## 큐 구현\n\n```typescript\nclass Queue<T> {\n  dataStore: T[];\n\n  constructor(dataStore?: T[]) {\n    this.dataStore = dataStore || [];\n  }\n\n  get length() {\n    return this.dataStore.length;\n  }\n\n  enqueue(element: T) {\n    this.dataStore.push(element);\n  }\n\n  dequeue() {\n    return this.dataStore.shift();\n  }\n\n  // 큐의 앞부분의 요소를 확인한다.\n  front() {\n    return this.dataStore[0];\n  }\n\n  // 큐의 끝부분의 요소를 확인한다.\n  back() {\n    return this.dataStore[this.dataStore.length - 1];\n  }\n\n  toString() {\n    return this.dataStore.join(\"\\n\");\n  }\n\n  // 큐가 비었는지 안비었는지 확인한다.\n  empty() {\n    if (this.dataStore.length === 0) return true;\n    return false;\n  }\n\n  [Symbol.iterator]() {\n    let position = -1;\n    const dataList = this.dataStore;\n    const length = this.length;\n    return {\n      next() {\n        position = position + 1;\n        return {\n          value: dataList[position],\n          done: position >= length\n        };\n      }\n    };\n  }\n}\n\n```\n\n## 예제\n\n1. 큐로 데이터 정렬하기 (기수정렬)\n\n기수 정렬은 두 번의 과정을 걸쳐 데이터를 정렬한다. 우리는 0 부터 99 사이의 정수 데이터를 사용한다.\n첫 번째 과정에서는 1의 자리 숫자를 기준으로 숫자를 정렬하고 , 두 번째 과정에서는 10의 자리 숫자를 기주능로 데이터를 정렬한다.\n\n```typescript\ntype DigitType = 1 | 10;\nconst sampleList = [10, 29, 40, 50, 32, 54, 34, 56, 23, 97, 78];\n\n// digit 정렬 기준 자릿수\nfunction distribute(targetList: number[], digit: DigitType) {\n  const result: Queue<number>[] = new Array(10).fill(1).map(_ => new Queue());\n\n  targetList.forEach(num => {\n    if (digit === 1) {\n      const rest = num % 10;\n      result[rest].enqueue(num);\n    } else {\n      const rest = Math.floor(num / 10);\n      result[rest].enqueue(num);\n    }\n  });\n\n  return result;\n}\n\nfunction collect(queueList: Queue<number>[]) {\n  return queueList.flatMap(queue => {\n    // return queue.dataStore\n    const queueDataList = [];\n    for (const value of queue) {\n      queueDataList.push(value);\n    }\n    return queueDataList;\n  });\n}\n\nconst firstQueue = distribute(sampleList, 1);\nconst firstCollectList = collect(firstQueue);\nconst secondQueue = distribute(firstCollectList, 10);\nconst result = collect(secondQueue);\n\nconsole.log(\"sampleList\", sampleList);\nconsole.log(\"result\", result);\n```\n\n2. 우선순위 큐\n\n보통 큐에서 요소를 삭제할 때는 먼저 삽입한 요소부터 삭제된다. 하지만 이러한 선입선출 방식이 아닌 우선순위와 같은 다른 기준으로 요소를 삭제해야하는 경우도 있다. 이럴때는 우선순위 큐라는 자료구조를 이용한다.\n\n```typescript\n// 기존 queue 에서 dequeue를 수정해 준다.\n// 다음과 같은 큐에 들어갈 element가 있다고 가정하자.\n\nclass Job {\n  name: string\n  code: number\n\n  constructor(name:string, code:number) {\n    this.name = name;\n    this.code = code;\n  }\n}\n\nconst queue = new Queue<Job>()\n\n// 기존 큐에서 dequeue는 다음과 같이 수정해 준다.\nclass Queue {\n  // (...)\n  dequeue() {\n     const targetIndex = this.dataStore.reduce((resultIndex, elem, index) => {\n      if(resultIndex > elem.code) {\n        return index\n      }\n      return resultIndex\n    },0)\n  }\n}\n\n```\n","excerpt":"큐의 동작 큐에 요소를 삽입하는 동작을 인큐(enqueue) 큐에서 요소를 삭제하는 동작을 데큐(dequeue) 인큐는 큐에 끝부분에 요소를 추가하며, 데큐는 큐의 앞부분에서 요소를 삭제한다. 피크(peek)는 큐의 앞부분에 있는 요소를 확인할 수 …","fields":{"slug":"/queue/"},"frontmatter":{"date":"Mar 27, 2020","title":"[algorithms] Queue","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 스택의 동작\n\n- 스택은 리스트의 한쪽 긑으로만 요소에 접근할 수 있다.\n- 구내식당에 쌓아놓은 쟁반을 스택에 비유할 수 있다.\n- 스택은 후입선출(Last-in, First-out) 자료 구조로 알려져 있다.\n- 스택의 탑에 있지 않은 요소에는 접근할 수 있다.\n- 스택의 밑바닥에 있는 요소에 접근하려면 모든 요소를 제거하는 수밖에 없다.\n- push 동작을 이용해 스택에 추가, pop 동작을 이용해 스택에서 요소를 꺼낼 수 있다.\n- peak 을 이용하면 스택에 탑에 있는 요소를 제거하지 않고 내용만 확인할 수 있다.\n- clear 는 스택에 모든 요소를 삭제한다.\n\n## 재귀\n\n- 재귀를 구현할 때는 스택을 사용합니다.\n- 함수를 호출할 때마다 함수에 필요한 많은 변수의 사본이 메모리에 보관된다. 이 메모리가 스택이다.\n- 함수를 재귀 적으로 호출하면 이러한 모든 변수의 다른 사본이 메모리에 저장되고 그 다음에 계속 저장된다.\n\n```javascript\nfunction factorial(N){\n  return N<=1? 1 : N * factorial(N-1);\n}\n```\n\n## 스택 구현\n\n```typescript\nclass Stack<T> {\n  dataStore: T[];\n  top: number;\n\n  constructor() {\n    this.dataStore = [];\n    this.top = 0;\n  }\n\n  push(element: T) {\n    this.dataStore[class Stack<T> {\n  dataStore: T[];\n  top: number;\n\n  constructor(dataStore?: T[]) {\n    this.dataStore = dataStore || [];\n    this.top = 0;\n  }\n\n  push(element: T) {\n    this.dataStore[this.top] = element;\n    this.top = this.top + 1;\n  }\n\n  // top을 변화시킴, 영구적으로 내보낸다.\n  pop() {\n    const topElement = this.dataStore.splice(this.top - 1, 1)[0];\n    this.top = this.top - 1;\n    return topElement;\n  }\n\n  peek() {\n    return this.dataStore[this.top - 1];\n  }\n\n  clear() {\n    this.dataStore = [];\n    this.top = 0;\n  }\n\n  length() {\n    return this.dataStore.length;\n  }\n}\n```\n\n## 예제\n\n1. 수식을 인자로 받아 수식에 열거나 닫는 괄호가 없을 때 false를 반환하는 함수를 구현하시오 닫는 괄호가 다 정상적일땐 true 리턴하자. 예를 들어 '2.3 + 23 / 12 + (3.14159 * 0.24' 에는 닫는 괄호가 없다.\n\n```typescript\nfunction mathematicalLint(express: string) {\n  // 문자열로 된 수식을 배열로 쪼갠다. (기준을 띄어쓰기로? 아니면 문자 하나하나로?)\n  // 검증을 stack으로\n  // 괄호가 있는지 없는지는 regexp로?\n  // '(' 를 만나면 stack에 push ')' 를 만나면 스택확인, 쌍이 맞는지 확인, 그후 pop\n  // 최종적으로 stack이 비어야 닫는 괄호가 정상이다.\n  let result = true;\n  const verificationStack = new Stack<string>();\n  const splitExpress = express.split(\"\");\n\n  const length = splitExpress.length;\n\n  // O(n)\n  for (let i = 0; i < length; i++) {\n    if (splitExpress[i] === \"(\") {\n      verificationStack.push(splitExpress[i]); // 여는 괄호를 만나면 닫는 괄호를 만나야지 pop이 이뤄진다.\n    }\n\n    if (splitExpress[i] === \")\") {\n      // 스택이 비어 있다면\n      if (verificationStack.length() === 0) {\n        verificationStack.push(splitExpress[i]);\n        break;\n      }\n\n      if (verificationStack.peek() === \"(\") {\n        // 쌍이 맞는지 확인\n        verificationStack.pop();\n      }\n    }\n  }\n  console.log(\"verificationStack\", verificationStack);\n  return verificationStack.length() === 0;\n```\n\n2. 우리 주변의 페즈 디스펜서(사탕을 한 알씩 배출해주는 장치)는 스택과 같은 방식으로 동작한다 페즈 디스펜서에 빨간색, 노란색, 흰색 사탕이 섞여 있는데 노란색 사탕은 우리가 싫어하는 맛이다. 스택(한개 이상의 스택을 사용할 수 있다) 을 이용해 디스펜서의 다른 사탕 순서는 바꾸지 말고 노란색 사탕만 제거하는 프로그램을 구현하시오.\n\n```typescript\ntype CandyType = \"red\" | \"white\" | \"yellow\";\nconst PEZ_CANDY_DISPENSER: CandyType[] = [\n  \"red\",\n  \"white\",\n  \"yellow\",\n  \"red\",\n  \"yellow\",\n  \"white\",\n  \"red\",\n  \"red\"\n];\nconst pezDispenserStack = new Stack<CandyType>(PEZ_CANDY_DISPENSER);\n\nfunction removeCandy(dispenser: Stack<CandyType>, candy: CandyType) {\n  const resultStack = new Stack<CandyType>();\n  while (dispenser.length() !== 0) {\n    const dispenserItem = dispenser.pop();\n    if (dispenserItem !== \"yellow\") {\n      resultStack.push(dispenserItem);\n    }\n  }\n\n  return resultStack;\n}\n\nconsole.log(removeCandy(pezDispenserStack, \"yellow\"));\n```\n","excerpt":"스택의 동작 스택은 리스트의 한쪽 긑으로만 요소에 접근할 수 있다. 구내식당에 쌓아놓은 쟁반을 스택에 비유할 수 있다. 스택은 후입선출(Last-in, First-out) 자료 구조로 알려져 있다. 스택의 탑에 있지 않은 요소에는 접근할 수 있다. …","fields":{"slug":"/stack/"},"frontmatter":{"date":"Mar 27, 2020","title":"[algorithms] Stack","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 용어\n\n- 리스트 : 순서가 있는 일련의 데이터 집합\n- 요소 : 리스트에 저장된 각 데이터 항목\n- 길이 : 리스트에 저장된 요소의 수\n\n## 동작\n\n- append : 리스트 끝에 추가\n- insert : 기존 요소 뒤 또는 요소의 앞 부분에 삽입\n- remove : 요소를 삭제\n- clear : 리스트의 모든 요소를 삭제\n- toString : 요소 출력\n- getElement : 현재 요소의 값만 출력\n- next : 리스트의 현재 요소에서 다음 요소로 이동\n- prev : 현재 요소에서 이전 요소로 이동\n- moveTo(n) : n번째 위치로 한번에 이동\n- currPos : 리스트의 현재 위치를 가리킨다.\n\n## 코드\n\n```typescript\nclass List<T> {\n  listSize: number;\n  pos: number;\n  dataStore: T[];\n\n  constructor() {\n    this.listSize = 0;\n    this.pos = 0;\n    this.dataStore = []; // 리스트 요소를 저장할 빈 배열 초기화\n  }\n\n  get Length() {\n    return this.listSize;\n  }\n\n  clear() {\n    this.dataStore = [];\n    this.listSize = 0;\n    this.pos = 0;\n  }\n\n  findIndex(element: T) {\n    return this.dataStore.findIndex(elem => elem === element);\n  }\n\n  insert(newElement: T, afterElement: T) {\n    const startAt = this.findIndex(afterElement);\n    if (startAt > -1) {\n      this.dataStore.splice(startAt + 1, 0, newElement);\n      this.listSize = this.listSize + 1;\n      return true;\n    }\n\n    return false;\n  }\n\n  append(element: T) {\n    this.dataStore[this.listSize++] = element;\n  }\n\n  remove(element: T) {\n    const foundAt = this.findIndex(element);\n    if (foundAt > -1) {\n      this.dataStore.splice(foundAt, 1);\n      this.listSize = this.listSize - 1;\n      return true;\n    }\n\n    return false;\n  }\n\n  front() {\n    this.pos = 0;\n  }\n\n  end() {\n    this.pos = this.listSize - 1;\n  }\n\n  prev() {\n    if (this.pos > 0) {\n      this.pos = this.pos - 1;\n    }\n  }\n\n  next() {\n    if (this.pos < this.listSize - 1) {\n      this.pos = this.pos + 1;\n    }\n  }\n\n  currPos() {\n    return this.pos;\n  }\n\n  moveTo(position: number) {\n    this.pos = position;\n  }\n\n  getElement() {\n    return this.dataStore[this.pos];\n  }\n\n  // 리스트에 특정 element가 있는지 판단.\n  contains(element: T) {\n    return !!this.dataStore.find(elem => elem === element);\n  }\n\n  // 현재 리스트의 모든 요소보다 클 때만 삽입하는 함수 (숫자는 큰값, 문자는 알파벳순으로 나중을 의미)\n  isBigElementThanEveryListElement(element: T) {\n    return this.dataStore.every(elem => {\n      if (typeof elem === \"string\" && typeof element === \"string\") {\n        return element.toLowerCase() > elem.toLowerCase();\n      }\n\n      return element > elem;\n    });\n  }\n}\n```\n","excerpt":"용어 리스트 : 순서가 있는 일련의 데이터 집합 요소 : 리스트에 저장된 각 데이터 항목 길이 : 리스트에 저장된 요소의 수 동작 append : 리스트 끝에 추가 insert : 기존 요소 뒤 또는 요소의 앞 부분에 삽입 remove : 요소를 삭…","fields":{"slug":"/list/"},"frontmatter":{"date":"Mar 26, 2020","title":"[algorithms] List","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n## 준비된 API\n\n- /login → username, code\n\n- /login/check → valid, username\n\n- /logout\n\n> 이때, HTTPS 통신을 하지 않을꺼라면 API 주소 도메인은 WEB 도메인과 일치 시켜야 크롬에서 same-site로 인식한다.  크롬은 기본으로 same-site=Lax로 설정되어있다. 그래서 도메인이 다르면 까다로울 수 있다.\n\n## CSRF 란\n\nA 라는 사용자가 example.com에 로그인 된 채로 (유효한 session id를 쿠키로 가지고 있는) 있다면 B(악당) 이 `<img src=http://example.com/api/logout />` 이러한 페이지를 A 라는 사용자에게 넘겨서 A 사용자가 보게 된다면 example로 요청이 들어갈때 session id 쿠키와 함께 요청이 들어간다. 그러면 유효한 요청이 되어서 A 사용자도 모르게 로그아웃이 되는 것이다.  여기서는 단순 로그아웃 요청이지만 이 요청은 악의적인 데이터 수집, 수정, 삭제가 될 수 있다.\n\n## 로그인 프로세스\n\n1. ID, PASSWORD, 로그인 유지 유무 값을 /login API로 전달\n2. 전역 auth context에 USERNAME, AUTIFICATION 저장 ( 유일한 진실의 근원 )\n3. 처음 URL 치고 들어온 곳으로 Redirect 또는 '/' 로 Redirect\n\n## 로그인 유지 프로세스 ( URL 입력으로 유입 )\n\n1. 전역 auth 컨텍스트 실행시 check api를 호출\n2. 응답이 올때까지 null ( 화면에 아무것도 출력 안함 )\n3. 응답이 오면 AUTIFICATION 에 true /  false 셋팅\n4. true 시 privateRoute에서 해당 Component 보여줌.\n5. false 시 /login 으로 Redirect\n\n## 페이지 이동 프로세스 ( Link 이동 )\n\n1. 페이지 이동 Link 누를시 check api 호출 후 세션 valid 확인\n2. true 시 'to' props로 이동\n3. false 시 세션 만료 모달창 띄움 ( 모달 확인 시 /login 페이지로 이동 )\n\n    ㄴ 이때,  모달창은 이전에 보고 있던 화면에서 띄운다.\n\n## 제공하는 API 호출시 ( 페이지 내 )\n\n1. 응답으로 403 error 발생시 API 과 관련된 ErrorBoundary 에서 세션 만료 모달창 띄움\n2. 모달 확인시 /login 페이지로 이동\n\n## 로그아웃 프로세스\n\n1. 로그아웃 버튼 누를 시 403 error 발생시 세션 만료 모달창 띄움\n2. 모달 확인시 /login 페이지로 이동\n\n## 서버 → 클라이언트\n\n- Access-Control-Allow-Credentials: true 셋팅\n- Access-Control-Allow-Origin: \"*\" 이 아닌 구체적인 도메인으로 셋팅\n  - 요청 헤더의 Oringin, Referer를 참고해서 셋팅하면 되지 않을까 싶음.\n- API 응답으로 Set-Cookie http only 쿠키로 SESSIONID를 받음\n\n## 클라이언트 → 서버\n\n- withCredentials true 설정\n\n## 관련 코드\n\n### Login API\n\n```typescript\n// login API\n\nexport const AuthAPi: IAuthApi = {\n  login($elemForm) {\n    const formData = new FormData($elemForm);\n    formData.set(\"isKeep\", formData.has(\"isKeep\") ? \"true\" : \"false\");\n    return request({\n      url: `${DOMAIN}/login`,\n      method: \"POST\",\n      body: formData\n    });\n  },\n  check() {\n    return request({\n      url: `${DOMAIN}/login/check`,\n      method: \"GET\"\n    });\n  },\n  logout() {\n    return request({\n      url: `${DOMAIN}/logout`,\n      method: \"GET\"\n    });\n  }\n};\n```\n\n### AuthContext\n\n```typescript\n// AuthContext.tsx\ntype AuthContextProviderProps = {\n  children: React.ReactNode;\n};\ntype Action =\n  | {\n      type: \"LOGIN\";\n      username: string;\n    }\n  | { type: \"LOGIN_CHECK\"; username: string; isAuth: boolean }\n  | { type: \"LOGOUT\" };\ntype AuthDispatch = Dispatch<Action>;\n\nconst AuthStateContext = createContext<AuthState>({\n  username: \"\",\n  isAuthenticated: false\n});\n\nconst AuthDispatchContext = createContext<AuthDispatch | undefined>(undefined);\n\nfunction AuthReducer(state: AuthState, action: Action): AuthState {\n  switch (action.type) {\n    case \"LOGIN\":\n      return {\n        ...state,\n        username: action.username,\n        isAuthenticated: true\n      };\n    case \"LOGIN_CHECK\":\n      return {\n        ...state,\n        username: action.username,\n        isAuthenticated: action.isAuth\n      };\n    case \"LOGOUT\":\n      return {\n        ...state,\n        username: \"\",\n        isAuthenticated: false\n      };\n    default:\n      throw new Error(\"Unhandled action\");\n  }\n}\n\nexport function AuthContextProvider({ children }: AuthContextProviderProps) {\n  const [checkState, subject$] = useApiObservable(AuthAPi.check, false);\n  useEffect(() => {\n    subject$.next();\n  }, [subject$]);\n\n  const [authState, dispatch] = useReducer(AuthReducer, {\n    username: \"\",\n    isAuthenticated: false\n  });\n\n  const loginCheckSuccess = checkState.success;\n  const loginCheckError = checkState.error;\n  const loginCheckLoading = checkState.isLoading;\n\n  if (!loginCheckSuccess && !loginCheckError && !loginCheckLoading) return null;\n\n  const loginCheckResponse = (loginCheckSuccess?.response || {\n    valid: false\n  }) as CheckResponse;\n\n  if (loginCheckResponse.valid) {\n    // dispatch({ type: \"LOGIN_CHECK\", username: \"merlin.ho\", isAuth: true });\n    authState.isAuthenticated = true;\n    authState.username = loginCheckResponse.name || \"\";\n  }\n  return (\n    <AuthDispatchContext.Provider value={dispatch}>\n      <AuthStateContext.Provider value={authState}>\n        {children}\n      </AuthStateContext.Provider>\n    </AuthDispatchContext.Provider>\n  );\n}\n\nexport function useAuthState() {\n  const state = useContext(AuthStateContext);\n  return state;\n}\n\nexport function useAuthDispatch() {\n  const dispatch = useContext(AuthDispatchContext);\n  if (!dispatch) throw new Error(\"AuthDispatchContext value not found\");\n  return dispatch;\n}\n```\n\n### Login\n\n```typescript\n// Login.tsx\n\nfunction Login({ location }: LoginProps) {\n  const [loginState, subject$] = useApiObservable(AuthAPi.login, false);\n  const authDispatch = useAuthDispatch();\n\n  const onSubmit = (e: React.FormEvent) => {\n    if (e.currentTarget !== null) {\n      subject$.next(e.currentTarget as HTMLFormElement);\n    }\n  };\n\n  const resultLoginStatus = loginStatus(loginState);\n  if (resultLoginStatus.isLoginSuccess) {\n    authDispatch({\n      type: \"LOGIN\",\n      username: resultLoginStatus.username\n    });\n    // 리다이렉트\n    const { from } = (location.state as { from: { pathname: string } }) || {\n      from: { pathname: \"/\" }\n    };\n    return <Redirect to={from} />;\n    // return <Redirect to={{ ...from, state: { isAuth: true } }} />;\n  }\n\n  return (\n    <Flex\n      sx={{\n        flexDirection: \"column\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        height: \"100%\"\n      }}\n    >\n      <Box sx={{ position: \"relative\", width: \"400px\" }}>\n        <Heading variant=\"loginLogo\" sx={{ mb: 2 }}>\n          User Finding Operation\n        </Heading>\n        <LoginForm\n          onSubmit={onSubmit}\n          errorMessage={resultLoginStatus.errorMessage}\n        ></LoginForm>\n        <LoginInfo></LoginInfo>\n      </Box>\n    </Flex>\n  );\n}\n\nexport default Login;\n\n```\n\n### PrivateRoute\n\n```typescript\n// PrivateRoute.tsx\n\ntype PrivateRouteProps = {\n  // isLoginCheck: boolean;\n} & RouteProps;\n\nfunction PrivateRoute({\n  component: Component,\n  // isLoginCheck,\n  render,\n  ...rest\n}: PrivateRouteProps) {\n  const { isAuthenticated } = useAuthState();\n  return (\n    <Route\n      {...rest}\n      render={({ ...rest }) => {\n        if (isAuthenticated) {\n          return render\n            ? render({ ...rest })\n            : Component && <Component {...rest}></Component>;\n        }\n\n        return (\n          <Redirect\n            to={{\n              pathname: \"/login\",\n              state: { from: rest.location }\n            }}\n          ></Redirect>\n        );\n      }}\n    />\n  );\n}\n\nexport default PrivateRoute;\n\n```\n\n### AuthLink\n\n```typescript\n// AuthLink.tsx\n\ntype AuthLinkProps = {\n  children: React.ReactNode;\n} & NavLinkProps &\n  RouteComponentProps;\n\nfunction AuthLink({\n  children,\n  history,\n  to,\n  staticContext,\n  ...rest\n}: AuthLinkProps) {\n  const modalDispatch = useModalDispatch();\n  // const authDispatch = useAuthDispatch();\n\n  const onClick = (e: React.MouseEvent) => {\n    e.preventDefault();\n\n    AuthAPi.check().subscribe(result => {\n      const checkSuccess = result.success;\n      const responseStatus = checkSuccess?.response as\n        | CheckResponse\n        | undefined;\n      const isLoginSession = responseStatus || { valid: false };\n      if (isLoginSession.valid) {\n        return history.push(to as string);\n      }\n      // Todo: result.error가 나왔을 시에도 어떤 처리를 해놔야..\n      modalDispatch({ type: \"OPEN\", modalType: \"SESSION_EXPIRE\" });\n      // authDispatch({ type: \"LOGOUT\" });\n    });\n  };\n\n  return (\n    <NavLink to={to} {...rest} onClick={onClick}>\n      {children}\n    </NavLink>\n  );\n}\n\nexport default withRouter(AuthLink);\n\n```\n\n### Logout\n\n```typescript\n// logout 일부\n\nconst [logoutState, subject$] = useApiObservable(AuthAPi.logout);\n\nconst authDispatch = useAuthDispatch();\nconst modalDispatch = useModalDispatch();\n\nconst logout = (e: React.MouseEvent) => {\n  e.preventDefault();\n  subject$.next();\n};\n\nconst logoutSuccess = logoutState.success?.status as number | undefined;\nconst logoutError = logoutState.error;\nif (logoutSuccess === 200) {\n  authDispatch({ type: \"LOGOUT\" });\n  return <Redirect to={\"/login\"} />;\n}\n\nif (logoutError?.status === 403) {\n  modalDispatch({ type: \"OPEN\", modalType: \"SESSION_EXPIRE\" });\n}\n```\n","excerpt":"준비된 API /login → username, code /login/check → valid, username /logout 이때, HTTPS 통신을 하지 않을꺼라면 API 주소 도메인은 WEB 도메인과 일치 시켜야 크롬에서 same-site로 인…","fields":{"slug":"/session-login.md/"},"frontmatter":{"date":"Mar 25, 2020","title":"세션 로그인","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 동기\n\nOAuth 2.0의 절차를 글로 정리해 두자.\n다음 글은 생활코딩 에서 알려주신 OAuth 2.0 을 정리한 것입니다.\n\n## 역할\n\n- Resource Owner : User 사용자 - 우리의 서비스를 이용하는 사용자 및 구글,페이스북 등의 서비스도 함께 이용하는 사용자.\n- Client : 우리의 서비스\n- Resource Server(Authorization Server) : 우리의 서비스가 제어하고자 하는 자원, 우리의 서비스가 연동하려는 User의 서비스들 (ex. google, facebook)\n\n## Resource Server 등록\n\n- Client는 Resource Server에 우리 Client를 등록하게 됩니다. 이때 service 이름과 redirect_url을 입력 후 등록을 하면 Resource Server는 client_id, client_secret, redirect_url을 알려줍니다.\n\n## Access Token의 발급\n\n1. Resource Owner 는 Client 인 우리 서비스에 접속합니다. (이때, 우리 서비스는 Resource Server를 연동하는 서비스입니다.)\n사용자가 나의 서비스에 와서 글을 남겼다. -> 구글 캘린더에 표시를 하던가 페이스북에 \"글을 썼다\" 또는 \"글을 보았다\" 등을 공유\n\n2. Client 는 \"Login with Facebook, Login with Google\" 등의 버튼을 보여줍니다. 이때, Resource Server의 B,C 기능을 이용하겠다고 가정합니다. 이 버튼의 링크는 다음과 같습니다.\n`https://resource.server/?client_id=1&scope=B,C&redirect_url=http://slient/callback` 여기서 redirect_url은 Client 에서 미리 구축해두고 있어야 합니다.\n\n3. 위 버튼을 눌러 Resource Server에 접속이 되면 Resource Server은 Resource Owner에게 로그인 하라는 페이지를 보여주게 됩니다.\n\n4. Resource Owner가 로그인을 하게 됩니다.\n\n5. Resource Server는 이제 아까 url의 쿼리스트링과 Resource Server가 보유한 client_id와 redirect_url이 같은지 비교합니다.\n\n6. 같다면 다시 Resource Server는 Resource Owner 에게 해당 Client 서비스에게 B,C 기능을 열어주겠냐는 페이지를 보여줍니다.\n\n7. Resource Owner가 허용을 하게 되면 Resource Server는 authorization code(3 이라 칩시다)를 만들어 Resource Owner의 브라우저에게 다음과 같은 주소로 redirection 합니다.\n`https://client/callback?code=3`\n\n8. Client에서 `code=3` 이라는 정보를 받게 되면 authorization code = 3 을 생성하게 됩니다.\n\n9. Client에서는 다음과 같은 url로 Resource Server에 Access Token 을 요청 하게 됩니다.\n`https://resource.server/token?grant_type=authorization_code&code=3&redirect_url=https://client/callback&client_id=1&client_secret=2`\n\n10. Resource Server는 임시 비밀번호인 authorization code 와 client_id, client_secret, redirect_url을 확인해서 accesss_token을 만들어서 Client에 발급시켜 줍니다.\n\n## Refresh Token의 발급\n\n- access_token 에게는 수명이 있습니다. 이때 손쉽게 access_token을 다시 발급 받을 수 있는 방법이 refresh_token 입니다.\n- 보통은 access_token을 발급할때, refresh_token을 발급해 줍니다.\n- 수명이 끝난 access_token으로 API를 호출하게 되면 invalid 한 응답을 주게 됩니다.\n- access_token이 수명이 다하면 Authorization Server에 전달하면 access_token을 다시 발급해 주게 됩니다.\n- 예를 들어 구글의 경우에는 구글 API의 post 방식으로 `client_id`,`client_secret`,`refresh_token`,`grant_type=refresh_token` 정보를 넘겨주면 다시 access_token을 발급 해 주게 됩니다.\n\n## API 활용\n\n- 쿼리 스트링 : <API주소>/?access_token=<access_token>\n- request header : Authorization: Bearer <access_token>\n\n## 참고\n\n[https://www.youtube.com/playlist?list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-](https://www.youtube.com/playlist?list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-)","excerpt":"동기 OAuth 2.0의 절차를 글로 정리해 두자.\n다음 글은 생활코딩 에서 알려주신 OAuth 2.0 을 정리한 것입니다. 역할 Resource Owner : User 사용자 - 우리의 서비스를 이용하는 사용자 및 구글,페이스북 등의 서비스도 함께…","fields":{"slug":"/hello-OAuth.md/"},"frontmatter":{"date":"Mar 16, 2020","title":"OAuth 2.0","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 동기\n\n크롬 브라우저(v80) 에서 서브 도메인에 post 요청 시에 응답헤더로 Set-Cookie 가 설정되어서 오지만,\n크롬 dev tools의 application > cookie 로는 저장되는 모습을 볼 수가 없었습니다.\n\n하여 몇가지 테스트를 진행 해보고 파악을 해보려고 합니다.\n\n## 준비\n\n- 크롬 브라우저 (v80) : 모든 쿠키가 다 삭제된 상태\n- web API 서버 : `merlin.com:10001` (cors 설정)\n- 각각 다른 도메인 서버\n  - `merlin.com:20001` (first-class 도메인)\n  - `sub.merlin.com:20001` (서브 도메인)\n  - `third.com:20001` (third-party 도메인)\n\n### 코드 준비\n\n#### API SERVER\n\n```javascript\nconst express = require(\"express\");\nconst fs = require(\"fs\");\nconst cors = require(\"cors\");\nvar cookieParser = require(\"cookie-parser\");\n\nconst app = express();\nconst whiteList = [\n  \"http://merlin.com:20001\",\n  \"http://sub.merlin.com:20001\",\n  \"http://third.com:20001\"\n];\n\nconst corsOptions = {\n  origin: function(origin, callback) {\n    callback(null, whiteList.indexOf(origin) > -1);\n  },\n  methods: \"POST\",\n  credentials: true\n};\napp.use(cors(corsOptions));\napp.use(cookieParser());\n\napp.post(\"/timestamp\", function(req, res) {\n  console.log(\"Route: /timestamp\");\n  console.log(\"Cookies: \", req.cookies);\n\n  res.cookie(\"timestamp\", new Date() * 1, {\n    // domain: \"merlin.com\",\n    httpOnly: true,\n    path: \"/\"\n  });\n  res.send({\n    result: \"true\",\n    message: \"success request\"\n  });\n});\n\napp.listen(10001);\n\nconsole.log(\"Running API SERVER...\");\n\n```\n\n#### WEB SERVER\n\n```javascript\nconst express = require(\"express\");\nconst fs = require(\"fs\");\n\nconst app = express();\n\napp.get(\"/\", function(req, res) {\n  fs.readFile(\"index.html\", function(error, data) {\n    if (error) {\n      res.send(\"Page not found.\");\n    } else {\n      res.writeHead(200, { \"Content-Type\": \"text/html\" });\n      res.end(data);\n    }\n  });\n});\n\napp.listen(20001);\n\nconsole.log(\"Running WEB SERVER...\");\n```\n\n#### API 호출 로직\n\n```javascript\nconst apiUri = 'http://merlin.com:10001/timestamp'\n\nfunction getTimestamp() {\n  fetch(apiUri, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json;charset=UTF-8\"\n    },\n    credentials: 'include',\n  }).then(res => res)\n    .then(console.log)\n\n  //  axios(\n  //   {\n  //     method: 'POST',\n  //     url: apiUri,\n  //     withCredentials: true,\n  //   },\n  // ).then(console.log)\n}\n```\n\n## 실험방법\n\n1. 크롬 브라우저로 각 다른 도메인에 접근 합니다.\n\n2. 버튼을 눌렀을때 `merlin.com:10001`로 post method 호출을 보냅니다. ( axois, fetch )\n\n3. `merlin.com:10001` 에는 응답으로 쿠키를 보내봅니다. ( 쿠키에 도메인 설정 함 vs 쿠키에 도메인 설정을 안함 )\n  \n4. 크롬에서 쿠키가 잘 쌓이는지 확인합니다.  \n\n5. 한번 더 요청 시 저장된 쿠키가 서버로 잘 날라가는지도 확인합니다.\n\n6. 도메인 및 환경이 달라질 때마다 쿠키는 삭제해 줍니다.\n\n## 실험 (쿠키에 도메인 설정 안함)\n\n### 1차 도메인 fetch 방법(merlin.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/fetch/no-domain-first-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/fetch/no-domain-first-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/fetch/no-domain-first-server.png)\n\n### 1차 도메인 axois 방법(merlin.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/axios/no-domain-first-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/axios/no-domain-first-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/axios/no-domain-first-server.png)\n\n### 서브 도메인 fetch 방법 (sub.merlin.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/fetch/no-domain-second-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/fetch/no-domain-second-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/fetch/no-domain-second-server.png)\n\n### 서브 도메인 axios 방법 (sub.merlin.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/axios/no-domain-second-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/axios/no-domain-second-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/axios/no-domain-second-server.png)\n\n### 3자 도메인 fetch 방법(third.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/fetch/no-domain-third-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/fetch/no-domain-third-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/fetch/no-domain-third-server.png)\n\n### 3자 도메인 axios 방법(third.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/axios/no-domain-third-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/axios/no-domain-third-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/axios/no-domain-third-server.png)\n\n## 실험 쿠키에 도메인 설정 함 (domain: 'merlin.ho')\n\n### 1차 도메인 fetch 방법(merlin.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/fetch/domain-first-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/fetch/domain-first-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/fetch/domain-first-server.png)\n\n### 1차 도메인 axios 방법(merlin.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/axios/domain-first-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/axios/domain-first-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/axios/domain-first-server.png)\n\n### 서브 도메인 fetch 방법(sub.merlin.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/fetch/domain-second-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/fetch/domain-second-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/fetch/domain-second-server.png)\n\n### 서브 도메인 axios 방법(sub.merlin.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/axios/domain-second-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/axios/domain-second-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/axios/domain-second-server.png)\n\n### 3자 도메인 fetch 방법(third.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/fetch/domain-third-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/fetch/domain-third-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/fetch/domain-third-server.png)\n\n### 3자 도메인 axios 방법(third.com:20001)\n\n[header Set-Cookie]\n\n![헤더요청](./images/axios/domain-third-header.png)\n\n[chrome dev tools]\n\n![크롬쿠키](./images/axios/domain-third-chrome.png)\n\n[서버로 들어온 쿠키]\n\n![서버로 들어온 쿠키](./images/axios/domain-third-server.png)\n\n## 정리\n\n- 일단 이유는 모르겠으나 `axios` 요청시 응답으로 쿠키에 도메인 없이 `Set-Cookie`를 하게 되면 크롬 dev tools에 보이지 않는다.\n- 하지만 재 요청시 서버에 저장되있던 쿠키가 넘어가는 것으로 보아 쿠키가 저장이 되고 있는 사실을 알 수 있었다.\n- `axios` 요청시 응답 쿠키에 도메인이 설정이 되어 있어도 `3자 도메인`에는 크롬 dev tools에 보이지 않는다. 하지만 쿠키는 저장되는 것을 알 수 있다.\n- 크롬에서 최근에 `SameSite`가 default 값이 `Lax` 값으로 바뀐 이유 때문에 `3자 도메인`에 `Post` 요청시 경고가 콘솔창에서 뜹니다. (SameSite가 None이 아니면 전송이 안된다. Secure 설정도 필수.) 하지만 아직은 서버에 쿠키가 잘 전달 되는 것으로 보아 강제하지 않는거 같다.\n- 쿠키가 브라우저에 저장될 때는 본인이 생성된 서버 도메인과 쿠키의 domain이 맞는지 확인합니다. 만약 쿠키에 엉뚱한 `google.com` 이라고 도메인을 설정해 두면 브라우저는 이 쿠키는 저장시키지 않습니다.\n- 브라우저가 새로운 요청시 브라우저가 가지고 있는 쿠키를 전송하는데 이때는 쿠키에 설정된 domain 의 서브 도메인까지만 확인해서 전송시켜 줍니다. 이때, domain이 설정이 안되어 있다면 `document.cookie`는 쿠키가 만들어진 도메인에서만 접근이 가능합니다.\n","excerpt":"동기 크롬 브라우저(v80) 에서 서브 도메인에 post 요청 시에 응답헤더로 Set-Cookie 가 설정되어서 오지만,\n크롬 dev tools의 application > cookie 로는 저장되는 모습을 볼 수가 없었습니다. 하여 몇가지 테스트를 …","fields":{"slug":"/web-cookie.md/"},"frontmatter":{"date":"Mar 15, 2020","title":"web-cookie","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n## vega 란\n\n공홈 : [https://vega.github.io/vega/](https://vega.github.io/vega/)\n\nJSON 방식으로 시각화 문법을 작성하여 차트를 그리는 툴 입니다.\n\nd3.js 의 복잡한 메서드나 로직을 가지고 그리는 것이 아니라 vega에서 정해진 rule대로 json 을 작성하면 해당 규칙대로 차트를 그려줍니다.\n\n### 장점\n\n- config 처럼 셋팅만으로도 차트를 그릴 수 있습니다.\n- 온라인 툴을 제공하고 있어서 미리 셋팅된 config를 데이터 및 차트를 확인 할 수 있습니다.\n- 다양한 example을 제공하고 있습니다.\n\n### 단점\n\n- d3.js를 다뤄 보지 않았다면 용어나 단어에 의해 러닝커브가 발생 됩니다.\n- config json에 차트 관련 메서드들도 string 값으로 넘겨야 하고, 정확히 무슨 값을 넘겨야 하는지 모른다면 방대한 문서를 읽어야 합니다.\n- 온라인 툴에서 미리 확인 할 수 있는 데이터가 너무 길어질 경우에는 온라인 툴에서 확인하기가 어렵습니다. ( 개인적으로 View 메서드를 이용해서 돌려보라고 안내해줍니다. )\n\n## react-vega\n\ngithub : [https://github.com/vega/react-vega/tree/master/packages/react-vega](https://github.com/vega/react-vega/tree/master/packages/react-vega)\n\nvega로 그려지는 차트를 컴포넌트로 만들어주는 라이브러리\n\n- 차트를 그리는 config 를 입력으로 받아 컴포넌트를 만든다.\n- 해당 컴포넌트의 props API는 [https://github.com/vega/vega-embed](https://github.com/vega/vega-embed) API 를 참고하면 됩니다.\n  - mode, theme, defaultStyle, renderer, logLovel, tooltip, loader, patch, width, height, padding, actions, scaleFactor, config, editorUrl, sourceHeader, sourceFooter, hover, i18n, downloadFileName\n\n## 사용\n\nexample code : [https://github.com/vega/react-vega/tree/master/packages/react-vega#example-code](https://github.com/vega/react-vega/tree/master/packages/react-vega#example-code)\n\n### 예시 ( 트리 차트 )\n\n```typescript\nimport { createClassFromSpec } from \"react-vega\";\n\nexport default createClassFromSpec({\n  mode: \"vega\",\n  spec: {\n    $schema: \"https://vega.github.io/schema/vega/v5.json\",\n    width: 1200,\n    // height: 1500,\n    padding: 5,\n    background: \"white\",\n    autosize: { type: \"fit-x\", contains: \"padding\" },\n    signals: [\n      // 대화 형 동작을 유도 할 수있는 동적 변수\n      { name: \"colorIn\", value: \"firebrick\" },\n      { name: \"colorOut\", value: \"forestgreen\" },\n      {\n        name: \"active\",\n        value: null, // 마우스 오버에 따라서 active value에 동적으로 다른 값이 들어간다. \n        on: [\n          { events: \"text:mouseover\", update: \"datum.id\" },\n          { events: \"mouseover[!event.item]\", update: \"null\" }\n        ]\n      },\n      {\n        name: \"activeNode\",\n        value: null, // 마우스 오버에 따라서 active value에 동적으로 다른 값이 들어간다. \n        on: [\n          { events: \"text:mouseover\", update: \"datum\" },\n          { events: \"mouseover[!event.item]\", update: \"null\" }\n        ]\n      },\n      {\n        name: \"activeParent\",\n        value: null, // 마우스 오버에 따라서 active value에 동적으로 다른 값이 들어간다. \n        on: [\n          { events: \"text:mouseover\", update: \"datum.parent\" },\n          { events: \"mouseover[!event.item]\", update: \"null\" }\n        ]\n      }\n    ],\n    data: [ // 데이터 세트 정의 및 변환은 로드 할 데이터와 처리 방법을 정의합니다.\n      {\n        name: \"tree\",\n        // values: [# 데이터가 들어갈 영역],\n        transform: [\n          {\n            type: \"stratify\",\n            key: \"id\",\n            parentKey: \"parent\"\n          },\n          {\n            type: \"tree\",\n            method: \"tidy\",\n            size: [{ signal: \"height\" }, { signal: \"width\" }],\n            separation: true,\n            as: [\"y\", \"x\", \"depth\", \"children\"]\n          },\n          {\n            type: \"formula\",\n            expr: \"slice(datum.id, 0, 1)\",\n            as: \"type\"\n          }\n        ]\n      },\n      { \n        name: \"links\",\n        source: \"tree\",\n        transform: [\n          { type: \"treelinks\" },\n          {\n            type: \"linkpath\",\n            orient: \"horizontal\",\n            shape: \"diagonal\"\n          }\n        ]\n      },\n      { \n        name: \"ancestors\", // 기존 tree 데이터를 기반으로 ancestor를 생성한 파생된 데이터를 만든다.\n        source: \"tree\",\n        transform: [\n          {\n            type: \"formula\",\n            expr: \"treeAncestors('tree', datum.id)\", // 리턴 배열\n            as: \"ancestors\",\n            initonly: true\n          }\n        ]\n      },\n      {\n        name: \"treeAncestorsFlatten\", // ancestors 데이터를 기반으로 배열값인 ancestors 열 값을 flatten 하게 만든다.\n        source: \"ancestors\",\n        transform: [{ type: \"flatten\", fields: [\"ancestors\"] }]\n      },\n      {\n        name: \"selected\",\n        source: \"treeAncestorsFlatten\",\n        transform: [\n          {\n            type: \"filter\",\n            expr:\n              \"datum.id === active || datum.parent === active || datum.id === activeParent || datum.ancestors.id === active\"\n          }\n        ]\n      }\n    ],\n\n    marks: [\n      {\n        type: \"path\",\n        from: { data: \"links\" },\n        encode: {\n          update: {\n            path: { field: \"path\" },\n            stroke: [\n              {\n                test:\n                  \"indata('selected', 'id', datum.source.id) && indata('selected', 'id', datum.target.id)\",\n                signal: \"colorIn\"\n              },\n              {\n                test:\n                  \"indata('selected', 'ancestors.id', datum.source.id) && indata('selected', 'ancestors.id', datum.target.id)\",\n                signal: \"colorIn\"\n              },\n              { value: \"#ddd\" }\n            ]\n          }\n        }\n      },\n      {\n        type: \"symbol\",\n        from: { data: \"tree\" },\n        encode: {\n          enter: {\n            size: { value: 100 },\n            stroke: { value: \"#fff\" }\n          },\n          update: {\n            x: { field: \"x\" },\n            y: { field: \"y\" },\n            fill: [\n              { test: \"datum.id === active\", value: \"red\" },\n              { test: \"indata('selected', 'id', datum.id)\", signal: \"colorIn\" },\n              {\n                test: \"indata('selected', 'ancestors.id', datum.id)\",\n                signal: \"colorIn\"\n              },\n              { value: \"#e4cccc\" }\n            ]\n          }\n        }\n      },\n      {\n        type: \"text\",\n        from: { data: \"tree\" },\n        encode: {\n          enter: {\n            text: { signal: \"datum.id + ' ' + datum.name\" },\n            fontSize: { value: 12 },\n            baseline: { value: \"middle\" }\n          },\n          update: {\n            x: { field: \"x\" },\n            y: { field: \"y\" },\n            dx: { signal: \"datum.children ? -7 : 7\" },\n            align: { signal: \"datum.children ? 'right' : 'left'\" },\n            tooltip: { signal: \"datum.name\" },\n            fill: [\n              { test: \"datum.id === active\", value: \"red\" },\n              { test: \"indata('selected', 'id', datum.id)\", signal: \"colorIn\" },\n              {\n                test: \"indata('selected', 'ancestors.id', datum.id)\",\n                signal: \"colorIn\"\n              },\n\n              { value: \"#333\" }\n            ]\n          }\n        }\n      }\n    ]\n  }\n});\n```\n\n```typescript\n// 사용법\n<TagTreeChart\n  data={tagChartData}\n  actions={false}\n  height={resultChartHeight}\n  renderer={\"svg\"}\n></TagTreeChart>\n```","excerpt":"vega 란 공홈 : https://vega.github.io/vega/ JSON 방식으로 시각화 문법을 작성하여 차트를 그리는 툴 입니다. d3.js 의 복잡한 메서드나 로직을 가지고 그리는 것이 아니라 vega에서 정해진 rule대로 json 을…","fields":{"slug":"/react-vega.md/"},"frontmatter":{"date":"Mar 12, 2020","title":"react-vega","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이번 프로젝트에 rebass 라는 `React primitive ui component build with styled system` 이라는 라이브러리를 사용해보고 정보와 사용 느낀점을 남깁니다.\n\n## rebass 란\n\nReact에서 사용할 수 있는 UI 원시 컴포넌트들을 지원하는 라이브러리로써 기존의 `css-in-js` 라이브러리에 `styled-system`을 이용해서 만들어져 있습니다.\n\n즉, css-in-js에 이런 `styled-system`을 믹싱해서 원시 컴포넌트를 미리 만들어 둔 것이 `rebass` 입니다.\n\ncss-in-js : styled-component , @emotion\n\n## css-in-js (styled-component, @emotion) 장점\n\n여기서는 별도의 css-in-js 들을 설명하진 않겠습니다. 대신 장점 몇 가지를 나열해 보겠습니다.\n\n1. 셀렉터의 스코프가 전역이 아닙니다. 이 말은, 셀렉터가 겹칠일이 없다는 것입니다.\n2. sass 문법을 사용할 수 있습니다. 즉, '&' 단어로 현재 컴포넌트를 나타낼 수 있고 이걸로 부모 , 형재 등등의 선택자들을 셀렉팅 할 수 있습니다.\n3. React Context API를 이용해 theme를 적용할 수 있습니다.\n4. 다이나믹하게 스타일링을 적용할 수 있습니다. 컴포넌트에 props를 전달해서 동적으로 스타일을 정의 할 수 있습니다. 또한 js 특정 값에 따라서 스타일을 쉽게 정의 내릴 수 있습니다.\n\n무엇보다도 컴포넌트 베이스 디자인을 할 수 있고 작은 독립적인 단위로 UI 분할을 하는데 도움을 줍니다.\n\n한곳 또한 한 페이지 이상 또는 자주 사용된다면 특정 스타일 또는 디자인을 갖고 있다면 클래스를 만들고 어플리케이션의 다른 영역에서 그 클래스를 사용하는 것보다 하나의 스타일된 컴포넌트를 만들고 특정 컴포넌트를 사용하는 것이 중복된 css를 줄이고 color 또는 공간을 조정하는 것 같은 UI를 약간 변경하는 데 필요한 시간을 줄입니다.  \n\n## styled-system 이란\n\n`Styled System`은 `constraint-based design system principles`에 영향을 받아 비주얼 디자인의 특정 영역 내에서 디자인 제약 스케일을 관리하기 위한 솔루션 입니다.\n\n> \"디자인 시스템은 기본적으로 디자인과 코드로 구현 된 규칙, 제약 조건 및 원칙의 모음입니다.\" -Sylvee L.-\n> '디자인 시스템'이란, 서비스를 만드는데 사용한 공통 컬러, 서체, 인터랙션, 각종 정책 및 규정에 관한 모든 컴포넌트를 정리해놓은 것을 뜻합니다. -배재민 디자이너-\n\n예를 들면 폰트의 사이즈, 여백의 사이즈, 컬러, 기타 다른 시각적인 속성들을 theme object로 관리 할 수 있도록 도와줍니다. 이제는 구체적인 디자인 시스템을 포함하는 theme.js 를 사용해서 컴포넌트의 props를 셋팅해주게 됩니다.\n\n또한 일관된 스타일을 적용 할 때 올바른 작업을 쉽게 수행 할 수있는 API를 제공하도록 합니다.\n\n## rebass 장점\n\n`rebass`는 `system-styled` 장점을 더욱 간단히 이용 하는 것이라, 아래 장점들은 `styled-system`의 장점이 되기도 합니다.\n\n1. 가장 작고 견고한 Component 들을 제공합니다.\n\n  컴포넌트 개발시에 기본적으로 제공하는 (Box, Text, Image.. 등등의 컴포넌트를 미리 제공해 줍니다.)\n\n  ```typescript\n    import {Box, Text, Image} from 'rebass'\n  ```\n\n2. 일관 된 컴포넌트의 props 개발\n\n  다음 유지보수시 서로 다른 개발자가 작성한 컴포넌트가 아래의 예시와 같다고 했을 때\n  \n  ```typescript\n    <CustomButton1 type=\"thin\"/>\n    <CustomButton2 thin/>\n  ```\n\n  다양한 API 형식을 지니는 컴포넌트를 제작할 수 있으며 이는 곧 또다른 유지보수시 큰 시간을 들이게 됩니다.\n  \n  반면 rebass를 사용한다면 새롭게 props 를 만들 필요가 없을 뿐더러 다른 개발자가 보아도 쉽게 이해 할 수 있습니다.\n  \n  ```typescript\n    <CustomButton1 p={2} /> // padding 이 테마의 scale의 2번째 값을 적용한다.\n    <CustomButton2 p={3} /> // padding 이 테마의 scale의 3번째 값을 적용한다.\n  ```\n\n3. 테마를 우선순위로 사용하면서 일관된 스타일을 유지\n\n  css-in-js 에서도 테마를 지원하지만 기본적으로 우선시 되지는 않습니다. 하지만 rebass 컴포넌트는 테마를 우선 적용하도록 되어있습니다.\n\n4. 확장성이 용이\n\n  css-in-js에서 사용하도록 하는 `styled()` 로 확장하는 컴포넌트는 기존 컴포넌트의 API가 복잡할수록 예측 가능하도록 확장하기가 어렵습니다. 반면 rebass로 확장을 하는 경우에는 예측 가능하도록 설계가 되어 있습니다.\n\n  ```typescript\n    import {Button} from 'rebass'\n    \n    function CustomButton() {\n      return <Button sx={\n                color: 'point' // theme에 포인트 컬러\n              } />\n    }\n    \n    <CustomButton /> // 일반적으로 color는 point 컬러\n    <CustomButton color={'red'} /> // red color로 수정\n  ```\n\n## 추후 theme를 잘 쓰기 위한 노력\n\n스타일에 대한 적절한 추상화 작업이 필요합니다. 최대한 추상화로 정의 내릴 수 있는 디자인은 모두 theme에 녹여내는 작업이 필요 합니다.\n\n디자인을 보고 더 이상 쪼갤 수 없는 스타일 요소들을 분류하고 한 스타일 요소에 최대 n개가 넘지 않는 선에서 추상화를 시킵니다.\n\nex) borderRadius 의 경우 smallRadius, mediumRadius, largeRadius\n\n이렇게 theme.js 에 디자인 명세를 작성하면 페이지에 들어가는 컴포넌트들은 될 수 있으면 이 명세에 따르도록 만듭니다.\n피치 못할 경우에는 각 컴포넌트에서 필요한 스타일을 추가 및 오버라이딩 해서 적용합니다.\n\n1. 디자인 가이드로 준 수치는 모두 theme.js 로 설정해 둔다.\n2. theme에 있는 수치들은 sx props로 셋팅한다.\n3. 보통은 atoms 단위에 있는 컴포넌트는 sx로 셋팅한다. ( 다른 컴포넌트에서 확장시 css props로 확장 )\n4. moleculos 이상부터는 공간부분을 대부분 theme에서 가져다 쓴다.\n5. 나머지는 css로 사용하되 json 또는 styled-component의 css helper를 이용하면 간단하게 이용할 수 있을 듯 싶다.\n\n## rebass + typescript\n\nrebass와 typecript를 함께 썼을때 이슈로는 다음과 같습니다.\n\nrebass는 css-in-js를 `@emotion` 기반으로 사용하고 `styled-system`을 사용하는 것으로 github에서 보았습니다.\n\n```typescript\n  import styled from '@emotion/styled'\n  \n  export const Box = styled('div', {\n    shouldForwardProp\n  })({\n    boxSizing: 'border-box',\n    margin: 0,\n    minWidth: 0,\n  },\n    base,\n    variant,\n    sx,\n    props => props.css,\n    compose(\n      space,\n      layout,\n      typography,\n      color,\n      flexbox,\n    ),\n  )\n  \n  interface BoxKnownProps\n      extends BaseProps,\n          StyledSystem.SpaceProps,\n          StyledSystem.LayoutProps,\n          StyledSystem.FontSizeProps,\n          StyledSystem.ColorProps,\n          StyledSystem.FlexProps,\n          StyledSystem.OrderProps,\n          StyledSystem.AlignSelfProps,\n          SxProps {\n      variant?: StyledSystem.ResponsiveValue<string>;\n      tx?: string;\n  };\n  export interface BoxProps extends BoxKnownProps, Omit<React.HTMLProps<HTMLDivElement>, keyof BoxKnownProps> {}\n  export const Box: React.FunctionComponent<BoxProps>;\n```\n\n하지만 다른 컴포넌트에서 `@emotion/core`를 import 할 경우 css에 대한 충돌이 발생 합니다.\n\n`@emotion/core` 에서 사용하는 css type 은\n\n```typescript\n  declare global {\n    namespace JSX {\n      /**\n       * Do we need to modify `LibraryManagedAttributes` too,\n       * to make `className` props optional when `css` props is specified?\n       */\n  \n      interface IntrinsicAttributes {\n        css?: InterpolationWithTheme<any>\n      }\n    }\n  }\n```\n\nrebass 의 css type을 살펴보면\n\n```typescript\n  import * as StyledComponents from 'styled-components';\n  \n  export interface BaseProps extends React.RefAttributes<any> {\n      as?: React.ElementType;\n      css?: StyledComponents.CSSObject | StyledComponents.FlattenSimpleInterpolation | string;\n  }\n```\n\n여기서 rebass의 css props는 왜 StyledComponents 를 아직도 type으로 지정하는지는 아직 파악이 안됩니다.\n\n## rebass 느낀점\n\n디자이너가 있다면 어느정도 디자인에 대한 `system`을 만들어 두고 시작하면 좀 더 손쉽게 쓸 수 있을거 같습니다.\n여기서 디자인 `system`은 간단하게 디자인 가이드 정도 생각하면 될 듯 싶습니다.\n스타일 어디까지를 테마로 뺴두어야 할지의 경계를 정하지 못한다면 theme.js가 자칫 의미가 없어질 수 있습니다.\n\n장점을 정리해보면 다음과 같습니다.\n\n1. 테마를 우선순위로\n2. 일관된 props ( 모양과 행동으로 구체적인 props를 갖는게 좋음.)\n3. 컴포넌트의 계층 구조를 손쉽게 생각할 수 있게 해줌.\n4. 컴포넌트 확장에 용이\n\n### 아쉬웠던 점\n\ncss-in-js 들에는 develop 할 경우 css 네이밍을 개발자가 정해놓은 룰에 따라서 네이밍을 붙여주기도 합니다.\n\n특히 `@emotion` 에서는 [https://emotion.sh/docs/babel-plugin-emotion](https://emotion.sh/docs/babel-plugin-emotion) 를 사용하면 css 네이밍을 붙여줍니다.\n\n이는 개발자 도구에서도 어느 컴포넌트에서 렌더링이 되었는지 한눈에 알아 볼 수 있습니다.\n\n- `rebass`에서 `@emotion/styled` 를 사용하고 있어서 위 플러그인을 사용함.\n\n하지만 `rebass` 에서는 다음의 경우에만 css 네이밍을 붙여 줍니다.\n\n1. props로 css 속성이 들어간 컴포넌트 : babel config에 정해진 룰대로 자동으로 css 네이밍을 붙여줍니다.\n2. sx props 안에 label property가 존재하는 경우 : label의 값으로 css 네이밍을 붙여줍니다.\n\n## styled component로 비슷하게 만들어 보기\n\n추가적으로 테마를 사용하지 않을 경우에 styled component 모듈로도 이렇게 primitive UI Component를 만들어 볼 수 있을 것이다.\n\n해서 한번 도전해 보았다.\n쉬운 `Atom`의 `Box Component` 는 다음과 같이 만들 수 있을 꺼 같습니다.\n\n```typescript\nimport React from \"react\";\nimport styled, { FlattenSimpleInterpolation } from \"styled-components\";\n\ntype BoxProps = {\n  children?: React.ReactNode;\n  css?: FlattenSimpleInterpolation;\n};\ntype BoxStyledProps = {\n  css?: FlattenSimpleInterpolation;\n};\n\nconst BoxStyled = styled.div<BoxStyledProps>`\n  ${props => (props.css ? props.css : \"\")}\n`;\n\nfunction Box({ children, css }: BoxProps) {\n  return <BoxStyled css={css}>{children}</BoxStyled>;\n}\n\nexport default Box;\n```\n\n## 참고\n\nstyled-system 사용법 : [https://varun.ca/styled-system/](https://varun.ca/styled-system/)\n\nstyled-component와 styled-system을 함께 사용했을때 이점 : [https://medium.com/styled-components/build-better-component-libraries-with-styled-system-4951653d54ee](https://medium.com/styled-components/build-better-component-libraries-with-styled-system-4951653d54ee)\n\nstyled-system 신조 : [https://jxnblk.com/blog/the-three-tenets-of-styled-system/](https://jxnblk.com/blog/the-three-tenets-of-styled-system/)\n\n디자인 시스템 1 : [https://medium.muz.li/what-is-a-design-system-1e43d19e7696](https://medium.muz.li/what-is-a-design-system-1e43d19e7696)\n\n디자인 시스템 2 : [https://medium.com/sketch-app-sources/design-system-principles-service-design-c3e439666b97](https://medium.com/sketch-app-sources/design-system-principles-service-design-c3e439666b97)\n\n디자인 시스템 3 : [https://medium.com/guleum/%EB%94%94%EC%9E%90%EC%9D%B8-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EA%B5%AC%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-beefa8214884](https://medium.com/guleum/%EB%94%94%EC%9E%90%EC%9D%B8-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EA%B5%AC%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-beefa8214884)","excerpt":"이번 프로젝트에 rebass 라는  이라는 라이브러리를 사용해보고 정보와 사용 느낀점을 남깁니다. rebass 란 React에서 사용할 수 있는 UI 원시 컴포넌트들을 지원하는 라이브러리로써 기존의  라이브러리에 을 이용해서 만들어져 있습니다. 즉,…","fields":{"slug":"/hello-rebass.md/"},"frontmatter":{"date":"Mar 09, 2020","title":"Hello rebass","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 설치\n\ncreact react app 로 typescript로 만들어진 템플릿을 설치해줍니다.\n\n```bash  \n  npx create-react-app my-app --template typescript\n```\n\n## 함수 선언식 Component\n\n함수형 component를 만드는데는 대게 화살표 함수형으로 만들곤 했었습니다.\n\n이때 사용할 수 있는 타입은 다음과 같습니다.\n\n```typescript\ntype CustomComponentProps = {\n\n}\n\nconst CustomComponent: React.FC<CustomComponentProps> = () => {\n\n  return <div></div>\n}\n```\n\nReact.FC 타입을 사용하게 되면 장 단점이 있습니다.\n\n장점으로는 children이나 static 컴포넌트 프로퍼티들 ( defaultProps, propTypes, contextTypes, displayName ) 이 자동 완성이 지원된다는 점입니다.\n\n하지만 단점으로는 다음과 같습니다.\n\n1. defaultProps 설정이 유효하지 않다는 점입니다. defaultProps 설정을 해도 컴포넌트를 사용할 시에 해당 props를 전달하지 않으면 컴파일 에러가 뜹니다.\n2. children 이 \"?:(optional)\" 으로 들어가 있기 때문에 명시적으로 children이 들어가야 하는지 아니면 안들어가도 되는지를 알 수 가 없습니다.\n\n하여 함수형 컴포넌트를 만들 때는 다음과 같이 만듭니다.\n\n```typescript\ntype CustomComponentProps = {\n\n}\n\nfunction CustomComponent({}: CustomComponentProps) {\n  return <div></div>\n}\n\nexport default CustomComponent\n```\n\n## Component props type\n\ncomponent의 props의 타입을 지정해 두면 component를 사용할 시에 코드 어시스트의 혜택을 얻을 수 있습니다. \n\n또한 유지보수시 잘못된 props를 넣거나 다른 타입의 props를 할당하는 것을 방지 할 수 있습니다. \n\n이때 interface 또는 type alias 방법을 사용할 수 있습니다. \n\n### type alias 와 interface 차이점\n\n1. class에 implement 문을 작성할 시 type alias 도 가능하지만 \"union\" 문이 들어간 type alias는 허용하지 않습니다. \n2. interface에 extends 문을 작성할 시 type alias 도 가능하지만 \"union\" 문이 들어간 type alias는 허용하지 않습니다.\n3. type alias 는 declaration merging 이 되지 않습니다. \n\n대게 React와 props와 state를 type alias로 타입 설정 하길 권장합니다. 하여 여기서 기본적으로는 type alias 방법을 사용합니다. 이유는 다음과 같습니다 .\n\n1. 더 적은 타이핑\n2. 일관성 있는 문법 제공 ( interface와 type alias로 된 모든 것들을 intersection으로 묶을 수 있습니다. )\n3. React 컴포넌트를 사용자들이 재 선언을 해서 사용(몽키패칭)할 필요가 없습니다. 따라서 interface의 declaration merging 기능이 필요가 없습니다. ( 대게 컨벤션으로 interface는 라이브러리를 제작할때 공공 API를 위해 사용하거나 서드파티를 위해 엠비언트 타입을 정의할때 사용합니다. )\n\ntype alias 를 사용했을 시에 예시는 다음과 같습니다.\n\n1. defaultProps를 지정시에 해당 타입을 typeof로 합칠 수 있습니다.\n\n    - 다음과 같이 하면 CustomComponent 를 사용할 시 name props은 optional props로 나타나게 되어 더 명시적으로 디폴트 값이 있다는 것을 알려줄 수 있습니다.\n\n    ```typescript\n    type CustomComponentProps = {\n      age: number\n    } & typeof defaultProps\n\n    const defaultProps = {name: 'merlin'}\n    function CustomComponent({name}) {\n    }\n\n    CustomComponent.defaultProps = defaultProps\n    ```\n\n    - rebass 의 컴포넌트 Props는 interface로 되어 있지만 type의 intersection 으로 컴포넌트의 props를 extends 할 수 있습니다.\n\n    ```typescript\n    import React from \"react\";\n    import { Box, BoxProps } from \"rebass\";\n    import { iconCollection } from \"./Icon.styled\";\n    import { IconType } from \"types\";\n    \n    type IconProps = BoxProps & {\n      icon: IconType;\n      children?: never;\n    }\n    \n    function Icon({ icon, ...rest }: IconProps) {\n      return <Box sx={iconCollection[icon]} {...rest}></Box>;\n    }\n    \n    export default Icon;\n    ```\n\n## 자주 사용 한 typescript 문법\n\n- keyof\n\n```typescript\ninterface CustomObject {\n  name: 'merlin'\n  address: 'address'\n}\n\n// CustomObjecyKeyType = 'name' | 'address'\ntype CustomObjectKeyType = keyof CustomObject \n\n// CustomObjectValueType = 'merlin' | 'address'\ntype CustomObjectValueType = CustomObject[keyof CustomObject]\n```\n\n- Exclude\n\n```typescript\n\ntype CustomObjectValueType = 'merlin' | 'address' | 'age' | 'info'\n\n\n// FilterCustomObjectValueType = 'merlin' | 'address'\ntype FilterCustomObjectValueType = Exclude<CustomObjectValueType, 'info' | 'age'>\n```\n\n- Pick\n\n```typescript\ninterface CustomObject {\n  name: 'merlin'\n  address: 'address'\n  age: 'age'\n  info: 'info'\n}\n\n/* {\n  name: 'merlin'\n  address: 'address'\n} */\ntype PickCustomObjectType = Pick<CustomObject, \"name\" | \"address\">;\n```\n\n## typescript + react 장점\n\n1. component 에 props로 무엇이 있는지 그 props 값으로는 무엇이 들어가야 하는지 빼먹진 않았는지 알 수 있습니다. \n2. 복잡한 API 응답 타입도 미리 지정해 두면 코드 어시스트가 작동되어 API 응답 값에 무엇이 있었는지 쉽게 알 수 있습니다. \n3. hooks 을 destructure 시에 어떤 타입이 나오는지 쉽게 알 수 있습니다. \n\n## 참고\n\n[https://medium.com/@martin_hotell/10-typescript-pro-tips-patterns-with-or-without-react-5799488d6680#78b9](https://medium.com/@martin_hotell/10-typescript-pro-tips-patterns-with-or-without-react-5799488d6680#78b9)\n\n[https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c](https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c)","excerpt":"설치 creact react app 로 typescript로 만들어진 템플릿을 설치해줍니다. 함수 선언식 Component 함수형 component를 만드는데는 대게 화살표 함수형으로 만들곤 했었습니다. 이때 사용할 수 있는 타입은 다음과 같습니다.…","fields":{"slug":"/typescript-react.md/"},"frontmatter":{"date":"Mar 08, 2020","title":"typescript + react 사용기","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n## 동기\n\n- react와 rxjs를 함께 사용할 때 어떻게 사용 할 수 있을까?\n\n## React 컴포넌트를 update 할 수 있는 트리거들\n\n- function Component 의 hooks (useState, useEffect, useReducer 등등..)\n- class Component 의 setState 메서드\n- forceUpdate() 메서드\n\n## React hooks 역할\n\n- 상태값의 저장\n- component의 lifecycle에 대한 반응\n- 상태 변화에 따른 재 렌더링 유발\n\n## RxJS의 Subject\n\n- `Subject` 는 `EventEmitter` 와 같다.\n- 여러 관찰자에게 멀티 캐스팅 하는 유일한 방법.\n- `Subject` 는 `observable` 이고 `observer` 다.\n- `Subject` 는 `observable` 과 많은 `observer` 들 사이에서 bridge/proxy 형태로 행동할수 있다.\n- 이 행동은 다수의 `observer` 들에게 같은 `observable` 실행을 공유 할수가 있다.\n- 뒤 늦게 `subscribe` 를 하면 가장 최근 방출된 값을 가져올 수 있다.\n\n## store를 외부로 따로 관리할 경우\n\n### data의 흐름\n\n- 전역에서 필요한 `state`는 외부에서 관리한다.\n- 이 `state`가 변하는걸 알리기 위해 `Observable`로 만들어 준다. (`BehaviorSubject`)\n- 관찰이 필요한 react function Component에서는 `BehaviorSubject`(이때는 `Observable` 역할) 값을 구독하고 해당 값을 `useState`로 관리한다. ( 이를 도와줄 custom Hooks를 만든다. : `useObservable` )\n- `state`가 새롭게 바뀌었을 때 `setState` 로 `useState`의 `state` 변경함으로써 react function Component 에서 업데이트가 발생 되게 된다. \n- 전역 `state` 값을 바꾸기 위해서는 `BehaviorSubject`(이때는 `Observer` 역할) 값을 가지고 `next(value)` 메서드를 호출한다.\n\n### 예시 코드\n\n```javascript\n// hooks (useObservable)\nimport { useState, useEffect } from \"react\";\nimport * as Rx from \"rxjs\";\n\nfunction useObservable<T>(observable: Rx.Observable<T>) {\n  const [state, setState] = useState();\n\n  useEffect(() => {\n    const sub = observable.subscribe(setState);\n    return () => sub.unsubscribe();\n  }, [observable]);\n\n  return state;\n}\n\n// 종료 시점, pipe,\n\nexport default useObservable;\n```\n\n```javascript\n// store\nimport { ITodoItem, ITodoStore } from \"../types\";\nimport { BehaviorSubject } from \"rxjs\";\n\nclass TodoItem implements ITodoItem {\n  todo: string;\n  isActive: boolean;\n\n  constructor(todo: string, isActive: boolean) {\n    this.todo = todo;\n    this.isActive = isActive;\n  }\n}\n\nclass TodoStore implements ITodoStore {\n  todoList$: BehaviorSubject<ITodoItem[]>;\n\n  constructor(todoList: ITodoItem[]) {\n    this.todoList$ = new BehaviorSubject(todoList);\n  }\n\n  // action\n  addTodo = ({ todo, isActive }: ITodoItem) => {\n    const newTodo = new TodoItem(todo, isActive);\n    const newTodoList = [...this.todoList$.value, newTodo];\n\n    this.todoList$.next(newTodoList);\n  };\n}\n\nconst TODO_LIST: ITodoItem[] = [\n  { todo: \"typescript 학습하기\", isActive: false }\n];\n\nconst todoStore: ITodoStore = new TodoStore(TODO_LIST);\n\nexport default todoStore;\n\n```\n\n```javascript\n// react function component\n// Todo\nimport React from \"react\";\nimport TodoList from \"./TodoList\";\nimport useObservable from \"../hooks/useObservable\";\nimport todoStore from \"../store/TodoStore\";\nimport { ITodoItem } from \"../types\";\n\nfunction Todo() {\n  const todoList = useObservable<ITodoItem[]>(todoStore.todoList$);\n\n  return <TodoList todoList={todoList}></TodoList>;\n}\n\nexport default Todo;\n\n```\n\n```javascript\n// TodoList\nimport React from \"react\";\nimport TodoItem from \"./TodoItem\";\nimport { ITodoItem } from \"../types\";\n\ntype TodoListProps = {\n  todoList: ITodoItem[];\n};\n\nfunction TodoList({ todoList }: TodoListProps) {\n  return (\n    <ul>\n      {todoList.map((todoItem: ITodoItem) => (\n        <TodoItem key={todoItem.todo} todoItem={todoItem}></TodoItem>\n      ))}\n    </ul>\n  );\n}\n\nTodoList.defaultProps = {\n  todoList: []\n};\n\nexport default TodoList;\n```\n\n```javascript\n// TodoItem\nimport React from \"react\";\nimport { ITodoItem } from \"../types\";\n\ntype TodoItemProps = {\n  todoItem: ITodoItem;\n};\n\nfunction TodoItem({ todoItem }: TodoItemProps) {\n  return <li>{todoItem.todo}</li>;\n}\n\nexport default TodoItem;\n\n```\n\n## store를 외부로 따로 두지 않고 hooks로 관리 할 경우\n\n### React hooks 규칙\n\n상태를 저장하는 custom hooks 을 만들 경우 내부에는 rxjs 코드가 없도록 유지합니다. 이유는 이런 hooks들은 rxjs의 디펜던시를 두지 않고 재 사용성을 특징으로 만들기 위함입니다.\n\n대신 rxjs를 다뤄야 하는 custom hooks는 따로 만듭니다.\n\n### rxjs 역할\n\n- hooks에 저장된 상태에 따른 비동기 처리와 같은 side effect(부수효과) 처리 로직\nex) API 호출, location 허용\n\n### side effect를 rxjs로 다룰때의 장점\n\n- 언제 발생될지 모르는 데이터 또는 연속된 데이터 스트림을 다루기에 용이\nex) 연속된 같은 API 호출에서 가장 최신 호출의 데이터를 가져와서 view에 반영\n\n- 여러 side effect를 모아서 일괄 처리에 용이\nex) 여러 API 호출의 응답이 다 모였을 때 view 반영 및 에러처리\n\n### 예시 코드\n\n```typescript\n// useTab.ts\n\nimport { useState, useCallback, useMemo } from \"react\";\nimport { ITabItem } from \"types\";\nimport { setActiveByID } from \"utils\";\n\nfunction useTab<T>(tabDataList: ITabItem<T>[]) {\n  const [tabList, setTabList] = useState<ITabItem<T>[]>(tabDataList);\n  // Computed 한 값\n  // 현재 탭 객체\n  const currentTabData = useMemo(() => {\n    const activeIndex = tabList.findIndex(tabData => tabData.isActive);\n    return tabList[activeIndex];\n  }, [tabList]);\n\n  // 탭 눌렀을때\n  const onHandleTabClick = useCallback(\n    (tabId: T): void => {\n      if (currentTabData.id !== tabId) {\n        setTabList(setActiveByID<ITabItem<T>, T>(tabId));\n      }\n    },\n    [currentTabData]\n  );\n\n  return {\n    currentTabData,\n    tabList,\n    onHandleTabClick\n  };\n}\n\nexport default useTab;\n```\n\n```typescript\n// useApiObservable.ts\n\nimport { useState, useEffect, useRef } from \"react\";\nimport { Observable, Subject } from \"rxjs\";\n\nimport { switchMap, tap, filter } from \"rxjs/operators\";\nimport { IAPIResponse } from \"types\";\n\nfunction useApiObservable<T>(\n  api$: (value: T) => Observable<IAPIResponse>\n): [IAPIResponse, Subject<T>] {\n  const [state, setState] = useState<IAPIResponse>({\n    success: null,\n    error: null,\n    isLoading: false\n  });\n\n  const { current: subject$ } = useRef(new Subject<T>());\n\n  useEffect(() => {\n    const sub = subject$\n      .pipe(\n        filter(triggerData => triggerData !== null),\n        tap(_ =>\n          setState(beforeState => ({\n            success: beforeState.success,\n            error: beforeState.error,\n            isLoading: true\n          }))\n        ),\n        switchMap(value => api$(value))\n      )\n      .subscribe(setState);\n\n    return () => sub.unsubscribe();\n  }, [subject$, api$]);\n\n  // return { ...state, subject$ };\n  return [state, subject$];\n}\n\nexport default useApiObservable;\n```\n\n```typescript\n// 사용\n const { tabList, onHandleTabClick, currentTabData } = useTab(\n    TAB_OCCUPANCY_LIST\n  );\n  const [occupancyState, subject$] = useApiObservable<\n    IOccupancyApiFetchParameter\n  >(occupancyApi.fetch);\n\n  // currentTabData가 변경 되었을 때 api 스트림에 값 방출\n  useEffect(() => {\n    subject$.next({\n      type: currentTabData.id\n    });\n  }, [subject$, currentTabData]);\n```\n\n## 추가적으로 고려해야 할 점\n\n- 다양한 종류의 rxjs 의 operation 조합을 pipe로 따로 관리하자.\n- 어느 때고 필요하다면 구독을 취소 시킬 수 있어야 한다.\n\n## 참고\n\n- [https://www.bitovi.com/blog/rxjs-with-react-pt-1](https://www.bitovi.com/blog/rxjs-with-react-pt-1)\n\n## 전체 코드 (store 외부에 두었을 때만)\n\n- [https://github.com/chchoing88/ts-react](https://github.com/chchoing88/ts-react)","excerpt":"동기 react와 rxjs를 함께 사용할 때 어떻게 사용 할 수 있을까? React 컴포넌트를 update 할 수 있는 트리거들 function Component 의 hooks (useState, useEffect, useReducer 등등..) c…","fields":{"slug":"/react-rxjs.md/"},"frontmatter":{"date":"Jan 14, 2020","title":"React with RxJS","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# preact, rollup, babel 구성기\n\nreact의 경량화 버젼인 preact를 rollup과 babel로 환경 셋팅한 경험기 입니다.\n`preact-cli` 가 존재하지만 각 설정들이 숨겨져 있고 `eject` 시키기가 어려워서 새롭게 구성했습니다.\n\n## preact\n\n- 3kb 용량의 경량화 된 react 입니다.\n- 약간의 설정으로 react 문법과 동일하게 사용할 수 있습니다.\n- `preact`는 별도의 빌드 툴이 없어도 브라우저에서 사용할 수 있도록 제작이 되어있습니다. \n- Hooks 도 지원을 하고 있습니다.\n- 기존 react의 이벤트 시스템을 가지고 있지 않아서 가볍습니다.\n- `className` 대신 `class`를 사용하기 때문에 기존 마크업 된 결과물을 쉽게 가져다 넣을 수 있습니다. \n- `Component.render()` 메서드에 인자로 `this.props` 와 `this.state` 값을 순차적으로 받아 올 수 있습니다.\n- `preact`의 `h()` 함수는 `react`에 `createElement`와 매칭이 됩니다.\n- `preact`에선 `onChange` 대신에 `onInput`을 사용합니다.\n\n## preact & babel \n\n- `preact` 에서 JSX를 사용하기 위해선 별도의 babel 셋팅이 필요합니다.\n\n```javascript\n{\n  \"plugins\": [\n    [\"@babel/plugin-transform-react-jsx\", {\n      \"pragma\": \"h\",\n      \"pragmaFrag\": \"Fragment\",\n    }]\n  ]\n}\n```\n\n- 폭 넓은 브라우저 대응을 위한 babel 을 셋팅합니다.\n- polyfill을 대신할 `core-js` 와 `regenerator-runtime` 을 설치 해줍니다. \n- `\"useBuiltIns\": \"usage\"` 설정은 각 파일에서 사용될 폴리 필에 대한 것만 가져옵니다.\n\n```javascript\n\"presets\": [[\n    \"@babel/preset-env\",\n    {\n      \"targets\": {},\n      \"useBuiltIns\": \"usage\",\n      \"corejs\": 3\n    }\n  ]]\n```\n\n## preact & rollup\n\n- axios를 번들에 넣고 싶을 때 `resolve({ browser: true,})` 를 넣어주어야 합니다. 왜냐하면 axios 모듈은 유니버셜 코드 (서버 와 브라우저 환경에서 모두 작동) 이기 때문에 브라우저에서만 작동되는 스크립트를 번들 하기 위해선 브라우저 에서 작동할 번들이라고 알려주어야 합니다. (모듈의 package.json 의 browser 키 값을 보고 필요한 것만 번들해 옵니다.)\n- plugin 순서는 `babel`, `resolve`, `commonjs` 를 지켜주도록 합니다.\n\n```javascript\n// rollup.config.js\nimport resolve from 'rollup-plugin-node-resolve'\nimport commonjs from 'rollup-plugin-commonjs'\nimport babel from 'rollup-plugin-babel'\nimport postcss from 'rollup-plugin-postcss'\nimport staticSite from 'rollup-plugin-static-site'\nimport { uglify } from 'rollup-plugin-uglify'\n\nexport const context = process.env.npm_config_context\n\nif (!context) {\n  throw new Error(`please insert npm command line '--context={pageName}'`)\n}\n\nexport default {\n  input: `src/page/${context}.js`,\n  output: {\n    file: `dist/${context}/bundle_${context}.js`,\n    format: 'iife',\n  },\n  plugins: [\n    babel({\n      exclude: 'node_modules/**', // only transpile our source code\n    }),\n    resolve({\n      browser: true,\n    }),\n    commonjs(),\n    postcss(),\n    uglify(),\n    staticSite({\n      dir: `dist/${context}`,\n      filename: 'index.html',\n      template: { path: `src/public/index.html` },\n    }),\n  ],\n}\n```\n\n## github\n\n[github](https://github.com/chchoing88/preact-practice)\n\n> 예외사항으로 페이지 마다 번들된 JS를 만들기 위해서 `rollup` 셋팅을 조금 바꿔두었습니다. 필요시 적절하게 수정해야 합니다.","excerpt":"preact, rollup, babel 구성기 react의 경량화 버젼인 preact를 rollup과 babel로 환경 셋팅한 경험기 입니다.\n 가 존재하지만 각 설정들이 숨겨져 있고  시키기가 어려워서 새롭게 구성했습니다. preact 3kb 용량…","fields":{"slug":"/preact-configuration.md/"},"frontmatter":{"date":"Dec 19, 2019","title":"preact 구성기","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nReact 16 버젼으로 올라오면서 Context 와 Hooks를 이용해서 store를 대체 할 수 있다는데 Atomic 구조와 어떻게 쓰면 성능을 신경쓰면서 사용 할 수 있을지에 대한 고민 글입니다.\nReact Context 와 Hooks를 사용하면 zero configuration 의 장점이 있습니다.\n\n컴포넌트는 함수형 컴포넌트로 만듭니다.\n\nAtomic 구조 : `atoms > molecules > organisms > template + pages`\n\n## Hooks 와 Context의 역할\n\nHooks의 가장 큰 장점 중 하나는 **상태와 관련된 로직을 재사용** 할 수 있다는 것입니다. 따라서 **컴포넌트와 무관하게 관련된 상태와 로직**을 Hooks로 구현을 하도록 합니다. 특히 `custom Hooks` 를 만들어 재 활용 할 수 있다는 장점이 있습니다. \n\nHooks의 단점을 꼽자면 Hooks을 가지고 있는 컴포넌트 하위로는 props로 데이터나 메서드를 내려 보낼 순 있지만 자식 컴포넌트가 부모 컴포넌트에게 영향을 미치기란 어렵다. 즉, 공유하기가 어려움.\n\nContext는 **일정한 범위에 속한 컴포넌트 트리 간 데이터 공유** 를 쉽게 할 수 있도록 고안 된 API입니다. 필요한 컴포넌트에 일일이 props로 전달하지 않아도 Context 가 가지고 있는 값을 공유 받을 수 있다는게 가장 큰 장점입니다.\n\n\n## Atomic 과 Hooks, Context가 만났을때 사용 정의\n\n- 하나의 기능에 대한 상태와 메서드들은 하나의 `custom Hooks`로 묶어 둡니다. \n- Atomic 관점에서 기능의 응집도가 높은 단위는 `organisms` 또는 `molecules` 단위가 될 수 있습니다. \n- `organisms` 과 하나의 `custom Hooks` 의 관계는 1 대 N 이 될 수 있습니다.\n- `molecules` 와 하나의 `custom Hooks` 의 관계는 1 대 1 관계를 유지 합니다. \n- `Context.Provider` 로 `Context` 범위 설정은 여러 기능에서 상태를 공유해야 하는 상황인 `organisms` 또는 `pages` 단위에 매칭이 되어야 합니다.\n- `pages` 단위 에서 `Context.Provider`로 공유가 필요한 값을 주입 합니다. 이때, 자주 변경이 이러나는 `Provider` 를 제일 안쪽에 위치시키도록 합니다.\n- `organisms` 단위에서는 `useContext`로 해당 `Context` 값을 참조해 오도록 합니다. \n\n> `Context.Provider` 의 value 가 바뀌면 `useContext` 로 구독하고 있는 컴포넌트는 한번씩 호출을 하게 된다. (Reconciliation - component가 호출되서 리턴된 Element가 이전 Element와 같은지 비교) ( 호출 자체가 비용이 많지는 않지만 Virtual Dom인 React Element를 새롭게 만들어내는 불필요한 작업을 하게 될 수도 있습니다. 사실 중요한건 React Element가 이전과 바뀌지 않게 유지하는 것입니다. )\n\n> 잘못 알고 있었던 사실 : `Context.Provider`의 `value` 값이 바뀌면 그 밑에 `children` 컴포넌트들이 전부 호출이 되는 줄 알았으나 사실은 해당 `Context` 를 구독하고 있는 컴포넌트를 상위로 하위 자식 컴포넌트들만 호출이 된다.\n\n\n\n## 언제 Hooks 와 Context를 쓸까?\n\n- 기본적으로 상태가 필요한 기능은 `Hooks` 를 사용합니다.\n- **재사용**이 필요한 기능에 대해서는 `custom Hooks`를 만들어 다양한 컴포넌트에서 사용합니다.\n- 상태가 **전역** 관리되어져야 할때와 서로 다른 컴포넌트 끼리의 **공유** 가 필요할 시에는 `Context`를 사용합니다.\n\n## Hooks 사용\n\n- Hooks는 함수형 컴포넌트에서 `상태에 따른 관련 메서드들의 응집도를 높이고 재사용성`을 위해 사용됩니다. ( 비교 대상은 class component에서 흔히 life cycle에 따라 관련 로직들이 흩어져 있는 모습을 볼수가 있습니다. )\n- 서로 연관된 상태와 기능을 가진 `custom Hooks` 를 제작해 특정 component(View)에 의존하지 않는 별도의 Hooks로 만들면 **재사용성**에 도움이 됩니다.\n- `computed` 한 값은 `useMemo`로 상태값을 저장해 두고, `action` 을 공유해야 하는 함수의 경우에는 `useCallback` 을 사용해서 매번 함수가 새로 만들어 지는걸 방지 합니다.\n- `setState` 의 리턴된 배열이 [`상태`, `set함수`]라 했을 때 두번째 `set함수`를 사용할 때는 **함수형 업데이트** (`setXXX(preState => newState)`)를 이용하면 `상태` 값에 의존적이지 않아도 됩니다. \n\n\n### 예시) 탭 UI\n\n```javascript\n// hooks/ui.js\nimport React, { useState, useMemo, useCallback } from 'react'\n\nconst useTab = (tabDataList) => {\n  const [tabList, setTabList] = useState(tabDataList) // [{id: 'merlin', name: 'merlin', content: <Merlin/>, actived: true}]\n \n  // action 하는 함수들\n  // tab을 추가 하려 할때\n  const addTabList = useCallback((tabData) => {\n    // 함수형 업데이트 \n    setTabList(tabList => [\n      ...tabList,\n      tabData\n    ])\n  }, [])\n\n\n  // 탭 눌렀을때 \n  const onHandleTabClick = useCallback((tabId) => {\n    // tabName 이 맞는게 있으면 그걸 true 바꾸고 나머지 false\n    // 맞는게 없으면 그대로 두자.\n    // 함수형 업데이트\n    setTabList(tabList => {\n      if(tabList.some(tabData => tabData.id === tabId)) {\n        return tabList.map((tabData, index) => {\n          tabData.actived = (tabData.id === tabId)\n          return tabData\n        })\n      }\n      return tabList\n    })\n  }, [])\n\n  // Computed 한 값\n  // 현재 탭 index \n  const currentTabIndex = useMemo(() => {\n    return tabList.findIndex(tabData => tabData.actived)\n  }, [tabList])\n  // 전체 탭 갯수 \n  const tabLength = useMemo(() => {\n    return tabList && tabList.length || 0\n  }, [tabList])\n\n\n  return {\n    currentTabIndex,\n    tabLength,\n    tabList,\n    onHandleTabClick,\n    initTabList,\n    addTabList\n  }\n}\n\nexport { useTab }\n```\n\n```javascript\n// TabWrapper.js\nimport React from 'react'\nimport { useTab } from 'hooks/ui'\n\nconst TabWrapper = () => {\n  const {\n    currentTabIndex,\n    tabLength,\n    tabList,\n    onHandleTabClick,\n    initTabList\n    } = useTab([\n    {id: 'merlin', name: 'merlin', content: <Merlin />, actived: true},\n    {id: 'ho', name:'ho', content: <Ho />, actived: false}\n  ])\n\n  return (\n    <>\n      <TabList activedIndex={currentTabIndex} onClickTab={onHandleTabClick}>\n      <TabContents activedTabContent={tabList.content}>\n    </>\n  )\n}\n```\n\n\n## Context 사용\n\n- `Context.Provider` 는 합성 패턴을 이용해서 만들어 줍니다.\n- `Context` 는 단독 기능으론 관계가 없지만 서로 엮어서 기능을 해야할때 서로 가지고 있는 상태나 메서드를 **공유** 해야 할 필요성이 있을 때 사용합니다.\n- `Context` 안에서도 자주 쓰는 기능이 있을 경우에는 `custom Hooks` 로 빼두어서 해당 `custom Hooks`를 `state` 관리용으로 사용합니다.\n- `Context.Provider` 의 `value props`에 넘기는 값은 별도의 `Provider 컴포넌트`를 만들어 그 컴포넌트 안에 `state`를 유지하게 만들어 줍니다. \n- `Provider 컴포넌트` 안의 `state` 값은 `useState` 를 이용해서 관리합니다. \n  - 일반 객체롤 상태관리를 할 경우 Provider 컴포넌트가 호출될 때마다 이전 객체를 유지하지 못합니다. 매 새로운 객체가 만들어지게 됩니다.\n  - 일반 객체를 상태관리를 했을 경우 상태가 변경되었을때 React의 재 렌더링을 진행하라는 신호를 주지 못하게 됩니다. \n- `Provider 컴포넌트` 의 `state`의 변경을 위한 메서드 공유가 필요한 경우 에는 별도의 객체를 만들어 `useMemo`로 매 호출마다 객체가 바뀌지 않게 막아줍니다. (적절한 디펜던시를 걸어주어서 디펜던시가 바뀌었을 때만 변경이 되도록 합니다.)\n- **상태와 액션을 가지고 있는 Context 가 있다고 하고 액션만 필요한 컴포넌트만 있다고 했을때, 상태 변경시 불필요하게 액션만 필요한 컴포넌트도 렌더링이 될 수 있으니 이때는 상태 Context와 액션 Context로 분리해서 사용하자.**\n\n### 기본 포멧 예시\n\n- TodoList 에서 'done', 'doing', 'todo' 의 리스트 갯수를 Header 에서 보여주어야 한다면 TodoList 정보를 `Context`로 관리 `Pages` 단위의 범주로 설정해야 합니다.\n\n```javascript\n// Context 기본 포멧\n// TodoContext.js\nimport React, { useState, createContext } from 'react'\n\nconst TodoContext = createContext()\n\nconst TodoProvider = ({}) => {\n  // 상태\n  const [todoList, setTodoList] = useState([])\n  // 액션\n  const addTodo = () => {}\n  const removeTodo = () => {}\n\n  // Bad!!\n  // const store = {\n  //   name: 'merlin',\n  //   setName: () => {}\n  // }\n  \n  // (...)\n\n  const todoStore = useMemo(() => ({\n    todoList,\n    addTodo,\n    removeTodo,\n  }), [todoList])\n\n  return <TodoContext.Provider value={todoStore}>{children}</TodoContext.Provider>\n}\n\n\nexport { TodoProvider }\nexport default TodoContext\n```\n\n- TodoProvider 컴포넌트 안에서 사용하는 Hooks들의 로직이 **재사용이 필요하거나 로직이 복잡해질때는 custom Hooks로 빼둡니다.**\n\n```javascript\n// useTodo.js\nimport React, { useState, useMemo } from 'react'\n\nconst useTodo = () => {\n  const [todoList, setTodoList] = useState([])\n  const addTodo = () => {}\n  const removeTodo = () => {}\n\n  // (...)\n\n  const todoStore = useMemo(() => ({\n    todoList,\n    addTodo,\n    removeTodo,\n  }), [todoList])\n\n  return TodoStore\n}\n```\n\n```javascript\n// TodoContext.js\nimport React, { useState, createContext } from 'react'\nimport useTodo from 'useTodo'\n\nconst TodoContext = createContext()\n\nconst TodoProvider = ({}) => {\n  const todoStore = useTodo()\n\n  return <TodoContext.Provider value={todoStore}>{children}</TodoContext.Provider>\n}\n\n\nexport { TodoProvider }\n\nexport default TodoContext\n```\n\n### organisms 컴포넌트 범위에서 provider를 하면서 organisms 내에서 useContext를 사용하지 않고 재사용할 수 있도록 props로 받는 컴포넌트를 만들고 싶다면? (필요시)\n\n```javascript\n// util.js\n// Context value 값을 어떻게 매핑할지 정의하는 함수와 적용할 컴포넌트를 인자로 받아 새로운 컴포넌트를 만들어 주는 HOC\n\nexport const createWithProvider = (\n  Context,\n  Provider\n) => mapContextToProps => WrappedComponent => {\n\n  const UseContextComponent = props => {\n    const contextValue = mapContextToProps(useContext(Context))\n    return <WrappedComponent {...contextValue} {...props}></WrappedComponent>\n  }\n\n  const withProvier = props => {\n    return (\n      <Provider>\n        <UseContextComponent {...props}></UseContextComponent>\n      </Provider>\n    )\n  }\n\n  const displayName =\n    WrappedComponent.displayName || WrappedComponent.name || 'component'\n  withProvier.displayName = displayName\n\n  return withProvier\n}\n```\n\n```javascript\n// TodoContext.js\n\nimport React, { useState, createContext } from 'react'\nimport useTodo from 'useTodo'\n\nconst TodoContext = createContext()\n\nconst TodoProvider = ({}) => {\n  const todoStore = useTodo()\n\n  return <TodoContext.Provider value={todoStore}>{children}</TodoContext.Provider>\n}\n// Context value 값을 어떻게 매핑할지 정의하는 함수와 적용할 컴포넌트를 인자로 받아 새로운 컴포넌트를 만들어 주는 HOC\nconst withTodoProvider = createWithProvider(TodoContext, TodoProvider)\n\nexport { TodoProvider, withTodoProvider }\n\nexport default TodoContext\n```\n\n```javascript\n// TodoContainer.js\n\nimport Todo from '../organisms/todo/Todo'\nimport { withTodoProvider } from '../../context/TodoContext'\n\n// Todo organism의 props에 Context value 값을 매핑\nexport default withTodoProvider(({ todoList, actions }) => ({\n  todoList,\n  actions,\n}))(Todo)\n\n```\n\n## React.memo 를 사용한 컴포넌트 리렌더링 방지\n\n- `React.memo`는 higher order component로 props의 얕은 비교를 통해 리 렌더링 성능을 올립니다.\n- 함수형 컴포넌트의 `props` 변경이 없다면 컴포넌트의 호출을 막아 불필요한 리 렌더링(실제 DOM에 그려지는 것이 아닌 컴포넌트 호출로 새로운 React Element 생성) 되는 것을 방지하여 렌더링 성능을 최적화 시킬 수 있습니다.\n- `Atomic` 컴포넌트 단위에선 `molecules` 컴포넌트 단위에서 `React.memo`를 사용할 수 있도록 합니다. 또는 성능을 실제로 개선할 수 있는 상황에서 사용합니다.\n\n```javascript\nimport React, {memo} from 'react'\n\nconst TodoItem = ({todoList, onClick}) => {\n  return (\n    <div>TodoItem</div>\n  )\n}\n\nexport default memo(TodoItem)\n```\n\n- 일반적인 얕은 비교가 아닌 `React.memo`에서 두번째 파라미터에 `propsAreEqual` 이라는 함수를 사용하여 특정 값들만 비교를 하는 것도 가능합니다. 리턴 값이 `true`(이전 props랑 다음에 들어오는 props가 같은 경우)면 리렌더링을 방지하고 `false` 면 리 렌더링을 실행합니다.\n\n```javascript\nimport React, {memo} from 'react'\n\nconst TodoItem = ({todoList, onClick}) => {\n  return (\n    <div>TodoItem</div>\n  )\n}\n\nexport default memo(TodoItem, (prevProps, nextProps) => prevProps.todoList === )\n```\n\n## 참고\n\n- [React Hooks와 Context를 이용한 설계 패턴](https://www.huskyhoochu.com/react-pattern-hooks-and-contexts/)\n- [TypeScript 환경에서 리액트 Context API 제대로 활용하기](https://velog.io/@velopert/typescript-context-api#context-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0)","excerpt":"React 16 버젼으로 올라오면서 Context 와 Hooks를 이용해서 store를 대체 할 수 있다는데 Atomic 구조와 어떻게 쓰면 성능을 신경쓰면서 사용 할 수 있을지에 대한 고민 글입니다.\nReact Context 와 Hooks를 사용하…","fields":{"slug":"/context-hooks.md/"},"frontmatter":{"date":"Dec 11, 2019","title":"React Context 와 Hooks 설계","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Rollup Setting & babel Setting\n\n간단한 스크립트 개발 셋팅을 위한 rollup 과 babel 셋팅 및 crawling을 위한 proxy 서버 셋팅을 정리해둡니다.\n\n## Rollup production setting\n\nrollup 셋팅시 다음과 같은 plugin을 설치하라는 공식 문서가 보입니다.\n\n- `rollup-plugin-node-resolve` : `node_modules`에 설치된 제 3자 모듈의 위치를 [Node resolution algorithm](https://nodejs.org/api/modules.html#modules_all_together) 를 사용해서 모듈의 위치를 찾아줍니다. 이 resolve 가 없을시 `import hljs from \"highlight.js/lib/highlight\";` 이런 node_modules에 설치된 모듈을 찾지 못합니다. \n- `rollup-plugin-commonjs` : 다음 플러그인을 사용하면 node_modules에 설치된 모듈중에서 `require` 문을 사용하는 CommonJS 모듈을 ES6로 변환해서 번들코드에 포함시켜 줍니다. JS의 다양한 모듈 타입을 ES6로 맞춰서 번들한다고 생각하면 됩니다.\n- `rollup-plugin-babel` : 코드 번들링할때 babel을 이용하기 위해서 사용됩니다.\n\n\n\n## Rollup production Code\n\n```javascript\n// rollup.config.js\nimport resolve from \"rollup-plugin-node-resolve\";\nimport commonjs from \"rollup-plugin-commonjs\";\nimport babel from \"rollup-plugin-babel\";\nimport postcss from 'rollup-plugin-postcss'\nimport staticSite from 'rollup-plugin-static-site'\nimport { uglify } from 'rollup-plugin-uglify'\n\n\nexport default {\n  input: \"src/js/main.js\",\n  output: {\n    file: \"dist/bundle.js\",\n    format: \"iife\"\n  },\n  plugins: [\n     babel({\n      exclude: \"node_modules/**\" // only transpile our source code\n    })\n    resolve({\n      browser: true, // axios 같이 서버 코드랑 브라우저 코드가 다 들어있는 모듈일때 package.json 보고 브라우저 관련 코드만 가져온다.\n    }),\n    commonjs(),\n    postcss(), // css 도 번들 포함\n    uglify(), \n    staticSite({\n      dir: `dist/${context}`,\n      filename: 'index.html',\n      template: { path: `src/public/index.html` },\n    }),\n    \n  ]\n};\n\n```\n\n## Rollup dev setting\n\ndev에서는 개발서버를 돌려주는 `rollup-plugin-serve` 와 `rollup-plugin-livereload` 를 사용합니다.\n\ndev 모드에서는 `--watch` 를 꼭 붙여주어서 코드가 변화할때마다 다시 번들하게 만들어 주어야 합니다.\n\n```bash\n\"scripts\": {\n    \"start\": \"rollup -c ./rollup.config.dev.js --watch\"\n  },\n```\n\n* 주의 : 최신 rollup 버젼에서는 `rollup-plugin-server` 모듈은 사용하지 말자.\n\n## Rollup dev Code\n\n```javascript\nimport common from \"./rollup.config\";\nimport serve from \"rollup-plugin-serve\";\nimport livereload from \"rollup-plugin-livereload\";\nimport * as path from \"path\";\n\nexport default {\n  input: \"src/js/main.js\",\n  output: {\n    file: \"dist/bundle.dev.js\",\n    format: \"iife\"\n  },\n  plugins: [\n    ...common.plugins,\n    serve({\n      open: true,\n      contentBase: path.join(process.cwd(), \"/dist\"),\n      host: \"localhost\",\n      port: 9000\n    }),\n    livereload(\"dist\")\n  ]\n};\n```\n\n## babel setting\n\n바벨에서 `preset` 이라고 하는 것은 여러 플러그인을 모아둔것이라 불리웁니다.\n공식 프리셋은 다음과 같습니다.\n\n- @babel/preset-env\n- @babel/preset-flow\n- @babel/preset-react\n- @babel/preset-typescript\n\n기본적인 프로젝트 셋팅시엔 타겟 환경에 따라 구문을 변환해줄 수 있는 가장 대표적인 `preset-env`를 사용합니다.\n\n아래는 기본 설치 방법 입니다.\n\n```bash\nnpm install --save-dev @babel/preset-env\n\n```\n\n`@babel/preset-env`는 지정한 대상 환경을 가져 와서 매핑 목록과 비교하여 플러그인 목록을 컴파일하고 그것을 Babel에 전달합니다.\n\n### loose mode\n\n많은 바벨 플러그인은 2가지 모드를 지원합니다. \n\n하나는 일반 모드(normal mode) 이고 또다른 하나는 (루즈 모드)loose mode 입니다.\n\n- normal mode : 최대한 ECMAScript 6 의 의미에 가깝게 따릅니다.\n- loose mode : 간단하게 ES5로 코드를 생성합니다.\n\n예를 들면 \n\n```javascript\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    toString() {\n        return `(${this.x}, ${this.y})`;\n    }\n}\n```\n\n위와 같은 코드에서 normal mode로 변환하면 `toString` 이라는 메서드를 non-enumerable(비 열거) 하게 만들지만 ( 비 열거가 되면 객체에서 속성을 열거하려 할때 나오지 않습니다. )\n\nloose mode 모드에선 손으로 작성한 것과 같은 스타일 처럼 일반 메서드로 할당 시켜 버립니다.\n\n- [참고](https://2ality.com/2015/12/babel6-loose-mode.html)\n\n\n\n### useBuiltIns\n\n여러가지 옵션중에 `useBuiltIns` 이란 옵션은 polyfills을 다루기 위한 옵션 입니다.\n\n사전에 다음과 같이 설치를 해주어야 합니다.\n\n```bash\nnpm install core-js@3 --save\n\n# or\n\nnpm install core-js@2 --save\n\n# and\n\nnpm istall regenerator-runtime --save\n```\n\n\n#### useBuiltIns: 'entry'\n\n코드 시작시 `import \"core-js\";` 라고 선언하게 되면 환경에 따라 필요한 polyfills들을 전부 불러오게 치환 해줍니다.\n또한 `core-js@3`을 사용하게 될시 `@babel/preset-env` 는 `core-js`를 최적화 시킬 수 있습니다. \n예를 들면 당신이 배열과 새로운 Math 의 메서드 polyfill이 필요하다면 다음과 같이 작성할 수 있습니다.\n\n```javascript\nimport \"core-js/es/array\";\nimport \"core-js/proposals/math-extensions\";\n```\n\n#### useBuiltIns: 'usage'\n\n각 파일에서 사용되는 대상 환경에서 지원되지 않는 기능에 대해 polyfill을 넣어줍니다. 번들러는 동일한 폴리필에 대해선 한번만 가져오는 이점이 있습니다. \n\n```javascript\n// first file:\nvar set = new Set([1, 2, 3]);\n\n// second file:\nvar array = Array.of(1, 2, 3);\n```\n\n위 코드는 IE >= 11 환경에서 아래와 같이 변경됩니다.\n\n```javascript\nrequire(\"core-js/modules/web.dom.iterable\");\nrequire(\"core-js/modules/es6.array.iterator\");\nrequire(\"core-js/modules/es6.object.to-string\");\nrequire(\"core-js/modules/es6.string.iterator\");\nrequire(\"core-js/modules/es6.set\");\n// first file:\nvar set = new Set([1, 2, 3]);\n\nrequire(\"core-js/modules/es6.array.of\");\n// second file:\nvar array = Array.of(1, 2, 3);\n```\n\n### corejs\n\n이 옵션은 `useBuiltIns: usage` or `useBuiltIns: entry` 이 옵션이 켜져있을때 효력이 발동되며 `@babel/preset-env`가 core-js 버전이 주입하도록 합니다.\n\n디폴트로는 polyfill은 안정적인(stable) ECMAScript 기능들만 주입하지만, 모든 polyfill을 원한다면 3가지 옵션이 있습니다.\n\n- `useBuiltIns: entry` 의 경우에는 제안에 있는 polyfill을 직접 import 시키는 법입니다. : `import \"core-js/proposals/string-replace-all\"`\n\n- `useBuiltIns: usage` 의 경우에는 2가지 경우가 있습니다.\n  - [`shippedProposals`](https://babeljs.io/docs/en/babel-preset-env#shippedproposals) 옵션을 `true`로 셋팅합니다. 이렇게하면 이미 브라우저에 이미 제공된 제안서에 대한 polyfill 및 변환이 가능합니다.\n  - `corejs: { version: 3, proposals: true }` 이렇게 하면 core-js에 있는 모든 제안된 기능들을 polyfilling 합니다.\n\n## babel config code\n\n```javascript\n{\n  \"presets\": [[\n    \"@babel/preset-env\",\n    {\n      \"targets\": {\n        \"ie\" : \"10\"\n      },\n      \"useBuiltIns\": \"entry\",\n      \"corejs\": 3\n    }\n  ]]\n}\n```\n\n## proxy 서버 셋팅\n\n기존의 마크업된 페이지에서 내가 개발한 코드가 제대로 동작하는지 확인하기 위해서 마크업 페이지를 crawling 해 `css, js, image 경로 변경 후 bundle된 javascript 삽입`된 HTML 응답하는 서버 필요가 생겼었다. \n\n### rollup setting 변경\n\n기존에 `rollup-plugin-serve`를 쓰던 개발 서버에서 `proxy` 설정을 하기 위해  `rollup-plugin-serve-proxy` 모듈로 교체한다. \n\n여기서 `proxy` 셋팅은 **적절하게 셋팅해둔 url로 요청이 들어왔을 시 대신 응답(proxy 서버) 해줄 서버를 가리킵니다.** \n\n```javascript\nimport common from \"./rollup.config\";\nimport serve from \"rollup-plugin-serve-proxy\";\nimport livereload from \"rollup-plugin-livereload\";\nimport htmlTemplate from \"rollup-plugin-generate-html-template\";\nimport * as path from \"path\";\n\nimport setting from \"./setting.json\";\nimport Proxy from \"./proxy/Proxy\";\n\nconst proxy = new Proxy({\n  targetHost: setting.target_host,\n  port: setting.port,\n  bundleJs: setting.bundle_js\n});\nproxy.listen(); // proxy 서버를 띄웁니다.\n\nexport default {\n  input: common.input,\n  output: {\n    file: \"dist/bundle.dev.js\",\n    format: \"iife\"\n  },\n  plugins: [\n    ...common.plugins,\n    htmlTemplate({\n      template: \"index.html\",\n      target: \"dist/index.html\"\n    }),\n    serve({\n      open: true,\n      contentBase: path.join(process.cwd(), \"/dist\"),\n      host: \"localhost\",\n      port: 9000,\n      proxy: {\n        dev: \"http://localhost:1234\" // /dev url로 들어오는 요청은 localhost:1234 서버가 대신 응답해 줍니다.\n      }\n    }),\n    livereload(\"dist\")\n  ]\n};\n\n```\n\n### proxy 서버 개발\n\nproxy 서버가 하는 일은 다음과 같습니다.\n\n- 사용자가 설정한 주소의 마크업을 크롤링 해옵니다. \n- 크롤링해온 HTML 파일에서 외부 링크나 내부 상대 경로를 이용하는 링크를 절대 경로로 교체 해줍니다. 이는, css, image, js 파일은 해당 마컵 서버에 있는걸 가져다 쓰겠다는 의미 입니다.\n- 마지막으로 body 에 개발 서버에 적제되어있는 bundle.js 파일을 삽입해줍니다.\n\n`target_host` 설정 후 `/dev` 이후 요청 받은 url에 따라서 마크업 서버에서 크롤링 해오는 페이지가 다르게 하기 위해서 다음과 같은 작업을 합니다.\n(예. `localhost:3000/dev/ho1/ho2?search` 로 접속하면 다음과 같은 주소에서 크롤링 해옵니다. `http://merlin.com/test/ho1/ho2?search`)\n\n\n```javascript\n\nconst getHtml = async (host, path) => {\n  try {\n    return await axios.get(`${host}${path}`);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nconst url = req.url\ngetHtml(this._targetHost, url).then(... )\n\n```\n\n\n### 코드 예제\n\n\n```javascript\n{\n  \"target_host\" : \"http://merlin.com/test\",\n  \"bundle_js\" : \"bundle.dev.js\",\n  \"port\" : 1234\n}\n```\n\n```javascript\n// DevController.js\nconst axios = require(\"axios\");\nconst cheerio = require(\"cheerio\");\n\nconst HTTP_REG = /^((http(s?))\\:\\/\\/)/;\nconst ROOT_REG = /^(\\/)/;\nconst REL_REG = /^(\\.(\\.?))/;\nconst isHttpUrl = url => {\n  return HTTP_REG.test(url);\n};\n\nconst isRootUrl = url => {\n  return ROOT_REG.test(url);\n};\n\nconst isRelativeUrl = url => {\n  return REL_REG.test(url);\n};\n\nconst getHtml = async (host, path) => {\n  try {\n    return await axios.get(`${host}${path}`);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nconst stringifyScriptTag = src => {\n  return `<script type=\"text/javascript\" src=\"${src}\"></script>`;\n};\n\n// ./css/path/aaa\n// ../css/path/ccc\n// /insure-2019/apt/css/path/bbb\n// css/path/aaa => ./css/path/aaa\n\nconst convertAbsolutePath = (hostUrl, pathname, attrPath) => {\n  if (isRootUrl(attrPath)) {\n    return `${hostUrl.substring(0, hostUrl.lastIndexOf(\"/\"))}${attrPath}`;\n  }\n\n  if (isRelativeUrl(attrPath)) {\n    return `${hostUrl}${pathname}/${attrPath}`;\n  }\n\n  return `${hostUrl}/${attrPath}`;\n};\n\nconst convertCssPath = ($, host, pathname) => {\n  const $link = $(\"link\");\n\n  $link.each((index, cssLink) => {\n    const $cssLink = $(cssLink);\n    const cssHref = $cssLink.attr(\"href\");\n\n    if (cssHref && !isHttpUrl(cssHref)) {\n      // 경로가 있고 http로 시작하지 않는 경로만 바꿔준다.\n      const absolutePath = convertAbsolutePath(host, pathname, cssHref);\n      $cssLink.attr(\"href\", absolutePath);\n    }\n  });\n};\n\nconst convertScriptPath = ($, host, pathname) => {\n  const $script = $(\"script\");\n  const scriptSrc = $script.attr(\"src\");\n\n  if (scriptSrc && !isHttpUrl(scriptSrc)) {\n    $script.each((index, scriptLink) => {\n      const $scriptLink = $(scriptLink);\n      const absolutePath = convertAbsolutePath(host, pathname, scriptSrc);\n      $scriptLink.attr(\"src\", absolutePath);\n    });\n  }\n};\n\nconst convertImagePath = ($, host, pathname) => {\n  const $img = $(\"img\");\n  const imgSrc = $img.attr(\"src\");\n\n  if (imgSrc && !isHttpUrl(imgSrc)) {\n    $img.each((index, imgLink) => {\n      const $imgLink = $(imgLink);\n      const absolutePath = convertAbsolutePath(host, pathname, imgSrc);\n      $imgLink.attr(\"src\", absolutePath);\n    });\n  }\n};\n\nconst appendBundleScript = ($, jsfile) => {\n  $(\"body\").append(stringifyScriptTag(`/${jsfile}`));\n};\n\nclass DevController {\n  constructor({ targetHost, bundleJs }) {\n    this._targetHost = targetHost;\n    this._bundleJs = bundleJs;\n  }\n\n  getCrawlingHtml(req, res) {\n    const url = req.url;\n    const pathname = url.substring(0, url.lastIndexOf(\"/\"));\n\n    getHtml(this._targetHost, url)\n      .then(html => {\n        const $ = cheerio.load(html.data);\n        convertCssPath($, this._targetHost, pathname);\n        convertScriptPath($, this._targetHost, pathname);\n        convertImagePath($, this._targetHost, pathname);\n        appendBundleScript($, this._bundleJs);\n\n        return $.html();\n      })\n      .then(data => res.send(data));\n  }\n}\n\nexport default DevController;\n\n```\n\n```javascript\n// devRouter.js\nconst express = require(\"express\");\nconst devRouter = express.Router();\n\nexport function devRouting(app, controller) {\n  app.use(\"/dev\", devRouter);\n\n  devRouter.get(\"/*\", (req, res, nex) => {\n    controller.getCrawlingHtml(req, res);\n  });\n}\n\n```\n\n```javascript\n// Proxy.js\n// require\nconst express = require(\"express\");\nconst app = express();\nimport DevController from \"./DevController\";\nimport { devRouting } from \"./devRouter\";\n\nclass Proxy {\n  constructor({ targetHost, port = 1234, bundleJs }) {\n    this._targetHost = targetHost;\n    this._port = port;\n    this._bundleJs = bundleJs;\n    this._devController = new DevController({ targetHost, bundleJs });\n    this.routing();\n  }\n\n  routing() {\n    devRouting(app, this._devController);\n  }\n\n  listen() {\n    app.listen(this._port, () => {\n      console.log(`${this._port}번 port에 proxy server를 띄웠습니다.`);\n    });\n  }\n}\n\nexport default Proxy;\n\n```\n\n\n\n\n","excerpt":"Rollup Setting & babel Setting 간단한 스크립트 개발 셋팅을 위한 rollup 과 babel 셋팅 및 crawling을 위한 proxy 서버 셋팅을 정리해둡니다. Rollup production setting rollup 셋팅…","fields":{"slug":"/hello-rollup.md/"},"frontmatter":{"date":"Nov 25, 2019","title":"Hello Rollup","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 리액트가 동작하는 방법 (요약)\n\n- react는 모든 요소를 생성해서 해당 되는 dom에 밀어 넣는다.\n- react는 소스코드에 처음부터 HTML을 넣지 않고, HTML에서 HTML을 추가하거나 제거하는 법을 알고있다.\n- 빈 HTML을 로드한 다음에 react가 HTML을 밀어 넣게 된다.\n- react에서는 virtual DOM이라는게 있고 react가 이걸 만들어내서 HTML을 만들어 낸다. 소스코드에는 찾아 볼 수 없다.\n\n## Element\n\n- Element는 DOM 노드 또는 다른 컴포넌트와 관련하여 화면에 표시할 내용을 설명하는 일반 개체입니다.\n\n```javascript\n// element의 형태\n\n{\n  type: 'button',\n  props: {\n    className: 'button button-blue',\n    children: {\n      type: 'b',\n      children: 'OK!'\n    }\n  }\n}\n```\n\n## Component\n\n- component는 대문자로 시작해야 한다.\n- component는 2가지 형태( class , function) 으로 존재 할 수 있다.\n- class component 는 React.Component를 상속받아 render 메서드를 지닌 형태이다.\n- class component , function component 이 둘다 입력으로 props를 받고 산출물로 element tree를 반환한다.\n- component가 입력으로 props를 받으면 부모 컴포넌트가 type 으로 해당 component 와 그것의 props를 element로 리턴했다는 것이다.\n- react는 Component를 가져와서 브라우저가 이해할 수 있는 평범한 일반 HTML로 만들어 준다.\n- **react는 Component를 이용해서 Element를 만듭니다. (컴포넌트는 엘리먼트를 만들어주는 함수 또는 클래스 입니다.)**\n- component는 재사용이 가능하게 만들 수 있다. 이 말은 component를 계속 반복해서 사용할 수 있다는 것이다.\n\n## instance\n\n- class component 에서 사용되는 this로 참조하는 값이다.\n- instance는 local state를 저장하고 lifecycle event에 반응하기에 적합하다.\n\n## JSX\n\n- React는 component와 동작하고 모든 것은 component이다.\n- 우리의 목적은 component를 보기 좋게 만드는 것이다.\n- component가 data를 보여주게 하는 것이다.\n- component는 HTML을 반환하는 함수이다.\n- react는 component를 사용해서 HTML처럼 작성하려는 경우에 필요하다.\n- javascript와 HTML 사이의 이러한 조합을 JSX라고 부른다.\n- component를 만들고 사용하는데 있어서 React에서 만든 JSX 라는 것을 사용하게 된다.\n- jsx는 babel을 통해서 createElement 함수로 바뀌고 실행된다.\n\n## Props\n\n- 부모 component에서 자식 component로 정보를 보낼때 React Element의 props 객체에 정보를 실어서 보내게 된다.\n- PropTypes 으로 props의 타입을 체크 할 수 있다.\n\n```javascript\n// Food component에서는 인자로 props 객체를 받을 수 있다.\nconst Food = ({name}) => {\n\treturn (\n\t\t<div>I like {name}</div\n\t)\n}\n\nconst somethingComponent = () => (\n\t<Food name=\"kimchi\"/>\n)\n\n// 위 문법은 아래와 같이 변형된다.\nconst somethingComponent = () => ({\n\ttype: Food,\n\tprops: {\n\t\tname: \"kimchi\"\n\t}\n})\n```\n\n### render prop\n\n- render props에 함수를 넘겨주면 그 해당 함수에 인자로 내가 생성한 데이터를 넣어주겠다. 그 데이터가 필요한 컴포넌트를 자유롭게 렌더링 해라\n- render prop은 무엇을 렌더링할지 컴포넌트에 알려주는 함수이다.\n- render 대신에 children을 이용해서 사용할 수도 있다.\n- 이 테크닉은 자주 사용되지 않기 때문에, API를 디자인할 때 children은 함수 타입을 가지도록 propTypes를 지정하는 것이 좋습니다.\n\n```javascript\nMouse.propTypes = {\n  children: PropTypes.func.isRequired\n};\n\n<Mouse render={mouse => (\n          <Cat mouse={mouse} />\n        )}/>\n\n// Mouse 컴포넌트는 데이터를 생성. render에 넘겨주는 함수의 인자(mouse)에 데이터를 넘겨주면\n// Cat 컴포넌트에서 해당 데이터를 이용해서 view\n```\n\n## State\n\n- 동적 데이터와 함께 작업할때 만들어지는 데이터, 변하는 데이터 즉, 다이나믹한 데이터들의 종류를 말한다.\n- state는 class component에 존재한다.\n- `react`는 자동적으로 모든 `class component의 render 메서드`를 실행 하고자 한다.\n- `state`는 object이고 class component에는 data를 넣을 공간이 있다. 그리고 이 데이터는 변한다.\n- 바꿀 데이터를 state 안에 넣는다.\n- `state`를 직접적으로 바꾼다면 React는 `render function` 을 `refresh` 하지 않는다. 이 말의 의미는 state의 상태를 변경할때 React가 `render function` 을 호출하길 원한다는 뜻이다.\n- `setState` 메서드를 이용해서 state를 변경하면 React는 state를 refresh 하고 또한 render function 을 호출해준다.\n- `setState`로 `state`를 변경하고 새로 Render가 필요할때 사용합니다.\n- `state`를 변경하고자 할때 직접적으로 변경하는 것이 아니라 `setState` 메서드를 사용해서 변경합니다.\n- `setState`를 호출하게 되면 React의 스케쥴에 등록을 하게 되고 현재 클래스컴포넌트의 인스턴스와 `setState`의 인자로 넘겼던 `partialState`를 인자로 넘기게 됩니다. 이때 `partialState`는 `fiber`에 담겨져 있다가 `reconciliation`이 끝나고 나면 state에 `Object.assign`으로 적용이 됩니다. ( 즉, 바로 state가 변경되지 않습니다. 중요한건 `reconciliation`이 끝나고 `state` 가 한번에 반영이 된다는 것입니다. )\n- 그렇기 때문에 `setState` 를 연속으로 호출이 되면 전에 `setState` 호출 해서 얻은 결과가 뒤에 `setState` 에 반영이 되지 않는 것입니다. 그래서 `state`에 객체 대신에 함수 인자를 전달하는게 좋습니다. \n\n```javascript\nthis.state = 1\nthis.setState({\n  likes: this.state.likes + 1\n});\n\nthis.setState({\n  likes: this.state.likes + 1\n});\n\n// this.state = 2\n```\n\n- setState에서 this.state를 직접 참조(의존)하기 보다는 현재 state를 받는 함수 형태로 넘기는게 좋다. ( setState(currentState => currentState + 1) )\n\n## Life Cycle\n\n- life cycle method는 react가 component를 생성하는 그리고 없애는데 호출되는 메서드 이다.\n- component가 생성될 때, render 전에 호출되는 몇가지 function 이 있다.\n- mount, update, unmount 때에 따라 호출되는 method가 있다.\n- mount\n    - `contstructor()` : 컴포넌트를 새로 만들 때마다 호출되는 클래스 생성자 메서드 입니다.\n    - `static getDerivedStateFromProps()` : 컴포넌트가 인스턴스화 된 후, 새 props를 받았을 때 호출된다. props에 있는 값을 state에 넣을 때 사용하는 메서드 입니다.\n    - `render()` : 우리가 준비한 UI를 렌더링하는 메서드 입니다. \n    - `componentDidMount()` : 컴포넌트가 웹 브라우저상에 나타난 후 호출하는 메서드입니다.\n- update\n    - `static getDerivedStateFromProps()` : 이 메서드는 마운트 과정에서도 호출되며, 업데이트가 시작하기 전에도 호출됩니다. props의 변화에 따라 state 값에도 변화를 주고 싶을 때 사용합니다.\n    - `shouldComponentUpdate()` : 컴포넌트가 리렌더링을 해야 할지 말아야 할지를 결정하는 메서드 입니다. 이 메서드에서는 true 혹은 false 값을 반환하며, true을 반환하면 다음 라이프사이클 메서드를 계속 실행하고, false를 반환하면 작업을 중지합니다. 즉, 컴포넌트가 리렌더링 되지 않습니다. 만약 특정 함수에서 this.forceUpdate() 함수를 호출하면 이 과정을 생략하고 바로 render 함수를 호출합니다.\n    - `render()` : 컴포넌트를 리렌더링 합니다.\n    - `getSnapshotBeforeUpdate()` : DOM이 업데이트 직전에 호출된다. (이 라이프 사이클은 많이 필요하지 않지만, 렌더링되는 동안 수동으로 스크롤 위치를 유지해야할 때와 같은 경우에는 유용할 수 있다)\n    - `componentDidUpdate()` : 컴포넌트의 업데이트 작업이 끝난 후 호출하는 메서드 입니다.\n- unmount\n    - `componentWillUnmount()` : 컴포넌트가 웹 브라우저상에서 사라지기 전에 호출하는 메서드 입니다.\n\n## Composition\n\n- 컴포넌트에서 다른 컴포넌트를 `children` 이나 `props` 로 받아서 구성할 수 있다.\n- 일반적인 컴포넌트에서 특수한 경우인 경우를 고려해야하는 경우 더 \"구체적인\" 컴포넌트가 \"일반적인\" 컴포넌트를 렌더링하고 구체적인 내용은 `props` 를 통해 내용을 구성한다.\n- 가끔은 상위 컴포넌트에서 하위 컴포넌트에 필요한 데이터를 `props` 로 해당 하위컴포넌트에 전달할때 depth가 너무 깊으면 힘들어지니 상위 컴포넌트에서 데이터를 포함한 해당 하위 컴포넌트를 품고 `props` 로 전달해서 render 하면 더 편할 때가 있다. 다 편한건 아니다.\n\n## Reconciliation (재조정)\n\n- 컴포넌트를 호출 => 새로운 `React Element` 반환 => 새로운 `Element와` 이전 `Element` 비교 => 변화 감지\n- 컴포넌트가 `React Element` 새로 만들면 기존 `Dom` 에 그려졌던 `Element`랑 비교\n- 변화가 생긴 컴포넌트를 기준으로 그 컴포넌트가 반환한(리턴한) `React Element`를 이전(DOM에 그려졌던 Element)과 비교\n- 비교된 결과가 이전 인스턴스가 없었던 것이라면 새로운 `element`를 바탕으로 새롭게 append 시도\n- 비교된 결과가 새로운 `element`가 없다면 이전 `instance`를 실제 DOM에서 삭제\n- 배교된 결과가 타입이 다르다면 새로운 element를 바탕으로 `replace` 시도 ( 자식까지 모두 )\n- 새로운 `element type` 이 `dom type`이면 `dom property` 들을 update 진행\n- 새로운 `element type` 이 컴포넌트라면 (class, function) 컴포넌트의 `render()` 메서드 또는 `return` 결과의 `React Element` 들을 가지고 다시 `reconcile` 진행\n\n### 변화 감지\n\n아래 다음과 같은 경우 자식들을 모두 instantiate 해서 한방에 부모 DOM에 append 또는 replace 합니다.\n\n- 타입이 다를때\n- 새로 생겨나야 할때\n\nReconciliation 할 때 경우의 수는 다음과 같습니다.\n\n- 없으면 새로 만들고 ( 자식 까지 새로 만들어서 만듬 ) appendChild - 한방\n- 있었던건데 없어지면 지우고 ( 자식 밑으로 삭제 ) removeChild - 한방\n- 타입이 다르면 새로 만들어서 ( 자식 까지 만들어서 ) replaceChild - 한방\n- DOM Element 인데 type이 같으면 update 하고 기존 dom 활용\n- React Component 이면 render() 해서 reconcilation 재귀\n\n## Context API\n\n- 하나의 액션으로 해당하는 컴포넌트만 바꾸는게 아닌 다른 여러 컴포넌트도 바꾸고 싶다.  ( one to many 관계 )\n- context를 이용하면 단계마다 일일이 props를 넘겨주지 않고도 컴포넌트 트리 전체에 데이터를 제공할 수 있습니다.\n- context의 주된 용도는 다양한 레벨에 네스팅된 많은 컴포넌트에게 데이터를 전달하는 것입니다.\n- 같은 데이터를 모든 하위 컴포넌트에게 널리 \"방송\"이 필요할 때는 context가 유용하다.\n- React 컴포넌트인 Provider는 context를 구독하는 컴포넌트들에게 context의 변화를 알리는 역할을 합니다.\n- Consumer는 context 변화를 구독하는 React 컴포넌트입니다. 함수 컴포넌트안에서 context를 읽기 위해서 쓸 수 있습니다. Context.Consumer의 자식은 함수여야합니다. 이 함수는 context의 현재값을 받고 React 노드를 반환합니다.\n- useContext를 쓰면 컴포넌트 함수 자체는 실행이 된다. 실제로 return 부분이 실행된다면 그게 실제로 re-rendering 되는 것이기 때문에 return 에 있는 부분만 캐싱을 해줘야 한다. useMemo 사용 ( 참고 : [https://www.youtube.com/watch?v=Y7m9RKmD0UQ](https://www.youtube.com/watch?v=Y7m9RKmD0UQ) )\n\n## React Hooks\n\n- 함수형 컴포넌트에서도 상태 관리를 할 수 있는 useState. 렌더링 직후 작업을 설정하는 useEffect 등의 기능을 제공하여 기존의 함수형 컴포넌트에서 할 수 없었던 다양한 작업을 할 수 있게 해 줍니다.\n- useState는 함수형 컴포넌트에서도 가변적인 상태를 지닐 수 있게 해줍니다.\n- useEffect는 리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook이다.\n클래스형 컴포넌트의 componentDidMount와 componentDidUpdate를 합친 형태로 보아도 무방하다.\n- useEffect는 기본적으로 DOM 렌더링되고 난 직후마다 실행되며, 두 번째 파라미터 배열에 무엇을 넣는지에 따라 실행되는 조건이 달라진다.\n- 컴포넌트가 언마운트되기 전이나 업데이트 되기 직전에 어떠한 작업을 수행하고 싶다면 useEffect에서 cleanup 함수를 반환해 주어야 합니다.\n- useEffect 사용할시 관계 없는 로직일때는 분리해서 넣으십쇼. Hooks은 무엇을 하는지에 따라 코드를 분리 시켜줄수 있습니다.\n- effect는 다음 effect가 발생할때 마다 default로 이전 effect를 clean up 해줄 수 있다. effect 의 return 으로 함수를 적어둔다면 리엑트는 자동으로 정리를 해야할때(다음 effect 함수가 실행되기 이전에) 이 함수를 실행 시킵니다.\n- useEffect가 발동되면 해당되는 함수 컴포넌트는 무조건 다시 호출이 됩니다.\n- useEffect의 두번째 인자로 빈 배열(`[]`)을 넣는다면 mount시와 unmount시에만 호출이 됩니다. 그래서 update시에 effect 함수 호출을 건너뛸 수 있습니다.\n- 만약 useEffect의 두번째 인자로 빈 배열(`[]`)을 넣는다면 effect 안에 있는 state와 props는 항상 초기값을 가리킬 것입니다.\n\n### useEffect 는 왜 매 업데이트 시 마다 호출이 될까?\n\n우리 컴포넌트에서 this.props에서 친구의 온라인 유무 상태를 받아온다고 생각해보자. componentDidMount와 componentWillMount시에 친구 ID를 사용해서 로직을 구현할 것이다. 근데 만약 props가 변경되어 친구가 변경 되었다면, 다른 친구의 온라인 상태를 표현해 줄것입니다.\n\n또한 unMount시에 없는 친구 ID를 사용하기에 에러가 나기 충분하다. 그래서 사용자는 componentDidUpdate 에 추가 로직을 잊지 않고 넣어주어야 합니다.\n\n훅을 사용하면 이런 류의 버그 걱정을 덜어줄 수 있습니다.\n\n```javascript\nfunction FriendStatus(props) {\n  // ...\n  useEffect(() => {\n    // ...\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n```\n\n```javascript\n// Mount with { friend: { id: 100 } } props\nChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Run first effect\n\n// Update with { friend: { id: 200 } } props\nChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effect\nChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Run next effect\n\n// Update with { friend: { id: 300 } } props\nChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effect\nChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Run next effect\n\n// Unmount\nChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect\n```\n\n### 디펀던시 리스트에서 함수를 생략해도 안전한가요?\n\n일반적으로는 안전하지 못합니다.\n\n특히 해당 함수가 props를 참조하고 있다면 bug가 일어날 수 있습니다.\n왜냐하면 props가 바뀌면 해당 함수를 호출하지 않기 때문입니다.\n해당 함수를 생략하려면 오직 그 함수가 props나 state 그것에 파생된 값을 참조하고 있지 않을때만 안전합니다.\n\n```javascript\nfunction Example({ someProp }) {\n  function doSomething() {\n    console.log(someProp);\n  }\n\n  useEffect(() => {\n    doSomething();\n  }, []); // 🔴 This is not safe (it calls `doSomething` which uses `someProp`)\n}\n```\n\neffect 함수 밖 함수에 의해 사용되는 state나 props를 인지하긴 힘듭니다. 그렇기 때문에 보통 effect가 필요한 함수를 안쪽에 선언할 것입니다. 그러면 컴포넌트 스코프의 어떤 값들이 effect에 의존적인지 알아보기 쉬울 것입니다.\n\n```javascript\nfunction Example({ someProp }) {\n  useEffect(() => {\n    function doSomething() {\n      console.log(someProp);\n    }\n\n    doSomething();\n  }, [someProp]); // ✅ OK (our effect only uses `someProp`)\n}\n```\n\n만약에 컴포넌트 스코프에 있는 어떠한 값도 사용하지 않는다면 빈배열로 넣는것은 안전할 것입니다.\n\n만약에 몇몇 이유로 effect 안에 함수를 이동시키기 없다면 몇몇 선택지가 있습니다.\n\n- **해당 함수를 컴포넌트 밖으로 빼려고 노력을 하십시요.** 이런 경우에는 컴포넌트의 props, state 를 참조하고 있지 않다는 보장이 생기기 때문에 디펜던시 리스트에 있을 필요가 없습니다.\n\n- 만약 함수가 순수함수이고 렌더링 도중에 불려도 안전하다면 **effect 밖에서 호출 하십시요.** 그리고 effect에 리턴 된 값을 의존하게 하십시요.\n\n- 마지막은, `useCallback` 로 감싼 정의된 **함수를 effect 디펜던시에 추가** 하십시요. 이것은 useCallback에 걸어둔 디펜던시가 변경되지 않는다면 매 render 시 마다 변경되지 않음을 보장할 수 있습니다.\n\n```javascript\nfunction ProductPage({ productId }) {\n  // ✅ Wrap with useCallback to avoid change on every render\n  const fetchProduct = useCallback(() => {\n    // ... Does something with productId ...\n  }, [productId]); // ✅ All useCallback dependencies are specified\n\n  return <ProductDetails fetchProduct={fetchProduct} />;\n}\n\nfunction ProductDetails({ fetchProduct }) {\n  useEffect(() => {\n    fetchProduct();\n  }, [fetchProduct]); // ✅ All useEffect dependencies are specified\n  // ...\n}\n```\n\n위 예제는 `ProductPage`의 `productId` prop의 변화가 `ProductDetails` 컴포넌트의 refetch를 발동 시킨다는 것을 보장합니다.\n\n### Hooks 규칙\n\n1. 리액트 함수의 제일 상단에 작성해야합니다.\n\n- 조건문, 내부 함수, 반복문 안에 사용하지 않습니다.\n\n2. 리액트 함수 안에서만 사용합니다.\n\n- custom 함수 안에서는 예외적으로 호출 할 수 있습니다.\n\n## React Render\n\nReact and the Virtual DOM 참고 동영상:  [https://www.youtube.com/watch?v=BYbgopx44vo](https://www.youtube.com/watch?v=BYbgopx44vo)\n\n### version 1\n\n- 중첩된 `Element`를 그릴수 있는 `render` 함수를 두게 된다. 여기서 `render` 는 재귀 함수를 통해 만들 수 있다.\n- 초기 생각해 볼 수 있는 `render`는 계속 `DOM`을 `append`를 시키는 것이다.\n- 진화된 `render`는 `root parent`에 `child`가 있다면 기존에 돔을 교체하는 `replaceChild` 를 시키는 것이다.\n\n### version 2\n\n- 위에서 문제는 모든 `dom`을 재 생성하기 때문에 마지막 `root parent`만 `replace`를 시킨다는 것이다. 재사용 할 수 있는 dom은 그대로 두는게 효율적일 것이다.\n- 이때 `Reconciliation`이 등장한다. 새로 생성한 `element tree`와 이전 `render`된 `element tree`를 비교해서 달라진 곳만 `update`를 시킨다.\n- 기존 그려졌던 `element`의 type 비교와 더불어 dom 의 재사용을 위한 새로운 개념인 `instance : {dom, element, childInstances }` 라는것을 도입\n- `reconcile` 함수의 역할은 `parentDom`, 이전의 그려졌던 `instance`, 새로운 `element` 받아서 조건(새로 생성, 업데이트, 삭제)에 맞게끔 `dom` 에 그려 준다.\n  - 이전에 그려놓은 `instance` 가 없다면 새로 `instance` 를 만들고 만들어진 dom 을 `append` 시킨다.\n  - 새로 그려지는 `element` 가 `null` 이라면 매칭되는 `parentDom` 에서 자식들을 삭제한다.\n  - 이전에 그려놓은 `instance` 의 `element type` 과 새로 그릴려는 `element type` 이 같고 `DOM Element` 라면 이전에 그려 놓은 `instance 의 dom` 에 prop 만 업데이트를 하게 됩니다. 그리고 나서 해당 `instance` 의 `children` 을 `reconcil` 을 한다. 여기서 따로 `reconcileChildren` 함수가 존재하는 이유는 `children` 이 배열 타입이기 때문이다.\n  - 이전에 그려놓은 `instance` 의 `element type` 과 새로 그릴려는 `element type` 이 같고 `Component Element` 라면 컴포넌트의 인스턴스인 `public instance` 자체는 변하지 않는다. ( 때문에 컴포넌트의 state는 유지 된다. ) 그리곤 업데이트 전 라이프사이클이 호출이 되어 props가 업데이트 되고 `render()` 를 호출하게 되어 컴포넌트의 이전 엘리먼트 트리와 다음 엘리먼트 트리에 대해 diff 알고리즘을 재귀적으로 적용한다.\n  - 그 외 모든 경우에는 `parenDom` 기준으로 `reconcilation` 새롭게 `instance` 를 만들어서 replace 한다.\n- 이렇게 진행이 되면 다음과 같은 문제가 또 발생할 수 있다.\n    - 모든 변화에 전체 virtual DOM tree를 reconciliation을 진행할 수 밖에 없다.\n    - State가 글로벌 하게 존재하게 된다.\n    - State를 컴포넌트 안으로 넣어 보자.\n- 그래서 `class Component`가 탄생하게 된다. 이 `class 컴포넌트`의 인스턴스는 기존의 `instance` 개념과 차별을 두기 위해 `public instance`라고 명명한다.\n- `public instance`에는 `setState` 메서드를 통해서 `reconciliation을` 진행하고 기존에 그려졌던 `instance를` 지니고 있기 때문에 전체가 아닌 자기 자신을 기준으로 해서 자식들로만 `reconcile` 을 할 수 있는 장점을 얻을 수 있다.\n\n### version 3\n\n- 여기서 또 다른 문제점을 해결하기 위해 `Fiber` 라는게 도입\n- 여기서 `reconciliation` 로직은 재귀를 통해서 `Element tree` 구조의 변화를 감지하고 최종적으로 DOM을 그려낸다. 이 비용이 높아지면 브라우저의 메인 쓰레드를 잡아 먹기 때문에 동시에 다른 비싼 비용들의 로직들을 처리 해 낼수가 없다. ( 버벅이는 현상이 나타남 )\n- 기존의 재귀 용법에서 `iterator`, 즉 반복문 형태로 구조를 바꾸고(tree구조를 선형적으로 바꾸게 됨) react 스케쥴링을 통해서 cpu가 idle인 경우일 때 일부 `reconcile을` 처리하고 이 반복이 모두 완료가 되었을 때, DOM에 그리게 되는 형식이다.\n- 정리하면 숫자를 증가하는 버튼을 한번 눌렀을 때, 즉, 뷰 업데이트가 이뤄지길 원할 때, `update` 큐에 업데이트 정보(해당 instance와 업데이트할 state)가 들어가게 되고 해당 `update` 를 빼와서 새로운 `fiber tree` 만들게 된다. 이때 `cpu의 idle 타임`을 보면서 이벤트가 발생한 컴포넌트에서 부터 선형트리 구조를 만들면서 `update` 정보를 수집하게 된다.\n- 만약에, 큐에 들어간 작업들 중에서 더 빠르게 끝나는 작업이 있다면 `cpu의 idle 타임`을 보고 그 작업부터 완료 되서 스크린에 보여 지게 될것이다.\n\n## 참고\n\n- [cheetsheets](https://devhints.io/react)","excerpt":"리액트가 동작하는 방법 (요약) react는 모든 요소를 생성해서 해당 되는 dom에 밀어 넣는다. react는 소스코드에 처음부터 HTML을 넣지 않고, HTML에서 HTML을 추가하거나 제거하는 법을 알고있다. 빈 HTML을 로드한 다음에 rea…","fields":{"slug":"/react/"},"frontmatter":{"date":"Nov 20, 2019","title":"React 정리","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n이 글은 아래 링크에 있는 글을 의역 했습니다.\n[참조](https://airbnb.io/enzyme/)\n\n엔자임은 리엑트를 위한 Javascript Testing 유틸리티 입니다. 리엑트 컴포넌트들의 결과물을 테스트 하기 용이합니다. 또한 출력에 따라 런타임을 조작, 탐색 및 런타임 시뮬레이션 할 수 있습니다.\n\n엔자임의 API는 DOM 조작 및 순회를 위해 jQuery의 API를 흉내 냄으로써 직관적이고 유연합니다.\n\n> assert라는 단어를 영한 사전에서 찾아 보면 \"단언하다, 확실히 하다\"라는 뜻을 가지고 있는데 코드가 정확하게 동작할 수 있는 상황이라는 것을 확인한다. \n\n## Upgrading from Enzyme 2.x or React < 16\n\n엔자임이 React 16과 호환이 되는지 체크해보겠습니까? 현재 Enzyme 2.x 버젼때를 사용하고 계신가요? 훌륭합니다!\n[마이크레이션 가이드](https://airbnb.io/enzyme/docs/guides/migration-from-2-to-3.html) 에서 React 16이 지원되는 Enzyme v3으로 마이그레이션 하는 법을 도와줄 것입니다.\n\n### intallation\n\nenzyme 을 시작하기 위해서 npm을 통해 간단하게 설치 할 수 있습니다. react 버젼에 따른 Adapter와 함께 enzyme을 설치 할 수 있습니다. 만약 enzyme과 React16을 사용한다면 다음과 같이 설치 할 수 있습니다.\n\n```bash\nnpm i --save-dev enzyme enzyme-adapter-react-16\n```\n\n각 adapter는 추가적으로 사용자가 설치해야 할 peer dependencies를 가지고 있을 수 있습니다. 예를 들면 `enzyme-adapter-react-16` 은  peer dependencies 으로 `react` 와 `react-dom`을 필요로 합니다.\n\n현재 Enzyme에는 React 16.x, React 15.x, React 0.14.x 및 React 0.13.x와 호환되는 어댑터가 있습니다.\n\n\n다음 어댑터는 공식적으로 효소에 의해 제공되며 다음과 같은 React와 호환됩니다.\n\n| Enzyme Adapter Package | React semver compatibility |\n| --- | --- |\n| `enzyme-adapter-react-16` | `^16.4.0-0` |\n| `enzyme-adapter-react-16.3` | `~16.3.0-0` |\n| `enzyme-adapter-react-16.2` | `~16.2` |\n| `enzyme-adapter-react-16.1` | `~16.0.0-0 or ~16.1` |\n| `enzyme-adapter-react-15` | `^15.5.0` |\n| `enzyme-adapter-react-15.4` | `15.0.0-0 - 15.4.x` |\n| `enzyme-adapter-react-14` | `^0.14.0` |\n| `enzyme-adapter-react-13` | `^0.13.0` |\n\n마지막으로, 원하는 adapter를 사용하기 위해서 enzyme을 설정해주어야 합니다. 이 작업을 위해서 top level의 `configure(...)`API를 사용해야 합니다.\n\n```javascript\n// setup file\n\nimport Enzyme from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\n\nEnzyme.configure({ adapter: new Adapter() });\n```\n\n```javascript\n// test file\nimport { shallow, mount, render } from 'enzyme';\n\nconst wrapper = shallow(<Foo />);\n```\n\n## Running Enzyme Tests\n\nEnzyme은 사용하는 테스트 러너 또는 어설 션 라이브러리와 관련하여 만들어 놓은 것을 써야 합니다. 모든 주요 테스트 러너 및 어설 션 라이브러리와 호환되어야합니다.\nenzyme 대한 문서와 예제는 mocha와 chai를 사용하지만 선택한 프레임 워크에 맞는 것을 사용할 수 있습니다.\n\nReact 구성 요소를 테스트하기 위해 사용자 지정 어설 ​​션 및 편의 기능과 함께 enzyme를 사용하려면 다음을 사용하는 것이 좋습니다.\n\n\n- [`chai-enzyme`](https://github.com/producthunt/chai-enzyme)  with Mocha/Chai.\n- [`jasmine-enzyme`](https://github.com/FormidableLabs/enzyme-matchers/tree/master/packages/jasmine-enzyme)  with Jasmine.\n- [`jest-enzyme`](https://github.com/FormidableLabs/enzyme-matchers/tree/master/packages/jest-enzyme)  with Jest.\n- [`should-enzyme`](https://github.com/rkotze/should-enzyme)  for should.js.\n- [`expect-enzyme`](https://github.com/PsychoLlama/expect-enzyme)  for expect.\n\n\n## Basic Usage\n\n### [Shallow Rendering](https://airbnb.io/enzyme/docs/api/shallow.html)\n\n```javascript\nimport React from 'react';\nimport { expect } from 'chai';\nimport { shallow } from 'enzyme';\nimport sinon from 'sinon'; // 자바스크립트를 위한 독립형 테스트 spies, stubs 그리고 mocks 을 제공\n\nimport MyComponent from './MyComponent';\nimport Foo from './Foo';\n\ndescribe('<MyComponent />', () => {\n  it('renders three <Foo /> components', () => {\n    const wrapper = shallow(<MyComponent />);\n    expect(wrapper.find(Foo)).to.have.lengthOf(3);\n  });\n\n  it('renders an `.icon-star`', () => {\n    const wrapper = shallow(<MyComponent />);\n    expect(wrapper.find('.icon-star')).to.have.lengthOf(1);\n  });\n\n  it('renders children when passed in', () => {\n    const wrapper = shallow((\n      <MyComponent>\n        <div className=\"unique\" />\n      </MyComponent>\n    ));\n    expect(wrapper.contains(<div className=\"unique\" />)).to.equal(true);\n  });\n\n  it('simulates click events', () => {\n    const onButtonClick = sinon.spy();\n    const wrapper = shallow(<Foo onButtonClick={onButtonClick} />);\n    wrapper.find('button').simulate('click');\n    expect(onButtonClick).to.have.property('callCount', 1);\n  });\n});\n```\n\n### [Full DOM Rendering](https://airbnb.io/enzyme/docs/api/mount.html)\n\n```javascript\nimport React from 'react';\nimport sinon from 'sinon';\nimport { expect } from 'chai';\nimport { mount } from 'enzyme';\n\nimport Foo from './Foo';\n\ndescribe('<Foo />', () => {\n  it('allows us to set props', () => {\n    const wrapper = mount(<Foo bar=\"baz\" />);\n    expect(wrapper.props().bar).to.equal('baz');\n    wrapper.setProps({ bar: 'foo' });\n    expect(wrapper.props().bar).to.equal('foo');\n  });\n\n  it('simulates click events', () => {\n    const onButtonClick = sinon.spy();\n    const wrapper = mount((\n      <Foo onButtonClick={onButtonClick} />\n    ));\n    wrapper.find('button').simulate('click');\n    expect(onButtonClick).to.have.property('callCount', 1);\n  });\n\n  it('calls componentDidMount', () => {\n    sinon.spy(Foo.prototype, 'componentDidMount');\n    const wrapper = mount(<Foo />);\n    expect(Foo.prototype.componentDidMount).to.have.property('callCount', 1);\n    Foo.prototype.componentDidMount.restore();\n  });\n});\n\n```\n\n### [Static Rendered Markup](https://airbnb.io/enzyme/docs/api/render.html)\n\n```javascript\nimport React from 'react';\nimport { expect } from 'chai';\nimport { render } from 'enzyme';\n\nimport Foo from './Foo';\n\ndescribe('<Foo />', () => {\n  it('renders three `.foo-bar`s', () => {\n    const wrapper = render(<Foo />);\n    expect(wrapper.find('.foo-bar')).to.have.lengthOf(3);\n  });\n\n  it('renders the title', () => {\n    const wrapper = render(<Foo title=\"unique\" />);\n    expect(wrapper.text()).to.contain('unique');\n  });\n});\n\n```\n\n## Using enzyme with Jest\n\n### Configure with Jest\n\nJest와 함께 Enzyme 설정과 adapter을 위해 설정 파일을 동작하기 위해선 설정 파일([해당 구성 파일의 가능한 위치는 Jest의 설명서를 확인하십시오.](https://jestjs.io/docs/en/configuration) 안에 `setupFileAfterEnv`을 문자열 그대로의 <rootDir>와 셋업 파일의 경로를 셋팅해줘야 합니다.\n\n```javascript\n{\n  \"jest\": {\n    \"setupFilesAfterEnv\": [\"<rootDir>src/setupTests.js\"]\n  }\n}\n```\n\n### Jest version 15 and up\n\nJest 버젼 15 부터는 Jest가 더이상 기본적으로 mocks modules(Automocking-test에서 import 하는 모든 모듈을 자동적으로 mocked 시켜라)을 하지 않습니다. 이 때문에 Jest에 enzyme을 사용하기 위한 특별한 설정을 추가 하지 않아도 되비다.\n\nJest 문서에서 권장하는대로 Jest 및 해당 Babel 통합을 설치하세요. 그리고 enzyme을 설치하고 그 다음 테스트 파일 맨 위에 React와 enzyme 함수들 모듈들이 필요합니다.\n\n```javascript\nimport React from 'react';\nimport { shallow, mount, render } from 'enzyme';\n\nimport Foo from '../Foo';\n```\n\nJest 스냅 샷 테스트에만 사용하려는 경우가 아니면 Jest 자체 렌더러를 포함 할 필요가 없습니다.\n\n### Example Project for Jest version 15+\n\n\n[Example test for Jest 15+](https://github.com/vjwilson/enzyme-example-jest)\n\n## API Reference\n\n\n### Shallow Rendering\n\n**shallow(node[, options]) => ShallowWrapper**\n\nShallow Rendering은 컴포넌트를 단위 테스트하는데 제약을 가하고 테스트들이 하위 child 컴포넌트들의 행동에 간적접적으로 영향이 가지 않도록 하는데 유용합니다.\n\nEnzyme v3부터 얕은 API는 componentDidMount 및 componentDidUpdate와 같은 React 라이프 사이클 메소드를 호출합니다. 이에 대한 자세한 내용은 버전 3 마이그레이션 안내서를 참조하십시오.\n\n리엑트 컴포넌트를 Shallow Rendering 하고 나면 해당 컴포넌트 자체가 아닌 컴포넌트가 render 하는 children을 감싼 wrapper 객체가 리턴됩니다. 이때, children안에 있는 컴포넌트는 별도로 render 되지 않은 형태로 나옵니다.\n\n```javascript\nimport { shallow } from 'enzyme';\n\nconst wrapper = shallow(<MyComponent />);\n// ...\n```\n\n```javascript\nimport { shallow } from 'enzyme';\nimport sinon from 'sinon';\nimport Foo from './Foo';\n\ndescribe('<MyComponent />', () => {\n  it('renders three <Foo /> components', () => {\n    const wrapper = shallow(<MyComponent />);\n    expect(wrapper.find(Foo)).to.have.lengthOf(3);\n  });\n\n  it('renders an `.icon-star`', () => {\n    const wrapper = shallow(<MyComponent />);\n    expect(wrapper.find('.icon-star')).to.have.lengthOf(1);\n  });\n\n  it('renders children when passed in', () => {\n    const wrapper = shallow((\n      <MyComponent>\n        <div className=\"unique\" />\n      </MyComponent>\n    ));\n    expect(wrapper.contains(<div className=\"unique\" />)).to.equal(true);\n  });\n\n  it('simulates click events', () => {\n    const onButtonClick = sinon.spy();\n    const wrapper = shallow(<Foo onButtonClick={onButtonClick} />);\n    wrapper.find('button').simulate('click');\n    expect(onButtonClick).to.have.property('callCount', 1);\n  });\n});\n```\n\n#### Returns\n\n렌더러의 결과에서 나온 인스턴스를 감싼 객체\n\n### Full Rendering\n\n**mount(node[, options]) => ReactWrapper**\n\nFull DOM rendering은 DOM API와 상호 작용할 수 있는 components가 있거나 higher order components로 래핑 된 components를 테스트 해야하는 사용 사례에 이상적입니다.\n\nFull DOM rendering을 위해서는 전체 범위에서 전체 DOM API를 사용할 수 있어야합니다. 이는 최소한 브라우저 환경과 유사한 환경에서 실행되어야 함을 의미합니다. 브라우저 내에서 테스트를 실행하지 않으려면 mount를 사용하는 데 권장되는 방법은 jsdom이라는 라이브러리에 의존하는 것입니다. 이 라이브러리는 본질적으로 JS에서 완전히 구현 된 헤드리스 브라우저입니다.\n\n참고 : 얕은 렌더링 또는 정적 렌더링과 달리 전체 렌더링은 실제로 구성 요소를 DOM에 마운트하므로 테스트가 모두 동일한 DOM을 사용하는 경우 서로 영향을 줄 수 있습니다. 테스트를 작성하는 동안이를 명심하고 필요한 경우 .unmount () 또는 정리와 유사한 것을 사용하십시오.\n\n리엑트 컴포넌트를 Full Rendering 하고 나면 해당 컴포넌트의 인스턴스를 wrapper 한 객체가 리턴된다. 또한 컴포넌트 인스턴스의 children 에 또다른 리엑트 컴포넌트가 있다면 그것 또한 render 해준 결과가 나온다.\n\n```javascript\nimport { mount } from 'enzyme';\n\nconst wrapper = mount(<MyComponent />);\n// ...\n```\n\n```javascript\nimport { mount } from 'enzyme';\nimport sinon from 'sinon';\nimport Foo from './Foo';\n\ndescribe('<Foo />', () => {\n  it('calls componentDidMount', () => {\n    sinon.spy(Foo.prototype, 'componentDidMount');\n    const wrapper = mount(<Foo />);\n    expect(Foo.prototype.componentDidMount).to.have.property('callCount', 1);\n  });\n\n  it('allows us to set props', () => {\n    const wrapper = mount(<Foo bar=\"baz\" />);\n    expect(wrapper.props().bar).to.equal('baz');\n    wrapper.setProps({ bar: 'foo' });\n    expect(wrapper.props().bar).to.equal('foo');\n  });\n\n  it('simulates click events', () => {\n    const onButtonClick = sinon.spy();\n    const wrapper = mount((\n      <Foo onButtonClick={onButtonClick} />\n    ));\n    wrapper.find('button').simulate('click');\n    expect(onButtonClick).to.have.property('callCount', 1);\n  });\n});\n```\n\n#### Returns\n\n렌더러의 결과에서 나온 인스턴스를 감싼 객체\n\n### Static Rendering\n\n`render` function 은 렌더링 기능을 사용하여 React 트리에서 HTML을 생성하고 결과 HTML 구조를 분석하십시오.\n\n`render`는 enzyme의 다른 렌더러인 `mount` 및 `shallow`서 매우 유사한 래퍼를 반환합니다. 그러나 render는 third party HTML 파싱 및 순회 라이브러리 Cheerio를 사용합니다. Cheerio는 HTML 구문 분석 및 순회를 매우 잘 처리하며 이 기능을 복제하는 것은 장애가 될 것이라고 믿습니다.\n\n이 문서의 목적 상 Cheerio의 생성자(constructor)를 CheerioWrapper 라고합니다. 즉, ReactWrapper 및 ShallowWrapper 생성자와 유사합니다. CheerioWrapper 인스턴스에서 사용 가능한 메소드에 대해서는 [Cheerio API](https://github.com/cheeriojs/cheerio#api) 문서를 참조 할 수 있습니다.\n\n```javascript\nimport { render } from 'enzyme';\n\nconst wrapper = render(<MyComponent />);\n// ...\n```\n\n```javascript\nimport React from 'react';\nimport { render } from 'enzyme';\nimport PropTypes from 'prop-types';\n\ndescribe('<Foo />', () => {\n  it('renders three `.foo-bar`s', () => {\n    const wrapper = render(<Foo />);\n    expect(wrapper.find('.foo-bar')).to.have.lengthOf(3);\n  });\n\n  it('rendered the title', () => {\n    const wrapper = render(<Foo title=\"unique\" />);\n    expect(wrapper.text()).to.contain('unique');\n  });\n\n  it('renders a div', () => {\n    const wrapper = render(<div className=\"myClass\" />);\n    expect(wrapper.html()).to.contain('div');\n  });\n\n  it('can pass in context', () => {\n    function SimpleComponent(props, context) {\n      const { name } = context;\n      return <div>{name}</div>;\n    }\n    SimpleComponent.contextTypes = {\n      name: PropTypes.string,\n    };\n\n    const context = { name: 'foo' };\n    const wrapper = render(<SimpleComponent />, { context });\n    expect(wrapper.text()).to.equal('foo');\n  });\n});\n```","excerpt":"이 글은 아래 링크에 있는 글을 의역 했습니다.\n참조 엔자임은 리엑트를 위한 Javascript Testing 유틸리티 입니다. 리엑트 컴포넌트들의 결과물을 테스트 하기 용이합니다. 또한 출력에 따라 런타임을 조작, 탐색 및 런타임 시뮬레이션 할 수…","fields":{"slug":"/hello-enzyme.md/"},"frontmatter":{"date":"Nov 18, 2019","title":"Hello Enzyme","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이 글은 아래 링크에 있는 글을 의역 했습니다.\n[참조](https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2019-264e19514d0a)\n\n# Test Types\n\n일반적으로 웹사이트를 위한 아주 중요한 테스트 타입들은 다음과 같다.\n\n- **Unit Tests** - 입력을 제공하고 출력이 예상한것과 같은지 확인하여 function들 또는 class들 같은 개별 테스팅 입니다.\n\n```javascript\nexpect(fn(5)).to.be(10)\n```\n\n- **Integration Tests** - 사이드 이펙트를 포함해서 그것들의 목표를 위한 몇몇의 유닛 테스트에서의 절차들을 테스트 합니다.\n\n```javascript\nconst flyDroneButton = document.getElementById('fly-drone-button')\n\nflyDroneButton.click()\n\nassert(isDroneFlyingCommandSent())\n\n//or even\ndrone.checkIfFlyingViaBluetooth().then(isFlying => assert(isFlying))\n```\n\n- **Functional Tests** (또는 e2e 테스트라고 알려져있는) - 웹사이트 또는 브라우저의 컨트롤을 통해서 product 스스로에서 기능 시나리오가 어떻게 작동하는지 테스트 하는 방법입니다. 이 테스트 들은 어플리케이션의 내부 구조는 무시하고 블랙박스처럼 외부 에서 바라보는 것처럼 테스트를 진행합니다.\n\n```\nGo to page \"https://localhost:3303\"\n\nType \"test-user\" in the field \"#username\"\n\nType \"test-pass\" in the field \"#password\"\n\nClick on \"#login\"\n\nExpect Page Url to be https://localhost:3303/dashboard\n\nExpect \"#name\" to be \"test-name\"\n```\n\n# Running Tests\n\n테스트들은 테스트 라이브러리와 테스트를 포함하고 있는 JS들과 함께 HTML 페이지를 만들어서 브라우저에서 테스트가 이루어 집니다.\n\n또한 테스트들은 간단하게 test를 import하고 관련 라이브러리들과 함께 Node.js에서도 실행이 가능합니다.\njsdom은 대게 순수한 자바스크립트를 사용해서 브라우저와 같은 환경에서 시뮬레이션 하기 위해 Node.js에서 사용이 됩니다.\n그것은 window, document, body, location, cookies, selectors 그리고 브라우저 안에서 JS를 돌릴때 얻을 수 있는 어떤 것이든 제공합니다.\n하지만 render들은 실제가 아닙니다. 'headless mode' 와는 차이가 있습니다. 왜냐하면 headless mode를 하기 위해서는 실제 브라우저가 필요하고 jsdom과 다르게 스크린샷을 가질 수 있습니다.\n\n우리는 두번째 방법(Node.js + jsdom) 방법을 추천합니다. 왜냐하면 실제 브라우저에서 테스트 하는 것보다 빠르기 때문입니다. 첫번째 방법이 일상 샐활에서 실제 그려주는 소프트웨어와 같은 것을 사용해서 더 실뢰도가 있긴 하지만 jsdom을 사용하면 가볍고 다양한 케이스들을 충분히 행할 수 있습니다.\n\n# Test Tools Types\n\n테스트 툴들은 다음과 같은 기능들로 나뉘어 집니다. 일부는 하나의 기능 만 제공하고 일부는 조합을 제공합니다.\n가장 유연한 설정 기능을 얻으려면 여러 도구를 함께 사용하는 것이 일반적입니다.\n\n1. **Test launchers** 는 당신의 테스트들을 유저가 CLI 또는 UI 를 이용해서 설정한 노드 또는 브라우저에서 실행하게 합니다.\n    또한 브라우저를 수동으로 열어도 가능합니다. ([Karma](https://karma-runner.github.io/), [Jasmine](http://jasmine.github.io/), [Jest](https://facebook.github.io/jest/), [TestCafe](https://github.com/DevExpress/testcafe), [Cypress](https://www.cypress.io/))\n\n2. **Testing structure** 는 당신의 테스트 파일들을 정렬할 수 있도록 도와줍니다. ([Mocha](https://mochajs.org/), [Jasmine](http://jasmine.github.io/), [Jest](https://facebook.github.io/jest/), [Cucumber](https://github.com/cucumber/cucumber-js), [TestCafe](https://github.com/DevExpress/testcafe), [Cypress](https://www.cypress.io/))\n\n3. **Assertion functions** 기대한 값과 테스트 결과 값을 비교합니다. ([Chai](http://chaijs.com/), [Jasmine](http://jasmine.github.io/), [Jest](https://facebook.github.io/jest/), [Unexpected](http://unexpected.js.org/), [TestCafe](https://github.com/DevExpress/testcafe), [Cypress](https://www.cypress.io/))\n\n4. **Generate and display test progress and results.** ([Mocha](https://mochajs.org/), [Jasmine](http://jasmine.github.io/), [Jest](https://facebook.github.io/jest/), [Karma](https://karma-runner.github.io/), [TestCafe](https://github.com/DevExpress/testcafe), [Cypress](https://www.cypress.io/))\n\n5. **Mocks, spies, and stubs** 는 테스트들의 특정 부분을 분리하고 그것들의 사이드 이펙트 들과 분리시켜 주기 위해 사용합니다. ([Sinon](http://sinonjs.org/), [Jasmine](http://jasmine.github.io/), [enzyme](http://airbnb.io/enzyme/docs/api/), [Jest](https://facebook.github.io/jest/), [testdouble](https://testdouble.com/))\n\n6. **Generate and compare snapshots** 는 이전 수행에서의 의도로 부터 컴포넌트와 데이터 구조의 변화를 확인하기 위해 사용합니다. ([Jest](https://facebook.github.io/jest/), [Ava](https://github.com/avajs/ava))\n\n7. **Generate code coverage** 당신의 테스트로 인해 코드가 어느정도 커버가 되는지에 대한 코드의 양을 알 수 있습니다. ([Istanbul](https://gotwarlost.github.io/istanbul/), [Jest](https://facebook.github.io/jest/), [Blanket](http://blanketjs.org/))\n\n8. **Browser Controllers** Functional Tests를 위한 유저 액션을 시뮬레이션 합니다. ([Nightwatch](http://nightwatchjs.org/), [Nightmare](http://www.nightmarejs.org/), [Phantom](http://phantomjs.org/)**,** [Puppeteer](https://github.com/GoogleChrome/puppeteer), [TestCafe](https://github.com/DevExpress/testcafe), [Cypress](https://www.cypress.io/))\n\n9. **Visual Regression** **Tools** 는 이미지 비교 기술을 사용하여 사이트를 이전 버전과 시각적으로 비교하는 데 사용됩니다. ([Applitools](https://applitools.com/), [Percy](https://percy.io/), [Wraith](http://bbc-news.github.io/wraith/), [WebdriverCSS](https://github.com/webdriverio-boneyard/webdrivercss))\n\n위에서 언급 한 용어 중 일부를 설명해 보겠습니다.\n\n**Test launchers** 들은 테스트 리스트를 받습니다. 그리고 이 테스트들을 돌리기 위한 다양한 설정과 발판들이 필요로 합니다. ( 어떤 브라우저에서 돌아갈지, 어떤 바벨 플러그인을 사용할지, 어떤 포멧으로 결과가 나올지 등등)\n\n```\n# Install Karma:\nnpm install karma --save-dev\n\n# Install plugins that your project needs:\nnpm install karma-jasmine jasmine-core karma-chrome-launcher karma-firefox-launcher --save-dev\n\n# Run on\nnpx karma start karma.conf.js --log-level debug --single-run\n```\n\n```javascript\n// karma.conf.js\nmodule.exports = function(config) {\n  config.set({\n    basePath: '../..',\n    frameworks: ['jasmine'],\n    autoWatch: true,\n    browsers: ['Firefox', 'Chrome'],\n    files: [\n      // simple pattern to load the needed testfiles\n      // equal to {pattern: 'test/unit/*.spec.js', watched: true, served: true, included: true}\n      'test/unit/*.spec.js',\n    ],\n    //...\n  })\n}\n```\n\n**Testing structure**는 테스트 구조를 언급합니다. 요즘 테스트는 일반적으로 행동 중심 개발 (BDD)을 지원하는 BDD 구조로 구성됩니다. 종종 다음과 같이 보입니다.\n\n```javascript\ndescribe('calculator', function() {\n  // describes a module with nested \"describe\" functions\n  describe('add', function() {\n    // specify the expected behavior\n    it('should add 2 numbers', function() {\n       //Use assertion functions to test the expected behavior\n       ...\n    })\n  })\n})\n```\n\n**Assertion functions**은 테스트 된 변수에 예상 값이 포함되도록하는 데 사용됩니다.\n그들은 일반적으로 다음과 같이 보입니다. 처음 두 스타일이 가장 일반적입니다.\n\n```javascript\n// Chai expect (popular)\nexpect(foo).to.be.a('string')\nexpect(foo).to.equal('bar')\n\n// Jasmine expect (popular)\nexpect(foo).toBeString()\nexpect(foo).toEqual('bar')\n\n// Chai assert\nassert.typeOf(foo, 'string')\nassert.equal(foo, 'bar')\n\n// Unexpected expect\nexpect(foo, 'to be a', 'string')\nexpect(foo, 'to be', 'bar')\n```\n\n**Spies** 는 우리에게 함수에 대한 정보를 제공합니다. 예를 들면 얼마나 많이 호출이 되었는지 어느 케이스에 누가 호출했는지에 대한 정보를 알려줍니다. 즉, 해당 함수에 스파이를 심어서 정보를 빼내오는 것입니다.\n\nSpies 들은 기대가 되는 프로세스의 사이드 이팩트를 확인하기 위해서 통합 테스트에서 사용됩니다. 예를 들면, 일부 프로세스 동안에 계산 함수가 몇 번이나 호출이 되었는가? 에 대한 확인을 할 수 있습니다.\n\n`father.execute()`가 어떻게 동작하는지 알아보고 `father.child`가 이 프로세스에서 몇번 동작하는지 세어봅시다.\n\n```javascript\nclass Child {\n  ...\n  execute() { ... }\n  ...\n}\n\nclass Father {\n  constructor() {\n    this.child = new Child()\n  }\n  ...\n  execute() {\n    ...\n    this.child.execute()\n    ...\n    this.child.execute()\n    ...\n  }\n  ...\n}\n\nit('should call child execute twice when father executes', () => {\n  const father = new Father()\n\n  // create a sinon spy to spy on object.method\n  const childSpy = sinon.spy(father.child, 'execute')\n\n  // call the method with the argument \"3\"\n  father.execute()\n\n  // make sure child.execute was called twice\n  assert(childSpy.calledTwice)\n})\n```\n\n**Stubbing or dubbing** 는 테스트 중에 예상되는 동작을 보장하기 위해 기존 모듈의 선택된 방법을 사용자 제공 기능으로 대체합니다.\n\n다른 컴포넌트를 테스트하는 도중에 `user.isValid()`가 항상 `true` 인것을 보장받기 위해서 다음과 같이 할 수 있습니다.\n\n```javascript\n// Sinon\nsinon.stub(user, 'isValid').returns(true)\n\n// Jasmine stubs are actually spies with stubbing functionallity\nspyOn(user, 'isValid').andReturns(true)\n\n// Testing someFn with user where user.isValid() returns true\nassert(someFn(user))\n```\n\n**Mocks or Fakes** 들은 프로세스의 다른 부분을 테스트하기 위해 특정 모듈이나 동작을 위조하는 데 사용됩니다.\n\n예를 들면, Sinon 에서는 특정 테스트 플로우를 테스트할때 빠르고 예상되는 응답을 보장하는 오프라인인 fake 서버를 만들 수 있습니다.\n\n```javascript\nit('returns an object containing all users', done => {\n  // create and configure the fake server to replace the native network call\n  const server = sinon.createFakeServer()\n  server.respondWith('GET', '/users', [\n    200,\n    { 'Content-Type': 'application/json' },\n    '[{ \"id\": 1, \"name\": \"Gwen\" },  { \"id\": 2, \"name\": \"John\" }]',\n  ])\n\n  // call a process that includes the network request that we mocked\n  Users.all().done(collection => {\n    const expectedCollection = [\n      { id: 1, name: 'Gwen' },\n      { id: 2, name: 'John' },\n    ]\n    expect(collection.toJSON()).to.eql(expectedCollection)\n    done()\n  })\n\n  // respond to the request\n  server.respond()\n\n  // remove the fake server\n  server.restore()\n})\n```\n\n**Snapshot Testing** 은 기대되는 결과 값이랑 데이터 구조를 비교할 때 사용합니다.\n\n공식 Jest 문서의 다음 예에서 특정 `Link` 컴포넌트의 스냅샷 테스트를 보여줍니다.\n\n```javascript\nit('renders correctly', () => {\n  // create an instance of the Link component with page and child text\n  const linkInstance = <Link page=\"http://www.facebook.com\">Facebook</Link>\n\n  // create a data snapshot of the component\n  const tree = renderer.create(linkInstance).toJSON()\n\n  // compare the sata to the last snapshot\n  expect(tree).toMatchSnapshot()\n})\n```\n\n이것은 사실 렌더가 되는것이 아니고 컴포넌트의 그림을 찍는 것입니다. 하지만 그것은 분리된 파일로 내부 데이터를 저장합니다.\n\n```\nexports[`renders correctly 1`] = `\n<a\n  className=\"normal\"\n  href=\"http://www.facebook.com\"\n  onMouseEnter={[Function]}\n  onMouseLeave={[Function]}\n>\n  Facebook\n</a>\n`;\n```\n\n테스트가 동작할때, 새로운 스냅샷은 마지막에 찍었던것과 비교합니다. 개발자는 변화가 의도된 것인지 확인하는 알림을 받습니다.\n\n![https://miro.medium.com/max/2000/0*wqUDMDebG-ipMs5d.png](https://miro.medium.com/max/2000/0*wqUDMDebG-ipMs5d.png)\n\n> 스냅샷은 대게 컴포넌트의 표현 데이터를 비교하는데 사용하지만 다른 데이터 타입과 비교하는데에도 쓰입니다. redux stores 또는 어플리케이션의 다른 유닛의 내부 구조 같은 곳에서도 쓰입니다.\n\n브라우저는 그 위에 설치된 드라이버로 제어 할 수 있으며 다른 방법을 사용하여 브라우저를 제어 할 수 있습니다. 이것이 셀레늄의 작동 방식입니다.\n\n```\nNode.js <=> WebDriver <=> FF/Chrome/IE/Safari drivers <=> browser\n```\n\n또는 전체 어플리케이션의 환경을 접근할 수 있는 JS 코드의 [script injection](https://dzone.com/articles/testcafe-e2e-testing-tool) 는 유저의 행동 시뮬레이션과 같은 이벤트를 발생 시킬 수 있습니다.\n\n```javascript\ndocument.getElementByID('someButton').dispatchEvent(clickEvent).\n```\n\n```\nNode.js <=> FF/Chrome/IE/Safari injected script <=> Simulated events\n```\n\n# Putting it All Together\n\n이제 당신이 좋아하는 문법과 테스트 구조와 단언하는 구문의 함수 라이브러리를 선택하고 어떻게 테스트를 진행하길 원하는지를 결정해야 한다.\n\n몇몇 프레임 워크들은 [Jest](https://facebook.github.io/jest/docs/en/snapshot-testing.html), [Jasmine](https://jasmine.github.io/), [TestCafe](https://devexpress.github.io/testcafe/), and [Cypress](https://www.cypress.io/) 이 모든것을 제공합니다.\n\n또한 몇몇 것들은 몇몇 기능만 제공하고 다른 라이브러리와 혼재해서 사용해야 합니다. ([mocha](https://mochajs.org/) + [chai](https://www.chaijs.com/) + [sinon](https://sinonjs.org/))\n\n여기서는 2가지의 다른 프로세스를 생성할것을 제안 합니다. 하나는 **unit and integration tests** 이고 다른 하나는 **Functional Tests** 입니다. 왜냐하면 functional tests는 대게 길고 특별하게 몇몇의 다른 브라우저에서 테스트를 진행해야 하기 때문입니다.\n\n각 유형의 테스트를 실행하는 것이 적절한시기를 생각하십시오. 예를 들면 다음과 같습니다.\n모든 변경에 대한 단위 + 통합, 커밋 전에 만 기능 테스트.\n\n## Unit Tests\n\n이 단위는 응용 프로그램 유틸리티, 서비스 및 도우미의 모든 작은 단위를 포함해야합니다.\n이 모든 단위에 간단하고 엣지 케이스 입력(예상을 벗어난 입력)을 제공하고 어설 션 함수을 사용하여 출력이 예상 한대로 되도록 하십시오.\n또한 코드 적용 범위보고 도구를 사용하여 이 유닛테스가 어느정도 적용되는지 확인하십시오.\n\n유닛 테스트들은 함수형 프로그래밍과 가능하면 순수 함수를 사용하기 위한 한가지 이유이기도 합니다.\n\n당신의 어플리케이션이 순수하면 할수록, 테스트 하기는 점점 쉬워 집니다.\n\n## Integration Tests\n\n구식 테스트는 단위 테스트에 중점을 두 었으며 많은 작은 부품이 작동하지만 전체적으로 프로세스가 계속 실패하는 응용 프로그램이 만들어졌습니다.\n반면에 통합 테스트는 장치가 리팩터링되고 테스트를 통과했지만 해당 프로세스에 실패한 경우를 감지합니다.\n\n![https://miro.medium.com/max/300/1*xHibbXdcePT0GtpeZRgxSA.gif](https://miro.medium.com/max/300/1*xHibbXdcePT0GtpeZRgxSA.gif)\n\n시스템의 각 부분 이상을 개별적으로 테스트하는 것이 중요한 이유에 대한 최고의 데모는이 위대한 GIF에서 볼 수 있습니다.\n\n통합 테스트는 중요한 교차 모듈 프로세스를 포함해야합니다.\n때로는 여러 클래스로부터의 프로세스가 확장되고 프런트-엔드-백-엔드 상호 작용과 같은 다른 시스템을 테스트 하기도 합니다.\n\n단위 테스트와 비교해서 예상되는 side effect를 보장하기 위해 **spies**를 사용하는것이 이득이 될 것입니다. 그리고 **stubs**은 특정 프로세스에 포함되지 않은 프로세스의 한 부분을 mock과 modify 위해 사용하는 것이 이득이 될 것입니다.\n\n또한 단위 테스트와 달리 창에 액세스하려면 브라우저 또는 브라우저와 유사한 환경 (jsdom)이 필요할 수 있습니다.\n\n**구성 요소 스냅 샷 테스트**도 이 범주에 속합니다. 프로세스가 브라우저 나 브라우저와 유사한 환경에 프로세스를 실제로 렌더링하지 않고 선택된 컴포넌트에 프로세스가 어떻게 영향을 미치는지 테스트 할 수있는 방법을 제공합니다.\n\n## Functional Tests\n\n때때론 빠르고 효과적인 unit and integration tests가 충분치 않을 때도 있습니다.\n\nFunctional tests 는 브라우저를 컨트롤 합니다. 그리고 유저의 행동을 이들의 환경에서 시뮬레이션 합니다. (clicking, typing, scrolling etc…) 그리고 end user의 시야로 실제 시나리오를 행합니다.\n\n또한 많은 서비스가 이러한 테스트를 실행할 장치와 브라우저를 제공한다는 점에 주목할 가치가 있습니다.\n이와 같은 더 많은 서비스가 있습니다.\n\n**Visual regression testing tools**(시각적 회귀 테스트 도구) 를 설정하여 스크린 샷을 스마트하게 비교하여 응용 프로그램의 다른 화면이 시각적으로 괜찮은지 ( 브라우저 마다의 차이점을 비교 - 흡싸 틀린그림 찾기 ) 확인할 수 있습니다. 이 스크린 샷은 일반적으로 기능 테스트의 일부로 또는 별도의 브라우저 자동화 세션을 실행하여 수행됩니다.\n\n![https://miro.medium.com/max/600/1*U8eW7J15E1GIBMQuvmMWVA.gif](https://miro.medium.com/max/600/1*U8eW7J15E1GIBMQuvmMWVA.gif)\n\n# List of General Prominent Testing Tools\n\n거기에는 수십 가지 훌륭한 도구가 있습니다. 여기에 모든 것을 포함시킬 수는 없었지만 다음 목록에 알아야 할 가장 중요하고 가장 잘 관리되는 도구와 가장 채택 된 도구를 포함 시키려고 했습니다.\n\n### jsdom\n\n[jsdom](https://github.com/jsdom/jsdom?source=post_page-----264e19514d0a----------------------)\n\n\n**jsdom**은 WHATWG DOM 및 HTML 표준의 JavaScript 구현입니다. 즉, jsdom은 일반 JS 이외의 것을 실행하지 않고 브라우저 환경을 시뮬레이션합니다.\n\n이전에도 말했듯이, 이 브라우저 환경 시뮬레이션에서 test를 진행하는 것은 매우 빠릅니다. jsdom의 단점은 실제 브라우저 외부에서 모든 것을 시뮬레이션 할 수 없다는 것입니다 (예 : 스크린 샷을 찍을 수 없음).이를 사용하면 테스트 범위가 제한 될 수 있습니다.\n\nJS 커뮤니티는 jsdom을 빠르게 향상시키고 현재 버전은 실제 브라우저와 매우 가깝습니다.\n\n### Electron\n\n[Electron](https://github.com/electron/electron?source=post_page-----264e19514d0a----------------------)\n\n**Electron framework** 은 자바스크립트와 HTML 과 CSS를 사용해서 데스크탑의 여러 플랫폼을 작성할 수 있습니다. 이것 또한 headless mode (창이 없이 화면을 그려주는 작업을 가상으로 진행해주는 방법) 입니다.\n\n방대한 커뮤니티가 있고 매우 중요한 어플리케이션들이 이 위에 구축되어 있습니다. 그래서 따라서 최신 상태를 유지해야합니다. [Atom](https://atom.io/), [Slack](http://slack.com/), [Skype](https://www.macstories.net/news/microsoft-releases-cross-platform-skype-update-and-announces-call-recording-and-other-features/), [GitHub Desktop](https://desktop.github.com/) 에서 사용하고 있습니다.\n\n[Cypress.io] (https://www.cypress.io/)와 같은 테스트 도구는 Electron을 사용하여 브라우저를 최대한 제어하여 테스트를 시작합니다.\n\n### Istanbul\n\n[Istanbul, a JavaScript test coverage tool.](https://istanbul.js.org/?source=post_page-----264e19514d0a----------------------)\n\n**Istanbul** 은 너에게 유닛 테스트가 너의 코드를 커버하는지에 대한 수치를 말해줍니다. 이것은 구문, 라인, 함수, 브랜치에 퍼센테이지로 적용이 되며 그래서 커버할게 무엇이 남았는지를 이해할 수 있습니다.\n\n### Karma\n\n[Karma — Spectacular Test Runner for Javascript](https://karma-runner.github.io/2.0/index.html?source=post_page-----264e19514d0a----------------------)\n\n**Karma** 는 페이지의 환경에서 테스트를 실행하기 위해 특수 웹 페이지가있는 테스트 서버를 호스팅합니다. 이 페이지는 많은 브라우저와 jsdom을 포함한 브라우저와 유사한 환경에서 실행될 수 있습니다.\n\n### Chai\n\n[Chai](https://github.com/chaijs/chai?source=post_page-----264e19514d0a----------------------)\n\n**Chai** 는 가장 유명한 assertion 라이브러리 입니다. 많은 플러그인과 확장 기능이 있습니다.\n\n### Unexpected\n\n[Unexpected](https://github.com/unexpectedjs/unexpected?source=post_page-----264e19514d0a----------------------)\n\n**Unexpected** 는 Chai와 약간 다른 문법을지닌 assertion 라이브러리 입니다. 또한 확장가능 하므로 [unexpected-react] (https://github.com/bruderstein/unexpected-react)와 같은 라이브러리를 사용하여 어설 션을 더욱 발전시킬 수 있습니다.\n\n### Sinon.JS\n\n[Standalone test spies, stubs and mocks for JavaScript. Works with any unit testing framework.](http://sinonjs.org/?source=post_page-----264e19514d0a----------------------)\n\n**Sinon** 는 매우 강력한 어떤 모든 테스팅 프레임워크에서 작동하는 자바스크립트를 위한 독립형 테스트 spies, stubs 그리고 mocks 을 제공합니다.\n\n### testdouble.js\n\n[A minimal test double library for TDD with JavaScript](https://github.com/testdouble/testdouble.js?source=post_page-----264e19514d0a----------------------)\n\n**testdouble**는 Sinon이하는 일을하는 덜 인기있는 라이브러리입니다. 디자인, 철학 및 기능에 몇 가지 차이점이있어 많은 경우에 유용하게 사용할 수 있습니다. \n\n여기를 읽어 보세요. [here](https://www.sitepoint.com/javascript-testing-tool-showdown-sinon-js-vs-testdouble-js/), [here](https://spin.atomicobject.com/2016/03/21/javascript-mocking-testdouble/) and [here](http://blog.testdouble.com/posts/2016-03-13-testdouble-vs-sinon.html).\n\n### Wallaby\n\n[Integrated Continuous Test Runner for JavaScript](https://wallabyjs.com/?source=post_page-----264e19514d0a----------------------)\n\n**Wallaby**는 언급할 가치가 있는 또 다른 도구 입니다. 무료는 아닙니다만 많은 유저들이 사는것을 추천합니다. 이것은 IDE에서 동작하며 변경된 코드와 관련된 test를 동작시키며 코드와 함께 실시간으로 장애가 발생했는지 여부를 나타냅니다.\n\n!(https://miro.medium.com/max/1612/1*b-jNPVyrwyAJssbHNYPwtQ.png)[https://miro.medium.com/max/1612/1*b-jNPVyrwyAJssbHNYPwtQ.png]\n\n### Cucumber\n\n[Cucumber](https://github.com/cucumber/cucumber-js?source=post_page-----264e19514d0a----------------------)\n\n**Cucumber** 는 Gherkin 구문을 사용하는 승인된 파일 과 그것들과 부합하는 테스트로 나누어서 BDD 테스팅 작성을 도와줍니다.\n\n테스트들은 우리가 집중하고있는 JS를 포함한 프레임 워크에서 지원하는 다양한 언어로 작성될 수 있습니다.\n\n```feature\n// like-article.feature\nFeature: A reader can share an article to social networks\n  As a reader\n  I want to share articles\n  So that I can notify my friends about an article I liked\nScenario: An article was opened\n    Given I'm inside an article\n    When I share the article\n    Then the article should change to a \"shared\" state\n```\n\n```javascript\n// like-article.steps.js\nmodule.exports = function() {\n  this.Given(/^I'm inside an article$/, function(callback) {\n    // functional testing tool code\n  })\n  \n  this.When(/^I share the article$/, function(callback) {\n    // functional testing tool code\n  })\n    \n  this.Then(/^the article should change to a \"shared\" state$/, function(callback) {     \n    // functional testing tool code\n  }) \n}\n```\n\n많은 팀이이 구문을 TDD보다 편리하게 사용할 수 있습니다.\n\n# Choose Your Unit and Integration Tests Framework\n\n- 간단히 말해서, 만약 그냥 시작하고 싶다거나 대형 프로젝트에 빠른 프레임워크를 찾고 있다면 **Jest** 와 함께 라면 잘못 가지 않을 것입니다.\n\n- 만약 확장가능하고 매우 유연한 설정을 원한다면, go with **Mocha**.\n\n- 간단함을 원한다면 go with **Ava**.\n\n- 진정한 low-level을 원한다면, go with **tape**.\n\n### Jest\n\n[Painless JavaScript Testing](https://facebook.github.io/jest/?source=post_page-----264e19514d0a----------------------)\n\n**Jest** 는 페이스북에서 만들고 유지하고있는 테스팅 프레임워크 입니다. 급격한 인기로 2017년에 가장 유명한 라이브러리가 되었습니다.\n\n후에 이야기할 **Jasmin**을 기반으로 만들어 졌습니다. 후에 페이스북은 대부분의 기능을 대체했으며 그 위에 많은 특징들을 추가했습니다.\n\n- **Performance** - 가장 먼저 Jest는 영리한 병렬 테스트 메커니즘을 구현하여 테스트 파일이 많은 대규모 프로젝트의 경우 더 빠른 것으로 간주됩니다.\n- **UI** - 깔끔하고 편리합니다.\n- **Ready-To-Go** - [Sinon](https://sinonjs.org/)과 같은 라이브러리에 해당하는 assertion, spies, 그리고 mock 들이 탑재 되어 있습니다. 고유 한 기능이 필요한 경우에도 라이브러리를 쉽게 사용할 수 있습니다.\n- **Globals** - Jasmine 과 같이 기본적으로 메서드와 객체가 글로벌하게 생성이 됩니다. 그래서 별도의 요구가 필요하지 않습니다. 테스트의 유연성과 제어력이 떨어지기 때문에 이는 잘못된 것으로 간주 될 수 있습니다. 하지만 대부분 케이스에서 이것은 삶을 평온하게 만듭니다.\n\n```javascript\n// \"describe\" is in the global scope already\n// so no these require lines are **not required**:\n// import { describe } from 'jest'\n// import { describe } from 'jasmine'\n\ndescribe('calculator', function() {\n  ...\n})\n```\n\n- **Snapshot testing** - jest-snapshot은 페이스북에 의해 개발되어지고 유지되어져 왔습니다. 도구의 프레임 워크 통합의 일부로 또는 올바른 플러그인을 사용하여 거의 모든 다른 프레임 워크에서 사용할 수 있습니다.\n- **Improved modules mocking** - Jest는 테스트 속도를 향상시키기 위해 무거운 모듈을 mock하는 쉬운 방법을 제공합니다. 예를 들어, 네트워크 요청을하지 않고 promise를 resolve하기 위해 서비스를 mocked 할 수 있습니다.\n- **Code coverage** - Istanbul 기반의 매우 강력하고 빠른 코드 커버리지를 포함하고 있습니다.\n- **Reliability** - 젋은 라이브러리 이지만 2017년, 2018년을 통해서 Jest는 안정화 되어있고 신뢰를 받고있다. 현재는 메이저 IDE와 툴들에서 지원을 하고 있습니다.\n- **Development** - jest는 오직 파일 업데이트로 test들을 watch모드로 매우 빠르게 동작합니다.\n\n### jasmine\n\n[jasmine](https://github.com/jasmine/jasmine?source=post_page-----264e19514d0a----------------------)\n\n**Jasmine**은 Jest의 기반이 되는 테스팅 프레임워크 입니다. 왜 Jest보다 Jasmine을 선호 할까요? 그것은 더 오래 되었고 더 많은 기사와 툴, 그리고 수년에 걸친 커뮤니티에서 생성된 수 많은 질문과 답이 있기 때문입니다.\n\n또한 Angular는 아직도 Jest보다 이것을 사용하는것을 추천합니다. 비록 Jest는 Angular 테스트를 실행하는 데 완벽하게 적합하지만 많은 사람들이 jasmine을 사용합니다.\n\n\n-   **Ready-To-Go** - 테스트를 시작하는 데 필요한 모든 것이 포함되어 있습니다.\n-   **Globals** - 글로벌 스코프에 중요한 모든 테스트 기능이 제공됩니다.\n-   **Community** -  2009 년부터 시장에 출시되었으며 이를 바탕으로 한 수많은 기사, 제안 및 도구를 수집했습니다.\n-   **Angular** - 모든 버전에 대해 Angular가 널리 지원되며  and [official Angular documentation](https://angular.io/guide/testing)에서 권장합니다.\n\n### mocha\n\n[mocha](https://github.com/mochajs/mocha?source=post_page-----264e19514d0a----------------------)\n\n**Mocha** 는 Jasmine과 달리 많이 사용하는 라이브러리 입니다. 제 3의 assertion, mocking, spying tools과 함께 사용되어 집니다. (대게 Sinone 과 Chai)\n\nMocha는 셋업이 어렵고 더 많은 라이브러리로 나눠져 있지만 더 유연하고 확장이 가능합니다.\n\n예를 들면 만약 특별한 assertion logic을 원한다면 Chai를 fork 해서 원하는 자신만의 Chai assertion 라이브러리로 대체할 수 있습니다. 이것 또한 Jasmine에서 할 수 있지만 Mocha가 이런 변경은 좀 더 명확하고 명백합니다.\n\n-   **Community** - 고유 한 시나리오를 테스트하기위한 많은 플러그인과 확장 기능이 있습니다.\n-   **Extensibility** - 플러그인, 확장 및 라이브러리가 그 위에서 만 실행되도록 설계된 지점까지 매우 확장 가능합니다.\n-   **Globals** - 기본적으로 테스트 구조 전역을 작성하지만 분명히 Jasmine과 같은 assertions, spies and mocks는 아닙니다. \n\n### AVA\n\n[AVA](https://github.com/avajs/ava?source=post_page-----264e19514d0a----------------------)\n\n**Ava**는 테스트를 병렬로 실행하는 최소한의 테스트 라이브러리입니다.\n\n- **Ready-To-Go** - 테스트를 시작하는 데 필요한 모든 것이 포함되어 있습니다 (쉽게 추가 할 수있는 스파이 및 더빙 외에). 테스트 구조 및 어설 션에 다음 구문을 사용하고 Node.js에서 실행됩니다.\n\n```javascript\nimport test from 'ava'\n\ntest('arrays are equal', t => {\n  t.deepEqual([1, 2], [1, 2])\n})\n```\n\n- **Globals** - 위에서 본 것처럼 테스트 전역을 만들지 않으므로 테스트를 더 많이 제어 할 수 있습니다.\n- **Simplicity** - 많은 고급 기능을 지원하면서 복잡한 API가없는 간단한 구조 및 어설 션.\n- **Development** - Ava는 업데이트 된 파일 만 업데이트하므로 테스트는 watch 모드에서 빠르게 실행됩니다.\n- **Speed** - 별도의 Node.js 프로세스로 테스트를 병렬로 실행합니다.\n- **Snapshot testing** [프레임 워크의 일부로 지원됩니다](https://github.com/avajs/ava#snapshot-testing).\n\n### tape\n\n[tap-producing test harness for node and browsers](https://github.com/substack/tape?source=post_page-----264e19514d0a----------------------)\n\n**Tape**가 가장 간단합니다. 매우 짧고 \"포인트까지\" API를 사용하여 노드로 실행하는 JS 파일 일뿐입니다.\n\n\n- **Simplicity** - Ava보다 훨씬 더 복잡한 API가 없는 최소 구조 및 assertions .\n- **Globals** - 테스트 전역을 만들지 않으므로 테스트를보다 강력하게 제어 할 수 있습니다.\n- **No Shared State**  between tests - Tape는 “각각” 과 같은 기능을 사용하여 테스트 모듈성을 보장하고 테스트주기를 최대로 사용자가 제어 할 수 없도록합니다.\n- **No CLI**  is needed - Tape는 JS가 실행할 수있는 곳이면 어디든 실행됩니다.\n\n# Functional Testing Tools\n\n우선, 위에서 언급했듯이 [여기](https://www.keycdn.com/blog/browser-compatibility-testing-tools/) 및 [여기](https://www.guru99.com/top-10-cross-browser-testing-tools.html) 테스트가 실행되는 컴퓨터를 호스팅하고 다른 장치 및 브라우저에서 이러한 테스트를 실행하는 데 도움이되는 서비스 공급자에 대한 훌륭한 기사를 찾을 수 있습니다.\n\n기능 테스트를 위한 도구는 구현, 철학 및 API에서 서로 매우 다르므로 다양한 솔루션을 이해하고 제품에서 테스트하는 데 시간을 투자하는 것이 좋습니다.\n\n* 간단히 말해서, 간단한 설정의 크로스 브라우저 올인원 도구를 사용하여 \"시작하기\"를 원한다면  [**TestCafe**](https://devexpress.github.io/testcafe/).\n\n* 편리한 UI, 명확한 문서화, 멋진 도구 및 전체적으로 재미있는 올인원 도구 기능 테스트 경험을 원한다면  [**Cypress.io**](https://www.cypress.io/).\n\n* 오래되고 입증 된 도구를 선호하는 경우 다음과 같이 \"시작\"할 수 있습니다.  [**Nightwatch.js**](http://nightwatchjs.org/).\n\n* 커뮤니티 지원과 유연성을 극대화하여 오래되고 더 입증 된 도구를 선호하는 경우, [**WebdriverIO**](https://webdriver.io/)  을 사용하십시요.\n\n* 가장 안정적이고 Angular 친화적 인 솔루션을 원한다면 다음을 사용하십시요.  [**Protractor**](https://github.com/angular/protractor).\n\n### selenium\n\n[A browser automation framework and ecosystem.](https://github.com/SeleniumHQ/selenium?source=post_page-----264e19514d0a----------------------)\n\n**Selenium**과 그것에 의존하는 도구는 수년간 기능 테스트 시장을 지배했습니다. 테스트 용으로 특별히 작성되지 않았으며 추가 기능 및 브라우저 확장 프로그램을 사용하여 브라우저를 제어하는 ​​드라이버를 노출시켜 다양한 목적으로 브라우저를 제어 할 수 있습니다.\n\n```\nNode.js <=> WebDriver <=> FF/Chrome/IE/Safari drivers <=> browser\n```\nSelenium WebDriver 는 다양한 방식과 다양한 언어를 이용해서 접근할 수 있습니다. 그리고 몇몇 툴은 실제 프로그래밍 없이도 다룰 수 있습니다.\n\nWebDriver는 테스팅 프레임워크에 삽입할 수 있습니다. 그리고 테스트를 다음과 같이 작성할 수 있습니다.\n\n```javascript\ndescribe('login form', () => {\n \n  before(() => {\n    return driver.navigate().to('http://path.to.test.app/')\n  })\n  \n  it('autocompletes the name field', () => {\n    driver\n      .findElement(By.css('.autocomplete'))\n      .sendKeys('John')\n    \n    driver.wait(until.elementLocated(By.css('.suggestion')))\n    \n    driver.findElement(By.css('.suggestion')).click()\n    \n    return driver\n      .findElement(By.css('.autocomplete'))\n      .getAttribute('value')\n      .then(inputValue => {\n        expect(inputValue).to.equal('John Doe')\n      })\n  })\n  \n  after(() => {\n    return driver.quit()\n  })\n})\n```\n\nWebDriver 자체는 충분할 수 있으며 실제로 일부 사람들은 그대로 사용하는 것이 좋습니다. 하지만 이를 포크하거나 변경하거나 줄임으로써 다양한 라이브러리를 만들어 확장 할 수 있습니다.\n\n그러나 일부 사람들은 직접 사용하지 않는 것을 선호합니다. 셀레늄 라이브러리를 살펴 보세요.\n\n### Protractor\n\n[E2E test framework for Angular apps](https://github.com/angular/protractor?source=post_page-----264e19514d0a----------------------)\n\n**Protractor**는 셀레늄을 감싸고 Angular를 위한 향상된 구문과 특수 내장 후크를 제공하는 라이브러리입니다.\n\n\n- **Angular** - 다른 JS 프레임 워크에서도 성공적으로 사용할 수 있지만 특별한 후크가 있습니다. [Angular official documentation](https://angular.io/guide/testing)  에서는 이 툴을 사용하길 추천합니다.\n- **Error reporting** - Good mechanism.\n- **Support** - TypeScript 지원이 가능하며 라이브러리는 거대한 Angular 팀에 의해 운영되고 유지됩니다.\n\n### WebdriverIO\n\n[Selenium 2.0 bindings for NodeJS](http://webdriver.io/?source=post_page-----264e19514d0a----------------------)\n\n**WebdriverIO** 에는 자체 셀레늄 WebDriver 구현이 있습니다.\n\n- **Syntax** - 매우 쉽고 읽기 쉽습니다.\n- **Flexible** - 매우 간단하며, 유연하고 확장 가능한 라이브러리 입니다.\n- **Community** - 훌륭한 지원과 열정적 인 개발자 커뮤니티가 있습니다.\n\n### Nightwatch\n\n[Nightwatch](http://nightwatchjs.org/?source=post_page-----264e19514d0a----------------------)\n\n**Nightwatch** 에는 자체 셀레늄 WebDriver 구현이 있습니다. 또한 자체 테스트 프레임 워크에 테스트 서버, 어설 션 및 도구를 제공합니다.\n\n- **Framework** - 다른 프레임 워크와 함께 사용할 수도 있지만 다른 프레임 워크의 일부가 아닌 기능 테스트를 실행하려는 경우 특히 유용합니다.\n- **Syntax** - 가장 쉽고 읽기 쉬운 것처럼 보입니다.\n- **Support** - typescript 지원이 없으며 일반적으로이 라이브러리는 다른 라이브러리보다 약간 덜 지원되는 것 같습니다.\n\n### Appium\n\n[:iphone: Automation for iOS, Android, and Windows Apps.](https://github.com/appium/appium?source=post_page-----264e19514d0a----------------------)\n\n\n**Apium**은 다음 도구를 사용하여 모바일 장치에서 웹 사이트를 테스트하기 위해 Selenium과 유사한 API를 제공합니다.\n\n- **iOS 9.3+**: Apple’s  [XCUITest](https://developer.apple.com/reference/xctest)\n- **Before iOS 9.3**: Apple’s  [UIAutomation](https://developer.apple.com/library/ios/documentation/DeveloperTools/Reference/UIAutomationRef/)\n- **Android 4.2+**: Google’s  [UiAutomator/UiAutomator2](http://developer.android.com/tools/help/uiautomator/index.html)\n- **Android 2.3+**: Google’s  [Instrumentation](http://developer.android.com/reference/android/app/Instrumentation.html). (Instrumentation support is provided by bundling a separate project,  [Selendroid](http://selendroid.io/))\n- **Windows Phone**: Microsoft’s  [WinAppDriver](http://github.com/microsoft/winappdriver)\n\n따라서 Selenium 또는 Selenium 기반 도구를 사용하는 경우 Apium을 사용하여 모바일 장치에서 테스트 할 수도 있습니다.\n\n### TestCafe\n\n[Automated browser testing for the modern web development stack](https://devexpress.github.io/testcafe/?source=post_page-----264e19514d0a----------------------)\n\nTestCafe는 셀레늄 기반 도구의 훌륭한 대안입니다. 2016 년 말에 다시 작성되어 오픈 소스로 제공되었습니다.\n\nTestCafe에는 프로그래밍이 아닌 테스트 도구를 제공하는 유료 버전도 있었습니다. 더 이상 사용되지 않으며 새로운 TestCafe Studio로 대체 될 예정입니다. 이 TestCafe Studio는 현재 무료로 제공되지만 몇 달 안에 공식적으로 출시되면 상용 제품이 될 것입니다.\n\nTestCafe는 Selenium처럼 브라우저 자체를 제어하는 ​​대신 JavaScript 스크립트로 웹 사이트에 삽입합니다. 이를 통해 **모바일 장치를 포함한 모든 브라우저**에서 실행할 수 있으며 JavaScript 실행 루프를 완전히 제어 할 수 있습니다.\n\n\n- **Fast to set up** - Npm 으로 설치하고 and 원하는 브라우저에서 첫번째 테스트를 실행할 수 있습니다.\n- **Cross Browser and Devices** - 많은 브라우저와 장치를 지원하며 테스트를위한 장치와 브라우저를 제공하는 [SauceLabs](https://saucelabs.com/) 또는 [BrowserStack](https://www.browserstack.com/)과 함께 사용할 수 있습니다. \n여기에는 [Headless Chrome](https://developers.google.com/web/updates/2017/04/headless-chrome) 및 [Headless Firefox](https://developer.mozilla.org/en-US/Firefox/Headless_mode) 에서 테스트 실행이 포함됩니다. \n- **Parallel Testing** - TestCafe는 [한 번에 여러 브라우저 인스턴스에서 테스트를 실행할 수 있습니다.](https://devexpress.github.io/testcafe/documentation/using-testcafe/common-concepts/concurrent-test-execution.html). 이 연습은 테스트 시간을 크게 단축시킬 수 있습니다.\n- **Convenient Error Reporting**\n- **Own Ecosystem** - [TestCafe는 자체 테스트 구조를 사용합니다](https://testcafe-discuss.devexpress.com/t/interacting-with-browser-using-testcafe-apis-but-without-testcafe-test-runner/300/6). \nUI 테스트는 일반적으로 다른 테스트와는 별도로 실행되기 때문에 매우 편리 할 수 ​​있습니다. [그러나 일부 사람들은 싫어합니다.](https://medium.com/tech-quizlet/cypress-the-future-of-end-to-end-testing-for-web-applications-8ee108c5b255).\n\n```javascript\n// test-cafe-code-example.js\nimport { Selector } from 'testcafe';\n\nfixture `Getting Started`\n    .page `https://devexpress.github.io/testcafe/example`\n\n// Own testing structure\ntest('My first test', async t => {\n    await t\n        .typeText('#developer-name', 'John Smith')\n        .click('#submit-button')\n        .expect(Selector('#article-header').innerText)\n        .eql('Thank you, John Smith!')\n})\n```\n\n### Cypress\n\n[JavaScript End to End Testing Framework](https://www.cypress.io/?source=post_page-----264e19514d0a----------------------)\n\nCypress는 TestCafe의 직접적인 경쟁 업체입니다. 웹 사이트에 테스트를 주입하는 비교적 동일한 작업을 수행하지만 더 현대적이고 유연하며 편리한 방식으로 테스트를 시도합니다.\n\n[차이점]((https://medium.com/yld-engineering-blog/evaluating-cypress-and-testcafe-for-end-to-end-testing-fcd0303d2103))은 Cypress.io가 브라우저에서 자체적으로 실행되고 Cypress는 브라우저 프로세스에서 실제 테스트 코드를 실행하는 반면 TestCafe는 노드에서 실행합니다. Cypress는 브라우저에서 삽입 된 스크립트와의 직렬 통신을 통해 테스트를 제어한다는 것입니다.\n\n\n- [**Parallel testing**](https://docs.cypress.io/guides/guides/parallelization.html#Parallelization-process) 는 버젼 3.10.에서 소개 되었습니다.\n- **Documentation** - 깔끔합니다.\n- 직렬화 없이 **Native access to all your application’s variables** (다른 한편으로 TestCafe는 객체를 JSON으로 바꾸고 텍스트로 Node.js로 보낸 다음 다시 객체로 파싱 함.)\n- **Very convenient running and debugging tools** - 테스트 프로세스의 쉬운 디버깅 및 로깅.\n- **No cross-browser Support** - 현재는 오직 크롬만 지원하고 있습니다. [and not headless](https://github.com/cypress-io/cypress/issues/832). Runs in Electron in headless mode. They  [are working on it as this article is being created](https://github.com/cypress-io/cypress/issues/310). (And we will update the article once they do it)\n- **Some use-cases are missing**  하지만 지속적으로 개발하고 있습니다. 예를들면 [lack of HTML5 drag-n-drop](https://github.com/cypress-io/cypress/issues/857).\n- **Using Mocha**  테스트 구조 제공자는 표준을 사용하고 나머지 테스트와 동일한 구조로 기능 테스트를 빌드 할 수 있습니다.\n\n```javascript\ndescribe('My First Cypress Test', function() {\n  it(\"Gets, types and asserts\", function() {\n    cy.visit('https://example.cypress.io')\n\n    cy.contains('type').click()\n\n    // Should be on a new URL which includes '/commands/actions'\n    cy.url().should('include', '/commands/actions')\n\n    // Get an input, type into it and verify that the value has been updated\n    cy.get('.action-email')\n      .type('fake@email.com')\n      .should('have.value', 'fake@email.com')\n  })\n})\n```\n\n### Puppeteer\n\n[Headless Chrome Node API](https://github.com/GoogleChrome/puppeteer?source=post_page-----264e19514d0a----------------------)\n\n**Puppeteer** 는 Node.js 라이브러리 입니다. 구글에서 디벨롭 하고 있고 크롬 또는 [**Headless Chrome**](https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md) 를 컨트롤 하기 위한 Node.js API 를 제공하고 있습니다.\n\n헤드리스 Chrome은 --headless 플래그와 함께 Chrome v59에 발표 되었으며 일반적으로 Chrome v59 버젼 이상입니다.\nChrome은 헤드리스 모드에서 실행될 때 이를 제어하기위한 API를 노출하며, 앞에서 말했듯이 Puppeteer는 Google이 이를 제어하기 위해 제공하는 JavaScript 도구입니다.\n\nFirefox는 2017 년 말에 헤드리스 모드를 출시했습니다.\n\n다른 테스트 도구또한 Headless Chrome 및 Firefox를 사용할 수도 있습니다. 예를 들면 : TestCafe, Karma, Cypress.\n\n- **Puppeteer**는 비교적 새롭지 만 주변에 도구와 래퍼를 사용하고 개발하는 큰 커뮤니티가 있습니다.\n- 기본이며 최신 Chrome 엔진을 사용하므로 **매우 빠릅니다.**\n- Headless Chrome (Puppeteer도 마찬가지)의 주요 단점 중 하나는 플래시와 같은 [**확장자를 지원하지 않습니다**](https://bugs.chromium.org/p/chromium/issues/detail?id=706008) 아마 플래시는 가까운 장래에는 없을 것입니다.\n\n\n### PhantomJS\n\n[PhantomJS](http://phantomjs.org/?source=post_page-----264e19514d0a----------------------)\n\nPhantom은 크롬 엔진을 구현하여 제어 가능한 Chrome과 같은 헤드리스 브라우저를 만듭니다. Google이 'Puppeteer'를 발표 이전 까지 헤드리스 모드로 실행하는 것이 훌륭한 도구였습니다.\n\n주요 관리자 인 Vitaliy Slobodin은 더 이상 작동하지 않으며 개발이 중단되고 저장소가 보관되었습니다.\n\n### Nightmare\n\n[A high-level browser automation library](https://github.com/segmentio/nightmare?source=post_page-----264e19514d0a----------------------)\n\n**Nightmare**는 매우 간단한 테스트 구문을 제공하는 Functional Testing 라이브러리입니다.\nChromium을 사용하여 브라우저의 동작을 제어하는 ​​Electron을 사용합니다.\n\n최근에 유지되지 않는 것 같습니다. 아마도 “Puppeteer”가 소개 되었기 때문에 동일한 기능을 즉시 사용할 수 있습니다.\n\n### CodeceptJS\n\n[Modern Era Acceptance Testing Framework for NodeJS](https://github.com/codeception/codeceptjs/?source=post_page-----264e19514d0a----------------------)\n\n위에서 논의한 CucumberJS와 마찬가지로 Codecept는 다른 라이브러리 API에 대한 또 다른 추상화를 제공하여 테스트와의 상호 작용이 사용자 행동에 중점을 둔 약간 다른 철학을 사용하도록 합니다.\n\n그 모습은 다음과 같습니다.\n\n```javascript\n// codecept-example.js\nScenario('login with generated password', async (I) => {\n  I.fillField('email', 'miles@davis.com');\n  I.click('Generate Password');\n  const password = await I.grabTextFrom('#password');\n  I.click('Login');\n  I.fillField('email', 'miles@davis.com');\n  I.fillField('password', password);\n  I.click('Log in!');\n  I.see('Hello, Miles');\n});\n```\n\n이 코드를 사용하여 실행할 수있는 라이브러리 목록은 다음과 같습니다. 모두 위에서 논의했습니다.\n\n[WebDriverIO](https://github.com/Codeception/CodeceptJS/blob/master/docs/helpers/WebDriverIO.md), [Protractor](https://github.com/Codeception/CodeceptJS/blob/master/docs/helpers/Protractor.md), [Nightmare](https://github.com/Codeception/CodeceptJS/blob/master/docs/helpers/Nightmare.md), [Appium](https://github.com/Codeception/CodeceptJS/blob/master/docs/helpers/Appium.md), [Puppeteer](https://github.com/Codeception/CodeceptJS/blob/master/docs/helpers/Puppeteer.md).\n\n이 구문이 귀하의 요구에 더 적합하다고 생각되면, 한 번 써보세요.\n\n# Visual Regression Testing\n\n시각적 회귀 테스트 도구는 대략 다음과 같이 구성됩니다.\n\n- CI 용 CLI를 포함하여 브라우저를 자동화하거나 위에서 설명한 기능 테스트 도구의 일부로 실행하기위한 기술 및 통합\n- 스마트 스크린 샷을 이미지 및 DOM 스냅 샷으로 작성\n- 때로는 고급 AI를 사용하여 차이를 발견하기 위한 이미지 및 DOM 비교 기술.\n- 인간이 사용자와 관련된 내용 만 표시하도록 비교 메커니즘을 승인, 거부 및 개선 할 수있는 UI\n\n시장에는 이러한 유형의 도구가 많이 있지만이 분야는 여전히 먼 길을 가고 있다고 생각합니다.\n\n또한 시각적 회귀 테스트 범주의 유료 도구가 무료 도구보다 훨씬 우수하다는 것을 알았습니다.\n\n### Applitools\n\n[Applitools Eyes](https://applitools.com/?source=post_page-----264e19514d0a----------------------)\n\n\n- **설정이 쉽습니다.**\n- AI를 사용하여 비교기술 그리고 차이점에 관하여 사람이 인지할 수 있는 기술 그리고 오 탐지의 차이점과 부정에 대해 매우 강력하게 만듭니다.\n- 위에서 설명한 여러 도구와 편리하게 통합 할 수 있습니다.\n- 신생 기업 및 비영리 단체의 특별 가격을 포함하여 무료 및 유료 유연한 요금제를 제공합니다.\n\n### Percy\n\n[Continuous visual integration for web apps.](https://github.com/percy?source=post_page-----264e19514d0a----------------------)\n\n- **설정이 쉽습니다.**\n- 스마트 **비교 기술**을 사용합니다.\n- 차이점에 관하여 사람이 편리하게 인지 할 수 있습니다.\n- 위에서 설명한 **여러 도구와 편리하게 통합** 할 수 있습니다.\n- 훌륭한 도구와 잘 **통합**되어 있습니다.\n- 무료 및 유료 탄력 요금제가 있습니다.\n\n### Happo\n\n[Happo.io — Cross-browser screenshot testing](https://happo.io/?source=post_page-----264e19514d0a----------------------)\n\nHappo는 유료 시각 회귀 테스트 도구입니다. 변경 전후에 UI 구성 요소의 시각적 모양을 비교하기 위해 CI에 연결됩니다.\n응용 프로그램의 일관된 크로스 브라우저 및 반응 형 스타일을 보장하기 위해 다른 브라우저와 다른 화면 크기에서 스크린 샷을 찍을 수 있습니다.\n\n오픈 소스 프로젝트에 대한 무료 요금제로 지불했습니다.\n\n### LooksSame\n\n[gemini-testing/looks-same](https://github.com/gemini-testing/looks-same?source=post_page-----264e19514d0a----------------------)\n\nYandex는 현재 사용이 중단 된 Gemini와 함께이 라이브러리를 만들었으며 사용하기 쉬운 시각적 회귀 테스트 도구였습니다.\n\nYandex는 이제 WebdriverIO v4 및 Mocha.js를 사용하여 테스트를 실행하고 시각적 조정을 위해 LooksSame을 사용하는 \n[**hermione**](https://github.com/gemini-testing/hermione)로 마이그레이션 했습니다. 위에서 언급 한 유료 도구보다 더 단순하고 제한적이지만 간단한 웹 사이트의 경우 충분할 수 있습니다.\n\nLooksSame은 원하는 방식으로 스크린 샷을 생성하는 한 자체적으로 사용할 수도 있습니다.\n\n### BackstopJS\n\n[BackstopJS](https://github.com/garris/BackstopJS?source=post_page-----264e19514d0a----------------------)\n\nPuppeteer 및 CI를 지원하는 Chrome Headless에서 실행되는 오픈 소스 시각적 회귀 유틸리티입니다.\n\n\n### AyeSpy\n\n[AyeSpy-A visual regression testing tool](https://github.com/newsuk/AyeSpy?source=post_page-----264e19514d0a----------------------)\n\n[News UK](https://www.news.co.uk/)의 [Times Tooling](https://github.com/newsuk) 팀에서 내놓은 오픈소스 유틸리티 입니다.\n\nvisual regression 테스트를 Chrome/Firefox에서 생성하기 위해 selenum docker를 사용합니다.\n\n### reg-suit\n\n[Visual Regression Testing tool.](https://github.com/reg-viz/reg-suit?source=post_page-----264e19514d0a----------------------)\n\n**이미지를 비교**하고 보고서를 생성하여 **클라우드에 저장**하는 오픈 소스 라이브러리입니다. \n**기존 functional test에 시각적 회귀 테스트를 추가**하려는 경우 매우 편리합니다. \n기존 테스트 흐름에 스크린 샷을 찍는 단계를 추가하고 이를 사용하여 이러한 스크린 샷을 비교하십시오.\n\n### Differencify\n\n[Differencify is a library for visual regression testing](https://github.com/NimaSoroush/differencify?source=post_page-----264e19514d0a----------------------)\n\nJest 스냅 샷과 잘 통합 된 Puppeteer 테스트 도구를 사용하는 또 다른 오픈 소스 Chrome Headless 입니다.\n도커에서 실행할 수 있으며 편리한 보고서를 생성합니다.\n\n## No Coding Functional Testing Tools\n\n### testim\n\n[Testim.io | Agile, Self-Healing, Autonomous Testing Solution](https://www.testim.io/?source=post_page-----264e19514d0a----------------------)\n\n별도의 창에서 응용 프로그램을 열고 **브라우저 확장**을 사용하여 응용 프로그램과의 수동 상호 작용을 테스트 시나리오로 기록합니다.\n**machine learning**을 사용하여 테스트 시나리오를 기록하고 검증 할 수 있습니다. \n크로스 브라우저이며 많은 CI 및 협업 도구와 잘 통합되어 있습니다.\n\n무료 및 유료 탄력 요금제가 있습니다.\n\n### Screener\n\n[Automated Visual Testing](https://screener.io/?source=post_page-----264e19514d0a----------------------)\n\n**크롬 확장 프로그램**을 사용하여 테스트를 기록하고 심층적 인 시각적 회귀 보고 기능을 제공합니다. \n**스토리 북과 다른 CI 도구 및 BrowserStack 및 Sauce Labs**와 같은 멋진 통합 기능이 있습니다.\n\n무료가 아닙니다.","excerpt":"이 글은 아래 링크에 있는 글을 의역 했습니다.\n참조 Test Types 일반적으로 웹사이트를 위한 아주 중요한 테스트 타입들은 다음과 같다. Unit Tests - 입력을 제공하고 출력이 예상한것과 같은지 확인하여 function들 또는 class…","fields":{"slug":"/hello-testing.md/"},"frontmatter":{"date":"Nov 14, 2019","title":"Hello Testing","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 지리 공간 정보 시각화\n\n- 지리 공간 데이터는 흔히 접할 수 있는 데이터 범주로서, 도나 군 등 행정구역 형태나, 도시 혹은 사람이 트윗한 장소, 지표면 위성 사진 등의 형태로 제공할 수 있다.\n- 구글 API 등 전용 라이브러리를 사용하는 이유는 주로 구글 스트리트 뷰나 퓨전 테이블등의 생태계 때문이다. 그러나 그런 생태계가 필요 없으면 D3로 지도를 만드는 편이 더 현명하다.\n- 다른 구문이나 추상 계층을 공부할 필요도 없으면 D3 지도가 제공하는 엄청난 융통성을 누릴 수 있기 때문이다.\n\n## 기본 지도 제작\n\n- shapefile은 가장 널리 사용하는 복잡한 지리 데이터 포맷으로, 이즈리사가 개발했으며 데스크톱 GIS(Geographic Information System) 애플리케이션에서 볼 수 있다.\n- GIS(Geographic Information System) 란 인간생활에 필요한 지리정보를 컴퓨터 데이터로 변환하여 효율적으로 활용하기 위한 정보시스템이다.\n- 도형이나 선 등 복잡한 지리 데이터를 다룰 때는 복잡한 데이터 포맷도 다루어야 한다. 그럴때는 GeoJSON을 이용하게 되는데, GeoJSON은 웹 지도 데이터의 표준이다.\n- GeoJSON은 이름에서도 알 수 있듯이 지리 데이터를 JSON 포멧으로 인코딩하는 방법이다.\n- GeoJSON의 featureCollection은 feature라는 JSON 객체들을 담고 있으며, feature 객체는 지형의 경계를 `coordinates` 속성에 저장([경도, 위도])하고, 지형에 대한 메타데이터를 `properties` 속성에 저장한다.\n- 데스트톱 GIS(Geographic Information System) 애플리케이션 [http://qgis.org](http://qgis.org)\n- Postgres에서 실행되는 공간 데이터베이스 [http://postgis.net](http://postgis.net)\n- 지리 공간 데이터를 조작하는 라이브러리 [http://gdal.org](http://gdal.org)\n\n```javascript\n// GeoJSON의 형태\nconst GeoJson = {\n  type: 'FeatureCollection',\n  features: [\n    {\n      type: 'Feature',\n      id: 'AFG',\n      properties: {\n        name: 'Afghanistan',\n      },\n      geometry: {\n        type: 'Polygon',\n        coordinates: [\n          [\n            [61.210817, 35.650072],\n            //...\n          ],\n        ],\n      },\n    },\n  ],\n}\n```\n\n### 투영법\n\n- 지도 제작에서 기본은 투영법이다.\n- GIS에서 투영법은 자구 상의 점을 평면에 렌더링하는 과정을 말한다.\n- 도법(projection)은 구의 특별한 점을 평면에 투영하는 방법이다.\n- 웹 지도에서 가장 널리 사용하는 도법인 메르카토르 도법을 사용한다.\n- 메르카토르 도법을 사용하려면 D3 확장인 d3.geo.projection.js를 추가 해야한다. (v5 버젼에서는 기본 API이다.) 도법을 정의하면 `d3.geoPath`를 이용해서 선택한 도법(projection)에 기초해 지리 데이터를 화면에 그린다.\n- 메르카토르 도법(projection)이 기본적으로 미국을 중심으로 한 일부 세계만 SVG 영역에 투영하도록 설정돼 있기 때문이다.\n- 모든 projection은 SVG에서 사용하는 표준적인 translate()와 scale() 메서드를 지원하지만 도법에 따라 효과가 다르다.\n- projection 이라는 어떤 매개체를 통해서 하나의 데이터와 다른 스페이스의 데이터를 2개를 연결해주는 것이다. \n\n```javascript\n// projection 이 도법\nd3.json('world.geojson').then(data => createMap(data))\n\nfunction createMap(countries) {\n  const aProjection = d3.geoMercator()\n  const geoPath = d3.geoPath().projection(aProjection)\n  d3.select('svg')\n    .selectAll('path')\n    .data(countries.features)\n    .enter()\n    .append('path')\n    .attr('d', geoPath)\n    .attr('class', 'countries')\n}\n```\n\n### 축척\n\n- 메르카토르 도법에서는 사용할 수 있는 공간의 너비를 2로 나눈 값의 몫을 Math.pi로 나누면 화면에 세계 전체를 보여준다.\n- 일반적으로 지도와 도법에 맞는 축척을 알아내려면 여러 값으로 시험해봐야 하지만 확대 기능을 추가하면 더 쉬워진다.\n- 도법에 따라 기본 축적이 다르다.\n- `d3.geoMercator().scale()` 처럼 아무 인자도 전달하지 않고 메서드를 호출하면 기본값을 확인할 수 있다.\n- 아래 코드 처럼 `scale`과 `translate`를 조정하면 우리가 사용하는 지리 데이터의 다른 부분도 투영할 수 있다. 하지만 그린랜드와 남극 등 극에 가까운 지역은 엄청나게 돼곡돼 있다.\n\n```javascript\nd3.json('world.geojson').then(data => createMap(data))\nconst width = 500\nconst height = 500\n\nfunction createMap(countries) {\n  const aProjection = d3\n    .geoMercator()\n    // scale값은 도법에 따라 다르지만, 여기에서는 80이 제대로 작동한다.\n    .scale(80)\n    // 투영 중심을 그림 영역의 중심으로 옮긴다.\n    .translate([width / 2, height / 2])\n  const geoPath = d3.geoPath().projection(aProjection)\n  d3.select('svg')\n    .selectAll('path')\n    .data(countries.features)\n    .enter()\n    .append('path')\n    .attr('d', geoPath)\n    .attr('class', 'countries')\n}\n```\n\n### 지도 위에 점 찍기\n\n- 도시를 아주 크게 표현할 때는 도형으로 표현할 수도 있지만, 일반적으로 도시나 사람은 지도 위에 점으로 표현된다.\n- 인구 수에 비례해 점의 크기를 설정할 수도 있다.\n- D3의 projections은 geoPath()에 사용할 뿐만 아니라 그 자체를 하나의 함수로서 사용할 수도 있다. 경도와 위도 쌍을 담은 배열을 전달해 호출하면 점을 찍을 화면 좌표를 반환한다. 예를 들어 샌프란시스코 ( 대략 경도 37, 위도 -122) 를 찍을 화면 위치를 알고 싶으면 그 값을 projection에 전달해 호출한다.\n\n```javascript\naProjection([37, -122])\n```\n\n```css\nsvg {\n  height: 700px;\n  width: 700px;\n  border: 1px solid gray;\n}\npath.countries {\n  stroke-width: 1;\n  stroke: black;\n  opacity: 0.5;\n  fill: red;\n}\n\ncircle.cities {\n  stroke-width: 1;\n  stroke: black;\n  fill: white;\n}\n\ncircle.centroid {\n  fill: red;\n  pointer-events: none;\n}\n\nrect.bbox {\n  fill: none;\n  stroke-dasharray: 5 5;\n  stroke: black;\n  stroke-width: 2;\n  pointer-events: none;\n}\n\npath.graticule {\n  fill: none;\n  stroke-width: 1;\n  stroke: black;\n}\n```\n\n```javascript\n// projection 이 도법\nPromise.all([d3.json('world.geojson'), d3.csv('cities.csv')]).then(dataList => {\n  const [countries, cities] = dataList\n  createMap(countries, cities)\n})\n\nconst width = 500\nconst height = 500\n\nfunction createMap(countries, cities) {\n  const aProjection = d3\n    .geoMercator()\n    .scale(80)\n    .translate([width / 2, height / 2])\n  const geoPath = d3.geoPath().projection(aProjection)\n\n  d3.select('svg')\n    .selectAll('path')\n    .data(countries.features)\n    .enter()\n    .append('path')\n    .attr('d', geoPath)\n    .attr('class', 'countries')\n    .style('fill', 'gray')\n\n  d3.select('svg')\n    .selectAll('circle')\n    .data(cities)\n    .enter()\n    .append('circle')\n    .style('fill', 'black')\n    .style('stroke', 'white')\n    .style('stroke-width', 1)\n    .attr('r', 3)\n    .attr('cx', function(d) {\n      return aProjection([d.y, d.x])[0]\n    })\n    .attr('cy', function(d) {\n      return aProjection([d.y, d.x])[1]\n    })\n}\n```\n\n### 도법과 영역\n\n- 사용하는 도법에 따라 지리 객체의 화면 크기가 왜곡된다. 이런 문제는 구 위의 좌표를 평면위의 좌표로 완벽하게 표현할 수 없으므로 발생한다.\n- 육지나 해양의 지리학적 영역, 측정 거리, 혹은 특정 도형을 시각적으로 표현하려 다양한 도법을 사용한다.\n- 몰바이데(Mollweide) 도법을 이용하면 가장자리가 몰바이데 곡선에 맞게 휘어진다. 메르카토르 도법은 남극 대륙의 크기를 너무 왜곡해 가장 큰 크기로 만들지만 이와 대조적으로 몰바이데 도법은 지리 데이터에 있는 국가와 대륙의 실제 크기를 유지하지만, 모양과 각도를 왜곡한다.\n- 전통적인 타일 매핑을 이용한 다면 메르카토르 도법을 사용, 전 세계 축척을 유지해야 한다면 일반적으로 지형의 면적을 왜곡하지 않는 몰바이데 도법을 이용하는 편이 좋다.\n- `geoPath()` 는 화면 영역의 크기를 측정하지만 지형의 실제 물리적인 면적을 나타내지는 않는다.\n- 많은 `projection` 을 이용하려면 js 파일을 하나 더 로드 해야 한다. `https://d3js.org/d3-geo-projection.v2.min.js`\n\n```javascript\n// projection 이 도법\nPromise.all([d3.json('world.geojson'), d3.csv('cities.csv')]).then(dataList => {\n  const [countries, cities] = dataList\n  createMap(countries, cities)\n})\n\nconst width = 500\nconst height = 500\n\nfunction createMap(countries, cities) {\n  const aProjection = d3\n    .geoMercator()\n    .scale(80)\n    .translate([width / 2, height / 2])\n\n  const mProjection = d3\n    .geoMollweide()\n    .scale(120)\n    .translate([width / 2, height / 2])\n\n  // const geoPath = d3.geoPath().projection(aProjection);\n  const geoPath = d3.geoPath().projection(mProjection)\n  // 영역의 최소값과 최대값을 구할 수 있다.\n  const featureSize = d3.extent(countries.features, d => geoPath.area(d))\n  // 지형을 측정해 색상 그레이디언트에 정의된 색상을 할당한다.\n  // scaleQuantize : 연속적인 range 대신에 불연속적인걸 사용한다는걸 제외하고는 linear scales 와 유사\n  // colorbrewer : 색상 배열로 정보 시각화에 지도 제작에 유용한 라이브러리\n  // http://colorbrewer2.org/export/colorbrewer.js\n  const countryColor = d3\n    .scaleQuantize()\n    .domain(featureSize)\n    .range(colorbrewer.Reds[7])\n\n  d3.select('svg')\n    .selectAll('path')\n    .data(countries.features)\n    .enter()\n    .append('path')\n    .attr('d', geoPath)\n    .attr('class', 'countries')\n    // 면적에 따라 나라의 색상을 칠한다.\n    .style('fill', d => countryColor(geoPath.area(d)))\n\n  d3.select('svg')\n    .selectAll('circle')\n    .data(cities)\n    .enter()\n    .append('circle')\n    .style('fill', 'black')\n    .style('stroke', 'white')\n    .style('stroke-width', 1)\n    .attr('r', 3)\n    .attr('cx', function(d) {\n      return mProjection([d.y, d.x])[0]\n    })\n    .attr('cy', function(d) {\n      return mProjection([d.y, d.x])[1]\n    })\n}\n```\n\n### 정보 시각화 용어 : 코로플레스 지도\n\n- 코로플레스 지도는 색상으로 데이터를 인코딩하는 지도를 말한다. 예를 들어 색상으로 나라별 GDP, 인구, 주요 언어 등 통계 데이터를 보여줄 수 있다.\n- D3 에서는 `properties` 필드에 정보를 가진 지리 데이터를 사용하거나 지리 데이터와 통계 데이터 테이블 두 개를 연결해 만들 수 있다.\n- 코로플레스 지도 공간 단위 문제가 발생할 수 있으므로 주의해야 한다. 공간 단위 문제는 통계 데이터를 왜곡해서 보여주려 기존 지형에 경계를 그릴 때 발생한다. 자기 당에 유리하도록 선거구를 정하는 게리맨더링은 이런 문제의 대표적인 예다.\n\n### 상호작용성\n\n- D3는 지역을 색칠하려고 영역을 계산하는 것 외에도 유용한 기능이 많다.\n- 지도를 제작할 때는 지리 영역의 중심(도심\\_centroid 라고 한다.)을 계산하는 기능과 경계 샂아를 구하는 기능을 흔히 사용한다.\n- 다음은 각 국가를 에워싼 사각형과 국가의 중심에 빨간 동그라미를 대화형으로 그렸다. 또한 경로에 마우스 오버 이벤트를 추가하고 각 지형의 중심에 원을, 주변에는 경계 상자를 그린다.\n- D3는 가중치로 중심을 계산하므로 경계 상자가 아니라 지형의 중심을 계산한다.\n\n```javascript\n// projection 이 도법\nPromise.all([d3.json('world.geojson'), d3.csv('cities.csv')]).then(dataList => {\n  const [countries, cities] = dataList\n  createMap(countries, cities)\n})\n\nconst width = 500\nconst height = 500\n\nfunction createMap(countries, cities) {\n  const aProjection = d3\n    .geoMercator()\n    .scale(80)\n    .translate([width / 2, height / 2])\n\n  const mProjection = d3\n    .geoMollweide()\n    .scale(120)\n    .translate([width / 2, height / 2])\n\n  // const geoPath = d3.geoPath().projection(aProjection);\n  const geoPath = d3.geoPath().projection(mProjection)\n  // 영역의 최소값과 최대값을 구할 수 있다.\n  const featureSize = d3.extent(countries.features, d => geoPath.area(d))\n  // 지형을 측정해 색상 그레이디언트에 정의된 색상을 할당한다.\n  // scaleQuantize : 연속적인 range 대신에 불연속적인걸 사용한다는걸 제외하고는 linear scales 와 유사\n  // colorbrewer : 색상 배열로 정보 시각화에 지도 제작에 유용한 라이브러리\n\n  const countryColor = d3\n    .scaleQuantize()\n    .domain(featureSize)\n    .range(colorbrewer.Reds[7])\n\n  d3.select('svg')\n    .selectAll('path')\n    .data(countries.features)\n    .enter()\n    .append('path')\n    .attr('d', geoPath)\n    .attr('class', 'countries')\n    // 면적에 따라 나라의 색상을 칠한다.\n    .style('fill', d => countryColor(geoPath.area(d)))\n\n  d3.selectAll('path.countries')\n    .on('mouseover', centerBounds)\n    .on('mouseout', clearCenterBounds)\n\n  function centerBounds(d, i) {\n    const thisBounds = geoPath.bounds(d)\n    const thisCenter = geoPath.centroid(d)\n\n    d3.select('svg')\n      .append('rect')\n      .attr('class', 'bbox')\n      .attr('x', thisBounds[0][0])\n      .attr('y', thisBounds[0][1])\n      .attr('width', thisBounds[1][0] - thisBounds[0][0])\n      .attr('height', thisBounds[1][1] - thisBounds[0][1])\n\n    d3.select('svg')\n      .append('circle')\n      .attr('class', 'centroid')\n      .attr('r', 5)\n      .attr('cx', thisCenter[0])\n      .attr('cy', thisCenter[1])\n  }\n\n  function clearCenterBounds() {\n    d3.selectAll('circle.centroid').remove()\n    d3.selectAll('rect.bbox').remove()\n  }\n}\n```\n\n## 더 나은 지도 제작 기법\n\n- 경위선망은 지도를 더 읽기 좋게 격자를 만든다.\n- zoom 객체는 지도를 이동하거나 확대할 수 있게 해준다.\n- 이 두 기능 모두 D3에서 제공하는 여타 작동이나 생성기와 같은 형식과 기능을 따르며 특히 지도에 도움이 된다.\n\n### 경위선망\n\n- 경위선망(graticule)은 지도 위에 나타난 격자선을 말한다. 선, 영역, 원호 생성기가 있듯이 경위선망도 생성기가 있다.\n- 경위선망 생성기는 격자선(위치와 개수를 지정하거나 기본값을 사용할 수 있다.)을 만들 수 있으며 경계선으로 사용할 수 있는 윤곽선도 만들 수 있다.\n- data() 대신 datum() 이라는 메서드를 사용하는데, datum()은 하나의 데이터점을 배열에 넣을 필요 없이 바로 바인딩하므로 더 편리하다. 즉, datum(yourDatapoint) 는 data([yourDatapoint]) 와 동일하다.\n- 데이터점 하나로 많은 경위선망을 그릴 수 있는 이유는 `geoGraticule`은 다중 선 스트링(multilinestring)이라는 지형을 생성하기 때문이다. 이 다중 선 스트링은 좌표 배열의 배열로서, 배열 안에 있는 각각의 배열은 하나의 개별적인 지형을 나타낸다. 다중 선 스트링과 다중 폴리곤은 GIS에서 늘 사용된다.\n- `d3.geoPath()`은 다중 선 스트링이나 다중 폴리곤을 입력 받으면 여러 개의 분리된 조각으로 구성된 <path> 요소를 그린다.\n- `d3.geoGraticule()`의 리턴 값을 실행(`graticule()`)시키면 GeoJSON MultiLineString geometry 객체가 리턴된다. 이 객체 안에는 경위선망을 위한 모든 자오선과 그에 해당하는 평행선을 가지고 있다.\n\n```javascript\n// 경위선망 추가\n// projection 이 도법\nPromise.all([d3.json('world.geojson'), d3.csv('cities.csv')]).then(dataList => {\n  const [countries, cities] = dataList\n  createMap(countries, cities)\n})\n\nconst width = 500\nconst height = 500\n\nfunction createMap(countries, cities) {\n  const aProjection = d3\n    .geoMercator()\n    .scale(80)\n    .translate([width / 2, height / 2])\n\n  const mProjection = d3\n    .geoMollweide()\n    .scale(120)\n    .translate([width / 2, height / 2])\n\n  // const geoPath = d3.geoPath().projection(aProjection);\n  const geoPath = d3.geoPath().projection(mProjection)\n  // 영역의 최소값과 최대값을 구할 수 있다.\n  const featureSize = d3.extent(countries.features, d => geoPath.area(d))\n  // 지형을 측정해 색상 그레이디언트에 정의된 색상을 할당한다.\n  // scaleQuantize : 연속적인 range 대신에 불연속적인걸 사용한다는걸 제외하고는 linear scales 와 유사\n  // colorbrewer : 색상 배열로 정보 시각화에 지도 제작에 유용한 라이브러리\n\n  const countryColor = d3\n    .scaleQuantize()\n    .domain(featureSize)\n    .range(colorbrewer.Reds[7])\n\n  // 경위선망 추가\n  const graticule = d3.geoGraticule()\n  console.log(graticule)\n  d3.select('svg')\n    .append('path')\n    .datum(graticule)\n    // .datum({\n    //   type:\"MultiLineString\",\n    //   coordinates: [\n    //     [\n    //       [-180, -89.999999],\n    //       [-180, 9.999999974752427e-7],\n    //       [-180, 89.999999]\n    //     ]\n    //   ]\n    // })\n    .attr('class', 'graticule line')\n    .attr('d', geoPath)\n    .style('fill', 'none')\n    .style('stroke', 'lightgray')\n    .style('stroke-width', '1px')\n\n  d3.select('svg')\n    .append('path')\n    .datum(graticule.outline)\n    .attr('class', 'graticule outline')\n    .attr('d', geoPath)\n    .style('fill', 'none')\n    .style('stroke', 'black')\n    .style('stroke-width', '1px')\n\n  // 경위선망 추가\n\n  d3.select('svg')\n    .selectAll('path')\n    .data(countries.features)\n    .enter()\n    .append('path')\n    .attr('d', geoPath)\n    .attr('class', 'countries')\n    // 면적에 따라 나라의 색상을 칠한다.\n    .style('fill', d => countryColor(geoPath.area(d)))\n\n  d3.selectAll('path.countries')\n    .on('mouseover', centerBounds)\n    .on('mouseout', clearCenterBounds)\n\n  function centerBounds(d, i) {\n    const thisBounds = geoPath.bounds(d)\n    const thisCenter = geoPath.centroid(d)\n\n    d3.select('svg')\n      .append('rect')\n      .attr('class', 'bbox')\n      .attr('x', thisBounds[0][0])\n      .attr('y', thisBounds[0][1])\n      .attr('width', thisBounds[1][0] - thisBounds[0][0])\n      .attr('height', thisBounds[1][1] - thisBounds[0][1])\n\n    d3.select('svg')\n      .append('circle')\n      .attr('class', 'centroid')\n      .attr('r', 5)\n      .attr('cx', thisCenter[0])\n      .attr('cy', thisCenter[1])\n  }\n\n  function clearCenterBounds() {\n    d3.selectAll('circle.centroid').remove()\n    d3.selectAll('rect.bbox').remove()\n  }\n}\n```\n\n### 확대\n\n- 화면에서 zoom 객체로 차트를 이동 할 수 있음을 알았다. 이제 zoom 객체로 확대 기능을 사용해보자.\n- 차트를 이동했을 경우에는 <g> 요소의 transfrom 속성을 조절했다. 이제 zoom 객체의 scale값과 translate값을 조절해 투영 설정을 변경함으로써 지도를 확대하고 패닝 시킨다.\n- 이번에는 zoom.scale()로, 더블클릭이나 마우스 휠을 앞으로 이동한 경우에는 확대하고 마우스 횔을 뒤로 이동한 경우에는 축소하도록 설정한다.\n- projection 객체에 zoom을 사용하는 경우에는 projection의 초기 scale 값을 zoom.sacle() 값으로 덮어써야 한다. translate도 이와 동일하게 처리한다. 그런 후 zoom을 발생하는 이벤트가 발생하면 언제든 새로운 값으로 projection 객체를 갱신한다.\n- zoom 에서 선택된 엘리먼트란 zoom 이벤트 핸들러에서 this 값으로 참조하는 엘리먼트 이다.\n- zoom 이벤트 핸들러에서 `d3.zoomTransform(this)` 리턴 값으로 translate와 scale 값을 알아 낼 수 있다.\n- zoom의 translateBy(selection, x, y)는 선택된 엘리먼트의 현재 zoom transform 의 translate 값이 주어진 x, y로 셋팅 되는 것이고 tanslateTo(selection, x, y, [,p])는 선택된 엘리먼트의 현재 zoom transform 의 translate 값이 주어진 p 포인트에 x , y 값이 보여지도록 셋팅 하는 것이다.\n- `d3.select('svg').call(d3.zoom())` 이 코드는 svg 엘리먼트에 scale, translate 변화에 따라서 `__zoom` 프로퍼티를 만들어서 업데이트 하겠다. 라는 뜻이 되겠다. 또한 `__on` 프로퍼티도 생성되어서 어떤 이벤트에 반응할 것인가도 정의해 둔다.\n- zoom에서는 뷰포트 범위의 중심이 기본값이다. 이 중심을 기준으로 k 배수 만큼 늘어난다. 만약 기준점이 (350, 350) 좌표에 있는 뷰포트 라면 (0, 350) 좌표는 스케일이 2개인 상태에서는 (-350, 1050) 좌표에 가있는다.\n- x축 계산식만 본다면 0(전 x축좌표) - 350(기준좌표) = -350(현재 떨어져있는 거리) 여기에 스케일이 2배 이므로 2를 곱해준다.\n- 700 그럼 중간지점에서 부터 -700 거리에 떨어져 있는 좌표를 찍어주면 된다. 기준좌표 350에서 -700이 떨어져 있으므로 -350 인 x 좌표가 나온다. ( (전 x 좌표 - 기준좌표) \\* 배수 + 기준좌표 = 새로운 x 좌표 )\n\n```javascript\n// projection 이 도법\nPromise.all([d3.json('world.geojson'), d3.csv('cities.csv')]).then(dataList => {\n  const [countries, cities] = dataList\n  createMap(countries, cities)\n})\n\nconst width = 700\nconst height = 700\n\nfunction createMap(countries, cities) {\n  const aProjection = d3\n    .geoMercator()\n    .scale(80)\n    .translate([width / 2, height / 2])\n\n  const mProjection = d3\n    .geoMollweide()\n    .scale(120)\n    .translate([width / 2, height / 2])\n\n  // const geoPath = d3.geoPath().projection(aProjection);\n  const geoPath = d3.geoPath().projection(mProjection)\n  // 영역의 최소값과 최대값을 구할 수 있다.\n  const featureSize = d3.extent(countries.features, d => geoPath.area(d))\n  // 지형을 측정해 색상 그레이디언트에 정의된 색상을 할당한다.\n  // scaleQuantize : 연속적인 range 대신에 불연속적인걸 사용한다는걸 제외하고는 linear scales 와 유사\n  // colorbrewer : 색상 배열로 정보 시각화에 지도 제작에 유용한 라이브러리\n\n  const countryColor = d3\n    .scaleQuantize()\n    .domain(featureSize)\n    .range(colorbrewer.Reds[7])\n\n  d3.select('svg')\n    .selectAll('path')\n    .data(countries.features)\n    .enter()\n    .append('path')\n    .attr('d', geoPath)\n    .attr('class', 'countries')\n    // 면적에 따라 나라의 색상을 칠한다.\n    .style('fill', d => countryColor(geoPath.area(d)))\n\n  // 경위선망 추가\n  const graticule = d3.geoGraticule()\n\n  d3.select('svg')\n    .append('path')\n    .datum(graticule)\n    .attr('class', 'graticule line')\n    .attr('d', geoPath)\n    .style('fill', 'none')\n    .style('stroke', 'lightgray')\n    .style('stroke-width', '1px')\n\n  d3.select('svg')\n    .append('path')\n    .datum(graticule.outline)\n    .attr('class', 'graticule outline')\n    .attr('d', geoPath)\n    .style('fill', 'none')\n    .style('stroke', 'black')\n    .style('stroke-width', '1px')\n  // 경위선망 추가\n\n  // 인터렉션\n  d3.selectAll('path.countries')\n    .on('mouseover', centerBounds)\n    .on('mouseout', clearCenterBounds)\n\n  function centerBounds(d, i) {\n    const thisBounds = geoPath.bounds(d)\n    const thisCenter = geoPath.centroid(d)\n\n    d3.select('svg')\n      .append('rect')\n      .attr('class', 'bbox')\n      .attr('x', thisBounds[0][0])\n      .attr('y', thisBounds[0][1])\n      .attr('width', thisBounds[1][0] - thisBounds[0][0])\n      .attr('height', thisBounds[1][1] - thisBounds[0][1])\n\n    d3.select('svg')\n      .append('circle')\n      .attr('class', 'centroid')\n      .attr('r', 5)\n      .attr('cx', thisCenter[0])\n      .attr('cy', thisCenter[1])\n  }\n\n  function clearCenterBounds() {\n    d3.selectAll('circle.centroid').remove()\n    d3.selectAll('rect.bbox').remove()\n  }\n  // 인터렉션\n\n  // zoom\n  const [translateX, translateY] = mProjection.translate()\n  const scaleK = mProjection.scale()\n  const mapZoom = d3.zoom().on('zoom', zoomed)\n\n  // d3.selectAll(\"div\").call(name, \"John\", \"Snow\");\n  // name(d3.selectAll(\"div\"), \"John\", \"Snow\");\n\n  // zoom.transform(selection, transform[, point])\n  // transfrom 설정시 선택된 요소의  current zoom transform 값이 셋팅되고, 시작 즉시 이벤트가 발생된다.\n  // zoom 영역을 설정시에 d3.interpolateZoom 를 사용해서 지정된 transform을 설정한다.\n  // zoom.transfrom 인자의 transfrom 은 Hb의 인스턴스인 transform 객체 또는 transfrom을 리턴하는 함수를 넣어준다.\n  // zoom.transform 인자의 point 로는 두개의 엘리먼트를 갖는 [x,y] 배열 또는 그런 배열을 리턴하는 함수를 넣어준다.\n  d3.select('svg')\n    .call(mapZoom)\n    .call(\n      mapZoom.transform,\n      d3.zoomIdentity.translate(translateX, translateY).scale(scaleK)\n    )\n\n  // zoom 이벤트 처리기를 호출할 때마다\n  // projection translate와 scale() 값을 zoom 객체의 값으로 갱신한다.\n  function zoomed() {\n    // 선택된 엘리먼트의 zoom transform 객체가 리턴\n    // x는 x축 변화량, y는 y축 변화량, k는 scale\n    const { x, y, k } = d3.zoomTransform(this)\n    console.log(d3.zoomTransform(this))\n\n    mProjection.translate([x, y]).scale(k)\n\n    d3.selectAll('path.countries').attr('d', geoPath)\n\n    d3.selectAll('path.line').attr('d', geoPath)\n\n    d3.selectAll('path.outline').attr('d', geoPath)\n  }\n}\n```\n\n### 시멘틱 줌\n\n화면 위의 요소를 확대한다고 할 때는 크기를 확대하는 것이 자연스럽게 떠오른다. 그렇지만 지도로 작업하다 보면 화면을 확대할 때 크기나 해상도만 느는 것이 아니라 화면에 보여줄 데이터의 종류도 변경한다는 것을 알게 된다. 단순한 그래픽 줌과 대비되는 이런 작동 특성을 시멘틱 줌이라고 한다. 예를 들어 축소된 지도에서는 국경과 몇몇 주요 도시만 보이지만, 지도를 확대하면 도로, 중소 도시, 공원 등을 볼 수 있다. 축소됐을 때는 전략이나 전반적인 정보를 보여주고, 확대됐을 때는 상세한 데이터를 보여줄 수 있어야 한다.\n\n지도에 수동 확대 컨트롤 추가\n\n```javascript\nPromise.all([d3.json('world.geojson'), d3.csv('cities.csv')]).then(dataList => {\n  const [countries, cities] = dataList\n  createMap(countries, cities)\n})\n\nconst width = 700\nconst height = 700\n\nfunction createMap(countries, cities) {\n  const aProjection = d3\n    .geoMercator()\n    .scale(80)\n    .translate([width / 2, height / 2])\n\n  const mProjection = d3\n    .geoMollweide()\n    .scale(120)\n    .translate([width / 2, height / 2])\n\n  // const geoPath = d3.geoPath().projection(aProjection);\n  const geoPath = d3.geoPath().projection(mProjection)\n  // 영역의 최소값과 최대값을 구할 수 있다.\n  const featureSize = d3.extent(countries.features, d => geoPath.area(d))\n  // 지형을 측정해 색상 그레이디언트에 정의된 색상을 할당한다.\n  // scaleQuantize : 연속적인 range 대신에 불연속적인걸 사용한다는걸 제외하고는 linear scales 와 유사\n  // colorbrewer : 색상 배열로 정보 시각화에 지도 제작에 유용한 라이브러리\n\n  const countryColor = d3\n    .scaleQuantize()\n    .domain(featureSize)\n    .range(colorbrewer.Reds[7])\n\n  d3.select('svg')\n    .selectAll('path')\n    .data(countries.features)\n    .enter()\n    .append('path')\n    .attr('d', geoPath)\n    .attr('class', 'countries')\n    // 면적에 따라 나라의 색상을 칠한다.\n    .style('fill', d => countryColor(geoPath.area(d)))\n\n  // 경위선망 추가\n  const graticule = d3.geoGraticule()\n\n  d3.select('svg')\n    .append('path')\n    .datum(graticule)\n    .attr('class', 'graticule line')\n    .attr('d', geoPath)\n    .style('fill', 'none')\n    .style('stroke', 'lightgray')\n    .style('stroke-width', '1px')\n\n  d3.select('svg')\n    .append('path')\n    .datum(graticule.outline)\n    .attr('class', 'graticule outline')\n    .attr('d', geoPath)\n    .style('fill', 'none')\n    .style('stroke', 'black')\n    .style('stroke-width', '1px')\n  // 경위선망 추가\n\n  // 인터렉션\n  d3.selectAll('path.countries')\n    .on('mouseover', centerBounds)\n    .on('mouseout', clearCenterBounds)\n\n  function centerBounds(d, i) {\n    const thisBounds = geoPath.bounds(d)\n    const thisCenter = geoPath.centroid(d)\n\n    d3.select('svg')\n      .append('rect')\n      .attr('class', 'bbox')\n      .attr('x', thisBounds[0][0])\n      .attr('y', thisBounds[0][1])\n      .attr('width', thisBounds[1][0] - thisBounds[0][0])\n      .attr('height', thisBounds[1][1] - thisBounds[0][1])\n\n    d3.select('svg')\n      .append('circle')\n      .attr('class', 'centroid')\n      .attr('r', 5)\n      .attr('cx', thisCenter[0])\n      .attr('cy', thisCenter[1])\n  }\n\n  function clearCenterBounds() {\n    d3.selectAll('circle.centroid').remove()\n    d3.selectAll('rect.bbox').remove()\n  }\n  // 인터렉션\n\n  // zoom\n  const [translateX, translateY] = mProjection.translate()\n  const scaleK = mProjection.scale()\n  const mapZoom = d3.zoom().on('zoom', zoomed)\n\n  // d3.selectAll(\"div\").call(name, \"John\", \"Snow\");\n  // name(d3.selectAll(\"div\"), \"John\", \"Snow\");\n\n  // zoom.transform(selection, transform[, point])\n  // transfrom 설정시 선택된 요소의  current zoom transform 값이 셋팅되고, 시작 즉시 이벤트가 발생된다.\n  // zoom 영역을 설정시에 d3.interpolateZoom 를 사용해서 지정된 transform을 설정한다.\n  // zoom.transfrom 인자의 transfrom 은 Hb의 인스턴스인 transform 객체 또는 transfrom을 리턴하는 함수를 넣어준다.\n  // zoom.transform 인자의 point 로는 두개의 엘리먼트를 갖는 [x,y] 배열 또는 그런 배열을 리턴하는 함수를 넣어준다.\n  d3.select('svg')\n    .call(mapZoom)\n    .call(\n      mapZoom.transform,\n      d3.zoomIdentity.translate(translateX, translateY).scale(scaleK)\n    )\n\n  // zoom 이벤트 처리기를 호출할 때마다\n  // projection translate와 scale() 값을 zoom 객체의 값으로 갱신한다.\n  function zoomed() {\n    // 선택된 엘리먼트의 zoom transform 객체가 리턴\n    // x는 x축, y는 y축, k는 scale\n    const { x, y, k } = d3.zoomTransform(this)\n    console.log(d3.zoomTransform(this))\n\n    mProjection.translate([x, y]).scale(k)\n\n    d3.selectAll('path.countries').attr('d', geoPath)\n\n    d3.selectAll('path.line').attr('d', geoPath)\n\n    d3.selectAll('path.outline').attr('d', geoPath)\n  }\n\n  function zoomButton(zoomDirection) {\n    if (zoomDirection === 'in') {\n      d3.select('svg').call(mapZoom.scaleBy, 1.5)\n    }\n\n    if (zoomDirection === 'out') {\n      d3.select('svg').call(mapZoom.scaleBy, 0.75)\n    }\n  }\n\n  d3.select('#controls')\n    .append('button')\n    .on('click', () => zoomButton('in'))\n    .html('Zoom In')\n  d3.select('#controls')\n    .append('button')\n    .on('click', () => zoomButton('out'))\n    .html('Zoom out')\n}\n```\n\n## 고급 지도 제작\n\n- 위 작성된 코드에서 인구에 기초해 <circle> 요소의 크기를 정하거나 <g> 요소로 레이블을 붙일 수도 있을 것이다.\n- 지도를 만들고 있다면 폴리곤과 점으로 경계 상자나 중심을 이용하고 zoom 객체에 연동시킬 것이다.\n- 만약 zoom의 행동을 가진 element가 뒤늣게 mousedown 이벤트를 등록한다면 mousedown 이벤트는 동작하지 않는다. 왜냐하면 zoom 이벤트에서 해당 이벤트를 소비하기 때문이다. 하지만 이벤트 propagation 룰에 의해 zoom 행동을 등록하기 전에 mousedown 이벤트를 등록하거나 이벤트 리스너에 capturing을 사용하거나 자손 element에 non-capturing 으로 등록한다면 mousedown 이벤트가 zoom 이벤트 발생 전에 볼수 있을 것이다. 그리고 `event.stopImmediatePropagation` 으로 zoom의 행동을 막을 수도 있다. 또한 `zoom.filter`를 사용해서 zoom의 행동을 컨트롤 할 수 있다.\n- continuous scale에서 `clamp`는 enable, disable로 설정할 수 있는데 이를 false로 설정할 시 domain에 벗어난 값은 range에서도 벗어난 값을 리턴한다. 그 반대로 true 값을 설정하면 domain에 벗어난 값은 range의 최소 또는 최대 값으로 매핑이 된다.\n- `projection` 객체의 `clipAngle` 속성은 중심에서 일정한 각도 이상을 벗어나는 경로를 `제거(clipping)` 한다.\n- 지구본을 초기화 할 때 나라를 모두 그리지만 그들 중 상당수는 잘려나간다. 그러므로 도형을 그릴때 영역을 계산하는 `geoPath.area(d)` 메서드는 메르카토르 도법에서보다 문제가 더 심하다. 예를 들어 호주가 마다가스카르와 비슷한 크기인 것처럼 색상이 칠해져 있는걸 볼 수 있다.\n- D3는 실제 지형 면적을 계산하는 `d3.geoArea()` 가 있다.\n\n### geoOrthographic 도법으로 지구본 만들기\n\n- `projection에 [longitude, latitude]` 값을 넣어서 실행하면 그려지는 `2D 좌표 값`(typically in pixels)을 리턴해준다.\n- 반대로 `projection.invert` 메서드에 평면 x,y 좌표값 배열(typically in pixels)을 넣어서 실행시키면 도법에 적용된 좌표를 다시 리턴해준다. 예를 들어 `geoOrthographic` 에선 [longitude, latitude] in degress 값을 리턴해준다.\n- Spherical Math 의 `d3.geoCentroid` 메서드는 한 국가의 GeoJSON 객체를 받으면 구 지형의 중심 좌표([경도 , 위도])값을 리턴해준다.\n- 지구본을 회전에 대해 알아두어야 하는 것은 위치는 [경도, 위도]로 표현을 해낼 수 있고 방향은 [lambda, phi, gamma] 로 표현해야 한다는 것이다.\n- 특히 이 방향 표현은 오일러를 사용해서 표현을 하고 있다. 오일러는 3개의 축에 대한 각도를 회전 정보로 사용한다. 예를 들어서 현재 지점의 좌표와 방향을 그리고 다음 지점의 좌표를 안다면 다음 지점의 방향을 구할 수있고 `projection.rotate`에 다음 지점의 방향을 넣어서 회전 시킬 수 있을 것이다.\n- 오일러각은 직각좌표계(Cartesian coordinate system)에서 X, Y, Z 축을 따라 오른손 좌표계 방향으로 각을 정의하고 정해진 순서에 따라 3번 회전 운동을 수행하며 회전 운동을 표현한다. 따라서 미리 회전 순서를 정해주지 않으면 오일러각은 매우 다양하게 정의될 수 있다.\n- 오일러는 직관적이라 사용자의 입력을 받을 수 있는 장점이 있지만 짐벌 락이라는 단점을 지니고 있다. 그래서 쿼터니온이라는 다른 표현을 사용한다. 이때, 사용자에게는 오일러 각을 입력받고 쿼터니온으로 연산을 진행해서 다시 오릴러 각으로 리턴을 받는 식으로 계산한다. 쿼터니온은 오일러 연산에서 발생하는 짐벌락 문제를 말끔히 해결하며 연산속도도 빠르다.\n\n\n```html\n<html>\n  <head>\n    <title>D3 in Action Chapter 5 - Example 7</title>\n    <meta charset=\"utf-8\" />\n    <!-- <script src=\"d3.v3.min.js\" type=\"text/JavaScript\"></script>\n<script src=\"colorbrewer.js\" type=\"text/JavaScript\"></script> -->\n    <script src=\"https://d3js.org/d3.v5.min.js\"></script>\n    <script src=\"https://d3js.org/d3-geo-projection.v2.min.js\"></script>\n    <script src=\"http://colorbrewer2.org/export/colorbrewer.js\"></script>\n    <script src=\"https://unpkg.com/versor\"></script>\n  </head>\n  <style>\n    svg {\n      height: 700px;\n      width: 700px;\n      border: 1px solid gray;\n    }\n    path.countries {\n      stroke-width: 1;\n      stroke: black;\n      opacity: 0.5;\n      fill: red;\n    }\n\n    circle.cities {\n      stroke-width: 1;\n      stroke: black;\n      fill: blue;\n    }\n\n    circle.centroid {\n      fill: red;\n      pointer-events: none;\n    }\n\n    rect.bbox {\n      fill: none;\n      stroke-dasharray: 5 5;\n      stroke: black;\n      stroke-width: 2;\n      pointer-events: none;\n    }\n\n    path.graticule {\n      fill: none;\n      stroke-width: 1;\n      stroke: black;\n    }\n  </style>\n  <body>\n    <div id=\"viz\">\n      <svg></svg>\n    </div>\n    <div id=\"controls\"></div>\n\n    <footer></footer>\n\n    <script>\n      Promise.all([d3.json('world.geojson'), d3.csv('cities.csv')]).then(\n        dataList => {\n          const [countries, cities] = dataList\n          createMap(countries, cities)\n        }\n      )\n\n      const width = 700\n      const height = 700\n\n      function createMap(countries, cities) {\n        // 정사 도법으로 설정하는 코드\n        const oProjection = d3\n          .geoOrthographic()\n          .scale(200)\n          .translate([width / 2, height / 2])\n          //.center([46.72940870961725, -19.301666904193652]) // longitude(경도) and latitude(위도) in degrees\n          // .angle(90);\n          .clipAngle(90) // 둥근 구를 세로로 자르는데 경도 각도를 기준으로 자르는거 같다.\n          // .clipExtent([0,0], [1700,1700])\n          .rotate([0, -20, 0])\n          .precision(0.1)\n        // .fitExtent([[0, 0], [width, height]], countries);\n\n        o = oProjection\n        const geoPath = d3.geoPath().projection(oProjection)\n\n        // 나라 그리는 코드\n        d3.select('svg')\n          .selectAll('path')\n          .data(countries.features)\n          .enter()\n          .append('path')\n          .attr('d', geoPath)\n          .attr('class', 'countries')\n        // // 면적에 따라 나라의 색상을 칠한다.\n        // .style(\"fill\", d => newFeatureColor(d3.geoArea(d)));\n\n        // 나라 색상 칠하기\n        const featureData = d3.selectAll('path.countries').data()\n        const realFeatureSize = d3.extent(featureData, d => d3.geoArea(d))\n        const newFeatureColor = d3\n          .scaleQuantize()\n          .domain(realFeatureSize)\n          .range(colorbrewer.Reds[7])\n        d3.selectAll('path.countries').style('fill', d =>\n          newFeatureColor(d3.geoArea(d))\n        )\n\n        // 경위선망 추가\n        const graticule = d3.geoGraticule()\n        d3.select('svg')\n          .append('path')\n          .datum(graticule)\n          .attr('class', 'graticule line')\n          .attr('d', geoPath)\n          .style('fill', 'none')\n          .style('stroke', 'lightgray')\n          .style('stroke-width', '1px')\n\n        d3.select('svg')\n          .append('path')\n          .datum(graticule.outline)\n          .attr('class', 'graticule outline')\n          .attr('d', geoPath)\n          .style('fill', 'none')\n          .style('stroke', 'black')\n          .style('stroke-width', '1px')\n        // 경위선망 추가\n\n        // zoom\n        const [translateX, translateY] = oProjection.translate()\n        const scaleK = oProjection.scale()\n        // let projectionXY = [null, null];\n        // let interpolator = null;\n        // let count = 0;\n        let v0, q0, r0\n        const mapZoom = d3\n          .zoom()\n          .on('start', () => {\n            console.log('start')\n            console.log(event)\n            v0 = versor.cartesian(oProjection.invert([event.x, event.y]))\n            q0 = versor((r0 = oProjection.rotate()))\n          })\n          .on('zoom', zoomed)\n          .on('end', () => {\n            console.log('end')\n            projectionXY = [null, null]\n            interpolator = null\n            count = 0\n          })\n\n        d3.select('svg')\n          .call(mapZoom)\n          .call(\n            mapZoom.transform,\n            d3.zoomIdentity.translate(translateX, translateY).scale(scaleK)\n          )\n\n        // zoom 이벤트 처리기를 호출할 때마다\n        // projection translate와 scale() 값을 zoom 객체의 값으로 갱신한다.\n        function zoomed() {\n          const v1 = versor.cartesian(\n            oProjection.rotate(r0).invert([event.x, event.y])\n          )\n          const q1 = versor.multiply(q0, versor.delta(v0, v1))\n          oProjection.rotate(versor.rotation(q1))\n\n          reDrawSvg()\n        }\n\n        function reDrawSvg() {\n          const currentRotate = oProjection.rotate()[0]\n          d3.selectAll('path.countries').attr('d', geoPath)\n          d3.selectAll('path.line').attr('d', geoPath)\n          d3.selectAll('path.outline').attr('d', geoPath)\n\n          d3.selectAll('circle.cities')\n            .attr('cx', d => oProjection([d.x, d.y])[0])\n            .attr('cy', d => oProjection([d.x, d.y])[1])\n            .style('display', d => {\n              return parseInt(d.y) + currentRotate < 90 &&\n                parseInt(d.y) + currentRotate > -90\n                ? 'block'\n                : 'none'\n            })\n        }\n      }\n    </script>\n  </body>\n</html>\n```\n\n### 위성 도법\n\n- 위성 도법의 각도를 지정하는데 tilt() 와 distance() 라는 새로운 설정이 있다. titl는 데이터를 바라보는 각도이며, distance는 지구 반지름에 대한 비율이다. (1.119는 지구 반지름의 11.9% 높이의 상공을 의미한다.)\n- 정확한 설정 값을 알아내는 법은 2가지가 있다. 하나는 수학이나 지리학을 전공했다면 계산하는 방법을 설명한 참고서를 살펴보거나 두번째는 코드로 회전, 기울임, 거리 척도를 대화형으로 설정하는 방법이 있다. [참고](http://bl.ocks.org/emeeks/10173187)\n\n\n```javascript\n// 중동이 유럽을 바라보는 시각의 변화\nPromise.all([d3.json(\"world.geojson\"), d3.csv(\"cities.csv\")]).then(\n    dataList => {\n      const [countries, cities] = dataList;\n      createMap(countries, cities);\n    }\n  );\n\n  const width = 700;\n  const height = 700;\n\n  function createMap(countries, cities) {\n    projection = d3.geoSatellite()\n      .translate([width / 2, height / 2])\n      .scale(1330)\n      .rotate([-30.24, -31, -56])\n      .tilt(30) // 지형을 내려다보는 각도\n      .distance(1.199) // 지구 반지름에 대한 비율이다.(1.119는 지구 반지름의 11.9% 높이의 상공을 의미한다.)\n      .clipAngle(35) // 중심에서 일정한 각도 이상을 벗어나는 경로를 제거\n      // .center([-2, -1])\n      \n    \n    const geoPath = d3.geoPath().projection(projection);\n\n    // 나라 그리는 코드\n    d3.select(\"svg\")\n      .selectAll(\"path\")\n      .data(countries.features)\n      .enter()\n      .append(\"path\")\n      .attr(\"d\", geoPath)\n      .attr(\"class\", \"countries\");\n\n    const featureData = d3.selectAll(\"path.countries\").data();\n    const realFeatureSize = d3.extent(featureData, d => d3.geoArea(d));\n    const newFeatureColor = d3\n      .scaleQuantize()\n      .domain(realFeatureSize)\n      .range(colorbrewer.Reds[7]);\n    d3.selectAll(\"path.countries\").style(\"fill\", d =>\n      newFeatureColor(d3.geoArea(d))\n    );\n  }\n```\n\n\n\n## TopoJSON 데이터와 기능\n\nTopoJSON 이라는 용어는 다음과 같은 세 가지 형태를 말한다. \n\n- 지리 데이터에 대한 데이터 표준이며 GeoJSON의 확장 버전\n- GeoJSON 파일에서 TopoJSON 포맷의 파일을 생성하려 node.js에서 돌아가는 라이브러리\n- TopoJSON 포맷의 파일을 처리해 D3 등의 라이브러리로 렌더링하는데 필요한 객체를 생성하는 자바스크립트 라이브러리\n\nGeoJSON 파일은 각 지형을 점, 선, 폴리곤을 나타내는 위도와 경도 좌표의 배열로 저장하는 반면, TopoJSON은 각 지형을 원호의 배열로 저장한다. 원호는 데이터 셋 안에 있는 하나 이상의 지형이 공유하는 선분이다. 미국과 멕시코가 공유하는 국경은 하나의 원호로서 미국 지형의 원호 배열에서 참조하고 멕시코 지형의 원호 배열에서 참조한다. \n\nTopoJSON 데이터 셋의 크기가 훨씬 더 작은 경우가 많고 어느 선분을 공유하는지 알고 있으면 이웃하는 지형이나 공유하는 국경을 쉽게 계산할 수 있고 지형을 쉽게 병합할 수 있다. \n\nD3가 도형을 생성하는데 읽고 생성할 수 있는 포맷으로 TopoJSON 포맷을 변경하려면 TopoJSON으로 지도를 만드는데 사용하는 웹사이트에 Topojson.js를 추가해야 한다. \n\n```javascript\nPromise.all([d3.json(\"world.topojson\"), d3.csv(\"cities.csv\")]).then(\n        dataList => {\n          const [countries, cities] = dataList;\n          createMap(countries, cities);\n        }\n      );\n\n      const width = 700;\n      const height = 700;\n\n      function createMap(countries, cities) {\n        // topo => geo 변환\n        const topoCountries = topojson.feature(countries, countries.objects.countries)\n        // console.log(topoCountries)\n        \n        const projection = d3.geoMollweide()\n          .scale(120)\n          .translate([width / 2, height / 2 ])\n          .center([20,0])\n\n        const geoPath = d3.geoPath().projection(projection);\n\n\n        // 나라 그리는 코드\n        d3.select(\"svg\")\n          .selectAll(\"path\")\n          .data(topoCountries.features)\n          .enter()\n          .append(\"path\")\n          .attr(\"d\", geoPath)\n          .attr(\"class\", \"countries\")\n          .style('stroke-width', 1)\n          .style('stroke', 'black')\n          .style('opacity', 0.5)\n\n        \n        const featureData = d3.selectAll(\"path.countries\").data();\n        const realFeatureSize = d3.extent(featureData, d => d3.geoArea(d));\n        const newFeatureColor = d3\n          .scaleQuantize()\n          .domain(realFeatureSize)\n          .range(colorbrewer.Reds[7]);\n        d3.selectAll(\"path.countries\").style(\"fill\", d =>\n          newFeatureColor(d3.geoArea(d))\n        );\n\n        // 병합\n        mergetAt(0)\n\n        function mergetAt(mergePoint) {\n          const filteredCountries = countries.objects.countries.geometries\n            .filter(d => {\n              const thisCenter = d3.geoCentroid(topojson.feature(countries, d))\n              return thisCenter[1] > mergePoint? true : null\n            })\n\n          d3.select('svg').insert('g')\n            .datum(topojson.merge(countries, filteredCountries))\n            .insert('path')\n            .style('fill', 'gray')\n            .style('stroke', 'black')\n            .style('stroke-width', '2px')\n            .attr('d', geoPath)\n\n          console.log(topojson.merge(countries, filteredCountries))\n        }   \n      }\n```\n\n## d3.geo tile을 이용한 타일 맵핑\n\n- 지금까지 그린것은 코로플레스 지도를 만든 것이다. 터레인(terrain), 즉 위성 사진을 사용하지는 않았다. \n- 래스터 데이터는 백터 데이터 만큼 가볍지 않다. 스마트폰에서 찍은 사진을 떠올려보자. 파일의 크기가 크다. \n- 엄청나게 큰 그림을 사용해야 하는 문제를 해결하려 웹 지도에서는 타일(tile)로 위성 사진을 보여준다. 예를 들어 도시의 고해상도 사진을 다양한 확대 수준에서 256px x 256px 크기로 나눈 후 서버에 확대 수준과 위치에 맞게 해당 사진들을 저장한다. \n- [Mapbox](http://mapbox.com) 같은 곳에서 타일을 제공하며, 이 타일을 커스터마이즈할 TileMill 같은 도구를 제공해준다. \n- 각 타일은 PNG 포맷인 래스터 이미지로서 지구 어딘가의 정사각형을 나타낸다. 파일명을 보면 그림 파일의 지리적 위치와 확대 수준을 알 수 있다. \n- d3.geoTile 객체가 파일명과 디렉터리 구조를 분석해주므로 지도에 해당 타일을 사용하기만 하면 된다. \n\n```html\n <html>\n  <head>\n    <title>D3 in Action Chapter 5 - Example 7</title>\n    <meta charset=\"utf-8\" />\n    <script src=\"https://d3js.org/d3.v5.min.js\"></script>\n    <script src=\"https://d3js.org/d3-geo-projection.v2.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/d3-tile@1\"></script>\n    <script src=\"http://colorbrewer2.org/export/colorbrewer.js\"></script>\n    <script src=\"https://unpkg.com/topojson@3\"></script>\n    <script src=\"https://unpkg.com/versor\"></script>\n  </head>\n  <style>\n    svg {\n      height: 700px;\n      width: 700px;\n      border: 1px solid gray;\n    }\n    path.countries {\n      stroke-width: 1;\n      stroke: black;\n      opacity: 0.5;\n      fill: red;\n    }\n\n    circle.cities {\n      stroke-width: 1;\n      stroke: black;\n      fill: blue;\n    }\n\n    circle.centroid {\n      fill: red;\n      pointer-events: none;\n    }\n\n    rect.bbox {\n      fill: none;\n      stroke-dasharray: 5 5;\n      stroke: black;\n      stroke-width: 2;\n      pointer-events: none;\n    }\n\n    path.graticule {\n      fill: none;\n      stroke-width: 1;\n      stroke: black;\n    }\n  </style>\n  <body>\n    <div id=\"viz\">\n      <svg></svg>\n    </div>\n    <div id=\"controls\"></div>\n\n    <footer></footer>\n\n    <script>\n      Promise.all([d3.json(\"world.topojson\"), d3.csv(\"cities.csv\")]).then(\n        dataList => {\n          const [countries, cities] = dataList;\n          createMap(countries, cities);\n        }\n      );\n\n      const width = 700;\n      const height = 700;\n      d3.select(\"svg\")\n        .append(\"g\")\n        .attr(\"id\", \"tiles\");\n\n      function createMap(countries, cities) {\n        // topo => geo 변환\n        const topoCountries = topojson.feature(\n          countries,\n          countries.objects.countries\n        );\n\n        const tile = d3.tile().size([width, height]);\n\n        const projection = d3\n          .geoMercator()\n          .scale(120)\n          .translate([width / 2, height / 2]);\n\n        const center = projection([0, 0]);\n        const geoPath = d3.geoPath().projection(projection);\n        const zoom = d3.zoom().on(\"zoom\", redraw);\n\n        const translateX = width - center[0];\n        const translateY = height - center[1];\n        const scaleK = projection.scale() * 2 * Math.PI;\n\n        d3.select(\"svg\")\n          .call(zoom)\n          .call(\n            zoom.transform,\n            d3.zoomIdentity.translate(translateX, translateY).scale(scaleK)\n          );\n\n        d3.select(\"svg\")\n          .selectAll(\"path\")\n          .data(topoCountries.features)\n          .enter()\n          .append(\"path\")\n          .attr(\"d\", geoPath)\n          .attr(\"class\", \"countries\");  \n\n        function redraw() {\n          \n          const transform = d3.zoomTransform(this);\n          const tiles = tile\n            .scale(transform.k)\n            .translate([transform.x, transform.y])();\n          console.log(\"tiles\", tiles);\n          const image = d3\n            .select(\"#tiles\")\n            .attr(\n              \"transform\",\n              `scale(${tiles.scale}) translate(${tiles.translate})`\n            )\n            .selectAll(\"image\")\n            .data(tile, d => d);\n\n          image.exit().remove(); // 화면 밖으로 나간 것을 모두 제거한다.\n          image\n            .enter()\n            .append(\"image\") // 새로운 이미지를 추가한다.\n            .attr(\"xlink:href\", d => {\n              return `https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/${\n                d[2]\n              }/${d[0]}/${\n                d[1]\n              }?access_token=pk.eyJ1IjoiY2hjaG9pbmciLCJhIjoiY2syazU1OWs0MHdqYzNtb2h6a2FtdXppZCJ9.nMTjqotAdJuGNYhCvLTOGA\n`;\n            })\n            .attr(\"width\", 1)\n            .attr(\"height\", 1)\n            .attr(\"x\", d => d[0])\n            .attr(\"y\", d => d[1]);\n\n          // 현재의 메르카토르 도법에 맞게 스케일을 계산한다. \n          projection.scale(transform.k / 2 / Math.PI).translate([transform.x, transform.y])\n          d3.selectAll('path.countries')\n            .attr('d',geoPath)\n            \n        }\n        \n        // 나라 색상\n        const featureData = d3.selectAll(\"path.countries\").data();\n        const realFeatureSize = d3.extent(featureData, d => d3.geoArea(d));\n        const newFeatureColor = d3\n          .scaleQuantize()\n          .domain(realFeatureSize)\n          .range(colorbrewer.Reds[7]);\n        d3.selectAll(\"path.countries\").style(\"fill\", d =>\n          newFeatureColor(d3.geoArea(d))\n        );\n       \n      }\n    </script>\n  </body>\n</html>\n```\n\n## 웹 지도 제작 관련 추가 자료\n\n- 위에서 사용했던 확대하는데 사용한 기법은 투영 확대 (projection zoom) 라고 하며 scale 과 translate 의 변화에 따라 지형의 모습을 수학적으로 다시 계산한다. 메르카토르 도법처럼 수평 투영 (flat projection) 기법을 사용하는 경우에는 zoom 객체의 scale과 translate 변화를 SVG 변환 기능에 연결해 성능을 향상 시킬 수 있다. 이때 SVG 변환에 의해 폰트와 스트로크의 두께가 변하므로 이에 대한 설정은 직접 조정해야 한다. \n\n- `d3.geoPath`의 context() 메서드를 사용하면 <canvas> 요소에 벡터 데이터를 쉽게 그릴 수 있으며, 경우에 따라 속도가 향상된다. canvas의 `toDataURL()` 메서드를 사용하면 화면을 PNG 파일로 만들어 저장할 수 있다.\n\n- `d3.hexbin` 플러그인을 사용하면 지도위에 헥스빈(hexbin)을 쉽게 만들 수 있다. [Hexbin](https://observablehq.com/@d3/hexbin-map)\n\n- 헥스빈과 마찬가지로, 점 데이터만 갖는 데이터에서 영역을 생성하고 싶을 때는 보로노이 다이어그램인 `d3.voronoi()`로 해당 점에서 폴리곤을 생성할 수 있다. [voronoi](https://www.jasondavies.com/maps/voronoi/us-capitals/)\n\n- 통계지도(cartogram)은 지리 객체의 영역이나 길이를 왜곡해 다른 정보를 준다. 예를 들어 주행 시간에 따라 도로의 길이를 왜곡하거나 인구에 기초해 나라의 크기를 크거나 작게 만들 수 있다. [제이슨 데이비스 예제](https://www.jasondavies.com/maps/dorling-world/), [마이크 보스톡 예제](https://bl.ocks.org/mbostock/4055908), [비용 통계 지도](http://orbis.stanford.edu/)","excerpt":"지리 공간 정보 시각화 지리 공간 데이터는 흔히 접할 수 있는 데이터 범주로서, 도나 군 등 행정구역 형태나, 도시 혹은 사람이 트윗한 장소, 지표면 위성 사진 등의 형태로 제공할 수 있다. 구글 API 등 전용 라이브러리를 사용하는 이유는 주로 구…","fields":{"slug":"/geo/"},"frontmatter":{"date":"Oct 16, 2019","title":"hello-geo","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n[이글](https://svelte.dev/blog/virtual-dom-is-pure-overhead)은 다음글을 보고 번역한 것입니다.\n\n만약 지난 몇년 동안 자바스크립트 프레임워크를 사용했다면 아마 'virtual DOM은 빠르다'는 말을 들었을 것입니다. 또한 종종 _real DOM_ 보다 더 빠르다는 의미로 사용되어져 왔습니다. 이런 생각들은 놀랍게도 인터넷을 통해 사람에서 사람 사이에 전파 되었습니다. 예를 들면 사람들은 어떻게 Selte가 virtual DOM 을 사용하지 않고도 빠를 수 있냐고 물어오곤 합니다.\n\n좀 더 자세히 살펴 봅시다.\n\n## What is the virtual DOM?\n\n`render()` 함수로 생성되는 app을 빌드 하는 많은 프레임워크에서 React component를 봅시다.\n\n```javascript\nfunction HelloMessage(props) {\n  return <div className=\"greeting\">Hello {props.name}</div>\n}\n```\n\nJSX가 없는 버젼은 다음과 같을 것입니다.\n\n```javascript\nfunction HelloMessage(props) {\n  return React.createElement(\n    'div',\n    { className: 'greeting' },\n    'Hello ',\n    props.name\n  )\n}\n```\n\n하지만 결과는 같을 것입니다. - 객체는 어떻게 페이지를 보여주어야 할지를 표현하는 수단입니다. 여기 이 객체가 virtual DOM 입니다. 매 시간 당신의 app의 state가 업데이트(예를 들면 `name` 이라는 prop가 변경될때) 되고 새로운게 생성됩니다. 프레임워크의 작업은 예전꺼에 맞서 새로운거와 함께 비교(`reconcile`)을 하는 것입니다. 그리고 무엇이 변화가 필요한지 그것들을 real DOM에 적용을 할지 파악해 갑니다.\n\n## How did the meme start?\n\n가상 DOM 성능에 대한 주장은 React의 시작으로 잘못 이해되었습니다. 전 React 핵심 팀 멤버 인 Pete Hunt의 2013 년 [이야기](https://www.youtube.com/watch?v=x7cQ3mrcKaY)에서 우리는 다음을 배웠습니다.\n\n> 이것은 실제로 정말 빠릅니다. 우선적으로 대부분의 DOM 작업들이 느린 경향이 있습니다. DOM에 대한 성능 연구가 많이 있었지만 대부분의 돔 조작은 프레임 drop 하는 경향이 있습니다.\n\n그러나 잠시만 생각해봅시다! 가상 DOM 조작은 결국 실제 DOM 에서의 조작에 추가되는 작업입니다. 더 빠를 수있는 유일한 방법은 우리가 덜 효율적인 프레임 워크와 비교하거나 (2013년에는 비교해봐야 할게 많았습니다.) 반대의견의 사람과 논쟁하는 것이었습니다. - 대안은 실제로 아무도하지 않는 일을하는 것입니다.\n\n```javascript\nonEveryStateChange(() => {\n  document.body.innerHTML = renderMyApp()\n})\n```\n\n피트는 곧 ...\n\n> React는 매직이 아닙니다. C를 사용하여 어셈블러를 사용하고 C 컴파일러를 이길 수있는 것처럼 원시 DOM 작업과 DOM API 호출을 사용하고 원하는 경우 React를 이길 수 있습니다. 그러나 C와 JAVA 또는 Javascript를 사용하는 것은 성능이 크게 향상이 됩니다. 왜냐하면 구체적인 플랫폼에 대해서 걱정할 필요가 없기 때문입니다. React를 사용하면 성능에 대해 생각하지 않고도 애플리케이션을 빌드 할 수 있으며 기본 상태는 빠릅니다.\n\n## So.. is the virtual DOM slow?\n\n정확히 아닙니다. '가상 DOM은 일반적으로 충분히 빠르다'와 비슷하지만 특정주의 사항이 있습니다.\n\nReact의 원래 약속은 성능에 대한 걱정없이 모든 단일 상태 변경에서 전체 앱을 다시 렌더링 할 수 있다는 것입니다. 실제로, 나는 그것이 정확하다고 생각하지 않습니다. 만약 그렇다면, 컴포넌트를 안전하게 건너 뛸 수있을 때 React에 알리는 방법 인 `shouldComponentUpdate` 와 같은 최적화가 필요하지 않습니다.\n\n`shouldComponentUpdate`를 사용하더라도 전체 앱의 가상 DOM을 한 번에 업데이트하는 것은 많은 작업입니다. 얼마 전 React 팀은 업데이트를 더 작은 청크로 나눌 수있는 React Fiber를 도입했습니다. 이는 업데이트가 총 작업량이나 업데이트 소요 시간을 줄이지 않지만 오랜 시간 동안 메인 스레드를 차단하지 않는다는 것을 의미합니다.\n\n## Where does the overhead come from?\n\n가장 분명한 것은. [`diffing isn't free`](https://twitter.com/pcwalton/status/1015694528857047040) 먼저 새로운 가상 DOM을 이전 스냅 샷과 비교하지 않으면 실제 DOM에 변경 사항을 적용 할 수 없습니다. 이전 `HelloMessage` 예제를 가져 오려면 `name` prop가 'world'에서 'everybody'로 변경되었다고 가정하십시오.\n\n1. 두 스냅 샷 모두 단일 엘리먼트를 포함합니다. 두 경우 모두 `<div>`이므로 동일한 DOM 노드를 유지할 수 있습니다.\n2. 이전 `<div>` 및 새 `<div>`의 모든 속성을 열거하여 변경, 추가 또는 제거해야하는지 확인합니다. 두 경우 모두 \"greeting\"값을 가진 className이라는 단일 속성이 있습니다.\n3. 요소로 내려 가면 텍스트가 변경되었음을 알 수 있으므로 실제 DOM을 업데이트 해야합니다.\n\n이 세 단계 중 대부분은 업데이트의 경우와 마찬가지로 앱의 기본 구조가 변경되지 않았으므로이 경우에는 세 번째 단계 만 가치가 있습니다. 3 단계로 바로 건너 뛸 수 있다면 훨씬 더 효율적일 것입니다.\n\n```javascript\nif (changed.name) {\n  text.data = name\n}\n```\n\n(이것은 거의 정확하게 Svelte가 생성하는 업데이트 코드입니다. 기존 UI 프레임 워크와 달리 Svelte는 런타임에 작업을 기다리지 않고 빌드 시간에 앱에서 변경 사항이 어떻게 발생하는지 알고있는 컴파일러입니다.)\n\n## It's not just the diffing though\n\nReact 및 기타 가상 DOM 프레임 워크에서 사용하는 diffing 알고리즘은 빠릅니다. 틀림없이 컴포넌트 자체에 더 많은 오버 헤드가 있을 수 있습니다. 이런 코드를 쓰지 않을 것입니다...\n\n```javascript\nfunction StrawManComponent(props) {\n  const value = expensivelyCalculateValue(props.foo)\n\n  return <p>the value is {value}</p>\n}\n```\n\n왜냐하면 `props.foo`가 변경되었는지 여부에 관계없이 모든 업데이트에서 부주의하게 값을 다시 계산하기 때문입니다. 그러나 훨씬 더 평범하게 보이는 방식으로 불필요한 계산 및 할당을 수행하는 것이 매우 일반적입니다.\n\n```javascript\nfunction MoreRealisticComponent(props) {\n  const [selected, setSelected] = useState(null)\n\n  return (\n    <div>\n      <p>Selected {selected ? selected.name : 'nothing'}</p>\n\n      <ul>\n        {props.items.map(item => (\n          <li>\n            <button onClick={() => setSelected(item)}>{item.name}</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  )\n}\n```\n\n여기에서는 `props.items`의 변경 여부에 관계없이 모든 상태 변경 시마다 각각의 자체 인라인 이벤트 핸들러가있는 새로운 가상 `<li>` 요소 배열을 생성합니다. 성능에 집착하지 않는 한 이를 최적화하지는 않을 것입니다. 아무 소용이 없습니다. 그래도 충분히 빠릅니다. 그러나 더 빠른 것이 무엇인지 아십니까? 이렇게 하지 않는 것입니다.\n\n불필요하게 작업을 하지 않아도 불필요하게 작업을 수행하는 데 따르는 위험은 앱이 결국에는 최적화할 때라는 명확한 증상이 없을때 'death by a thousand cuts(작은 문제가 모여 실패하는 뜻)'와 같이 실패 할 수 있다는 것입니다.\n\nSvelte는 명시 적으로 해당 상황에서 끝나지 않도록 설계되었습니다.\n\n## Why do frameworks use the virtual DOM then?\n\n가상 DOM은 기능이 아니라는 점을 이해해야합니다. 이는 목적을 위한 수단이며, 목적은 선언적이고 상태 중심의 UI 개발입니다. Virtual DOM은 일반적으로 충분한 성능으로 상태 변화에 대해 생각하지 않고도 앱을 빌드 할 수 있기 때문에 유용합니다. 이는 버그가 적고 지루한 작업 대신 창의적인 작업에 더 많은 시간을 소비한다는 것을 의미합니다.\n\n그러나 가상 DOM을 사용하지 않고도 유사한 프로그래밍 모델을 얻을 수 있다는 것이 밝혀졌습니다. 바로 여기가 Svelte입니다.\n","excerpt":"이글은 다음글을 보고 번역한 것입니다. 만약 지난 몇년 동안 자바스크립트 프레임워크를 사용했다면 아마 'virtual DOM은 빠르다'는 말을 들었을 것입니다. 또한 종종 real DOM 보다 더 빠르다는 의미로 사용되어져 왔습니다. 이런 생각들은 …","fields":{"slug":"/virualDom-overhead.md/"},"frontmatter":{"date":"Oct 12, 2019","title":"Virtual DOM is pure overhead","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Intro\n\nD3는 데이터 주도 문서 (data-driven docuement)의 약자이다.\nD3.js는 웹으로 접근할 수 있고 데이터 시각화를 정교하게 하려는 요구를 만족하려 만들어졌다. 데이터 시각화라고 하면 지도, 대화형 다이어그램, 기타 도구와 콘텐츠가 뉴스, 데이터 대시보드, 보고서, 그 밖에 웹에서 보는 모든것과 통합된 것을 의미한다.\n\nD3의 장점은 전통적인 차트를 그리기 위한 벡터 그래픽은 물론 표, 리스트, 문단 등 전통적인 HTML 요소, 나아가 지리 공간과 네트워크도 시각화할 수 있다는 점이다.\n\n## D3는 셀렉션과 바인딩이다.\n\n- 셀렉션 : 셀렉션은 데이터셋과 해당 데이터셋을 텍스트, 혹은 크기와 색상으로 표현하고자 할 때 이 모든걸 담은 묶음이다. 이 묶음 단위로 이동, 색상 변경, 데이터 값 변경을 수행하게 된다. D3의 힘은 셀렉션으로 데이터와 웹 페이지 요소를 결합하는 능력에서 나온다.\n\n```javascript\n// 데이터가 없는 셀렉션\n// d3.select(), d3.selectAll() 셀렉션 코드\n// 부모 dom은 html이다.\nconst test = d3\n  .selectAll('circle.a')\n  .style('fill', 'red')\n  .attr('cx', 100)\nconsole.log(test)\n\n// d3.select('div#ID').selectAll('span') 일떄 부모는 div#ID 이다.\n\n// Pt를 생성자로 두고 있는 객체\n/*\n{\n  _groups: Array(1)\n    0: NodeList(1)\n      0: circle,\n  _parents: [html]\n}\n*/\n```\n\n- 바인딩 : 셀렉션에 데이터를 연결하는 작업을 바인딩이라고 한다.\n\n```javascript\nconst test = d3.selectAll('div').data([1,5,11,3]).style('background', 'red').attr('class', 'b')\nconsole.log('test', test)\n/*\n{\n  _enter: Array(1)\n    0: Array(4)\n      1: rt {ownerDocument: document, namespaceURI: \"http://www.w3.org/1999/xhtml\", _next: null, _parent: html, __data__: 5}\n      2: rt {ownerDocument: document, namespaceURI: \"http://www.w3.org/1999/xhtml\", _next: null, _parent: html, __data__: 11}\n      3: rt {ownerDocument: document, namespaceURI: \"http://www.w3.org/1999/xhtml\", _next: null, _parent: html, __data__: 3}\n  _exit: [empty]\n  _groups: Array(1)\n    0: Array(4)\n      0: div#borderdiv.b\n  _parents: [html]\n}\n/*\n```\n\n## D3는 바인딩된 데이터로 웹 페이지 요소의 외형을 유도한다.\n\nHTML 요소의 D3 셀렉션을 이용하거나 선택적으로 데이터를 바인딩하고 페이지의 구조와 모습을 변경한다. 구조가 변경되면 사용자가 반응하게 되며, 사용자의 반응은 페이지의 콘텐츠를 더 많이 바뀌게 한다.\n\n# 정보 시각화 데이터 흐름\n\n데이터 시각화 절차 : 로딩 - 포맷 - 측정 - 생성 - 갱신\n\n## 다양한 포멧의 외부 파일에서 데이터 로딩하기\n\n- 포멧에 따른 로딩 메서드 : d3.text(), d3.xml(), d3.json(), d3.csv(), d3.html()\n\n> d3.json()은 promise를 리턴한다. promise를 다루듯이 처리 하면 된다.\n\n## 데이터 포맷팅\n\n- 정략적 데이터\n- 범주 데이터\n- 위상 데이터\n- 기하학적 데이터\n- 날짜/시간 데이터\n- 원시 데이터\n\n## 데이터 변환\n\n- 캐스팅(데이터 형변환) : 하나의 데이터형에서 다른 데이터형으로 변환하는 것\n- 정규화(스케일과 규모 변경) : 데이터를 화면에 표기할 수 있도록 정규화\n  - 스케일은 도메인(domain) 과 레인지(range)를 가졌다.\n  - **Ordinal Scales** : 연속되지 않는 domain과 range를 가졌다. 예를 들면, 카테고리의 이름을 색상에 매칭 시킬때나 세로 막 대형 차트에서 세로 막대의 가로 위치를 결정합니다.\n  - **Quantize Scales** : 연속적인 range 대신에 불연속적인걸 사용한다는걸 제외하고는 linear scales 와 유사하다. 연속 입력 domain은 출력 range에서의 값의 수 (즉, 카디널리티)에 기초하여 균일 한 세그먼트로 분할된다.\n\n```javascript\nconst newRamp = d3\n  .scaleLinear()\n  .domain([500000, 13000000])\n  .range([0, 500])\n\nnewRamp(1000000) // 20\nnewRamp(9000000) // 340\n\nnewRamp.invert(313) // 8,325,000\n```\n\n- 비닝(데이터 분류) : 일련의 범위에 있는 값으로 그룹화함으로써 정량적 데이터를 범주로 분류하는 것도 유용하다.\n  - 배열을 같은 크기의 부분으로 나누어 변윗값(quantile)을 사용할 수도 있다.\n\n```javascript\nconst sampleArray = [423, 124, 66, 424, 58, 10, 900, 44, 1]\nconst qScale = d3\n  .scaleQuantile()\n  .domain(sampleArray)\n  .range([0, 1, 2])\nqScale(423) // 2\nqScale(20) // 0\nqScale(10000) // 2\n```\n\n- 내포 : 데이터에 공통된 속성으로 데이터를 분연속적인 범주에 분류할 수 있다는 생각에서 출발한다.\n\n```javascript\nd3.json('tweets.json').then(data => {\n  const tweetData = data.tweets\n  const nestedTweets = d3\n    .nest()\n    .key(el => el.user)\n    .entries(tweetData)\n\n  console.log(nestedTweets)\n})\n\n/*\n[\n  0: {key: \"Al\", values: Array(3)}\n  1: {key: \"Roy\", values: Array(4)}\n  2: {key: \"Pris\", values: Array(2)}\n  3: {key: \"Sam\", values: Array(1)}\n]\n*/\n```\n\n## 데이터 측정\n\n- 데이터를 로딩후엔 데이터를 측정하고 정렬을 해야한다.\n- 속성의 최솟값, 최댓값, 이름뿐만 아니라 특정 속성값의 분산을 알아내는 일은 중요하다.\n- D3에서는 일반적으로 배열에 들어 있는 데이터의 특정 속성의 상댓값에 따라 크기와 위치를 정한다.\n\n```javascript\nconst testArray = [88, 10000, 1, 75, 12, 35]\nd3.min(testArray, el => el) // 배열에서 최솟값인 1을 반환한다.\nd3.max(testArray, el => el) // 최댓값 10000을 반환한다.\nd3.mean(testArray, el => el) // 평균값을 구한다.\n\nd3.extent(testArray, el => el) // [최솟값, 최댓값]\n```\n\n## 데이터 바인딩\n\n- 셀렉션은 하나 이상의 DOM 요소로 구성되며 연관된 데이터를 가질 수도 있다.\n- 데이터에 기초해 데이터를 생성하거나 삭제할 수 있다.\n\n### select(), selectAll()\n\n- select() 의 경우에는 셀렉션 객체의 \\_groups 프로퍼티에 요소로 HTMLElement나 SVGElement가 들어가 있는 배열이다. ([circle])\n- selectAll() 의 경우에는 셀력센 객체의 \\_groups 프로퍼티에 요소로 NodeList 객체가 들어간다. (NodeList)\n\n```javascript\n// 4개의 g 태그 자식으로 circle이 3개씩 있다고 가정해보자.\n// 아래와 같이 셀렉션을 지정했을때\nd3.selectAll('g').select('circle')\n\n/*\n_groups: Array(1)\n  0: (4) [circle, circle, circle, circle] g태그(부모) 별로 의 첫번째 circle만 가져옴\n*/\n\nd3.selectAll('g').selectAll('circle')\n/*\n_groups: Array(4)\n  0: NodeList(3) [circle, circle, circle] 0번 g태그\n  1: NodeList(3) [circle, circle, circle] 1번 g태그\n  2: NodeList(3) [circle, circle, circle] 2번 g태그\n  3: NodeList(3) [circle, circle, circle] 3번 g태그\n*/\n```\n\n### data()\n\n- 데이터 셋에 들어있는 각 데이터를 DOM 요소와 연결한다. (DOM.**data** 프로퍼티로 조회 가능)\n- `data()` 를 호출하면 셀렉션에 `_enter`와 `_exit` 프로퍼티가 생성된다.\n- `_enter` 프로퍼티에는 DOM에 매칭 되지 못한 데이터들을 기반으로 `rt` 객체를 만들어 둔다.\n\n```javascript\n_enter: Array(1)\n  0: Array(4)\n    1: rt {ownerDocument: document, namespaceURI: \"http://www.w3.org/1999/xhtml\", _next: null, _parent: html, __data__: 5}\n    2: rt {ownerDocument: document, namespaceURI: \"http://www.w3.org/1999/xhtml\", _next: null, _parent: html, __data__: 11}\n    3: rt {ownerDocument: document, namespaceURI: \"http://www.w3.org/1999/xhtml\", _next: null, _parent: html, __data__: 3}\n    length: 4\n```\n\n- `data()` 메서드가 데이터를 셀렉션에 어떻게 바인딩할지 지정해야 한다. 기본적으로 data()는 해당 데이터 값이 배열에서 어디에 위치하는가에 기초해 바인딩을 진행한다.\n- 일반적으로 배열 위치보다는 데이터 객체 자체의 값 등 어떤 의미있는 것을 바인딩 키로 사용해야 한다.\n\n```javascript\nd3.select('svg')\n  .selectAll('circle')\n  .data(incomingData, function(d) {\n    return d.key\n  })\n```\n\n### enter(), exit(), update()\n\n- 데이터를 셀렉션에 바인딩할 때 데이터의 값 개수가 DOM 요소 수보다 많거나 적을 수 있다. 많으면 enter() 메서드를 호출해 셀렉션에 해당 요소가 없는 값을 어떻게 처리 해야 할지 정의한다.\n- `enter()` 메서드는 사용할 데이터에 기초해 새로운 요소를 생성하는 방법을 정의하고 `exit()` 메서드에서는 데이터를 갖지 못하는 기존 요소를 어떻게 삭제할지 정의한다.\n- `enter()` 메서드를 사용하면 기존 셀렉션에 있는 `_enter` 속성에 있는 녀석을 참조해서 또다른 셀렉션을 반환한다.\n- 데이터가 Dom 보다 많을때 `enter()` 이후 체이닝 메서드에는 추가될 DOM에만 추가 속성들이 적용이 된다.\n- `exit()` 메서드에는 `remove()` 메서드를 사용할 수 있다.\n\n```javascript\nd3.selectAll('g')\n  .data([1, 2, 3, 4])\n  .exit()\n  .remove()\n```\n\n- `update()` 는 다음 코드와 같이 <g> 그룹 안에 있는 각각의 <text> 요소를 새로 바인딩된 데이터로 갱신하면 화면 요소가 변경된다.\n\n```javascript\n// 자식 요소에 대한 데이터 바인딩을 다시 초기화 하려고 부모 요소에 대해 selectAll()한 후 자식 요소에 대한 하위 셀렉션 요소를 만들었다.\nd3.selectAll('g')\n  .select('text')\n  .text(d => d)\n```\n\n- 부모 요소에서 자식 요소 셀렉션을 만들게 되면 자동으로 data가 할당되게 된다.\n- 데이터를 다시 바인딩하는 방법은 부모 요소를 선택하고 나서 자식요소를 선택하면 데이터를 다시 바인딩한다. 그러나 부모 요소 밑에 아주 많은 자식 요소가 있고 `selectAll()` 메서드는 데이터를 다시 바인딩하지 않으므로 부모 요소의 데이터를 자식들에게 다시 바인딩 하려면 다음과 같이 한다.\n\n```javascript\n// d3.selectAll('g').data([1,2,3,4]).selectAll('path') 는 부모의 데이터를 받지 않는다.\n// d3.selectAll('g').data([5,6,7,8]).select('path') 는 g의 데이터를 path로 내려 보낼 수 있다.\nd3.selectAll('g').each(function(d) {\n  // 데이터 [5,6,7,8] 이 있다고 가정하에\n  d3.select(this)\n    .selectAll('path')\n    .datum(d) // 데이터 하나만을 요소에 바인딩할때 datum() 메서드 사용, 데이텀: 데이터의 단수형을 말한다.\n})\n\n// or\nd3.select('svg')\n  .selectAll('g')\n  .data([5, 6, 7, 8])\n  .each(function(d) {\n    d3.select(this)\n      .selectAll('circle')\n      .each(function(p) {\n        d3.select(this).data([d])\n      })\n  })\n```\n\n### append(), insert()\n\n- append() 메서드로 요소를 정의하고 추가할 수 있다.\n- insert() 메서드는 요소를 추가할 위치를 지정할 수 있다.\n\n### attr()\n\n- 스타일과 속성을 바꾼다. 이때, 요소 모두에 적용한다는 점에 주의 하자.\n\n## 데이터 속성에 기초한 그래프 그리기\n\n```javascript\nd3.json('tweets.json').then(data => {\n  const tweetData = data.tweets\n  dataViz(tweetData)\n})\n\nfunction dataViz(incomingData) {\n  const nestedTweets = d3\n    .nest()\n    .key(el => el.user)\n    .entries(incomingData)\n  nestedTweets.forEach(el => {\n    el.numTweets = el.values.length\n  })\n\n  const maxTweets = d3.max(nestedTweets, el => el.numTweets)\n  const yScale = d3\n    .scaleLinear()\n    .domain([0, maxTweets])\n    .range([0, 100]) // 높이 값 스케일 정의\n\n  d3.select('svg')\n    .selectAll('rect')\n    .data(nestedTweets)\n    .enter()\n    .append('rect')\n    .attr('width', 50)\n    .attr('height', d => yScale(d.numTweets))\n    .attr('x', (d, i) => i * 60)\n    .attr('y', d => 100 - yScale(d.numTweets))\n    .style('fill', 'blue')\n    .style('stroke', 'red')\n    .style('stroke-width', '1px')\n    .style('opacity', 0.25)\n}\n```\n\n### '다변량' 데이터란?\n\n- 각각의 데이터점이 여러 데이터 특성을 가졌음을 의미\n- 예를 들어, 의료기록은 0에서 100까지의 점수 하나로 표현하지 않는 대신 건강한 정도를 나타내는 여러 척도로 구성한다.\n- 하나의 도형으로 여러 데이터점을 표현 할 수 있는 기법을 개발해야 한다.\n- 도형 하나가 데이터를 시각적으로 잘 표현하는 방법을 전문 용어로 '채널' 이라고 하며, 사용하는 데이터에 따라 시각적으로 잘 표현할 수 있는 채널이 따로 있다.\n\n### 채널\n\n- 데이터를 표현할 때 가장 잘 표현하는 시각적 방법이 무엇인지 고민해야 한다.\n- 채널에는 높이, 너비, 면적, 색상(색상, 채도, 명도), 위치, 모양 등이 있어 다양한 정보를 표현하는데 잘 맞는다.\n\n### 산포도 예제\n\n```javascript\nfunction dataViz(incomingData) {\n  // 데이터 추가\n  incomingData.forEach(el => {\n    el.impact = el.favorites.length + el.retweets.length\n    el.tweetTime = new Date(el.timestamp)\n  })\n\n  // 데이터 측정\n  const maxImpact = d3.max(incomingData, el => el.impact)\n  const arrStartEnd = d3.extent(incomingData, el => el.tweetTime)\n\n  // 스케일 설정\n  const timeRamp = d3\n    .scaleTime()\n    .domain(arrStartEnd)\n    .range([20, 480]) // x축\n  const yScale = d3\n    .scaleLinear()\n    .domain([0, maxImpact])\n    .range([0, 460]) // y축\n  const radiusScale = d3\n    .scaleLinear()\n    .domain([0, maxImpact])\n    .range([1, 20]) // 반지름 (트윗 영향도)\n  const colorScale = d3\n    .scaleLinear()\n    .domain([0, maxImpact])\n    .range(['white', 'red']) // 컬러 (트윗 영향도)\n\n  // 드로잉\n  d3.select('svg')\n    .selectAll('circle')\n    .data(incomingData)\n    .enter()\n    .append('circle')\n    // 크기, 색상, 수직 위치는 모두 영향력에 기반을 둔다.\n    .attr('r', d => radiusScale(d.impact))\n    .attr('cx', d => timeRamp(d.tweetTime))\n    .attr('cy', d => 480 - yScale(d.impact) + 1)\n    .style('fill', d => colorScale(d.impact))\n    .style('stroke', 'black')\n    .style('stroke-width', '1px')\n}\n```\n\n# 데이터 주도 설계와 상호작용성\n\n## 이벤트\n\n- on() 메서드는 바인딩 된 데이터를 함수에 자동으로 전달할 수 있다.\n\n```javascript\nteamG.on('mouseover', highlightRegion) // selection.on\nfunction highlightRegion(targetData) {\n  d3.selectAll('g.overallG')\n    .select('circle')\n    .style('fill', d => (d.region === targetData.region ? 'red' : 'gray'))\n}\n```\n\n## 그래프 전환\n\n- 그래픽 요소가 많고 상호작용성이 높은 웹 페이지를 만들때 전환을 부드럽게 처리하자.\n- 전환은 `delay()` 메서드로 일정 시간 후에 발생하도록 설정하거나 `duration()` 메서드로 일정 시간 발생하도록 설정할 수 있다.\n\n```javascript\nd3.selectAll('g.overallG')\n  .select('circle')\n  .transition()\n  .duration(1000)\n  .attr('r', d => radiusScale(d[datapoint]))\n```\n\n- delay() 메서드는 전환할 때의 시작 시각을 늦출 수 있다.\n\n```javascript\n// 원이 과장된 크기로 커졌다가 바인딩된 데이터 셋에 정의한 크기로 줄어들도록 전환효과 구현\nteamG\n  .append('circle')\n  .attr('r', 0)\n  .transition()\n  .delay((d, i) => i * 100)\n  .duration(500)\n  .attr('r', 40)\n  .transition()\n  .duration(500)\n  .attr('r', 20)\n  .style('fill', 'pink')\n  .style('stroke', 'black')\n  .style('stroke-width', '1px')\n```\n\n## DOM 조작\n\n셀렉션 안에 있는 DOM 요소에 직접 접근하려면 다음 다 방법 중 하나를 사용한다.\n\n- 인라인 함수에서 this 이용\n\n```javascript\nd3.select('circle').each((d, i) => {\n  console.log(d) // 원에 바인딩 데이터\n  console.log(i) // 요소들을 생성하는데 사용한 객체의 배열 인덱스\n  console.log(this) // <circle> DOM 요소 자체\n})\n```\n\n- node() 메서드 이용\n\n```javascript\nd3.select('circle').node()\n```\n\n> SVG는 z-레벨이 없으므로 요소를 그리는 순서가 DOM 순서에 의해 결정된다.\n\n아래 코드는 `text`와 `circle` DOM에 `active` 클래스를 붙여서 폰트 사이즈와 색상을 변경하는 코드이다.\n\n```javascript\nfunction highlightRegion2(targetData, i) {\n  d3.select(this)\n    .select('text')\n    .classed('active', true)\n    .attr('y', 10)\n  d3.selectAll('g.overallG')\n    .select('circle')\n    .each(function(d, i) {\n      // 안에서 this는 해당 DOM을 위해 사용해야 하니 화살표 함수를 지양하자.\n      d.region === targetData.region\n        ? d3.select(this).classed('active', true)\n        : d3.select(this).classed('inactive', true)\n    })\n}\n```\n\n이렇게 코드를 짰을 경우 텍스트가 커지면서 다른 `circle` DOM 요소 밑으로 가려지는 현상이 발생된다.\n따라서 해당 요소를 다시 부모에 append 시켜주어야 한다.\n\n```javascript\nfunction highlightRegion3(targetData, i) {\n  d3.select(this)\n    .select('text')\n    .classed('highlight', true)\n    .attr('y', 10)\n  d3.selectAll('g.overallG')\n    .select('circle')\n    .each(function(d, i) {\n      // 안에서 this는 해당 DOM을 위해 사용해야 하니 화살표 함수를 지양하자.\n      d.region === targetData.region\n        ? d3.select(this).classed('active', true)\n        : d3.select(this).classed('inactive', true)\n    })\n\n  this.parentElement.appendChild(this) // 다시 부모의 마지막에 추가해준다.\n}\n```\n\n## 색상 선택\n\n- 일반적으로 웹에서 색상은 빨간색, 녹색, 파란색을 16진수, RGB, CSS 색상명 중 하나로 표현한다.\n- D3는 색상을 이용할 수 있는 몇 가지 헬퍼 함수를 제공한다.\n- D3 함수로 동적으로 색상이나 투명도를 변경하려면 인라인 스타일을 사용해야 한다.\n\n```javascript\nfunction highlightRegion3(targetData, i) {\n  const teamColor = d3.rgb('pink') // pink 색상\n\n  d3.select(this)\n    .select('text')\n    .classed('highlight', true)\n    .attr('y', 10)\n  d3.selectAll('g.overallG')\n    .select('circle')\n    .style('fill', d => {\n      return d.region === targetData.region\n        ? teamColor.darker(0.75)\n        : teamColor.brighter(0.5) // 색상에서 밝기 조절\n    })\n  this.parentElement.appendChild(this) // 다시 부모의 마지막에 추가해준다.\n}\n```\n\n### HSL 색상 모델\n\n- 색상(hue), 채도(saturation), 밝기(lightness)\n- d3.hsl() 메서드는 HSL 색상 객체를 생성한다.\n- HSL을 이용하면 D3 함수로 분홍색을 진하게 만들 때나 색상 그레이디언트 또는 혼합 색상을 만들때, 우중충한 색상이 나오는 것을 피할 수 있다.\n\n## 색상 혼합\n\n보간은 두 점을 연결하는 방법을 의미한다. 여기서 말하는 연결은 궤적을 생성한다는 뜻이다. 보간이 필요한 이유는 정보를 압축한 것을 다시 복원하기 위함이다.\n\n특징점이라 불리는 선의 모양 복원에 꼭 필요한 점듦나 취해서 저장하는데 이 과정을 sampling이라 부른다. 일반적으로 sampling은 일정 시간 주기로 선의 점을 취하는 방식을 사용하는데 녹음 기술에서 많이 쓴다.\n\n```javascript\nconst ybRamp = d3\n  .scaleLinear()\n  .domain([0, 4])\n  .range(['yellow', 'blue'])\nconst testData = [0, 1, 2, 3]\n\nd3.select('svg')\n  .selectAll('circle')\n  .data(testData)\n  .enter()\n  .append('circle')\n  .attr('r', 20)\n  .attr('cy', 50)\n  .attr('cx', (d, i) => 60 * i + 30)\n  .style('fill', d => ybRamp(d))\n```\n\n여기서 노랑색에서 파란색으로 자연스럽게 색이 나오길 원하지만 위 처럼 코드를 작성하면 스케일의 기본 보간자는 빨간색, 녹색, 파란색 채널을 그저 숫자로 처리한다.\n\n아래 코드는 HCL 에 기초해서 보간법을 적용한다.\n\n```javascript\n// 스케일의 기본 보간법이 마음에 들지 않을 때는 직접 지정한다.\n// 특히 RGB값을 보간하는 방법 이외의 방법으로\n// 색상 스케일을 생성하고자 할 때는 직접 지정해야 한다.\nconst ybRamp = d3\n  .scaleLinear()\n  .interpolate(d3.interpolateHsl)\n  .domain([0, 4])\n  .range(['yellow', 'blue'])\nconst testData = [0, 1, 2, 3]\n\nd3.select('svg')\n  .selectAll('circle')\n  .data(testData)\n  .enter()\n  .append('circle')\n  .attr('r', 20)\n  .attr('cy', 50)\n  .attr('cx', (d, i) => 60 * i + 30)\n  .style('fill', d => ybRamp(d))\n```\n\nD3는 그밖에도 HCL과 LAB 색상 모델을 지원하는데, 파란색과 노란색의 중간 색상을 만들어 내는 방식이 다르다.\n먼저 HCL 그레이디언트는 색상(hue), 농도(chroma), 휘도(luminance) 에 기초해 중간색을 보간한다.\nLAB 그레이디언트는 L과 A,B에 기초해 중간색을 보간한다. LAB에서 L은 밝기 light를 의미하고 A, B는 색의 대응공간 (color opponent space)를 의미한다.\n\n우리는 종종 색상 그레이디언트를 만들어 수치형 요소를 색상에 매핑시킨다. 이때, D3 이산 색상 스케일을 사용하는 편이 좋다.\n이 스케일은 먼저 범줏값을 특정 색상에 매핑하는 `d3.schemeCategory10`(색상 팔레트-10가지 색상이 이미 정의되어 있는 팔레트) 이라는 새로운 스케일을 사용해야 한다.\n이 스케일은 도메인이 이미 10가지 눈에 띄는 색상으로 정의돼 있으므로 도메인을 변경할 수 없는 정량화 스케일처럼 작동한다.\n그 대신 이 색상들에 매핑하고자 하는 값들로 구성된 스케일을 만든다.\n\n```javascript\n// 문자형 team과 region을 제외한 모든 속성을 가져온다.\nd3.select('#controls')\n  .selectAll('button.teams')\n  .data(dataKeys)\n  .enter()\n  .append('button')\n  .on('click', buttonClick) // on 메서드는 바인딩 된 데이터를 함수에 자동으로 전달한다.\n  .html(d => d)\n\nfunction buttonClick(datapoint) {\n  const maxValue = d3.max(incomingData, d => parseFloat(d[datapoint]))\n\n  // const tenColorScale = d3.schemeCategory10(['UEFA', 'CONMEBOL', 'CAF', 'AFC']) //\n  const tenColorScale = d3.scaleOrdinal(d3.schemeCategory10)\n  const radiusScale = d3\n    .scaleLinear()\n    .domain([0, maxValue])\n    .range([2, 20])\n\n  d3.selectAll('g.overallG')\n    .select('circle')\n    .transition()\n    .duration(1000)\n    .style('fill', d => tenColorScale(d.region))\n    .attr('r', d => radiusScale(d[datapoint]))\n}\n```\n\n## 미리 생성한 콘텐츠\n\n### 그림\n\n```javascript\nd3.selectAll('g.overallG')\n  .insert('image', 'text') // 텍스트 요소 앞에 그림을 넣으라고 D3에 알려줌\n  .attr('xlink:href', d => `images/${d.team}.png`)\n  .attr('width', '45px')\n  .attr('height', '20px')\n  .attr('x', '-22')\n  .attr('y', '-10')\n```\n\n### HTML\n\n```javascript\n// css에 정의된 ID를 갖는 <div> 요소를 새로 만들고\n// modal.html에서 읽은 HTML 내용으로 채운다.\nd3.text('resources/modal.html', data => {\n  d3.select('body')\n    .append('div')\n    .attr('id', 'modal')\n    .html(data)\n})\nteamG.on('click', teamClick)\n\nfunction teamClick(d) {\n  d3.selectAll('td.data')\n    .data(d3.values(d))\n    .html(p => p)\n}\n```\n\n### 외부 SVG\n\n```javascript\nd3.html('resources/icon_1907.svg', loadSVG)\n\nfunction loadSVG(svgData) {\n  d3.selectAll('g.overallG').each(function(d) {\n    const gParent = this\n    d3.select(svgData)\n      .selectAll('path')\n      .each(function() {\n        gParent.appendChild(this.cloneNode(true))\n      })\n    // selectAll 메서드는 데이터를 다시 바인딩 하지 않는다.\n    d3.select(this)\n      .selectAll('path')\n      .datum(d) // 데이텀 : 단어의 단수형을 말한다. 데이터 하나만을 요소에 바인딩할때 사용.\n\n    const tenColorScale = d3.scaleOrdinal(d3.schemeCategory10)\n    d3.selectAll('path')\n      .style('fill', p => tenColorScale(p.region))\n      .style('stroke', 'black')\n      .style('stroke-width', '2px')\n  })\n}\n```\n\n### 예제\n\n```javascript\nd3.csv('worldcup.csv', data => data).then(arrData => overallTeamViz(arrData))\n\nfunction overallTeamViz(incomingData) {\n  d3.select('svg')\n    .append('g')\n    .attr('id', 'teamsG')\n    .attr('transform', 'translate(50,300)')\n    .selectAll('g')\n    .data(incomingData)\n    .enter()\n    .append('g')\n    .attr('class', 'overallG')\n    .attr('transform', function(d, i) {\n      return 'translate(' + i * 50 + ', 0)'\n    })\n\n  const teamG = d3.selectAll('g.overallG')\n\n  teamG\n    .append('circle')\n    .attr('r', 0)\n    .transition()\n    .delay((d, i) => i * 100)\n    .duration(500)\n    .attr('r', 40)\n    .transition()\n    .duration(500)\n    .attr('r', 20)\n  // .style(\"fill\", \"pink\") css 로 처리\n  // .style(\"stroke\", \"black\")\n  // .style(\"stroke-width\", \"1px\")\n\n  teamG\n    .append('text')\n    .style('text-anchor', 'middle')\n    .attr('y', 30)\n    // .style(\"font-size\", \"10px\") css 로 처리\n    .text(function(d) {\n      return d.team\n    })\n\n  // incomingData[0] 은 객체\n  const dataKeys = d3\n    .keys(incomingData[0])\n    .filter(el => el !== 'team' && el !== 'region')\n\n  // 문자형 team과 region을 제외한 모든 속성을 가져온다.\n  d3.select('#controls')\n    .selectAll('button.teams')\n    .data(dataKeys)\n    .enter()\n    .append('button')\n    .on('click', buttonClick) // on 메서드는 바인딩 된 데이터를 함수에 자동으로 전달한다.\n    .html(d => d)\n\n  function buttonClick(datapoint) {\n    const maxValue = d3.max(incomingData, d => parseFloat(d[datapoint]))\n\n    // const tenColorScale = d3.schemeCategory10(['UEFA', 'CONMEBOL', 'CAF', 'AFC']) //\n    const tenColorScale = d3.scaleOrdinal(d3.schemeCategory10)\n    const radiusScale = d3\n      .scaleLinear()\n      .domain([0, maxValue])\n      .range([2, 20])\n\n    d3.selectAll('g.overallG')\n      .select('circle')\n      .transition()\n      .duration(1000)\n      .style('fill', d => tenColorScale(d.region))\n      .attr('r', d => radiusScale(d[datapoint]))\n  }\n\n  teamG.on('mouseover', highlightRegion3)\n  teamG.on('mouseout', unHighlight)\n  function highlightRegion(targetData) {\n    d3.selectAll('g.overallG')\n      .select('circle')\n      .style('fill', d => (d.region === targetData.region ? 'red' : 'gray'))\n  }\n\n  function highlightRegion2(targetData, i) {\n    d3.select(this)\n      .select('text')\n      .classed('active', true)\n      .attr('y', 10)\n    d3.selectAll('g.overallG')\n      .select('circle')\n      .each(function(d, i) {\n        // 안에서 this는 해당 DOM을 위해 사용해야 하니 화살표 함수를 지양하자.\n        d.region === targetData.region\n          ? d3.select(this).classed('active', true)\n          : d3.select(this).classed('inactive', true)\n      })\n  }\n\n  function highlightRegion3(targetData, i) {\n    const teamColor = d3.rgb('pink')\n\n    d3.select(this)\n      .select('text')\n      .classed('highlight', true)\n      .attr('y', 10)\n    // d3.selectAll('g.overallG').select('circle').each(function (d,i) { // 안에서 this는 해당 DOM을 위해 사용해야 하니 화살표 함수를 지양하자.\n    //   d.region === targetData.region ? d3.select(this).classed('active', true) : d3.select(this).classed('inactive', true)\n    // })\n    d3.selectAll('g.overallG')\n      .select('circle')\n      .style('fill', d => {\n        return d.region === targetData.region\n          ? teamColor.darker(0.75)\n          : teamColor.brighter(0.5)\n      })\n    this.parentElement.appendChild(this) // 다시 부모의 마지막에 추가해준다.\n  }\n\n  function unHighlight() {\n    d3.selectAll('g.overallG')\n      .select('circle')\n      .attr('class', '')\n    d3.selectAll('g.overallG')\n      .select('text')\n      .classed('highlight', false)\n      .attr('y', 30)\n  }\n}\n\n// 색상 보간법\nconst ybRamp = d3\n  .scaleLinear()\n  .interpolate(d3.interpolateHsl)\n  .domain([0, 4])\n  .range(['yellow', 'blue'])\nconst testData = [0, 1, 2, 3]\n\nd3.select('svg')\n  .selectAll('circle')\n  .data(testData)\n  .enter()\n  .append('circle')\n  .attr('r', 20)\n  .attr('cy', 50)\n  .attr('cx', (d, i) => 60 * i + 30)\n  .style('fill', d => ybRamp(d))\n```\n\n# 차트\n\n- 생성기 : 데이터를 입력받고 이 데이터에 기초한 화면 객체를 생성하는데 필요한 SVG 그림 코드를 반환한다.(SVG의 속성 문자열 값) 생성기들은 <path> 요소의 d 속성을 작성하는데 필요한 과정을 추상화함으로써 복잡한 <path> 요소의 생성 과정을 단순하게 만들어줍니다.\n  d3.line(), d3.area(), d3.arc() 와 같은게 있습니다.\n\n- 컴포넌트 : 컴포넌트는 특정 차트 컴포넌트를 그리는데 필요한 일련의 화면 객체를 생성합니다. d3에서 가장 많이 사용하는 컴포넌트는 `d3.axisRight`와 같은 종류들입니다. 이것은 함수에 사용한 스케일과 설정에 기초해 축을 그리는데 필요한 수 많은 <line>, <path>, <g>, <text> 요소를 생성한다.\n\n- 레이아웃 : 레이아웃은 일련의 데이터, 그리고 생성기로 구성된 배열을 입력받아 특정 위치와 크기로 그리는데 필요한 데이터 속성을 동적 혹은 정적으로 추가한다. 레이아웃을 생성하고 데이터를 넣어주면 해당 차트를 그리는데 필요한 값들을 자동으로 생성해준다.\n\n## 축 생성\n\n- 축 생성에는 다음과 같은 메서드가 제공된다. x축 : d3.axisTop(), d3.axisBottom(), y축 : d3.axisLeft(), d3.axisRight()가 존재한다.\n- x축에 해당하는 d3.axisTop(), d3.axisBottom()는 기본적으로 svg 영역의 상단에 x축이 생성이 되고 Top과 Bottom의 차이는 tick의 방향이라고 생각 하면 되겠다 Top은 tick이 아래에서 위로 향하고 Bottom은 위에서 아래로 향하게 된다.\n- x축을 d3.axisTop() 으로 생성하게 되면 레이블과 눈금을 볼 수 없다. 이 요소들이 그림 영역 밖에 그려지기 때문이다. 그래서 x축을 아래로 이동하려면 translate 를 사용해야한다.\n\n```javascript\nconst yAxis = d3.axisRight().scale(yScale)\nconst xAxis = d3.axisBottom().scale(xScale)\nd3.select('svg')\n  .append('g')\n  .attr('id', 'yAxisG')\n  .call(yAxis)\nd3.select('svg')\n  .append('g')\n  .attr('id', 'xAxisG')\n  .call(xAxis)\n```\n\nx축을 바닥으로 옮기고 y축을 오른쪽으로 옮겼을 때의 코드는 아래와 같다.\n\n```javascript\nconst scatterData = [\n  { friends: 5, salary: 22000 },\n  { friends: 3, salary: 18000 },\n  { friends: 10, salary: 88000 },\n  { friends: 0, salary: 180000 },\n  { friends: 27, salary: 56000 },\n  { friends: 8, salary: 74000 },\n]\n\nxExtent = d3.extent(scatterData, function(d) {\n  return d.salary\n})\nyExtent = d3.extent(scatterData, function(d) {\n  return d.friends\n})\nxScale = d3\n  .scaleLinear()\n  .domain(xExtent)\n  .range([20, 480])\nyScale = d3\n  .scaleLinear()\n  .domain(yExtent)\n  .range([480, 20])\n\n// 축 생성\n// const yAxis = d3.svg.axis().scale(yScale).orient('right')// y축\nconst yAxis = d3\n  .axisRight()\n  .scale(yScale)\n  .tickSize(-460)\n  .tickPadding(7)\nconst xAxis = d3\n  .axisBottom()\n  .scale(xScale)\n  .tickSize(-460)\n  .tickPadding(7)\n// const xAxis = d3.axisTop().scale(xScale)\nd3.select('svg')\n  .append('g')\n  .attr('id', 'yAxisG')\n  .call(yAxis)\nd3.select('svg')\n  .append('g')\n  .attr('id', 'xAxisG')\n  .call(xAxis)\n\nd3.select('#xAxisG').attr('transform', 'translate(0, 480)')\nd3.select('#yAxisG').attr('transform', 'translate(480, 0)')\n\nd3.select('svg')\n  .selectAll('circle')\n  .data(scatterData)\n  .enter()\n  .append('circle')\n  .attr('r', 5)\n  .attr('cx', function(d) {\n    return xScale(d.salary)\n  })\n  .attr('cy', function(d) {\n    return yScale(d.friends)\n  })\n```\n\n## 점으로 선 그리기\n\n- 기본적으로 선 생성기는 x값 배열과 y값 배열, 두개를 인자로 받는다.\n- 선 생성기는 점 배열을 입력 받으므로 각 점의 좌표로 구성된 값을 생성기에 전달해야 한다.\n- 선 생성기의 x() 접근자 메서드를 사용해서 x값을 셋팅할수 있고 y() 접근자 메서드를 사용해서 y값을 셋팅할 수 있다.\n\n```javascript\nconst tweetLine = d3\n  .line() // tweetLine 이 선 생성기\n  // 데이터에 대한 접근자를 정의한다.\n  // 여기에서는 날짜 속성을 가져와 xScale()에 전달한다.\n  .x(d => xScale(d.day))\n  .y(d => yScale(y.tweets))\n\n// tweetdata로 로딩된 생성기가 추가한 경로를 그린다.\nd3.select('svg')\n  .append('path')\n  .attr('d', tweetLine(data))\n  .attr('fill', 'none')\n  .attr('stroke', 'darkred')\n  .attr('stroke-width', 2)\n```\n\n## 채워진 영역\n\n- SVG에서 선(line)과 채워진 영역(filled areas)는 거의 동일합니다. 단지 그리는 코드 제일 뒤에 'Z'를 추가하거나 도형에 'fill' 스타일이 있으면 닫힌 도형이 됩니다.\n- D3는 d3.line() 생성기로 선을 그리고, d3.area() 생성기로 영역을 그립니다. 두 생성기 모두 <path> 요소를 생성하지만 d3.area()는 경로의 아래 영역을 막아 영역을 만드는 헬퍼 함수를 제공한다.\n- y() 접근자만 셋팅 했을 때 y0에 y를 넣고 y1은 null 셋팅(null을 셋팅한다는 것은 이전에 계산되었던 y0 값을 재사용하겠다는 뜻이다.)한다.\n- x축으로 채워지는 모양을 만들기 위해선 y0, y1 또는 y, y1을 셋팅해주어야 한다.\n\n```javascript\n// y0 접근자 default\nfunction y() {\n  return 0\n}\n\n// y1 접근자 default\nfunction y(d) {\n  return d[1]\n}\n```\n\n- `path` 의 경로를 닫든 닫지 않든, 영역을 채우든 채우지 않든, 도형과 선을 그릴 때는 대부분 `d3.line()` 을 사용한다. (d 속성의 끝에 Z를 넣거나, fill 속성을 채워준다.) 그러나 `다른 도형의 꼭대기를 바닥`으로 삼아 누적된 도형을 그릴 때는 `d3.area()` 를 사용해야 한다. `d3.area()`는 누적 영역 차트나 스트림 그래프처럼 데이터의 대역을 그리기에 적절하다.\n\n```javascript\nd3.csv('movies.csv', data => data).then(arrData => areaChart(arrData))\n\nfunction areaChart(data) {\n  xScale = d3\n    .scaleLinear()\n    .domain([1, 10.5])\n    .range([20, 480])\n  yScale = d3\n    .scaleLinear()\n    .domain([0, 35])\n    .range([240, 20])\n\n  xAxis = d3\n    .axisBottom()\n    .scale(xScale)\n    .tickSize(480)\n    .tickValues([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n  d3.select('svg')\n    .append('g')\n    .attr('id', 'xAxisG')\n    .call(xAxis)\n\n  yAxis = d3\n    .axisRight()\n    .scale(yScale)\n    .ticks(10)\n    .tickSize(480)\n  //.tickSubdivide(true);\n\n  d3.select('svg')\n    .append('g')\n    .attr('id', 'yAxisG')\n    .call(yAxis)\n\n  // fillScale = d3.scaleLinear()\n  //     .domain([0,5])\n  //     .range([\"lightgray\",\"black\"]);\n\n  var n = 0\n  for (x in data[0]) {\n    if (x != 'day') {\n      const movieArea = d3\n        .area()\n        .x(function(d) {\n          return xScale(d.day)\n        })\n        .y0(function(d) {\n          return yScale(-d[x])\n        })\n        .y1(function(d) {\n          // return yScale(simpleStacking(d,x) - d[x]);\n          return yScale(d[x])\n        })\n        .curve(d3.curveCardinal.tension(0))\n\n      d3.select('svg')\n        .append('path')\n        .attr('id', x + 'Area')\n        .attr('d', movieArea(data))\n        .attr('fill', 'darkgray')\n        .attr('stroke', 'lightgray')\n        .attr('stroke-width', 2)\n        .style('opacity', 0.5)\n\n      n++\n    }\n  }\n}\n```\n\n- 위 차트를 누적 차트로 만들면 다음과 같다. 각 영역의 높이는 영화 한 편이 그날 벌어들인 매출액을 나타내며, 각 영역의 밑은 그날 다른 영화들이 벌어들인 매출액의 합계를 나타낸다.\n\n```javascript\nd3.csv('movies.csv', data => data).then(arrData => areaChart(arrData))\n\nfunction areaChart(data) {\n  xScale = d3\n    .scaleLinear()\n    .domain([0, 11])\n    .range([20, 480])\n  yScale = d3\n    .scaleLinear()\n    .domain([-100, 100])\n    .range([480, 20])\n\n  xAxis = d3\n    .axisBottom()\n    .scale(xScale)\n    .tickSize(480)\n    .tickValues([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n  d3.select('svg')\n    .append('g')\n    .attr('id', 'xAxisG')\n    .call(xAxis)\n\n  yAxis = d3\n    .axisRight()\n    .scale(yScale)\n    .ticks(10)\n    .tickSize(480)\n\n  d3.select('svg')\n    .append('g')\n    .attr('id', 'yAxisG')\n    .call(yAxis)\n\n  fillScale = d3\n    .scaleLinear()\n    .domain([0, 5])\n    .range(['lightgray', 'black'])\n\n  var n = 0\n  for (x in data[0]) {\n    if (x != 'day') {\n      const movieArea = d3\n        .area()\n        .x(function(d) {\n          return xScale(d.day)\n        })\n        .y0(function(d) {\n          console.log(simpleStacking(d, x)) // 매번 다른 객체, movie1\n          return yScale(simpleStacking(d, x) - d[x])\n        })\n        .y1(function(d) {\n          // return yScale(simpleStacking(d,x) - d[x]);\n          return yScale(simpleStacking(d, x))\n        })\n        .curve(d3.curveCardinal.tension(0))\n\n      d3.select('svg')\n        .append('path')\n        .attr('id', x + 'Area')\n        .attr('d', movieArea(data)) // data는 배열. 배열을 순회하면서 movie1 을 먼저 그리고\n        .attr('fill', fillScale(n))\n        .attr('stroke', 'lightgray')\n        .attr('stroke-width', 2)\n        .style('opacity', 0.5)\n\n      n++\n    }\n  }\n\n  function simpleStacking(incomingData, incomingAttribute) {\n    var newHeight = 0\n    for (x in incomingData) {\n      if (x != 'day') {\n        newHeight += parseInt(incomingData[x])\n        if (x == incomingAttribute) {\n          break\n        }\n      }\n    }\n    return newHeight\n  }\n}\n```\n\n- 누적 차트를 스트림 그래프로 만들려면 누적된 영역이 교차 해야한다.\n\n# 레이아웃\n\nD3에는 일반적인 차트 기법으로 표현할 수 있도록 데이터 포맷 작업을 도와주는 레이아웃(layout) 함수가 여럿 있습니다.\n또한 원호를 애니메이션 하는 트위닝(tweening) 이라는 기술도 있다.\n\n- 레이아웃은 데이터를 출력할 수 있도록 포맷한다.\n- 레이아웃의 도움을 받지 않고 원시 데이터에서 막대 그래프를 생성할 때 사용한 스케일과 컴포넌트는 레이아웃을 사용할 때도 필요하다.\n- 히스토그램은 자연수뿐만 아니라 스케일에 들어가는 범윗값도 자동으로 저장한다.\n- 다른 차원의 데이터로 차트를 동적으로 변경하더라도 원래 차트를 제가할 필요는 없다. 레이아웃으로 데이터를 다시 포맷하고 원래 요소에 다시 바인딩하면 된다.\n\n레이아웃에 데이터 셋을 넣어주면 원래 데이터뿐만 아니라 그래프 요소나 생성기에 전달할 새로운 속성을 가진 데이터 셋을 반환한다.\n\n5버젼에서 layout은 `Chords`, `Fouces`, `Hierarchies` 만 남아있다.\n\n## 파이 차트\n\n```javascript\nconst pieChart = d3\n  .pie() // 생성자\n  .value(d => d.numTweets)\n  .sort(null)\n\nconst newArc = d3\n  .arc() // 생성기\n  .innerRadius(20)\n  .outerRadius(100)\nconst tenColorScale = d3.scaleOrdinal(d3.schemeCategory10)\n\nd3.json('tweets.json').then(data => makeRingChart(data.tweets))\n\nfunction makeRingChart(arrIncomingData) {\n  const nestedTweets = d3\n    .nest()\n    .key(el => el.user)\n    .entries(arrIncomingData)\n  console.log('nestedTweets', nestedTweets)\n\n  nestedTweets.forEach(el => {\n    el.numTweets = el.values.length\n    el.numFavorites = d3.sum(el.values, d => d.favorites.length)\n    el.numRetweets = d3.sum(el.values, d => d.retweets.length)\n  })\n\n  const yourPie = pieChart(nestedTweets)\n\n  d3.select('svg')\n    .append('g')\n    .attr('transform', 'translate(250,250)')\n    .selectAll('path')\n    .data(yourPie, d => d.data.key)\n    .enter()\n    .append('path')\n    .attr('d', newArc)\n    .style('fill', d => tenColorScale(d.data.key))\n    .style('opacity', 0.5)\n    .style('stroke', 'black')\n    .style('stroke-width', '2px')\n    .each(function(d) {\n      this._current = d\n    })\n\n  setTimeout(() => {\n    pieChart.value(d => d.numFavorites)\n    d3.selectAll('path')\n      .data(pieChart(nestedTweets), d => d.data.key)\n      // transition 메서드가 원호를 잘 처리하지 못한다.\n      // 원호의 각을 전환하는 것이 아니라 각각의 부채꼴을 하나의 기하학적 도형으로 간주해 처리한다.\n      .transition()\n      .duration(1000)\n      .attrTween('d', arcTween) // attr('d', newArc)\n      .style('fill', d => tenColorScale(d.data.key))\n  }, 2000)\n\n  setTimeout(() => {\n    pieChart.value(d => d.numRetweets)\n    d3.selectAll('path')\n      .data(\n        pieChart(nestedTweets.filter(d => d.numRetweets > 0)),\n        d => d.data.key\n      )\n      .exit()\n      .remove()\n\n    d3.selectAll('path')\n      .data(\n        pieChart(nestedTweets.filter(d => d.numRetweets > 0)),\n        d => d.data.key\n      )\n      .transition()\n      .duration(1000)\n      .attrTween('d', arcTween)\n      .style('fill', d => tenColorScale(d.data.key))\n  }, 4000)\n\n  // 트위닝(tweening)\n  // 사전적 의미 ~사이에, ~중간에\n  // 키 프레임 사이를 자동으로 채워주는 기능\n  function arcTween(a) {\n    const i = d3.interpolate(this._current, a) // 이전 그려졌던 데이터와 바뀌어야 하는 데이터를 보간한다.\n    // this는 현재 DOM을 가리킨다.\n    this._current = i(0) // 바뀌어야 할 데이터를 다시 _current에 셋팅한다.\n    return function(t) {\n      // 원호의 모양을 계산해 원호를 트위닝 하는 원호 생성기를 사용한다.\n      // t 값이 0 에서 1로 세밀하게 증가한다.\n      return newArc(i(t))\n    }\n  }\n}\n```\n\n## 서클 팩\n\n- 다른 모든 레이아웃과 마찬가지로 팩 레이아웃은 데이터가 어떤 기본적인 틀에 맞춰 구성돼 있다고 가정한다.\n- 구체적으로 팩 레이아웃은 자식 요소들이 children 속성에 배열로 저장된 JSON 객체를 받는다.\n- 팩 레이아웃은 다음과 같은 계층 root객체가 필요하다.\n  - node.x : 원 객체의 중심 x 축\n  - node.y : 원 객체의 중심 y 축\n  - node.r : 원 객체의 반지름\n- 이 root 객체는 `d3.hierarchy(data[, children])` 또는 `d3.stratify()` 로 만들 수 있다.\n- root 객체를 만들고 나서는 `root.sum` 메서드를 호출해서 pack layout에 넘거야 합니다. 또한 `root.sort`로 계층의 순서도 조절할 수 있다.\n- `root.sum()`의 매개변수로 접근자 함수를 넣으면 각 node 별로 value 값이 생긴다.\n- `data()` 메서드로 넘길 때에는 레이아웃에 데이터를 넘긴 값의 `descendants()` 메서드를 호출해 계층별로 되어있는 구조를 선형구조인 배열로 바꿔준다.\n\n```javascript\nd3.json('tweets.json').then(data => dataViz(data.tweets))\n\nfunction dataViz(incData) {\n  const nestedTweets = d3\n    .nest()\n    .key(function(el) {\n      return el.user\n    })\n    .entries(incData)\n\n  const packableTweets = { id: 'root', values: nestedTweets }\n  const depthScale = d3.scaleOrdinal(d3.schemeCategory10) // ordinal : 서수\n  const packChart = d3\n    .pack() // 계층형 layout\n    .size([500, 500])\n    .radius(d => {\n      // console.log(d)\n      return d.value * 10\n    }) // radius는 pack 원의 반지름, default null일 경우 node.value 값으로 셋팅한다. , d 값은 말단 leaf node 객체이다.\n    .padding(5)\n  const rootData = d3\n    .hierarchy(packableTweets, d => d.values)\n    .sum(d => {\n      return d.favorites && d.retweets\n        ? d.favorites.length + d.retweets.length + 1\n        : 0\n    }) // 각 노드의 value를 셋팅해줌. 내부 값이 있는 leaf node만 셋팅해주고 싶다면 나머지는 0 으로 셋팅한다.\n\n  d3.select('svg')\n    .append('g')\n    .attr('transform', 'translate(0,0)')\n    .selectAll('circle')\n    .data(packChart(rootData).descendants())\n    .enter()\n    .append('circle')\n    .attr('r', function(d) {\n      return d.r\n    }) // 노드의 반지름을 depth 값에 따라 계산해 줄인다.\n    .attr('cx', function(d) {\n      return d.x\n    })\n    .attr('cy', function(d) {\n      return d.y\n    })\n    .style('fill', function(d) {\n      return depthScale(d.depth)\n    })\n    .style('stroke', 'black')\n    .style('stroke', '2px')\n}\n```\n\n## 트리\n\n- 트리 레이아웃은 다음과 같은 계층 root객체가 필요하다.\n  - node.x : 노드의 x 좌표\n  - node.y : 노드의 y 좌표\n- 노드와 노드를 연결 하기 위해선 `d3.hierarchy`의 리턴인 node 객체의 `links` 메서드를 사용한다. `links` 메서드를 사용하면 source 와 target 객체로 노드를 연결해 놓은 배열이 리턴된다.\n- 사용자가 드래그할 수 있도록 만들려 이벤트 리스너를 생성하는 `d3.zoom()`을 사용\n  - 작동하는 것은 컴포넌트와 똑같지만 그래픽 객체 대신 이벤트( 드래그, 마우스 휠, 드블 클릭 이벤트 )를 생성한다. 그런 다음 그래픽 요소를 작동하는 요소에 이벤트를 연결한다.\n  - 이벤트와 관련해 확대 객체는 translate()와 scale() 값을 조정해 전형적인 마우스 동작과 같은 결과를 가져온다. 이렇게 변경한 값을 이용하면 사용자의 상호작용에 대응애 그래픽 요소의 위치를 조정할 수 있다.\n  - zoom 컴포넌트를 생성할 때는 확대시작(zoomstart), 확대(zoom), 확대종료(zoomend) 이벤트가 발생할 때 호출할 함수를 정의한다.\n  - 확대는 사용자가 마우스를 드래그하는 동안 계속 발생하므로 리소스를 많이 사용하는 작업은 확대 이벤트의 시작과 끝에서만 하는 편이 좋다.\n  - 전체 차트를 드래그해 상화좌우로 패닝(panning) 할 수 있다.\n  - 지도를 다룰 때는 확대가 필요한 반면 이런 차트에서는 패닝을 훨씬 더 많이 사용한다.\n\n```javascript\nd3.json('tweets.json').then(data => dataViz(data.tweets))\n\nfunction dataViz(incData) {\n  // 데이터를 만드는 곳\n  const nestedTweets = d3\n    .nest()\n    .key(function(el) {\n      return el.user\n    })\n    .entries(incData)\n  const packableTweets = { id: 'root', values: nestedTweets }\n  const rootData = d3.hierarchy(packableTweets, d => d.values)\n\n  // 색 스케일\n  const depthScale = d3.scaleOrdinal(d3.schemeCategory10) // ordinal : 서수\n\n  const treeChart = d3.tree().size([500, 500]) // 계층형 레이아웃\n  const linkGenerator = d3\n    .linkHorizontal() // 가로로 링크를 생성하는 생성기\n    .x(d => d.y + 20) // 화면에 너무 붙지않게 하기 위해서\n    .y(d => d.x)\n\n  d3.select('svg')\n    .append('g')\n    .attr('class', 'treeG')\n    .selectAll('g')\n    .data(treeChart(rootData).descendants()) // treeChart(rootData) : node\n    .enter()\n    .append('g')\n    .attr('class', 'node')\n    .attr('transform', function(d) {\n      return 'translate(' + (d.y + 20) + ',' + d.x + ')' // 화면에 너무 붙지 않게 하기 위해서\n    })\n\n  d3.selectAll('g.node')\n    .append('circle')\n    .attr('r', 10)\n    .style('fill', function(d) {\n      return depthScale(d.depth)\n    })\n    .style('stroke', 'white')\n    .style('stroke-width', '2px')\n\n  d3.selectAll('g.node')\n    .append('text')\n    .text(function(d) {\n      return d.data.id || d.data.key || d.data.content\n    })\n\n  d3.select('g.treeG')\n    .selectAll('path')\n    .data(treeChart(rootData).links())\n    .enter()\n    .insert('path', 'g')\n    .attr('d', linkGenerator)\n    .style('fill', 'none')\n    .style('stroke', 'black')\n    .style('stroke-width', '2px')\n\n  treeZoom = d3.zoom()\n  treeZoom.on('zoom', zoomed)\n  d3.select('svg').call(treeZoom)\n\n  function zoomed() {\n    // 주어진 노드의 현재 transform이 리턴된다. 여기서 노드는 selection이 아닌 svg DOM Element 이다. \n    // element 내부에 __zoom이라는 속성으로 정보가 저장되지만 직접 접근하는 것보다 메서드를 통해서 접근하는게 좋다.\n    // transform.x : x축으로 이동한 양 tx\n    // transform.y : y축으로 이동한 양 ty\n    // transform.k : 스케일 지수 k\n    const { x, y } = d3.zoomTransform(this)\n\n    d3.select('g.treeG').attr('transform', 'translate(' + x + ',' + y + ')')\n  }\n}\n```\n\n## 스택\n\n- `d3.area()`에 전달해 누적 차트나 스트림 그래프를 쉽게 그릴 수 있도록 데이터를 포맷하는 스택 레이아웃을 제공한다.\n- 스트림 그래프는 적어도 차트의 영역이 시각적으로 각 영화의 이익 합계를 제대로 보여줄수 있다.\n- 스트림 그래프를 구현하려면 스택 레이아웃과 함께 영역 생성기를 사용해야 한다.\n  - 레이아웃의 요구에 맞도록 데이터를 처리한다.\n  - 데이터셋에 맞춰 레이아웃의 접근자 메서드를 설정한다.\n  - 레이아웃으로 데이터를 출력할 수 있게 포맷한다.\n  - 수정된 데이터를 직접 SVG 요소에 전달하거나 `d3.linkHorizontal()`, `d3.arc()`, `d3.area()` 등의 생성기와 결합시킨다.\n- `stack()` 생성기는 배열 데이터를 받아서 각 시리즈를 가지고있는 배열을 리턴한다.\n- 시리즈들은 key 접근자에 의해 결정된다.\n- 리턴된 배열은 2차원 배열로 구성이 되며 `result[i][j]`로 생각했을때, _i_ 는 key의 _i_ 번째 관한 데이터이고, _j_ 와 관련 되어있는 시리즈의 point는 입력된 배열 데이터의 _j_ 번째 요소에 해당한다.\n- 각 시리즈의 key 값은 `series.key`, index 값은 `series.index`, 각 포인트에 해당하는 input data는 `point.data`로 이용가능하다.\n\n```javascript\nvar data = [\n  {\n    month: new Date(2015, 0, 1),\n    apples: 3840,\n    bananas: 1920,\n    cherries: 960,\n    dates: 400,\n  },\n  {\n    month: new Date(2015, 1, 1),\n    apples: 1600,\n    bananas: 1440,\n    cherries: 960,\n    dates: 400,\n  },\n  {\n    month: new Date(2015, 2, 1),\n    apples: 640,\n    bananas: 960,\n    cherries: 640,\n    dates: 400,\n  },\n  {\n    month: new Date(2015, 3, 1),\n    apples: 320,\n    bananas: 480,\n    cherries: 640,\n    dates: 400,\n  },\n]\n\nvar stack = d3\n  .stack()\n  .keys(['apples', 'bananas', 'cherries', 'dates'])\n  .order(d3.stackOrderNone)\n  .offset(d3.stackOffsetNone)\n\nvar series = stack(data)\n\n// stack() 의 결과물\nconst result = [\n  [\n    [0, 3840], // point : 입력된 data 배열의 첫번째 데이터에 해당한다.\n    [0, 1600],\n    [0, 640],\n    [0, 320],\n  ], // apples (series)\n  [[3840, 5760], [1600, 3040], [640, 1600], [320, 800]], // bananas\n  [[5760, 6720], [3040, 4000], [1600, 2240], [800, 1440]], // cherries\n  [[6720, 7120], [4000, 4400], [2240, 2640], [1440, 1840]], // dates\n]\n```\n\n```javascript\nd3.csv('movies.csv').then(data => dataViz(data))\n\nfunction dataViz(incData) {\n  expData = incData\n  const stackData = []\n\n  const xScale = d3\n    .scaleLinear()\n    .domain([0, 11])\n    .range([0, 500])\n\n  const yScale = d3\n    .scaleLinear()\n    .domain([-30, 30])\n    .range([500, 0])\n\n  const movieColors = d3.scaleOrdinal(d3.schemeCategory10) // ordinal : 서수\n\n  const stackArea = d3\n    .area()\n    .x(function(d) {\n      return xScale(d.data.day)\n    })\n    .y0(function(d, i) {\n      return yScale(d[0])\n    })\n    .y1(function(d, i) {\n      return yScale(d[1])\n    })\n    .curve(d3.curveCardinal.tension(0))\n\n  const stackLayout = d3\n    .stack() // 생성자 (generate)\n    .keys(['movie1', 'movie2', 'movie3', 'movie4', 'movie5', 'movie6'])\n    .offset(d3.stackOffsetSilhouette) // 'silhouette' 수평선을 중심으로 누적된 영역을 그린다.\n    .order(d3.stackOrderInsideOut)\n\n  d3.select('svg')\n    .selectAll('path')\n    .data(stackLayout(incData))\n    .enter()\n    .append('path')\n    .style('fill', function(d) {\n      return movieColors(d.key)\n    })\n    .attr('d', function(d) {\n      return stackArea(d)\n    })\n}\n```\n\n## 생키 레이아웃\n\n- 생키 레이아웃은 플러그인이다. 기본적으로 d3에서 제공하는 api에 있지 않고 스크립트를 추가 해야 한다.[https://github.com/d3/d3-sankey](https://github.com/d3/d3-sankey)\n- 생키 다이어그램은 어떤 범주에서 다른 범주로 흘러가는 것을 보여줄 수 있다.\n- 생키 다이어그램은 구글 웹로그 분석에서 사용하는 다이어그램으로서, 웹 사이트의 한 페이지에서 다른 페이지로 이동한 사용자의 흐름을 보여준다.\n- 생키 다이어그램은 노드와 엣지(링크) 라는 두 종류의 객체로 구성된다.\n- 웹로그 분석에서 노드는 웹 페이지나 이벤트를, 엣지는 웹 페이지 간의 이동을 나타낸다.\n- 엣지는 웹 페이지 간의 이동을 나타낸다. 여러 노드를 다른 여러 노드에 연결할 수 있으므로 생키 다이어그램이 계층 구조를 표현하는 것은 아니다.\n\n### 데이터 시각화\n\n- 데이터 시각화는 데이터를 처리하는데 사용한 기법을 시각적으로 표현한 것이기도 하다.\n- 적절히 출력하는 레이아웃을 만든 후에는 설정과 요소를 바꿔가며 알고리즘이 어떻게 작동하는지 시각적으로 확인해볼 수 있다.\n\n## 워드 클라우드\n\n- 워드 클라우드는 텍스트를 중요도나 빈도에 따라 다른 크기로 표현한다.\n- 단어는 상당히 효율적인 그래픽 객체이다. 어떤 단어의 중요성을 나타내는 수치형 속성을 찾아낼 수 있다면 워드 클라우드 안에서 그 단어의 크기를 키워 사용자에게 중요성을 전달하면 된다.\n- 여타 레이아웃과 달리 cloud()는 워드 클라우드를 생성하는데 효율적인 공간의 계산을 완료 했을때, 이를 알려주려 end 이벤트를 발생한다. 이때 단어의 위치, 회전, 크기 등을 계산한 데이터셋을 함께 전달한다. 그러고 나면 레이아웃을 다시 언급하거나 변수에 할당할 필요 없이 바로 클라우드 레이아웃을 실행할 수 있다.\n- 클라우드 레이아웃을 다시 사용하거나 설정을 조정할 때는 다른 레이아웃과 마찬가지로 레이아웃을 변수에 할당해야 한다.\n","excerpt":"Intro D3는 데이터 주도 문서 (data-driven docuement)의 약자이다.\nD3.js는 웹으로 접근할 수 있고 데이터 시각화를 정교하게 하려는 요구를 만족하려 만들어졌다. 데이터 시각화라고 하면 지도, 대화형 다이어그램, 기타 도구와…","fields":{"slug":"/hello-d3.md/"},"frontmatter":{"date":"Oct 01, 2019","title":"hello-d3","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n[이글](https://medium.com/the-guild/under-the-hood-of-reacts-hooks-system-eb59638c9dba)을 번역 및 분석 한 글입니다. 잘못된 번역이 있을 수 있습니다. 또한 예전 코드들이 많으므로 참고만 해야 합니다. 현재 코드랑 다른점이 많이 있습니다.\n\n# Under the hood of React’s hooks system\n\n우리는 모두 그것에 대해 들었습니다. React 16.7 의 새로운 훅 시스템은 커뮤니티에서 많은 이야기가 나옵니다. 우리는 모두 그것을 시도하고 그것을 테스트하고, 그리고 그것의 잠재력에 대해 정말로 흥분했습니다. 후크에 대해 생각할 때 그것들은 다소 마술적입니다. 어떻게 든 React 는 인스턴스를 노출하지 않고도이 구성 요소를 관리합니다 (`this` 키워드를 사용하지 않아도 됨). 그래서 도대체 어떻게 React 가 그렇게합니까?\n\n오늘 나는 React 의 후크 구현에 대해 더 자세히 이해할 수 있기를 바랍니다. 마법 같은 기능의 문제점은 복잡한 스택 추적으로 뒷받침되기 때문에 문제가 발생하면 문제를 디버그하는 것이 더 어렵다는 것입니다. 따라서, React 의 새로운 후크 시스템에 대한 깊은 지식을 갖게되면 문제가 발생하면 이를 신속하게 해결할 수 있을 것입니다.\n\n> 시작하기 전에 저는 제가 React 의 개발자 / 유지자가 아니며 제 말을 아주 작은 알갱이로 가야한다고 말하고 싶습니다. 나는 React 's hooks 시스템의 구현에 깊이 깊이 잠긴했지만, 꼭 이것이 React 가 실제로 어떻게 작동 하는지를 보장 할 수는 없습니다. 필자는 필자의 말을 React 의 소스 코드에서 증명과 참조로 뒷받침했으며 가능한 한 견고하게 주장하려고 노력했습니다.\n\n![https://miro.medium.com/max/684/1*R-oovJm4IQBLDjZy6DvbBg.png](https://miro.medium.com/max/684/1*R-oovJm4IQBLDjZy6DvbBg.png)\n\n우선, 올바른 컨텍스트에서 호출되지 않으면 후크가 의미가 없다는 것을 알았을 것이므로 React의 범위 내에서 후크가 호출되도록하는 메커니즘을 살펴 보겠습니다.\n\n## The dispatcher\n\n디스패처는 후크 기능을 포함하는 공유 객체입니다. ReactDOM 의 렌더링 단계를 기반으로 동적으로 할당되거나 정리되며 사용자가 React 구성 요소 외부의 후크에 접근하지 못하게 합니다. (see [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberDispatcher.js?source=post_page---------------------------#L24)).\n\n```javascript\n// ReactFiberDispatcher.js\nimport {\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeMethods,\n  useLayoutEffect,\n  useMemo,\n  useMutationEffect,\n  useReducer,\n  useRef,\n  useState,\n} from './ReactFiberHooks'\n\nexport const Dispatcher = {\n  readContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeMethods,\n  useLayoutEffect,\n  useMemo,\n  useMutationEffect,\n  useReducer,\n  useRef,\n  useState,\n}\n```\n\n후크는 올바른 디스패처로 간단하게 전환하여 루트 구성 요소를 렌더링하기 전에 `enableHooks` 플래그에 의해 활성화 / 비활성화됩니다. 이는 기술적으로 런타임에 후크를 활성화 / 비활성화 할 수 있음을 의미합니다. React 16.6.X 에는 실험 기능이 구현되어 있지만 실제로는 사용할 수 없습니다. (see [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1211)).\n\n```javascript\n// 1211줄 ReactFiberScheduler.js\nif (enableHooks) {\n  ReactCurrentOwner.currentDispatcher = Dispatcher\n} else {\n  ReactCurrentOwner.currentDispatcher = DispatcherWithoutHooks\n}\n```\n\n렌더링 작업(여기서 렌더링 작업이라 하면 fiber를 구성하고 아직 스크린에 반영하지 않은 작업상태를 뜻한다.)이 끝나면 디스패처를 무효화하여 ReactDOM 렌더링주기 밖에서 후크가 실수로 사용되는 것을 방지합니다. 이것은 사용자가 어리석은 일을 하지 않도록 보장하는 메커니즘입니다. (see [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1376)).\n\n```javascript\n// 1376줄 ReactFiberScheduler.js\n// We're done performing work. Time to clean up.\nReactCurrentOwner.currentDispatcher = null\n```\n\ndispatcher는 `resolveDispatcher()` 함수를 사용하여 각각의 모든 후크 호출에서 resolve됩니다. 앞에서 말했듯이, React 의 렌더링주기 밖에서는 의미가 없어야하고, React 는 경고 메시지를 출력해야합니다 : _\"후크는 함수 구성 요소의 본체 내부에서만 호출 할 수 있습니다\"_ (see [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react/src/ReactHooks.js?source=post_page---------------------------#L17)).\n\nDispatcher 실행을 간단하게 표현하면 아래와 같습니다.\n\n매 `renderRoot` 에서만 `currentDispatcher` 가 할당되며 render가 모두 끝나면 `currentDispatcher` 을 null 처리 해서 외부 에서 `useXXX`를 호출 했을시 error 가 나게 했다.\n\n```javascript\nlet currentDispatcher\nconst dispatcherWithoutHooks = {\n  /* ... */\n}\nconst dispatcherWithHooks = {\n  /* ... */\n}\n\nfunction resolveDispatcher() { // 적절한 dispatcher를 리턴해준다.\n  if (currentDispatcher) return currentDispatcher\n  throw Error(\"Hooks can't be called\")\n}\n\nfunction useXXX(...args) {\n  const dispatcher = resolveDispatcher()\n  return dispatcher.useXXX(...args)\n}\n\nfunction renderRoot() {\n  currentDispatcher = enableHooks ? dispatcherWithHooks : dispatcherWithoutHooks // root render하기 전에 알맞는 dispatcher 셋팅\n  performWork()\n  currentDispatcher = null\n}\n```\n\n실제 React github 코드 상에선 아래와 같이 표현하고 있다. (예전 코드)\n\n```javascript\n// 16줄 ReactFiberScheduler.js\nfunction resolveDispatcher() {\n  const dispatcher = ReactCurrentOwner.currentDispatcher\n  invariant(\n    dispatcher !== null,\n    'Hooks can only be called inside the body of a function component.'\n  )\n  return dispatcher\n}\n```\n\n```javascript\n// 54줄 ReactFiberScheduler.js\nexport function useState<S>(initialState: (() => S) | S) {\n  const dispatcher = resolveDispatcher()\n  return dispatcher.useState(initialState)\n}\n```\n\n이제는 간단한 `캡슐화 메커니즘`을 살펴 보았으므로 이 기사의 핵심 인 후크로 넘어 가고자 한다. 여기서 나는 새로운 개념을 소개하고자 합니다.\n\n## The hooks queue\n\nReact 뒤에서, hooks는 호출 순서로 함께 연결된 노드로 표시됩니다. 후크는 단순히 생성된 다음 혼자 남겨지는 것이 아니기 때문에 그렇게 표현됩니다. 그들은 그들이 있는 그대로가 될 수 있도록 하는 메커니즘을 가지고 있다. 후크(hook)에는 구현에 뛰어 들기 전에 염두해야 할 필요한 몇 가지 프로퍼티들 있습니다.\n\n* hook의 초기 상태값은 초기 렌더링시에 생성됩니다.\n* hook의 상태는 즉시 업데이트 할 수 있습니다.\n* React 는 다음번 렌더링에서 hook 의 상태를 기억할 것입니다.\n* React 는 호출 순서에 따라 올바른 상태를 제공합니다.\n* React 는 이 hook 이 어떤 fiber 에 속하는지 알 수 있습니다.\n\n따라서 component 의 상태를 보는 방식을 다시 생각 해야합니다. 지금까지 우리는 마치 평범한 object 인 것처럼 그것에 대해 생각해 왔습니다.\n\n```javascript\n// React state - the old way\n{\n  foo: 'foo',\n  bar: 'bar',\n  baz: 'baz',\n}\n```\n\n그러나 후크를 처리 할 때 각 노드가 하나의 상태 모델을 나타내는 큐로 간주 되어야합니다.\n\n```javascript\n// React state - the new way\n{\n  memoizedState: 'foo',\n  baseUpdate: {\n    expirationTime: '만료시간',\n    action: '업뎃에 필요한 액션',\n    next: '다음 업뎃?'\n  },\n  queue: {\n    last: '마지막에 업데이트 했던 작업',\n    dispatch: ''\n  },\n  next: {\n    memoizedState: 'bar',\n    next: {\n      memoizedState: 'baz',\n      next: null\n    }\n  }\n}\n// 이것은 흡사 배열과 비슷할 수 있을거 같다.\n// ['foo', 'bar', 'baz'] iterator\n// ['foo', 'bar', 'baz'][Symbol.iterator]()\n```\n\n단일 훅 노드의 스키마는 [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js?source=post_page---------------------------#L243).에서 볼 수 있습니다.\n\n```javascript\ntype Update<A> = {\n  expirationTime: ExpirationTime,\n  action: A,\n  next: Update<A> | null,\n};\n\ntype UpdateQueue<A> = {\n  last: Update<A> | null,\n  dispatch: any,\n};\n\nexport type Hook = {\n  memoizedState: any,\n\n  baseState: any,\n  baseUpdate: Update<any> | null,\n  queue: UpdateQueue<any> | null,\n\n  next: Hook | null,\n};\n\n// ReactFiberHooks.js\nfunction createHook(): Hook {\n  return {\n    memoizedState: null,\n\n    baseState: null,\n    queue: null,\n    baseUpdate: null,\n\n    next: null,\n  }\n}\n```\n\n훅에는 몇 가지 추가 속성이 있지만 훅의 작동 방식을 이해하는 열쇠는 `memoizedState` 와 `next` 내에 있습니다. 나머지 프로퍼티들은 `useReducer()` 훅에 의해 특별히 사용되어 `디스패치 된 액션(dispatched actions)`과 `기본 상태들(base states)`를 캐싱하므로 다양한 경우를 대비하여 reduction process가 반복 될 수 있습니다 :\n\n* `baseState` - reducer 에 주어진 상태 객체.\n* `baseUpdate` -`baseState`를 생성 한 가장 최근의 dispatch 된 액션입니다. (ex. [state, setState] = useState(0); setState(액션))\n* `queue` - dispatch 된 액션의 대기열(queue), reducer 를 통해 처리되길 기다리는 액션들이다.\n\n각 함수형 `fiber`마다 memoizedState field 에 `hook`을 지니고 있다.\n\n```javascript\n\n// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nlet firstCurrentHook: Hook | null = null;\nlet currentHook: Hook | null = null;\nlet firstWorkInProgressHook: Hook | null = null;\nlet workInProgressHook: Hook | null = null;\n\n// https://github.com/facebook/react/blob/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js?source=post_page---------------------------#L367\nexport function useReducer<S, A>(\n  reducer: (S, A) => S,\n  initialState: S,\n  initialAction: A | void | null,): [S, Dispatch<A>] {\n  \n  currentlyRenderingFiber = resolveCurrentlyRenderingFiber();\n  workInProgressHook = createWorkInProgressHook();\n  let queue: UpdateQueue<A> | null = (workInProgressHook.queue: any);\n  // .. 생략..\n\n  // 업데이트 시\n  // // 재 렌더시 (isReRender) - workInProgressHook에 next가 존재할 경우 \n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  // 재 렌더가 아닐 경우\n\n\n  // 첫 렌더시 \n  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;\n  queue = workInProgressHook.queue = {\n    last: null,\n    dispatch: null,\n  };\n  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any)); // action 만 나중에 받게끔 dispatch를 bind 시킴.\n  return [workInProgressHook.memoizedState, dispatch];\n\n}\n\n\n\n// useState에서 사용하는 reducer에는 basicStateReducer 사용\nfunction basicStateReducer(state, action) {\n  return typeof action === 'function' ? action(state) : action\n}\n\n```\n\n> 여기서 reducer 는 action 과 payload state 를 받아서 새로운 state 를 반환하는 순수함수라 할 수 있겠다. baseUpdate 는 액션이라고 보면 될것이다.\n\n불행하게도 거의 모든 경우를 재현 할 수 없었기 때문에 reducer hook 을 잘 이해할 수 없었습니다. 그래서 정교하게 느껴지지 않을 것입니다. 나는 단지 reducer 구현이 너무 일관성이 없기 때문에 [implementation](https://github.com/facebook/react/blob/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js?source=post_page---------------------------#L380) 에서 구현 자체의 주석 중 하나조차도 \"(이것이) 원하는 의미론이 맞는지 확실치 않다(TODO: Not sure if this is the desired semantics, but it's what we do for gDSFP. I can't remember why.)\" 라고 말합니다. 그래서 어떻게 확신해야합니까?!\n\n후크로 돌아가서, 각각의 모든 컴포넌트 호출 이전에,  [`prepareHooks()`](https://github.com/facebook/react/blob/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js#L123)라는 이름의 함수가 호출됩니다. **이 함수안에서는 current fiber 와 hooks 큐(대기열) 안에 있는 그것의 첫 번째 hook 노드는 전역 변수에 저장됩니다. 이런 방식으로, 우리가 후크 함수 (`useXXX ()`)를 호출 할 때마다 어떤 컨텍스트에서 실행되는지를 알 수 있습니다.**\n\n> `prepareHooks()` 이 함수가 보이지 않는다. `prepareToUseHooks()` 이 함수인거 같다.\n\n다음은 Hooks 대기열이 실행되는 간단한 코드 형식이다.\n\n```typescript\ntype Update<A> = {\n  expirationTime: ExpirationTime\n  action: A\n  next: Update<A> | null\n}\n\ntype UpdateQueue<A> = {\n  last: Update<A> | null\n  dispatch: any\n}\ntype Hook = {\n  memoizedState: any\n\n  baseState: any\n  baseUpdate: Update<any> | null\n  queue: UpdateQueue<any> | null\n\n  next: Hook | null\n}\n\n// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nlet currentlyRenderingFiber: Fiber | null = null\n// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nlet workInProgressHook: Hook | null = null\nlet currentHook: Hook | null = null\n\n// Source: https://github.com/facebook/react/blob/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js#L123\n// 2. 전역에 셋팅\nfunction prepareHooks(current: Fiber | null,\n  workInProgress: Fiber,\n  nextRenderExpirationTime: ExpirationTime,) {\n     \n  renderExpirationTime = nextRenderExpirationTime;\n  currentlyRenderingFiber = workInProgress; // 현재 작업중인 Fiber\n  firstCurrentHook = current !== null ? current.memoizedState : null; // 이미 render된 Fiber(current)의 memoizedState를 firstCurrentHook 할당.\n}\n\n// Source: https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/react-reconciler/src/ReactFiberHooks.js:148\nfunction finishHooks() {\n  currentlyRenderingFiber.memoizedState = firstWorkInProgressHook\n  \n  currentlyRenderingFiber = null;\n  firstCurrentHook = null;\n  currentHook = null;\n  firstWorkInProgressHook = null;\n  workInProgressHook = null;\n}\n\n// Source: https://github.com/facebook/react/blob/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js#L332\nfunction resolveCurrentlyRenderingFiber() {\n  if (currentlyRenderingFiber) return currentlyRenderingFiber\n  throw Error(\"Hooks can't be called\")\n}\n// Source: https://github.com/facebook/react/blob/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js#L267\nfunction createWorkInProgressHook() {\n  // workInProgressHook 가 존재하고 next가 존재하지 않으면 hook을 새로 만들어서 workInProgressHook = workInProgressHook.next = hook;\n  // workInProgressHook 가 존재하고 next가 존재하면 workInProgressHook = workInProgressHook.next;\n  // workInProgressHook 가 존재하지 않고 firstWorkInProgressHook가 존재하지 않으면 firstWorkInProgressHook = workInProgressHook;\n  // 기존 fiber에 등록된 훅이 있으면 그 훅을 복사해서 사용하고 그게 아니라면 새로운 훅을 생성한다. \n  workInProgressHook = currentHook ? cloneHook(currentHook) : createNewHook()\n  currentHook = currentHook !== null ? currentHook.next : null;\n  return workInProgressHook\n}\n\n// 4. 컴포넌트 안에서 호출되는 useXXX 함수.\nfunction useXXX() {\n  const fiber = resolveCurrentlyRenderingFiber() // update 될 fiber 리턴.\n  const hook = createWorkInProgressHook() //현재 렌더링된 fiber의 memoizedState\n  // ...\n}\n\nfunction updateFunctionComponent(\n  recentFiber,\n  workInProgressFiber,\n  Component,\n  props\n) {\n  prepareHooks(recentFiber, workInProgressFiber) // 1. 훅 준비\n  Component(props) // 3. 컴포넌트 호출 - 여기서 useXXX 호출할 것이다.\n  finishHooks() // 5. Hooks 마무리\n}\n```\n\n업데이트가 완료되면, [`finishHooks()`](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/react-reconciler/src/ReactFiberHooks.js:148?source=post_page---------------------------) 이 호출 될 것입니다. 여기서 후크 대기열(hooks queue)의 첫 번째 노드에 대한 참조가 렌더링 된 fiber 의 `memoizedState` 속성에 저장됩니다. 즉, 후크 대기열과 그 상태를 외부 적으로 처리 할 수 ​​있습니다.\n\n컴퍼넌트의 메모 상태의 외부 읽기.\n\n```javascript\nconst ChildComponent = () => {\n  useState('foo')\n  useState('bar')\n  useState('baz')\n\n  return null\n}\n\nconst ParentComponent = () => {\n  const childFiberRef = useRef()\n\n  useEffect(() => {\n    // 자식이 mount 된 후에 실행된다.\n    let hookNode = childFiberRef.current.memoizedState\n\n    assert(hookNode.memoizedState, 'foo')\n    hookNode = hooksNode.next\n    assert(hookNode.memoizedState, 'bar')\n    hookNode = hooksNode.next\n    assert(hookNode.memoizedState, 'baz')\n  })\n\n  return <ChildComponent ref={childFiberRef} />\n}\n```\n\n가장 일반적인 상태 후크부터 시작하여 개별 후크에 대해 더 구체적으로 설명하고 이야기하겠습니다.\n\n## State hooks\n\n놀랍지만 `useState` 훅 뒤에선 `useReducer` 를 사용하고 단순히 미리 정의 된 reducer 핸들러를 제공합니다 (see [implementation](https://github.com/facebook/react/blob/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js?source=post_page---------------------------#L339)). 즉, `useState` 에 의해 리턴 된 결과는 실제로 reducer 상태(state)와 action 디스패처(dispatcher)입니다. 상태 후크가 사용하는 reducer 핸들러를 살펴 보시기 바랍니다.\n\n```javascript\nfunction basicStateReducer(state, action) {\n  return typeof action === 'function' ? action(state) : action\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S\n): [S, Dispatch<BasicStateAction<S>>] {\n  return useReducer(\n    basicStateReducer,\n    // useReducer has a special case to support lazy useState initializers\n    (initialState: any)\n  ) // return [state, dispatchState]\n}\n\n// dispatchState(value) => basicStateReducer 함수의 action에 value 값이 할당되고 action은 함수가 아니기에\n// 바로 action이 리턴되고 state에 할당된다.\n\n// 그럼 만약에 dispatchState((state) => state + 10) 이라고 하면 될까??? 된다.!!!\n// <button onClick={() => setCount((count) => count+10)}>increse</button>\n```\n\n`useReducer()` 함수는 간단하게 이렇게 작성될 수 있다. [useReducer](https://github.com/facebook/react/blob/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js?source=post_page---------------------------#L346)\n\n함수형 컴포넌트가 실행되고 나면 현재 fiber랑 해당 fiber에 hook을 전역으로 준비해둔다. 그리고 나서 `useState`를 호출이 되면 내부적으로 `useReduce` 함수가 실행이 되고 이 안에서 필요한 `hook` 을 만들어내거나 참조하게 된다. 그리고 나서 hook의 state와 dispatch를 리턴하고 나면 함수형 컴포넌트가 끝날쯤에 `finishHooks`을 호출 해당되는 hook의 첫번째 참조값을 해당 fiber의 memoizedState에 연결해두고 전역변수 들을 정리한다. \n\n아래 함수에서 `useState`호출시 `useReducer`를 호출 후 리턴 배열이 리턴이 되는데 이때 `dispatch`가 `dispatchAction` 함수의 binding 된 함수이다. 이때 바인딩 되는 인자들은 현재 렌더링 될 fiber 를 가지고 있게 되는데 그렇다면 우리가 `dispatch` 함수를 액션을 넣어서 호출 할 때마다 어떤 fiber 와 연관되어있는지 알게 되는 것이다. 그래서 해당 fiber 에서부터 reconcile 을 하는거 같다.\n\n\n\n\n\n```javascript\nexport function useReducer() {\n  currentlyRenderingFiber = resolveCurrentlyRenderingFiber()\n  workInProgressHook = createWorkInProgressHook()\n  let queue: UpdateQueue<A> | null = (workInProgressHook.queue: any)\n\n  // ...\n  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchAction.bind(\n    null,\n    currentlyRenderingFiber, // workInTree Fiber\n    queue\n  ): any))\n  return [workInProgressHook.memoizedState, dispatch]\n}\n\nfunction dispatchAction<A>(fiber: Fiber, queue: UpdateQueue<A>, action: A) {\n  //...\n  scheduleWork(fiber, expirationTime)\n}\n```\n\n예상대로 액션 디스패처에 새로운 상태를 직접 제공 할 수 있습니다. Dispatcher 에게 _액션 함수를 제공하여 이전 상태를 받고 새 상태를 반환 할 수도 있습니다 ._\n\n즉, 구성 요소 트리 아래로 `state setter`(useState 에서 리턴된 배열의 두번째 함수)를 보내면 다른 props 없이 상위 구성 요소의 현재 상태(current state)에 대해 변형을 실행할 수 있습니다. 예 :\n\n```javascript\nconst ParentComponent = () => {\n  const [name, setName] = useState()\n\n  return <ChildComponent toUpperCase={setName} />\n}\n\nconst ChildComponent = props => {\n  useEffect(\n    () => {\n      props.toUpperCase(state => state.toUpperCase())\n    },\n    [true]\n  )\n\n  return null\n}\n```\n\n마지막으로, 구성 요소의 라이플 사이클에 중요한 영향을 미치는 effect hooks 작동 방식을 알아보자.\n\n\n## Effect hooks\n\n이펙트 후크는 약간 다르게 동작하고 내가 설명하고 싶은 추가 로직 레이어를 가지고 있습니다. 다시 한 번, 구현에 들어가기 전에 effect hook의 프로퍼티들에 대해 염두에 두어야 할 사항이 있습니다.\n\n- effect hooks는 렌더링 시간 동안 생성되지만 페인팅 후에 실행됩니다.\n- 그렇게되면, 그들은 다음 페인팅 직전에 파괴 될 것입니다.\n- 그들은 정의된 순서대로 호출됩니다.\n\n_\"페이팅\"이라는 용어를 사용하고 \"렌더링\" 단어는 사용하하지 않았습니다. 이 두 가지가 다른데, 나는 최근의 [_React Conf_](https://conf.reactjs.org/?source=post_page---------------------------)에서 잘못된 용어를 사용하는 것을 많이 바왔다.! 공식 [_React docs_](https://reactjs.org/docs/hooks-reference.html?source=post_page---------------------------#useeffect)에서 \"페인팅\"과 같은 말을 \"렌더링이 화면에 적용 된 후\"라고 말합니다. render 메서드는 파이버 노드를 생성하지만 아직 아무것도 그리지 않습니다 ._\n\n따라서 이러한 효과를 유지해야하는 추가 대기열이 있어야하며 페인팅 후에 처리해야합니다. 일반적으로 말하자면, fiber는 effect node들을 포함하는 대기열을 보유하고 있습니다. 각 effect는 다른 유형이므로 적절한 단계에서 해결해야합니다.\n\n-   mutation이 일어나기 전에 `getSnapshotBeforeUpdate()` 인스턴스를 호출한다.  (see  [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L646)).\n-  all the host 삽입, 업데이트, 삭제 그리고 참조해제를 수행한다.  (see  [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L687)).\n- 모든 라이프 사이클 및 참조 콜백을 수행하십시오. 라이프 사이클은 별도의 실행으로 발생하므로 전체 트리에서 모든 배치, 업데이트 및 삭제가 이미 호출되었습니다. 이 실행은 또한 렌더러 관련 초기 효과를 트리거합니다. (see  [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L732)).\n- `useEffect()`  hook에 의해 스케쥴된 Effect - 구현에 기반한 \"passive effects\" 라고도 합니다. [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L779)  (어쩌면 우리는 React 커뮤니티에서이 용어를 사용해야 할까?).\n\nhook effects에 관해서는 fiber의 `updateQueue` 라는 속성에 저장해야하며 각 효과 노드(effect node)는 다음 스키마를 가져야합니다 ((see  [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js?source=post_page---------------------------#L477)):\n\n```typescript\nfunction pushEffect(tag, create, destroy, inputs) {\n  const effect: Effect = {\n    tag,\n    create,\n    destroy,\n    inputs,\n    // Circular\n    next: (null: any),\n  }; \n\n  return effect;\n}\n```\n\n-   `tag`  - 효과의 동작을 지시하는 이진수입니다 (곧 자세히 설명 할 것입니다).\n-   `create`  - painting 이후에 실행해야하는 콜백입니다.\n-   `destroy`  - 초기 렌더링 전에 실행되어야하는`create ()`에서 반환 된 콜백.\n-   `inputs`  - effect를 파괴하고 재생성 해야하는지 여부를 결정하는 값 집합입니다.\n-   `next`  - Component에서 정의 된 다음 효과에 대한 참조입니다.\n\n`tag` 프로퍼티 외에, 다른 프로퍼티는 이해하기 쉽고 간단합니다. 후크를 잘 연구했다면 React가 `useMutationEffect()` 와 `useLayoutEffect()`와 같은 몇 가지 특수 효과 후크를 제공한다는 것을 알 수 있습니다. 이 두 가지 효과는 내부적으로 `useEffect()` 를 사용합니다. 이것은 본질적으로 effect node를 만드는 것을 의미하지만, 다른 태그 값을 사용하여 effect node를 만듭니다.\n\n태그는 이진 값의 조합으로 구성됩니다. (see  [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactHookEffectTags.js?source=post_page---------------------------)):\n\n```javascript\nconst NoEffect = /*             */ 0b00000000;\nconst UnmountSnapshot = /*      */ 0b00000010;\nconst UnmountMutation = /*      */ 0b00000100;\nconst MountMutation = /*        */ 0b00001000;\nconst UnmountLayout = /*        */ 0b00010000;\nconst MountLayout = /*          */ 0b00100000;\nconst MountPassive = /*         */ 0b01000000;\nconst UnmountPassive = /*       */ 0b10000000;\n```\nReact에 의해 지원되는 후크 효과 유형.\n\n이 이진 값의 가장 일반적인 경우는 파이프 라인 (`|`)을 사용하여 비트를 그대로 단일 값에 추가하는 것입니다. 그런 다음 태그가 특정 동작을 구현하는지 여부를 앰퍼샌드 (`&`)를 사용하여 확인할 수 있습니다. 결과가 0이 아니면 태그가 지정된 동작을 구현 함을 의미합니다.\n\n```javascript\nconst effectTag = MountPassive | UnmountPassive\nassert(effectTag, 0b11000000)\nassert(effectTag & MountPassive, 0b10000000)\n```\nReact의 바이너리 디자인 패턴을 사용하는 방법을 보여주는 예제.\n\n다음은 React가 해당 태그와 함께 지원하는 후크 효과 유형입니다. (see  [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js:520?source=post_page---------------------------)):\n\n-   Default effect —  `UnmountPassive | MountPassive`.\n-   Mutation effect —  `UnmountSnapshot | MountMutation`.\n-   Layout effect —  `UnmountMutation | MountLayout`.\n\n행동 구현을 위한 React 검사 방법은 다음과 같습니다. (see  [implementation](https://github.com/facebook/react/tree/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberCommitWork.js?source=post_page---------------------------#L309)):\n\n```javascript\nif ((effect.tag & unmountTag) !== NoHookEffect) {\n  // Unmount\n}\nif ((effect.tag & mountTag) !== NoHookEffect) {\n  // Mount\n}\n```\nReact가 구현 한 실제 스냅 샷.\n\n그래서, 우리가 방금 배운 효과에 따라, 실제로 우리는 특정 fiber에 효과를 외부 적으로 주입 할 수 있습니다 :\n\n```javascript\nfunction injectEffect(fiber) {\n  const lastEffect = fiber.updateQueue.lastEffect\n\n  const destroyEffect = () => {\n    console.log('on destroy')\n  }\n\n  const createEffect = () => {\n    console.log('on create')\n\n    return destroy\n  }\n\n  const injectedEffect = {\n    tag: 0b11000000,\n    next: lastEffect.next,\n    create: createEffect,\n    destroy: destroyEffect,\n    inputs: [createEffect],\n  }\n\n  lastEffect.next = injectedEffect\n}\n\nconst ParentComponent = (\n  <ChildComponent ref={injectEffect} />\n)\n```\n효과 주입의 예.\n\n","excerpt":"이글을 번역 및 분석 한 글입니다. 잘못된 번역이 있을 수 있습니다. 또한 예전 코드들이 많으므로 참고만 해야 합니다. 현재 코드랑 다른점이 많이 있습니다. Under the hood of React’s hooks system 우리는 모두 그것에 대…","fields":{"slug":"/hood-hook/"},"frontmatter":{"date":"Jul 30, 2019","title":"Under the hood of React Hooks","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n[이글](https://medium.com/react-in-depth/in-depth-explanation-of-state-and-props-update-in-react-51ab94563311)을 번역 및 분석 한 글입니다. 잘못된 번역 및 생략된 번역이 있을 수 있습니다.\n\n# In-depth explanation of state and props update in React\n\n이전 기사 인 [Inside Fiber: in-depth overview of the new reconciliation algorithm in React](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e?source=post_page---------------------------) 에서는 이 기사에서 설명 할 업데이트 프로세스의 기술적 세부 사항을 이해하는 데 필요한 기반을 마련했습니다.\n\n필자는 이 기사에서 사용할 주요 데이터 구조 및 개념, 특히 fiber 노드, current 및 work-in-progress 트리, side-effects 및 effects list 에 대해 설명했습니다. 또한 주요 알고리즘에 대한 높은 수준의 개요를 제공하고 렌더링 및 커밋 단계의 차이점을 설명했습니다. 그것을 읽지 않았다면 거기에서 시작하는 것이 좋습니다.\n\n또한 화면에 렌더링 된 숫자를 단순히 증가시키는 버튼을 사용하여 샘플 애플리케이션을 소개했습니다.\n\n[여기](https://stackblitz.com/edit/react-jwqn64?source=post_page---------------------------)에서 해볼 수 있습니다. 이는 render 메소드에서 두 개의 하위 요소 button 및 span 을 반환하는 간단한 구성 요소로 구현됩니다. 버튼을 클릭하면 구성 요소의 상태가 핸들러 내부에서 업데이트됩니다. `span` 요소에 대한 텍스트 업데이트 결과는 다음과 같습니다.\n\n```javascript\nclass ClickCounter extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = { count: 0 }\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  handleClick() {\n    this.setState(state => {\n      return { count: state.count + 1 }\n    })\n  }\n\n  componentDidUpdate() {}\n\n  render() {\n    return [\n      <button key=\"1\" onClick={this.handleClick}>\n        Update counter\n      </button>,\n      <span key=\"2\">{this.state.count}</span>,\n    ]\n  }\n}\n```\n\n여기에서는 `componentDidUpdate` 라이프 사이클 메서드를 구성 요소에 추가했습니다. 이것은 React 가 `커밋 단계`에서 이 메서드를 호출하는 [effects](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)를 추가하는 방법을 보여주기 위해 필요합니다.\n\n이 글에서는 React 프로세스 state 업데이트 및 effects list 작성 방법을 알려 드리고자 합니다. `렌더링` 및 `커밋 단계`의 고급 기능에서 진행중인 작업을 살펴 ​​ 봅니다.\n특히, 우리는 React `completeWork`에서 어떻게 작동하는지 볼것입니다.\n\n* `ClickCounter`의 `state`에서 `count` 속성을 업데이트합니다.\n* `render` 메서드를 호출하여 children 목록을 가져 와서 비교를 수행합니다.\n* `span` 요소에 대한 props 을 업데이트합니다.\n\n그리고, `commitRoot`에서 React :\n\n* `span` 요소의 `textContent` 속성을 업데이트합니다.\n* `componentDidUpdate` 라이프 사이클 메소드를 호출합니다.\n\n그러나 그 전에 `click` 핸들러에서 `setState`를 호출 할 때 작업 일정을 빠르게 살펴 보겠습니다.\n\n**React 를 사용하기 위해 그걸 알 필요는 없습니다. 이 기사는 React 가 내부적으로 어떻게 작동하는지에 대한 것입니다.**\n\n## Render phase\n\n### Scheduling updates\n\n버튼을 클릭하면 `click` 이벤트가 트리거되고 React 는 button props 로 전달한 콜백함수를 실행합니다. 우리의 응용 프로그램에서는 단순히 카운터를 증가시키고 상태를 업데이트합니다.\n\n```javascript\nclass ClickCounter extends React.Component {\n    ...\n    handleClick() {\n        this.setState((state) => {\n            return {count: state.count + 1};\n        });\n    }\n}\n```\n\n모든 React component 에는 component 와 React 코어 사이의 다리 역할을 하는 연결된 `updater`가 있습니다. 이를 통해 setState 가 ReactDOM, React Native, 서버 측 렌더링 및 테스트 유틸리티에 의해 다르게 구현 될 수 있습니다.\n\n[setState 여기 참조](https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react/src/ReactBaseClasses.js)\n\n```javascript\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) { // 적절한 updater를 받게 되어 있음.\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\n\nComponent.prototype.setState = function(partialState, callback) {\n  invariant(\n    typeof partialState === 'object' ||\n      typeof partialState === 'function' ||\n      partialState == null,\n    'setState(...): takes an object of state variables to update or a ' +\n      'function which returns an object of state variables.'\n  )\n  this.updater.enqueueSetState(this, partialState, callback, 'setState')\n}\n```\n\n[classComponentUpdater 여기 참조](https://github.com/facebook/react/blob/0f3838a01b0fda0ac5fd054c6be13166697a113c/packages/react-reconciler/src/ReactFiberClassComponent.js#L180)\n\n\n```javascript\nconst classComponentUpdater = {\n  isMounted,\n  enqueueSetState(inst, payload, callback) {\n    const fiber = ReactInstanceMap.get(inst);\n    const currentTime = requestCurrentTime();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    const update = createUpdate(expirationTime);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  ...\n}\n```\n\n이 글에서는 Fiber reconciler 를 사용하는 ReactDOM 의 updater 객체 구현을 살펴 보겠습니다. `ClickCounter` 구성 요소의 경우 [`classComponentUpdater`](https://github.com/facebook/react/blob/6938dcaacbffb901df27782b7821836961a5b68d/packages/react-reconciler/src/ReactFiberClassComponent.js?source=post_page---------------------------#L186)입니다. 이는 Fiber 의 인스턴스를 검색하고, 업데이트를 대기열에 넣어두고, 작업을 예약하는(scheduling) 역할을합니다.\n\n업데이트가 대기열에 있으면 기본적으로 업데이트 큐에 추가되어 fiber 노드에서 처리됩니다. 여기서는 `ClickCounter` 구성 요소에 해당하는 Fibre 노드의 구조는 다음과 같습니다.\n\n```javascript\n{\n    stateNode: new ClickCounter,\n    type: ClickCounter,\n    updateQueue: {\n         baseState: {count: 0}\n         firstUpdate: {\n             next: {\n                 payload: (state) => { return {count: state.count + 1} }\n             }\n         },\n         ...\n     },\n     ...\n}\n```\n\n보시다시피 `updateQueue.firstUpdate.next.payload`의 함수는 `ClickCounter` 구성 요소의 `setState`에 전달한 콜백함수입니다. `렌더링 단계`에서 처리해야하는 첫 번째 업데이트를 나타냅니다.\n\n### Processing updates for the ClickCounter Fiber node\n\n[이전 기사의 작업 루프 장](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)에서는 `nextUnitOfWork` 전역 변수의 역할에 대해 설명했습니다. 특히, 이 변수는해야 할 일이있는 `workInProgress` 트리에서 Fibre 노드에 대한 참조를 보유하고 있음을 나타냅니다. React 가 Fibers 트리를 탐색하면서이 변수를 사용하여 완료되지 않은 다른 Fiber 노드가 있는지 확인합니다.\n\n`setState` 메소드가 호출되었다고 가정 해 보겠습니다. React 는 `setState`의 콜백을 `ClickCounter` fiber 노드의 `updateQueue` 프로퍼티에 추가하고 작업 일정을 조정합니다. React 는 `렌더링 단계`에 들어갑니다. [renderRoot](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1132) 함수를 사용하여 최상위 `HostRoot` Fibre 노드에서부터 이동을 시작합니다. 그러나 작업이 완료되지 않은 노드를 찾을 때까지 이미 처리 된 fiber 노드를 벗어납니다 (건너 뜁니다). 이 시점에서 해야 할 작업이 하나만있는 Fibre 노드가 있습니다. 그것은 `ClickCounter` Fiber 노드입니다.\n\n모든 작업은 `alternate` 필드에 저장되는 이 Fiber 노드의 복제본에서 수행됩니다. alternate 노드가 아직 작성되지 않은 경우 React 는 갱신을 처리하기 전에 `createWorkInProgress` 함수에서 사본을 생성합니다. 변수 nextUnitOfWork 가 alternate `ClickCounter` Fibre 노드에 대한 참조를 보유한다고 가정 해 봅시다.\n\n### beginWork\n\n첫째, 우리의 Fiber 는 [beginWork](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js?source=post_page---------------------------#L1489) 함수에 들어갑니다.\n\n> 이 함수는 트리의 모든 Fiber 노드에 대해 실행되기 때문에 `렌더링 단계`를 디버그하려는 경우 중단 점을 넣는 것이 좋습니다. 나는 이것을 자주하고 fiber 노드의 타입을 점검하여 필요한 곳에 중단점을 고정시킵니다.\n\n`beginWork` 함수는 기본적으로 tag 에 의해 Fibre 노드에 대해 수행해야하는 작업 유형을 결정한 다음 해당 함수를 실행하여 작업을 수행하는 큰 `switch` 문입니다. `CountClicks`의 경우 클래스 구성 요소이므로 이 분기가 수행됩니다.\n\n```javascript\nfunction beginWork(current$$1, workInProgress, ...) {\n    ...\n    switch (workInProgress.tag) {\n        ...\n        case FunctionalComponent: {...}\n        case ClassComponent:\n        {\n            ...\n            return updateClassComponent(current$$1, workInProgress, ...);\n        }\n        case HostComponent: {...}\n        case ...\n}\n```\n\n우리는 `updateClassComponent` 함수를 사용합니다. component, 작업 재개 중 첫 번째 렌더링인지 또는 React 업데이트 인지 여부에 따라 React 는 인스턴스를 만들고 해당 component 를 mount 하거나 단순히 업데이트합니다.\n\n```javascript\nfunction updateClassComponent(current, workInProgress, Component, ...) {\n    ...\n    const instance = workInProgress.stateNode;\n    let shouldUpdate;\n    if (instance === null) {\n        ...\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, Component, ...);\n        mountClassInstance(workInProgress, Component, ...);\n        shouldUpdate = true;\n    } else if (current === null) {\n        // In a resume, we'll already have an instance we can reuse.\n        shouldUpdate = resumeMountClassInstance(workInProgress, Component, ...);\n    } else {\n        shouldUpdate = updateClassInstance(current, workInProgress, ...);\n    }\n    return finishClassComponent(current, workInProgress, Component, shouldUpdate, ...);\n}\n```\n\n### Processing updates for the ClickCounter Fiber\n\n우리는 이미 `ClickCounter` 컴포넌트의 인스턴스를 가지고 있으므로 [`updateClassInstance`](https://github.com/facebook/react/blob/6938dcaacbffb901df27782b7821836961a5b68d/packages/react-reconciler/src/ReactFiberClassComponent.js?source=post_page---------------------------#L976)로 들어갑니다. 그곳이 React 가 클래스 component 에 대한 대부분의 작업을 수행하는 곳입니다. 다음은 실행 순서대로 함수에서 수행 된 가장 중요한 연산입니다.\n\n* `UNSAFE_componentWillReceiveProps()` hook (더 이상 사용되지 않음) 호출\n* `updateQueue`에서 업데이트를 처리하고 새 상태를 생성합니다. `updateQueue.firstUpdate.next.payload` 에 들어가있는 콜백함수\n* 이 새로운 상태로 `getDerivedStateFromProps`를 호출하고 결과를 얻습니다.\n* `shouldComponentUpdate`를 호출하여 component 가 업데이트하려고하는지 확인합니다. `false`의 경우,이 컴퍼넌트와 그 아이의 렌더링을 호출하는 것을 포함 해, 모든 렌더링 처리를 스킵합니다. 그렇지 않으면 업데이트 진행합니다.\n* `UNSAFE_componentWillUpdate` 호출 (더 이상 사용되지 않음)\n* `componentDidUpdate` 라이프 사이클 hook 트리거를 effect 에 추가합니다.\n\n  * `componentDidUpdate`를 호출하는 효과는 `렌더링 단계`에서 추가되지만 메서드는 다음 `커밋 단계`에서 실행됩니다.\n\n* component 인스턴스에서 `state` 및 `props` 을 업데이트합니다.\n\n  * `render` 메서드 output 은 대개 `state` 및 `props`에 따라 다르기 때문에 `state` 및 `props` 는 `render` 메서드가 호출되기 전에 component 인스턴스에서 업데이트해야합니다. 우리가 그렇게하지 않으면, 매번 동일한 출력을 반환 할 것입니다.\n\n다음은 함수로 단순화 시킨 버전입니다.\n\n```javascript\nfunction updateClassInstance(current, workInProgress, ctor, newProps, ...) {\n    const instance = workInProgress.stateNode;\n\n    const oldProps = workInProgress.memoizedProps;\n    instance.props = oldProps;\n    if (oldProps !== newProps) {\n        callComponentWillReceiveProps(workInProgress, instance, newProps, ...);\n    }\n    // updateQueue.firstUpdate.next.payload\n    let updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n        processUpdateQueue(workInProgress, updateQueue, ...);\n        newState = workInProgress.memoizedState;\n    }\n\n    applyDerivedStateFromProps(workInProgress, ...);\n    newState = workInProgress.memoizedState;\n\n    const shouldUpdate = checkShouldComponentUpdate(workInProgress, ctor, ...);\n    if (shouldUpdate) {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n        workInProgress.effectTag |= Update;\n        workInProgress.effectTag |= Snapshot;\n    }\n\n    instance.props = newProps;\n    instance.state = newState;\n\n    return shouldUpdate;\n}\n```\n\n위의 스니펫에서 일부 보조 코드를 제거했습니다. \n예를 들어 lifecycle 메서드를 호출하거나 트리거하기 위해 effect 에 추가하기 전에 React 는 `typeof` 연산자를 사용하여 component 가 메서드를 구현되었는지 확인합니다. \n예를 들어, React 가 effect 를 추가하기 전에 `componentDidUpdate` 메소드를 검사하는 방법은 다음과 같습니다.\n\n```javascript\nif (typeof instance.componentDidUpdate === 'function') {\n  workInProgress.effectTag |= Update\n}\n```\n\n이제는 `렌더링 단계`에서 `ClickCounter` Fiber 노드에 대해 어떤 작업이 수행되는지 알았습니다. \n이제 이러한 작업이 fiber 노드에서 값을 변경하는 방법을 살펴 보겠습니다. \nReact 가 시작되면 `ClickCounter` component 의 Fibre 노드는 다음과 같습니다.\n\n```javascript\n{\n    effectTag: 0,\n    elementType: class ClickCounter,\n    firstEffect: null,\n    memoizedState: {count: 0},\n    type: class ClickCounter,\n    stateNode: { // instance\n        state: {count: 0}\n    },\n    updateQueue: {\n        baseState: {count: 0},\n        firstUpdate: {\n            next: {\n                payload: (state, props) => {…}\n            }\n        },\n        ...\n    }\n}\n```\n\n작업이 완료되면 다음과 같은 Fiber 노드가 생깁니다.\n\n```javascript\n{\n    effectTag: 4, // 변경 Update\n    elementType: class ClickCounter,\n    firstEffect: null,\n    memoizedState: {count: 1}, // 변경\n    type: class ClickCounter,\n    stateNode: { // instance\n        state: {count: 1} // 변경\n    },\n    updateQueue: {\n        baseState: {count: 1}, // 변경\n        firstUpdate: null,\n        ...\n    }\n}\n```\n\n**잠시 시간을내어 프로퍼티 값의 차이점을 관찰하십시오.**\n\n업데이트가 적용되면 `memoizedState` 및 `updateQueue`의 `baseState`에서 속성 수의 값이 1 로 변경됩니다. React 는 또한 `ClickCounter` component 인스턴스의 상태를 업데이트했습니다.\n이 시점에서 큐에 더 이상 업데이트가 없으므로 `firstUpdate`는 null 입니다.\n\n그리고 중요하게도 우리는 `effectTag` 속성을 변경했습니다. 그것은 더 이상 `0`이 아니며, 값은 `4`입니다. 이진수에서는 `100`입니다. 이는 세 번째 비트가 설정됨을 의미합니다. 이는 `Update` [`side-effect tag`](https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js?source=post_page---------------------------)의 비트입니다.\n\n```javascript\nexport const Update = 0b00000000100\n```\n\n결론적으로 부모 `ClickCounter` Fibre 노드에서 작업 할 때 React 는 사전 변이(pre-mutation) 생명주기 메소드를 호출하고 state 를 업데이트하고 관련 부작용(side-effects)을 정의합니다.\n\n### Reconciling children for the ClickCounter Fiber\n\n완료되면 React 가 [`finishClassComponent`](https://github.com/facebook/react/blob/340bfd9393e8173adca5380e6587e1ea1a23cefa/packages/react-reconciler/src/ReactFiberBeginWork.js?source=post_page---------------------------#L355)로 들어갑니다. 여기서 React 는 컴포넌트 인스턴스의 `render` 메소드를 호출하고 해당 diffing 알고리즘을 component 가 리턴 한 children 에 적용합니다. 고급 개요는 문서에 설명되어 있습니다. [다음](https://reactjs.org/docs/reconciliation.html?source=post_page---------------------------#the-diffing-algorithm)은 관련 부분입니다.\n\n> 같은 유형의 두 개의 React DOM 요소를 비교할 때 React 는 두 속성을 보고 동일한 기본 DOM 노드를 유지하고 변경된 속성 만 업데이트합니다.\n\n그러나 우리가 더 깊이 파고 들면 실제로 Fiber 노드와 React elements 를 비교한다는 것을 알 수 있습니다. 그러나 프로세스가 매우 정교하기 때문에 지금은 자세하게 설명하지 않겠습니다. 나는 child reconciliation 의 과정에 초점을 둔 별도의 글을 쓸 것입니다.\n\n> 스스로 세부 사항을 배우고 싶다면 [reconcileChildrenArray](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactChildFiber.js?source=post_page---------------------------#L732) 함수를 확인하십시오. 우리의 어플리케이션에서는 `render` 메소드가 React 요소의 배열을 반환하기 때문에 `reconcileChildrenArray` 함수를 확인하십시오.\n\n이 시점에서 이해해야 할 중요한 두 가지가 있습니다. **먼저**, React 가 child reconciliation 를 진행할 때 `render` 메소드에서 반환 된 **child React elements 에 대한 Fibre 노드를 만들거나 업데이트 해야합니다.** `finishClassComponent` 함수는 현재 Fibre 노드의 `첫 번째 자식에 대한 참조`를 반환합니다. `nextUnitOfWork`에 할당되고 나중에 작업 루프(work loop)에서 처리됩니다. **둘째**, React 는 parent 에 대한 수행 한 작업의 일부로 **children 의 props 을 업데이트**합니다. 이를 위해 `render` 메소드에서 반환 된 React 요소의 데이터를 사용합니다.\n\n예를 들어, React 가 `ClickCounter` fiber 에 대한 children 을 reconciles 하기 전에 `span` 요소에 해당하는 Fibre 노드가 다음과 같이 표시됩니다.\n\n```javascript\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    key: \"2\",\n    memoizedProps: {children: 0},\n    pendingProps: {children: 0},\n    ...\n}\n```\n\n보시다시피, `memoizedProps` 및 `pendingProps`의 `children` 속성은 모두 `0`입니다. 여기에 `span` 요소에 대한 `render` 에서 반환 된 React 요소의 구조가 있습니다.\n\n```javascript\n// ClickCounter 의 render 메서드 호출 후에 리턴된 span element\n{\n  $$typeof: Symbol(react.element)\n  key: '2'\n  props: {\n    children: 1\n  }\n  ref: null\n  type: 'span'\n}\n```\n\n보시다시피, **Fibre 노드의 props 과 반환 된 React element 에는 차이점이 있습니다.** alternate fiber 노드를 만드는 데 사용되는 `createWorkInProgress` 함수에서 **React 는 React element 에서 업데이트 된 프로퍼티를 fiber 노드로 복사합니다.**\n\n따라서 React 가 `ClickCounter` component 에 대한 children 을 reconciling 한 후에는 `span` Fiber 노드에 `pendingProps`가 업데이트됩니다. 그들은 React 요소의 값과 일치합니다 :\n\n```javascript\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    key: \"2\",\n    memoizedProps: {children: 0},\n    pendingProps: {children: 1}, // 업데이트\n    ...\n}\n```\n\n나중에 React 가 `span` fiber 노드에 대한 작업을 수행 할 때 그것들을 `memoizedProps`에 복사하고 DOM 을 업데이트하기 위해 effects 를 추가합니다.\n\nReact 가 렌더링 단계에서 `ClickCounter` fiber 노드에 대해 수행하는 모든 작업이 그것입니다. 버튼은 `ClickCounter` component 의 첫 번째 자식이므로 `nextUnitOfWork` 변수에 할당됩니다. 그걸로 끝내야 할 것이 없으므로, React 는 Fibre 노드의 형제로 이동할 것입니다. [여기](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e?source=post_page---------------------------)에 설명 된 알고리즘에 따르면 노드의 형제 이동 로직은 `completeUnitOfWork` 함수에서 발생합니다.\n\n여기서 `button` 컴포넌트는 `beginWork()` 수행 후 별도의 자식이 없으므로 null 이 리턴될 것이다.\nnull 이 리턴되면 곧바로 `completeUnitOfWork` 메서드로 들어가서 `completeWork` 메서드를 진행하게 된다.\n그 후에 `sibling` 을 리턴하는데 그것이 `span` 태그이다.\n\n### Processing updates for the Span fiber\n\n그래서 변수 `nextUnitOfWork`는 `span` fiber 의 alternate 을 가리키고 React 가 작업을 시작합니다. `ClickCounter`에 대해 수행 된 단계와 유사하게 `beginWork` 함수로 시작합니다.\n\n`span` 노드가 `HostComponent` 타입이기 때문에, 이번에는 switch 문에서 React 가이 분기를 취합니다 :\n\n```javascript\nfunction beginWork(current$$1, workInProgress, ...) {\n    ...\n    switch (workInProgress.tag) {\n        case FunctionalComponent: {...}\n        case ClassComponent: {...}\n        case HostComponent:\n          return updateHostComponent(current, workInProgress, ...);\n        case ...\n}\n```\n\n[`updateHostComponent`](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js?source=post_page---------------------------#L686) 함수에서 끝납니다. 클래스 구성 요소에 대해 호출 된 `updateClassComponent` 함수와의 병렬을 볼 수 있습니다. functional component 의 경우 `updateFunctionComponent` 가됩니다. 이러한 모든 기능은 [`ReactFiberBeginWork.js`](https://github.com/facebook/react/blob/1034e26fe5e42ba07492a736da7bdf5bf2108bc6/packages/react-reconciler/src/ReactFiberBeginWork.js?source=post_page---------------------------) 파일에서 찾을 수 있습니다.\n\n### Reconciling children for the span fiber\n\n여기서는 `updateHostComponent`의 `span` 노드에 아무런 중요한 일도 일어나지 않습니다.\n\n### Completing work for the Span Fiber node\n\n`beginWork` 가 끝나면 노드는 `completeWork` 함수로 들어갑니다. 하지만 그 전에 React 는 span fiber 에 `memoizedProps`을 업데이트 해야합니다. `ClickCounter` 구성 요소에 대해 자식을 reconciling 할 때 React span fibre 노드의 `pendingProps`가 업데이트 되었음을 ​​ 기억할 수 있습니다.\n\n```javascript\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    key: \"2\",\n    memoizedProps: {children: 0},\n    pendingProps: {children: 1},\n    ...\n}\n```\n\n따라서 `beginWork` 가 span fiber 에 대해 완료되면 React `pendingProps` 가 `memoizedProps` 와 일치합니다.\n\n```javascript\nfunction performUnitOfWork(workInProgress) {\n    ...\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n    workInProgress.memoizedProps = workInProgress.pendingProps;\n    ...\n}\n```\n\n그런 다음 기본적으로 `beginWork` 에서 본 것과 비슷한 switch 문인 `completeWork` 함수를 호출합니다.\n\n```javascript\nfunction completeWork(current, workInProgress, ...) {\n    ...\n    switch (workInProgress.tag) {\n        case FunctionComponent: {...}\n        case ClassComponent: {...}\n        case HostComponent: {\n            ...\n            updateHostComponent(current, workInProgress, ...);\n        }\n        case ...\n    }\n}\n```\n\n우리의 span Fibre 노드는 HostComponent 이므로 `updateHostComponent` 함수를 실행합니다. 이 함수에서 React 는 기본적으로 다음을 수행합니다.\n\n* DOM 업데이트를 준비합니다.\n* span fiber 의 updateQueue 에 그것들을 추가한다.\n* DOM 을 업데이트하는 effect 추가\n\n이러한 작업을 수행하기 전에 span fiber 노드는 다음과 같습니다.\n\n```javascript\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    effectTag: 0\n    updateQueue: null\n    ...\n}\n```\n\n작업이 완료되면 다음과 같이 보입니다.\n\n```javascript\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    effectTag: 4, // update\n    updateQueue: [\"children\", \"1\"],\n    ...\n}\n```\n\n`effectTag` 및 `updateQueue` 필드의 차이점을 확인하십시오. 그것은 더 이상 `0`이 아니며, 값은 `4`입니다. 이진수에서는 `100`입니다. 이는 세 번째 비트가 설정됨을 의미합니다. 이는 업데이트 side-effect tag 의 비트입니다. 이것은 다음 `커밋 단계`에서 React 가 이 노드에 대해 수행해야하는 유일한 작업입니다. `updateQueue` 필드는 업데이트에 사용될 페이로드를 보유합니다.\n\nReact 가 `ClickCounter` 와 그 children 을 처리하면 `렌더링 단계`가 완료됩니다. 완성 된 대체 트리를 `FiberRoot` 의 `finishedWork` 속성에 할당 할 수 있습니다. 이것은 새로운 tree 가 화면에 뿌려져야 합니다. `렌더링 단계` 직후에 바로 처리하거나 나중에 React 가 브라우저에 의해 주어진 시간에 선택 될 수 있습니다.\n\n### Effects list\n\n우리의 경우 `span` 노드와 `ClickCounter` 컴포넌트는 side effects 가 있으므로 React 는 `Span` Fiber 노드에 대한 링크를 `HostFiber` 의 `firstEffect` 속성에 추가합니다.\nReact 는 [`completeUnitOfWork`](https://github.com/facebook/react/blob/d5e1bf07d086e4fc1998653331adecddcd0f5274/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L999) 함수에서 effects list 을 작성합니다. 다음은 `span` 노드의 텍스트를 업데이트의 effect 를 가진 Fiber tree 와 `ClickCounter`에서 hooks 를 호출하는 트리의 예입니다.\n\n![effect-linearList01](./effect-linearList01.png)\n\n다음은 효과가있는 노드의 선형 목록입니다.\n\n![effect-linearList02](./effect-linearList02.png)\n\n## Commit phase\n\n이 단계는 [`completeRoot`](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L2306) 함수로 시작합니다. 작업을하기 전에 `FiberRoot` 의 `finishedWork` 속성을 `null` 로 설정합니다.\n\n```\nroot.finishedWork = null;\n```\n\n첫 번째 `렌더링 단계`와 달리 `커밋 단계`는 항상 동기식이므로 `HostRoot`를 안전하게 업데이트하여 커밋 작업이 시작되었음을 나타낼 수 있습니다.\n\n커밋 단계에서는 React 가 DOM 을 업데이트하고 post mutation lifecycle 메서드 인 `componentDidUpdate` 를 호출합니다. 이를 위해 이전 `렌더링 단계`에서 생성 한 effects list 을 검토하고 적용합니다.\n\n우리는 `span` 및 `ClickCounter` 노드의 `렌더링 단계`에서 다음과 같은 effect 를 정의했습니다.\n\n```javascript\n{ type: ClickCounter, effectTag: 5 }\n{ type: 'span', effectTag: 4 }\n```\n\n`ClickCounter` 의 효과 태그 값은 `5` 또는 2 진수로 `101`이며 클래스 구성 요소의 경우 기본적으로 `componentDidUpdate` 라이프 사이클 메소드로 변환되는 업데이트 작업을 정의합니다. 또한 최하위 비트는 렌더링 단계에서이 fiber 노드에 대한 모든 작업이 완료되었음을 알리기 위해 설정됩니다.\n`span` 에 대한 효과 태그의 값은 `4` 또는 2 진수로 `100`이며 host component DOM 업데이트의 `update` 작업을 정의합니다. `span` 요소의 경우, React 는 요소의 `textContent`를 업데이트해야합니다.\n\n### Applying effects\n\nReact 가 어떻게 그 effects 를 적용하는지 봅시다. effects 를 적용하는 데 사용되는 `commitRoot` 함수는 세 가지 하위 함수로 구성됩니다.\n\n```javascript\nfunction commitRoot(root, finishedWork) {\n  commitBeforeMutationLifecycles()\n  commitAllHostEffects()\n  root.current = finishedWork\n  commitAllLifeCycles()\n}\n```\n\n각 하위 함수는 effects list 을 반복하고 effects 타입을 확인하는 루프를 구현합니다. 함수의 목적과 관련된 effect 를 발견하면 적용합니다. 여기서는 `ClickCounter` 구성 요소에서 `componentDidUpdate` 라이프 사이클 메서드를 호출하고 `span` 요소의 텍스트를 업데이트합니다.\n첫 번째 함수 인 [`commitBeforeMutationLifeCycles`](https://github.com/facebook/react/blob/fefa1269e2a67fa5ef0992d5cc1d6114b7948b7e/packages/react-reconciler/src/ReactFiberCommitWork.js?source=post_page---------------------------#L183) 는 `Snapshot` effect 를 찾고 `getSnapshotBeforeUpdate` 메서드를 호출합니다. 그러나 `ClickCounter` 구성 요소에 이 메서드를 구현하지 않았으므로 React 는 렌더링 단계에서 effect 를 추가하지 않았습니다. 그래서 우리의 경우이 함수는 아무 것도하지 않습니다.\n\n### DOM updates\n\n다음 React 는 `commitAllHostEffects` 함수로 이동한다. 여기서 React 가 `span` 요소의 텍스트를 `0`에서 `1`로 변경합니다. 클래스 구성 요소에 해당하는 노드에 DOM 업데이트가 없으므로 `ClickCounter` fiber 에는 아무 작업도 수행되지 않습니다.\n함수의 요지는 올바른 effect 의 타입를 선택하고 해당 작업을 적용한다는 것입니다. 여기서는 `span` 요소의 텍스트를 업데이트 해야하므로 여기에서 `Update` 분기를 가져옵니다.\n\n```javascript\nfunction updateHostEffects() {\n    switch (primaryEffectTag) {\n      case Placement: {...}\n      case PlacementAndUpdate: {...}\n      case Update:\n        {\n          var current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n      case Deletion: {...}\n    }\n}\n```\n\n`commitWork` 로 이동하면 결국 `updateDOMProperties` 함수로 들어간다. 렌더 단계 동안 Fibre 노드에 추가 된 `updateQueue` 페이로드를 가져 와서 `span` 요소의 `textContent` 속성을 업데이트합니다.\n\n```javascript\nfunction updateDOMProperties(domElement, updatePayload, ...) {\n  for (let i = 0; i < updatePayload.length; i += 2) {\n    // updateQueue: [\"children\", \"1\"],\n    const propKey = updatePayload[i];\n    const propValue = updatePayload[i + 1];\n    if (propKey === STYLE) { ...}\n    else if (propKey === DANGEROUSLY_SET_INNER_HTML) {...}\n    else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    } else {...}\n  }\n}\n```\n\nDOM 업데이트가 적용된 후 React 는 `finishedWork` 트리를 `HostRoot` 에 할당합니다. alternate 트리를 현재(current)로 설정합니다.\n\n```javascript\nroot.current = finishedWork\n```\n\n### Calling post mutation lifecycle hooks\n\n마지막 남은 기능은 [`commitAllLifecycles`](https://github.com/facebook/react/blob/d5e1bf07d086e4fc1998653331adecddcd0f5274/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L479) 입니다. 여기서 React 는 post mutational lifecycle methods 를 호출합니다. 렌더링 단계에서 React 는 `Update` effect 를 ClickCounter 구성 요소에 추가했습니다. 이것은 `commitAllLifecycles` 함수가 찾고 `componentDidUpdate` 메서드를 호출하는 effects 중 하나입니다.\n\n```javascript\nfunction commitAllLifeCycles(finishedRoot, ...) {\n    while (nextEffect !== null) {\n        const effectTag = nextEffect.effectTag;\n\n        if (effectTag & (Update | Callback)) {\n            const current = nextEffect.alternate;\n            commitLifeCycles(finishedRoot, current, nextEffect, ...);\n        }\n\n        if (effectTag & Ref) {\n            commitAttachRef(nextEffect);\n        }\n\n        nextEffect = nextEffect.nextEffect;\n    }\n}\n```\n\n함수는 또한 [refs](https://reactjs.org/docs/refs-and-the-dom.html?source=post_page---------------------------)를 업데이트하지만, 우리는 이 기능을 가지고 있지 않기 때문에 사용되지 않을 것이다. 이 메소드는 [`commitLifeCycles`](https://github.com/facebook/react/blob/e58ecda9a2381735f2c326ee99a1ffa6486321ab/packages/react-reconciler/src/ReactFiberCommitWork.js?source=post_page---------------------------#L351) 함수에서 호출됩니다.\n\n```javascript\nfunction commitLifeCycles(finishedRoot, current, ...) {\n  ...\n  switch (finishedWork.tag) {\n    case FunctionComponent: {...}\n    case ClassComponent: {\n      const instance = finishedWork.stateNode;\n      if (finishedWork.effectTag & Update) {\n        if (current === null) {\n          instance.componentDidMount();\n        } else {\n          ...\n          instance.componentDidUpdate(prevProps, prevState, ...);\n        }\n      }\n    }\n    case HostComponent: {...}\n    case ...\n}\n```\n\nReact 가 처음 렌더링 된 구성 요소에 대해 `componentDidMount` 메소드를 호출하는 함수임을 알 수 있습니다.\n그리고 그게 다야!\n\n\n## 정리\n\n### Render Phase\n\n- commit phase 작업을 해야할 effect 목록(선형)을 만들기 위해 fiber node를 작업한다.\n\n```javascript\nfunction performUnitOfWork(workInProgress) {\n  // children에 대한 포인터 또는 null\n  let next = beginWork(workInProgress)\n  if (next === null) {\n    // 더 이상의 자식이 없을때 completeUnitOfWork -> completeWork를 수행\n    // completeUnitOfWork는 sibling이 있을때 return sibling 후 다시 beginWork 진행\n    // sibling도 없을 시에 부모로 올라가서 completeUnitOfWork 내부에 있는 completeWork를 수행\n    next = completeUnitOfWork(workInProgress)\n  }\n  return next\n}\n```\n\n- 위 `performUnitOfWork` 를 while 하면서 fiber를 순차적으로 적용한다. \n- `beginWork()` 부터 시작. 여기선 컴포넌트의 타입에 따라 component를 update 진행한다. \n  - 클래스 컴포넌트의 경우에는 `updateClassComponent()` 다음 메서드 실행, 인스턴스를 create 또는 update를 진행한다. 특히 update시 fiber node를 가지고 instance를 update한다.\n  - `finishClassComponent()` 여기서는 children들의 reconciliation을 진행한다. 즉, 부모의 render 이후 React element와 이전의 fiber node를 비교 후 fiber node를 업데이트 한다. \n  - `finishClassComponent()` 이후에 `beginWork()` 리턴으로는 child가 있을 경우 첫번째 child 가 리턴 아닐 경우 null 이 리턴\n- 첫번째 child인 button 을 다시 `beginWork()` -> child가 없기 때문에 바로 null 리턴,  `completeUnitOfWork()` 진행 후 completeWork() 진행. \n- `span` 태그의 sibling 확인 (`completeUnitOfWork()` 메서드에서 수행)\n- `span` 태그의 `beginWork()` 수행 후, null 리턴, `completeUnitOfWork()` 진행 후 `completeWork()` 진행. \n- `span` 태그의 `completeWork()` 진행 시, `span` fiber의 `effectTag` 와 `updateQueue` 를 업데이트 진행. \n- effects list를 구성해서 `commit phase`로 넘김 ( root -> span -> ClickCounter )","excerpt":"이글을 번역 및 분석 한 글입니다. 잘못된 번역 및 생략된 번역이 있을 수 있습니다. In-depth explanation of state and props update in React 이전 기사 인 Inside Fiber: in-depth over…","fields":{"slug":"/react-fiber03/"},"frontmatter":{"date":"Jul 22, 2019","title":"React Fiber part3","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n[이글](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)을 번역 및 분석 한 글입니다. 잘못된 번역 및 생략된 번역이 있을 수 있습니다.\n\n# Inside Fiber: in-depth overview of the new reconciliation algorithm in React\n\nReact 는 유저인터페이스를 만들기 위한 라이브러리 입니다. React 의 코어는 component 의 state 변화를 추적하고 해당 state 를 화면에 갱신해주는 것입니다. 우리는 React 안에서 이러한 프로세스를 **reconciliation** 으로 알고있습니다.\n\n우리는 setState 메서드를 호출하고 프레임워크가 state 또는 props 가 변했는지 체크하고 UI 에 그려진 component 를 다시 렌더링 합니다.\n\nReact 의 문서는 React 엘리먼트, 라이프사이클 메서드 그리고 render 메서드 그리고 children 컴포넌트에 적용된 diffing 알고리즘 역활에 대해 좋은 설명을 제공하고 있습니다. render 메서드를 통해 리턴된 immutable 한 React elements 트리들이 공통적으로 \"vitual DOM\" 으로 알고있습니다. 이 용어는 초기에 사람들에게 React 을 설명하는 데 도움이되었습니다. 하지만 그것은 혼란을 야기하기도합니다. 그리고 React 문서 어디에도 사용하지 않습니다.\n\n이 글에서는 \"vitual DOM\"을 React element 들의 트리 라고 부르겠습니다.\n\nReact element 들의 트리외에도 프레임워크 에는 state 를 유지하는 용도로 항상 내부 instance 들의 트리를 가지고 있습니다.(components, DOM nodes, 기타등등..)\n16 버전부터는 React 가 내부 인스턴스 트리와 Fiber 라는 코드 이름을 관리하는 알고리즘을 새로운 구현 했습니다.\n\n## Setting the background\n\n여기 아주 간단한 어플리케이션이 있습니다. 이것을 이 시리즈에서 계속 사용할 예정입니다. 간단하게 숫자를 증가시키는 button 하나가 있습니다.\n\n![button-example01.gif](./button-example01.gif)\n\n그리고 여기 구현된 코드가 있습니다.\n\n```javascript\nclass ClickCounter extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = { count: 0 }\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  handleClick() {\n    this.setState(state => {\n      return { count: state.count + 1 }\n    })\n  }\n\n  render() {\n    return [\n      <button key=\"1\" onClick={this.handleClick}>\n        Update counter\n      </button>,\n      <span key=\"2\">{this.state.count}</span>,\n    ]\n  }\n}\n```\n\n[여기서](https://stackblitz.com/edit/react-t4rdmh?source=post_page---------------------------) 동작해볼 수 있습니다. 보는것과 같이 `render` 메서드에서 2 개의 child elements 인 `button` 과 `span` 을 반환하는 간단한 component 입니다.\n`button` 을 클릭하자마자 component 의 state 는 내부 handler 에 의해 업데이트가 됩니다. 그 결과로 `span` elemen에 text 가 업데이트가 됩니다.\n\nReact 는 `reconciliation` 동안 다양한 수행을 합니다. 예를 들면 첫 렌더링 과 state 가 update 동안 높은 수준의 React 수행 작업이 있습니다.\n\n- ClickCounter 의 state 안 있는 count 프로퍼티가 업데이트가 됩니다.\n- ClickCounter 의 children 과 그것들의 props 들을 비교, 탐색합니다.\n- span element 위해 props 를 update 합니다.\n\n라이프 사이클 메소드를 호출하거나 refs 를 업데이트하는 것과 같은 `reconciliation` 중에 수행되는 다른 작업이 있습니다.\n이런 모든 작업들은 Fiber 아키텍쳐에서 일괄적으로 \"work\" 라고 부릅니다. 이런 work 타입은 대게 React `element` 의 타입과 관계가 있습니다. 예를 들면 class component 는 React 가 instance 를 만들게 해주어야 합니다. 반면에 함수 컴포넌트 들의 경우에는 그렇지 않아도 됩니다. 알다시피 React 안에는 여러 종류의 `element` 들이 있습니다. 예를 들어, class 컴포넌트 , 함수 컴포넌트, host 컴포넌트 (DOM nodes) , 포탈 등등. 이런 React 타입은 `createElement` 함수의 첫번째 매개변수에 의해 정의 됩니다.\n이 `createElement` 함수는 `render` 메서드안에서 `element` 를 생성하기 위해 사용됩니다.\n\n활동의 탐구와 주요 fiber 알고리즘을 탐구하기 전에 먼저 React 에서 내부적으로 사용하는 데이터 구조에 익숙해 지도록합시다.\n\n## From React Elements to Fiber nodes\n\nReact 의 모든 컴포넌트들은 우리가 render 메서드에서 리턴되는 view 라고 불리우거나 또는 템플릿이라고 UI 표현을 가지고 있습니다. 여기 우리의 `ClickCounter` 컴포넌트를 위한 템플릿이 있습니다.\n\n```html\n<button key=\"1\" onClick=\"{this.onClick}\">Update counter</button>\n<span key=\"2\">{this.state.count}</span>\n```\n\n### React Elements\n\n오직 템플릿은 JSX 컴파일러를 통해 거치면 React element 들이 잔뜩 생깁니다. 이것은 React 컴포넌트의 render 메서드에서 리턴되는 것으로 HTML 이 아닙니다. 우리는 JSX 를 사용하지 않을거라서 `ClickCounter` 컴포넌트의 render 메서드는 다음과 같이 작성될 수 있을 것입니다.\n\n```javascript\nclass ClickCounter {\n    ...\n    render() {\n        return [\n            React.createElement(\n                'button',\n                {\n                    key: '1',\n                    onClick: this.onClick\n                },\n                'Update counter'\n            ),\n            React.createElement(\n                'span',\n                {\n                    key: '2'\n                },\n                this.state.count\n            )\n        ]\n    }\n}\n```\n\n`render` 메서드 안에서 `React.createElement` 를 호출하는 것은 2 개의 데이터 구조를 생성할 것입니다.\n\n```javascript\n[\n    {\n        $$typeof: Symbol(react.element),\n        type: 'button',\n        key: \"1\",\n        props: {\n            children: 'Update counter',\n            onClick: () => { ... }\n        }\n    },\n    {\n        $$typeof: Symbol(react.element),\n        type: 'span',\n        key: \"2\",\n        props: {\n            children: 0\n        }\n    }\n]\n```\n\n여기서 `$$typeof` 의 프로퍼티를 React 가 추가해서 React elements 요소로 고유하게 식별됨을 알 수 있습니다.\n그리고 나서 element 의 설명인 `type`, `key` 그리고 `props` 를 가지고 있습니다. 이 값들은 `React.createElement` 에 전달되는 값입니다. 주의할점은 어떻게 React 가 text 컨텐츠를 `span` 과 `button` 의 children 에 표현하는가 입니다. 그리고 어떻게 click handler 가 button element props 의 한 부분이 되었는가 입니다. React element 의 ref 같은 다른 필드들은 이 글에서 벗어나는 것들입니다.\n\n`ClickCounter` 를 위한 React element 는 어떤 `props` 나 `key` 를 가지고 있지 않습니다.\n\n```javascript\n{\n    $$typeof: Symbol(react.element),\n    key: null,\n    props: {},\n    ref: null,\n    type: ClickCounter\n}\n```\n\n### Fiber nodes\n\n**reconciliation** 하는 동안에 render 메서드에서 리턴된 React element 들로 부터 나온 data를 fiber node 트리들에 합쳐지게 됩니다. 그래서 모든 React element 들은 해당하는 fiber node 를 지니게 됩니다. fibers 은 React element 들과 다르게 매 render 마다 재 생성되지 않습니다. 이것은 변할 수 있는 components 와 DOM 을 가지고 있는 data 구조입니다.\n\n우리는 이전에 React element 타입이 프레임워크의 다른 수행을 요한다고 했었다. 우리의 샘플 어플리케이션에서 `ClickCounter` 클래스 컴포넌트는 라이프 사이클 메서드 과 `render` 메서드를 호출한다. 반면에 `span` host 컴포넌트(DOM node)는 DOM 변화를 수행하게 됩니다. 따라서 각 React element 는 수행해야 할 작업을 설명하는 해당 타입에 맞게 Fiber node 로 변환됩니다.\n\n**Fiber 는 해야 할 작업을 나타내는 데이터 구조로 생각할 수 있습니다. 즉 작업 단위입니다. Fiber 의 아키텍쳐는 작업을 추적, 스케쥴, 일지정지, 중단 할수 있는 편리한 방법을 제공합니다.**\n\nReact element 가 fiber node 로 처음 변환되면, React 는 element 부터 나온 data 를 [createFiberFromTypeAndProps](https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js?source=post_page---------------------------#L414) 에서 사용해서 fiber 를 생성하게 됩니다.\n\n결과 업데이트에서 React는 fiber 노드를 재사용하고 해당 React element 의 데이터를 사용하여 필요한 프로퍼티들을 업데이트 합니다.\nReact 는 또한 node 를 key props 를 기반으로 계층안에서 움직이거나 만약 관련 React element 가 render 메서드를 통해 더이상 리턴되지 않는다면 node 를 삭제할 필요가 있을것이다.\n\n> [ChildReconciler](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactChildFiber.js?source=post_page---------------------------#L239) 함수를 통해서 모든 활성화된 모든 리스트들과 React 동작을 위한 fiber nodes 들에 관련한 함수들을 확인할 수 있습니다.\n\nReact 는 각 element 에 대한 fiber 를 생성하고 그들의 elements 의 트리를 가지고 있기 때문에 우리는 fiber nodes 트리를 가질 수 있습니다. 우리 샘플 케이스의 경우에는 다음과 같이 표현할 수 있습니다.\n\n![fiber tree](./fiberNode01.png)\n\n모든 fiber 노드들은 linked list 로 연결이 되어있습니다. fiber node 에 `child`, `sibling` 그리고 `return` 이라는 프로퍼티를 사용해서 연결이 되어있습니다.\n왜 이런 방식으로 작업이 되었는지 좀 더 설명을 원한다면 다음 글을 먼저 읽어 보십시요 [The how and why on React’s usage of linked list in Fiber](https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7?source=post_page---------------------------)\n\n### Current and work in progress trees\n\n첫번째 렌더링 이후에 React 는 UI 렌더링에 필요한 어플리케이션의 state 를 반영한 fiber 트리를 갖게 된다. 이 트리는 대게 **current**라고 불리운다. ( 한번 그려진 녀석들을 반영한 트리를 current 라고 함 ). React 가 current 를 tree 를 update 시작하면 그것은 **workInProgress** 트리 라고 불리운다. 이것은 스크린에 뿌려지게 될 미래의 state 를 반영합니다.\n\n모든 작업은 `workInProgress` 트리의 fiber 에서 수행됩니다. React 가 `current` 트리를 살펴보면서 기존의 각 fiber 노드에 대해 `workInProgress` 트리를 구성하는 alternate(대체) 노드를 만듭니다. 이 노드는 `render` 메서드에서 리턴된 React element 에서 나온 data 를 사용해서 만들게 됩니다. 업데이트가 처리되고 모든 관련 작업이 완료되면, React 는 스크린에 뿌려질 alternate 트리를 가지고 있을 것입니다. 이 `workInProgress` 트리가 render 되고나면 그것은 다시 `current` 트리가 됩니다.\n\nReact 코어의 원리중 하나는 일관성입니다. [여기참조](https://overreacted.io/ko/react-as-a-ui-runtime/). React 는 항상 DOM 을 한번에 update 합니다. 부분적인 결과는 표시되지 않습니다. `workInProgress`트리는 사용자에게 표시되지 않는 \"초안\"으로 사용되며, 그래서 React 는 맨 먼저 모든 컴포넌트들을 처리한 뒤에 그것들의 변화를 스크린에 반영할 수 있습니다. 여기 그러한 함수 중 하나의 시그니처 입니다.\n\n```javascript\n// updateHostComponent\nfunction updateHostComponent(current, workInProgress, renderExpirationTime) {...}\n```\n\n각 fiber 노드는 **alternate** 필드에 있는 다른 트리로 부터 나온 해당 fiber node에 대응하는 fiber 참조값을 보유 하고 있습니다. `current` 트리의 노드는 `workInProgress` 트리의 노드를 가리키고 그 반대의 경우도 마찬가지입니다.\n\n### Side-effects\n\n우리는 React 컴포넌트를 state 와 props 를 사용해서 UI 표현을 계산하는 함수라고 생각 할 수 있습니다. DOM 을 변경하거나 라이프 사이클 메소드를 호출하는 것과 같은 다른 모든 활동은 side-effect 또는 단순히 effect 로 간주되어야합니다. Effect 는 [문서](https://reactjs.org/docs/hooks-overview.html?source=post_page---------------------------#%EF%B8%8F-effect-hook)에도 언급되어 있습니다.\n\n> 우리는 데이터 가져 오기, 구독 또는 수동으로 이전 React component 에서 나온 **DOM 을 변경** 했을 것입니다. 우리는 이 작업들을 \"side effect\" 또는 짧게 \"effect\" 라고 불렀습니다. 왜냐하면 그것들은 다른 컴포넌트에 영향을 미칠수 있고 렌더링 동안에 수행 할 수 없기 때문입니다.\n\n대부분의 state 및 props 업데이트가 side-effects 을 일으키는 방법을 확인할 수 있습니다. effects 를 적용하는 것이 일종의 작업의 타입이기 때문에 fiber 노드는 업데이트 외에도 효과를 추적하는 편리한 메커니즘입니다. 각 fiber 노드는 그것과 연관된 effects 를 가질 수 있습니다. 그것들을 effectTag 필드에 인코딩됩니다.\n\n따라서 Fiber 에 있는 effects 는 기본적으로 업데이트가 처리 된 후 인스턴스에 대해 수행해야하는 [작업](https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js?source=post_page---------------------------)을 정의합니다. host component 들 (DOM 요소)의 경우 작업은 요소 추가, 업데이트 또는 제거로 구성됩니다. 클래스 컴포넌트의 경우 React 는 ref 를 업데이트하고 `componentDidMount` 및 `componentDidUpdate` 라이프 사이클 메소드를 호출해야 할 수 있습니다. 다른 유형의 fiber 들에 해당하는 다른 effects 도 있습니다.\n\n### Effects list\n\nReact 프로세스는 업데이트를 신속하게 처리하고 몇 가지 흥미로운 기술을 사용하여 그 수준의 성능을 달성합니다. **그 중 하나는 신속한 반복을 위해 effect 가 있는 fiber 노드의 선형 목록을 작성하는 것입니다.** 선형 목록 반복은 트리보다 훨씬 빠르며 side-effects 없는 노드에 시간을 할애 할 필요가 없습니다.\n\n이 리스트의 목표는 DOM 업데이트 또는 이와 관련된 다른 effects 가있는 노드를 표시하는 것입니다. 이 목록은 `finishedWork` 트리의 하위 집합이며 `current` 및 `workInProgress` 트리에서 사용되는 `child` 속성 대신 `nextEffect` 속성을 사용하여 연결됩니다.\n\nDan Abramov 는 effects list 에 대한 비유를 제시했습니다. 그는 크리스마스 트리에 모든 effectful 한 노드를 묶어놓은 \"크리스마스 불빛\"이 감겨져있는 것으로 생각하는 것을 좋아합니다. 이것을 시각화하기 위해 강조 표시된 노드가 할 일이있는 다음과 같은 fiber 노드 트리를 상상해 봅시다. 예를 들어, 우리의 업데이트로 인해 `c2`가 DOM 에 삽입되고, `d2`와 `c1`이 속성을 변경하고, `b2`는 라이프 사이클 메소드를 실행합니다. 이 effect list 는 React 가 나중에 다른 노드를 건너 뛸 수 있도록 그들을 연결합니다 :\n\n![updateFiberTree](./updateFiberTree.png)\n\n여기서 effects 를 가진 노드들이 어떻게 연결되어있는지 볼수 있습니다. 이런 노드들을 탐색할때 React 는 어디서 list 의 시작인지 알기 위해서 `firstEffect` 포인터를 사용합니다.\n그래서 위 다이어그램은 아래처럼 선형 리스트로 표현될 수 있습니다.\n\n![effectList](./effectList.png)\n\n보시다시피 React 는 children 부터 parents 까지 순서대로 효과를 적용합니다.\n\n### Root of the fiber tree\n\n모든 React 애플리케이션에는 컨테이너 역할을 하는 하나 또는 이상의 DOM 요소가 있습니다. 여기서는 ID 가 `container`인 div 가 이 경우에 해당됩니다.\n\n```javascript\nconst domContainer = document.querySelector('#container')\nReactDOM.render(React.createElement(ClickCounter), domContainer)\n```\n\nReact 는 각 컨테이너들에 대한 [fiber root](https://github.com/facebook/react/blob/0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74/packages/react-reconciler/src/ReactFiberRoot.js?source=post_page---------------------------#L31) 객체를 만듭니다. DOM 요소에 대한 참조를 사용하여 액세스 할 수 있습니다.\n\n```javascript\n// DOM 레퍼런스에 접근해서 fiberRoot에 접근 할 수있다.\nconst fiberRoot = query('#container')._reactRootContainer._internalRoot\n```\n\n이 fiber root 는 React 가 fiber tree 에 대한 참조를 보유하고있는 곳입니다. 그 fiber tree 참조 값은 fiber root 의 `current` 속성에 저장됩니다.\n\n```javascript\n// #container 의 Fiber node 이다.\nconst hostRootFiberNode = fiberRoot.current\n```\n\nfiber 트리는 `HostRoot` 인 [특별한 타입](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/shared/ReactWorkTags.js?source=post_page---------------------------#L34)의 fiber 노드로 시작합니다. 그것은 내부적으로 생성이 되고 가장 최상위 컴포넌트의 부모 역할을 합니다.\n이것은 `HostRoot`에서 `stateNode` 속성을 통해 `FiberRoot`로 연결되는 링크가 있습니다.\n\n```javascript\n// fiberRoot.current === hostRootFiberNode, #container 의 Fiber node\n// hostRootFiberNode.stateNode === fiberRoot\nfiberRoot.current.stateNode === fiberRoot // true\n```\n\nfiber root 를 통해 최상위 `HostRoot` fiber 노드에 액세스하여 fiber 트리를 탐색 할 수 있습니다. 또는 다음과 같이 구성 요소 인스턴스에서 개별 fiber 노드를 가져올 수 있습니다.\n\n```javascript\n// 컴포넌트 인스턴스에서 fiber node를 가져올 수 있다.\ncompInstance._reactInternalFiber\n```\n\n### Fiber node structure\n\n그렇다면 `ClickCounter` 컴포넌트에서 생성된 fiber nodes 의 구조를 살펴보자.\n이 fiber node에 `child`, `sibling`, `return` 속성을 지니고 있다.\n\n```javascript\n{\n    stateNode: new ClickCounter, // 함수형 컴포넌트는 null이 들어간다.\n    type: ClickCounter,\n    alternate: null,\n    key: null,\n    updateQueue: null,\n    memoizedState: {count: 0},\n    pendingProps: {},\n    memoizedProps: {},\n    tag: 1,\n    effectTag: 0,\n    nextEffect: null\n}\n```\n\n그리고 `span` DOM element :\n\n```javascript\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    alternate: null,\n    key: \"2\",\n    updateQueue: null,\n    memoizedState: null,\n    pendingProps: {children: 0},\n    memoizedProps: {children: 0},\n    tag: 5,\n    effectTag: 0,\n    nextEffect: null\n}\n```\n\nfiber node 에 꽤 많은 필드들이 있습니다. 여기서 이전 섹션에서 봤던 필드 `alternate`, `effetTag` 그리고 `nextEffects` 의 목적을 설명했었다. 그렇다면 나머지들은 왜 이것들이 필요한지 봅시다.\n\n#### stateNode\n\n컴포넌트의 클래스 인스턴스 DOM 노드 또는 fiber node 와 관련된 다른 React element 타입의 참조값을 지니고 있다.\n일반적으로 이 프로퍼티는 fiber 와 관련된 local state 를 유지하는데 사용된다고 말할 수 있습니다.\n\n#### type\n\n이 fiber 와 관련된 함수나 클래스를 정의한다. 클래스 컴포넌트들의 경우 type 은 생성자 함수를 가리키고 DOM element 들의 경우에는 특별한 HTML 태그를 가리킨다. 이 필드는 fiber 노드가 어떤 엘리먼트와 관련있는지 이해하는데 종종 사용된다.\n\n#### tag\n\n[fiber 의 타입](https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js)을 정의한다. 그것은 어떤 일을 해야하는지를 결정하기 위한 reconciliation 알고리즘으로 사용된다. 이전에 언급했듯이, 작업은 React element 의 타입에따라 달라집니다. 함수 [createFiberFromTypeAndProps](https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js?source=post_page---------------------------#L414) React element 를 관련된 fiber 노드 타입과 매핑시켜준다.\n우리 어플리케이션 안에서 `ClickCounter` 컴포넌트의 `tag` 프로퍼티는 `1` 이다. 이것은 `ClassComponent`를 뜻하고 `span` 엘리먼트의 `5`의 경우에는 `HostComponent`를 가리킨다.\n\n#### updateQueue\n\nstate 업데이트들, 콜백함수들과 DOM update 들의 queue.\n\n#### memoizedState\n\n결과를 만드는데 사용된 fiber 의 State. 업데이트 처리 할 때 memoizedState는 현재 화면에 렌더링 된 state 를 반영합니다.\n\n#### memoizedProps\n\n이전 렌더링 동안 출력을 생성하는 데 사용 된 fiber 의 Props.\n\n#### pendingProps\n\nReact element 들의 새로운 데이터로 업데이트된 Props 그리고 child components 또는 DOM elements 에 적용해야합니다.\n\n#### key\n\nReact 가 어떤 아이템이 변경되었는지, list 에서 추가되었거나 삭제되었는지 알아챌수 있게 해주는 children 그룹에 포함된 특별한 식별자. 여기에 설명 된 React 의 \"목록 및 키\"기능과 관련이 있습니다.\n\n완성된 fiber node 는 [여기](https://github.com/facebook/react/blob/6e4f7c788603dac7fccd227a4852c110b072fe16/packages/react-reconciler/src/ReactFiber.js?source=post_page---------------------------#L78)서 확인해볼수 있다. 여기서는 위의 설명에서 여러 필드를 생략했습니다.\n특히, 이전 글에서 설명한 트리 데이터 구조를 구성하는 포인터인 `child`, `siblig` 그리고 `return` 을 건너 뛰었습니다. 그리고 `expiredTime`, `childExpirationTime` 및 `mode` 와 같은 카테고리는 `Sceduler`에만 해당됩니다.\n\n## General algorithm\n\nReact 는 **렌더링**과 **커밋**의 두 가지 주요 단계로 작업을 수행합니다.\n\n첫 번째 `렌더링` 단계에서 React 는 `setState` 또는 `React.render`를 통해 예약 된 component들에 업데이트를 적용하고 UI 에서 업데이트해야 하는 항목을 파악합니다.\n\n초기 렌더링 인 경우 React 는 `render` 메소드에서 반환 된 각 요소에 대해 새 fiber 노드를 만듭니다. 다음 업데이트에서는 기존 React 요소의 fiber 가 다시 사용되고 업데이트됩니다.\n\n**단계의 결과는 side-effects 마크를 가진 fiber 노드의 트리입니다.** 이 effects 는 다음 `커밋` 단계에서 수행해야하는 작업을 설명합니다.\n\n이 `커밋` 단계에서 React 는 effects 로 표시된 fiber 트리를 가져 와서 인스턴스에 적용합니다. effects 목록을 검토하면서 DOM 업데이트 및 사용자가 볼 수있는 기타 변경 사항을 수행합니다.\n\n**첫 번째 `렌더링` 단계에서 작업을 비동기 적으로 수행 할 수 있다는 것을 이해하는 것이 중요합니다.**\n\nReact 는 사용 가능한 시간에 따라 하나 이상의 fiber 노드를 처리 할 수 있습니다. 그런 다음 작업을 숨기고 일부 이벤트에 양보합니다. 그런 다음 중단 된 부분부터 계속됩니다.\n\n그러나 때로는 완료된 작업을 무시하고 처음부터 다시 시작해야 할 수도 있습니다. 이러한 일시 중지는 이 단계에서 수행 한 작업으로 인해 DOM 업데이트와 같은 사용자가 볼 수있는 변경 사항이 발생하지 않음으로 인해 가능합니다.\n**반대로 다음 커밋 단계는 항상 동기식입니다.**\n\n이는 이 단계에서 수행 된 작업이 사용자에게 표시되는 변경 사항 (예 : DOM 업데이트.) 이기 때문에 React 가 단일 패스로 이를 수행해야합니다.\n\n라이프 사이클 메소드 호출은 React 가 수행하는 작업의 한 유형입니다.\n일부 메서드는 `렌더링` 단계에서 호출되고 다른 메서드는 `커밋` 단계에서 호출됩니다. 첫 번째 `렌더링` 단계를 수행 할 때 호출되는 라이프 사이클 목록은 다음과 같습니다.\n\n- [UNSAFE_]componentWillMount (deprecated)\n- [UNSAFE_]componentWillReceiveProps (deprecated)\n- getDerivedStateFromProps\n- shouldComponentUpdate\n- [UNSAFE_]componentWillUpdate (deprecated)\n- render\n\n보는 것과 같이 `렌더링` 단계에서 실행되는 일부 몇몇 레거시 라이프 사이클 메서드는 버젼 16.3 에서 `UNSAFE`라고 표시됩니다. 그것들은 문서에서 레거시 라이프 사이클이라고 불리워집니다. 그것들은 미래에 16.x 에서 지원이 중단되며 UNSAFE 접두사가 없는 해당 항목은 17.0 에서 제거됩니다. 이 변경 사항과 제안 된 마이그레이션 경로에 대한 자세한 내용은 [여기](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html?source=post_page---------------------------)를 참조하십시오.\n\n이것에 대한 이유가 궁금하십니까?\n\n`렌더링` 단계에서는 DOM 업데이트와 같은 부작용이 발생하지 않으므로 React 는 구성 요소를 비동기 적으로 업데이트를 처리할 수 있음을 알았습니다. (잠재적으로 여러 스레드에서 업데이트를 처리 할 수도 있습니다.) 그러나 `UNSAFE` 로 표시된 라이프 사이클은 종종 오해되고 미묘하게 오용되었습니다. 개발자는 새로운 비동기 렌더링 방식에 문제를 일으킬 수있는 부작용이있는 코드를 이러한 메서드에 넣는 경향이 있었습니다. UNSAFE 접두사가 없는 항목만 제거되지만 곧 나오는 동시 모드 (선택 해제 할 수 있음)에 여전히 문제가 발생할 수 있습니다.\n\n두 번째 `커밋 단계`에서 실행 된 라이프 사이클 메소드 목록은 다음과 같습니다.\n\n- getSnapshotBeforeUpdate\n- componentDidMount\n- componentDidUpdate\n- componentWillUnmount\n\n이러한 메소드는 동기적인 `커밋` 단계에서 실행되기 때문에 부작용이 포함되어 DOM 에 접할 수 있습니다.\n자 이제 우리는 tree 를 탐색하고 작업을 수행하는 데 사용되는 일반화 된 알고리즘을 살펴볼 배경을 가지고 있습니다.\n\n## Render phase\n\nreconciliation 알고리즘은 항상 [renderRoot](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1132) 함수를 사용하여 최상위 `HostRoot` fiber 노드에서 시작합니다. 그러나, React 는 완료되지 않은 작업이있는 노드를 찾을 때까지 이미 처리 된 fiber 노드에서 벗어납니다 (건너 뜁니다). 예를 들어, 컴퍼넌트 트리의 `setState` 를 깊게 들어가있는 component 에서 호출하면, React 는 위에서부터 시작 합니다만, `setState` 메소드를 호출 한 컴퍼넌트에 도착할 때까지, 부모를 신속하게 스킵합니다.\n\n### Main steps of the work loop\n\n모든 fiber 노드는 [작업 루프](https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1136)에서 처리됩니다. 다음은 루프의 동기 부분 구현입니다.\n\n```javascript\nfunction workLoop(isYieldy) {\n  if (!isYieldy) {\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  } else {...}\n}\n```\n\n위의 코드에서 `nextUnitOfWork`는 할 일이 있는 `workInProgress` 트리에서 fiber 노드에 대한 참조를 보유합니다. React 가 Fibers 트리를 탐색하면서 이 변수를 사용하여 완료되지 않은 다른 fiber 노드가 있는지를 확인합니다. 현재 fiber 처리 된 후 변수는 트리의 다음 fiber 노드에 대한 참조 또는 null 을 포함합니다. 이 경우 React 는 작업 루프를 종료하고 변경 사항을 커밋 할 준비가 됩니다.\n\n트리를 탐색하고 작업을 시작하거나 완료하는 데 사용되는 4 가지 주요 기능이 있습니다.\n\n- [performUnitOfWork](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1056)\n- [beginWork](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js?source=post_page---------------------------#L1489)\n- [completeUnitOfWork](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L879)\n- [completeWork](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberCompleteWork.js?source=post_page---------------------------#L532)\n\n그들이 어떻게 사용되는지를 보여주기 위해 다음과 같은 fiber 트리 탐색 애니메이션을 살펴보십시오. 데모 용으로 이러한 함수의 단순화 된 구현을 사용했습니다. 각 기능은 fiber 노드를 처리하고 React 가 트리 아래로 가면서 현재 활성화 된 fiber 노드가 변경된 것을 볼 수 있습니다. 비디오에서 알고리즘이 한 브랜치에서 다른 브랜치로 어떻게 이동하는지 명확하게 볼 수 있습니다. parents 에 가기 전에 먼저 children 위한 일을 마칩니다.\n\n![fiber Traversing](./fiberTraversing.gif)\n\n> 곧은 수직 연결은 sibling 를 의미하는 반면 구부러진 연결은 children 를 나타냅니다. b1 에는 자식이없고 b2 에는 자식 c1 이 하나 있습니다.\n\n다음은 재생을 일시 중지하고 현재 노드와 기능 상태를 검사 할 수있는 비디오에 대한 [링크](https://vimeo.com/302222454?source=post_page---------------------------)입니다. 개념적으로, 당신은 \"시작\"을 구성 요소로 \"들어가는 것\"으로, \"완료\"는 \"단계적으로\" 수행하는 것으로 생각할 수 있습니다. 이 함수들이하는 일을 설명하면서 [예제](https://stackblitz.com/edit/js-ntqfil?file=index.js&source=post_page---------------------------)와 구현을 가지고 놀 수도 있습니다.\n\n`performUnitOfWork`와 `beginWork`의 처음 두 함수를 살펴 보겠습니다.\n\n```javascript\n// while 문에서 계속 반복하는 함수\nfunction performUnitOfWork(workInProgress) {\n  // children에 대한 포인터 또는 null\n  let next = beginWork(workInProgress)\n  if (next === null) {\n    // 더 이상의 자식이 없을때 completeUnitOfWork -> completeWork를 수행\n    // completeUnitOfWork는 sibling이 있을때 return sibling 후 다시 beginWork 진행\n    // sibling도 없을 시에 부모로 올라가서 completeUnitOfWork 내부에 있는 completeWork를 수행\n    next = completeUnitOfWork(workInProgress)\n  }\n  return next\n}\n\nfunction beginWork(workInProgress) {\n  console.log('work performed for ' + workInProgress.name)\n  return workInProgress.child\n}\n```\n\n`performUnitOfWork` 함수는 `workInProgress` 트리에서 fiber 노드를 받고 `beginWork` 함수를 호출하여 작업을 시작합니다. 이 기능은 fiber 대해 수행해야하는 모든 작업을 시작하는 기능입니다. 이 증명을 위해, 우리는 단순히 작업이 완료되었음을 나타내기 위해 fiber 의 이름을 기록합니다. **`beginWork` 함수는 항상 루프에서 처리 할 다음 child 에 대한 포인터 또는 null 을 반환합니다.**\n\n다음 자식이 있으면 `workLoop` 함수의 `nextUnitOfWork` 변수에 할당됩니다. 그러나 자식이 없으면 React 는 분기의 끝에 도달 했으므로 현재 노드를 완료 할 수 있음을 알게됩니다. **노드가 완성되면 siblings 를 위한 작업을 수행 한 후 그 부모에게 역 추적해야합니다.** 이 작업은 `completeUnitOfWork` 함수에서 수행됩니다.\n\n```javascript\n// 여기서 들어오는 workInProgress는 child가 없어서 들어온것이다.\n// 더 이상의 child가 없다는건 현재 깊이의 끝에 도달했다는 것이고 이 fiber를 completeWork를 수행한다.\n// workInProgress를 받아서 sibling을 찾아보고 찾는다면 다시  performUnitOfWork를 수행한다.\n// child와 sibling이 없다면 부모로 올라가서 completeWork를 수행하게 된다.\nfunction completeUnitOfWork(workInProgress) {\n  while (true) {\n    let returnFiber = workInProgress.return\n    let siblingFiber = workInProgress.sibling\n\n    nextUnitOfWork = completeWork(workInProgress)\n\n    if (siblingFiber !== null) {\n      // If there is a sibling, return it\n      // to perform work for this sibling\n      // 형제가 있으면 형제를 리턴한다.\n      return siblingFiber\n    } else if (returnFiber !== null) {\n      // If there's no more work in this returnFiber,\n      // continue the loop to complete the parent.\n      // 부모가 있으면 작업 트리를 부모로 할당해서 completeWork를 유도한다.\n      workInProgress = returnFiber\n      continue\n    } else {\n      // We've reached the root.\n      return null\n    }\n  }\n}\n\nfunction completeWork(workInProgress) {\n  console.log('work completed for ' + workInProgress.name)\n  return null\n}\n```\n\n함수의 요지가 커다란 `while`루프 라는 것을 알 수 있습니다. React 는 `workInProgress` 노드에 children 이 없을 때 이 함수(`completeUnitOfWork`)로 들어갑니다. 현재 fiber 에 대한 작업을 마친 후 sibling 가 있는지 확인합니다. 발견되면 React 가 함수를 종료하고 형제에게 포인터를 반환합니다. `nextUnitOfWork` 변수에 할당되고 React 가 이 sibling 로 시작하는 분기에 대한 작업을 수행합니다. 이 시점에서 React 는 이전 siblings 를 위한 작업만 완료했다는 것을 이해하는 것이 중요합니다. 상위 노드에 대한 작업을 완료하지 않았습니다. **자식 노드로 시작하는 모든 분기가 완료되면 부모 노드와 백 트랙에 대한 작업이 완료됩니다.**\n\n구현에서 볼 수 있듯이 `performUnitOfWork` 와 `completeUnitOfWork` 는 모두 반복 작업을 위해 주로 사용되는 반면, 주요 작업은 `beginWork` 및 `completeWork` 함수에서 수행됩니다. 이 시리즈의 다음 기사에서는 `ClickCounter` component 및 `span` 노드에 대해 React 가 `beginWork` 및 `completeWork` 함수 에 수행되는 것에 대해 알아 봅니다.\n\n## Commit phase\n\n이 단계는 [completeRoot](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L2306) 함수로 시작합니다. 여기서 React 는 DOM 을 업데이트하고 사전 및 사후 mutation 라이프 사이클 메소드를 호출합니다.\n\nReact 가 이 단계에 이르면 2 개의 tree 와 effects list 가 있습니다. 첫 번째 tree 는 현재 화면에 렌더링 된 상태를 나타냅니다. 그런 다음 `렌더링` 단계 동안 만들어진 `alternate` 트리가 있습니다. 소스에서 `finishedWork` 또는 `workInProgress` 라고하며 화면에 반영 되어야하는 상태를 나타냅니다. 이 `alternate` 트리는 `child` 및 `sibling` 포인터를 통해 current 트리와 비슷하게 연결됩니다.\n\n그런 다음 effects list - `nextEffect` 포인터를 통해 연결된 `finishedWork` 트리의 노드 하위 집합입니다. effects list 은 `렌더링 단계(render phase)`를 실행 한 결과임을 기억하십시오. 렌더링의 전체 포인트는 삽입, 업데이트 또는 삭제해야 할 노드와 어느 components가 라이프 사이클 메소드 호출이 필요한지를 결정하는 것이 었습니다. 이것이 effects list 에서 우리에게 알려줍니다. **그리고 그것은 정확히 커밋 단계에서 반복되는 노드 집합입니다.**\n\n> 디버깅을 위해 `current` 트리는 fiber 루트의 `current` 속성을 통해 액세스 할 수 있습니다. `finishedWork` 트리는 `current` 트리의 `HostFiber` 노드의 `alternate` 프로퍼티를 통해 엑세스 할 수 있습니다.\n\n커밋 단계에서 실행되는 주요 기능은 `commitRoot`입니다. 기본적으로 다음과 같은 작업을 수행합니다.\n\n- `Snapshot` effect 태그가 지정된 노드에서 `getSnapshotBeforeUpdate` 라이프 사이클 메소드를 호출합니다.\n- `Deletion` effect 태그가 지정된 노드에서 `componentWillUnmount` 라이프 사이클 메소드를 호출합니다.\n- 모든 DOM 삽입, 업데이트 및 삭제를 수행합니다.\n- 완성 된 `작업 트리(finishedWork)`를 현재로 설정합니다.\n- `Placement` effect 태그가 지정된 노드에서 `componentDidMount` 라이프 사이클 메소드 호출\n- `Update` effect 태그가 지정된 노드에서 `componentDidUpdate` 라이프 사이클 메서드를 호출합니다.\n\npre-mutation 메소드인 `getSnapshotBeforeUpdate` 를 호출 한 후, React 는 트리 내의 모든 side-effects 커밋합니다. 두 단계에 걸쳐 `커밋`을 진행합니다. 첫 번째 단계는 모든 DOM (host) 삽입, 업데이트, 삭제 및 참조 해제를 수행합니다.\n그런 다음 React 는 `workInProgress` 트리를 `current` 트리로 표시하기 위해 `finishedWork` 트리를 `FiberRoot` 에 할당합니다.\n\n이 작업은 커밋 단계의 첫 번째 단계 이후에 완료되며, 따라서 `componentWillUnmount` 동안에는 이전 트리는 current 이지만 두 번째 단계 이전에는 finished work 트리가 `componentDidMount / Update` 동안 current 상태가 됩니다.\n두 번째 단계에서는 React 가 다른 모든 라이프 사이클 메소드 및 ref 콜백을 호출합니다. 이러한 메소드는 별도의 단계로 실행되므로 전체 트리에서 모든 배치, 업데이트 및 삭제는 이미 호출되었습니다.\n\n위에서 설명한 단계를 실행하는 함수의 요지는 다음과 같습니다.\n\n```javascript\nfunction commitRoot(root, finishedWork) {\n  commitBeforeMutationLifecycles()\n  commitAllHostEffects()\n  root.current = finishedWork\n  commitAllLifeCycles()\n}\n```\n\n각 하위 함수는 effects list 을 반복하고 effect 의 type 을 확인하는 루프를 구현합니다. 함수의 목적과 관련된 효과를 발견하면 그것을 적용합니다.\n\n## Pre-mutation lifecycle methods\n\n예를 들어, effects tree 를 반복하고 노드에 `Snapshot effect`가 있는지 확인하는 코드는 다음과 같습니다.\n\n```javascript\nfunction commitBeforeMutationLifecycles() {\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag\n    if (effectTag & Snapshot) {\n      const current = nextEffect.alternate\n      commitBeforeMutationLifeCycles(current, nextEffect) // C 대문자?\n    }\n    nextEffect = nextEffect.nextEffect\n  }\n}\n```\n\n클래스 구성 요소의 경우이 effect 는 `getSnapshotBeforeUpdate` 라이프 사이클 메소드를 호출하는 것을 의미합니다.\n\n## DOM updates\n\n[commitAllHostEffects](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L376) 는 React 가 DOM 업데이트를 수행하는 함수입니다. 이 함수는 기본적으로 노드에 대해 수행해야하는 작업 유형을 정의하고 실행합니다.\n\n```javascript\nlet nextEffect: Fiber | null = null;\n\nfunction commitAllHostEffects() {\n    switch (primaryEffectTag) {\n        case Placement: {\n            commitPlacement(nextEffect);\n            ...\n        }\n        case PlacementAndUpdate: {\n            commitPlacement(nextEffect);\n            commitWork(current, nextEffect);\n            ...\n        }\n        case Update: {\n            commitWork(current, nextEffect);\n            ...\n        }\n        case Deletion: {\n            commitDeletion(nextEffect);\n            ...\n        }\n    }\n}\n```\n\nReact 가 `commitDeletion` 함수에서 삭제 프로세스의 일부로 `componentWillUnmount` 메소드를 호출한다는 것은 흥미롭습니다.\n\n## Post-mutation lifecycle methods\n\n[commitAllLifecycles](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L465) 는 React 가 나머지 모든 라이프 사이클 메소드 인 `componentDidUpdate` 및 `componentDidMount` 를 호출하는 함수입니다.\n","excerpt":"이글을 번역 및 분석 한 글입니다. 잘못된 번역 및 생략된 번역이 있을 수 있습니다. Inside Fiber: in-depth overview of the new reconciliation algorithm in React React 는 유저인터페이…","fields":{"slug":"/react-fiber02/"},"frontmatter":{"date":"Jul 19, 2019","title":"React Fiber part2","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n[이글](https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/)을 번역 및 분석 한 글입니다. 잘못된 번역이 있을 수 있습니다.\n\n## Deep dive: How do React hooks really work?\n\n### What are Closures?\n\n클로져들은 JS 의 기본 컨셉입니다. 클로져는 다음과 같이 정의 내릴수 있습니다.\n클로져는 함수가 해당 렉시컬 범위에서 벗어나도 실행 되었을때 그것의 렉시컬 범위를 기억하고 있는 것이다.\n\n이들은 렉시컬 스코핑의 컨셉과 밀접하게 관련되어 있습니다.\n\n```javascript\n// Example 0\nfunction useState(initialValue) {\n  var _val = initialValue // _val is a local variable created by useState\n  function state() {\n    // state is an inner function, a closure\n    return _val // state() uses _val, declared by parent funciton\n  }\n  function setState(newVal) {\n    // same\n    _val = newVal // setting _val without exposing _val\n  }\n  return [state, setState] // exposing functions for external use\n}\nvar [foo, setFoo] = useState(0) // using array destructuring\nconsole.log(foo()) // logs 0 - the initialValue we gave\nsetFoo(1) // sets _val inside useState's scope\nconsole.log(foo()) // logs 1 - new initialValue, despite exact same call\n```\n\n여기 우리가 만든 useSate hook 이 있습니다. 이 함수 안에는 2 개의 내부 함수가 존재합니다, state, setState.\nstate 는 상단에 정의 내린 \\_val 의 로컬 변수가 리턴되는 함수이고 setState 는 로컬변수에 전달받은 파라미터로 셋팅한다.\n\n여기 state 의 실행문은 getter 함수이다. 여기서 중요한 것은 foo 와 setFoo 를 사용하여 내부 변수 \\_val 에 액세스하고 조작 할 수 있다는 것입니다. 그것들은 useState 의 범위에 대한 액세스를 유지하며 그 참조를 클로저라고합니다. React 와 다른 프레임 워크의 컨텍스트에서, 이것은 상태처럼 보입니다.\n\n### Usage in Function Components\n\n새롭게 작성된 useState 클론을 유사한 환경에서 적용해봅시다. 우리는 Counter 컴포넌트를 만들것입니다.\n\n```javascript\n// Example 1\nfunction Counter() {\n  const [count, setCount] = useState(0) // same useState as above\n  return {\n    click: () => setCount(count() + 1),\n    render: () => console.log('render:', { count: count() }),\n  }\n}\nconst C = Counter()\nC.render() // render: { count: 0 }\nC.click()\nC.render() // render: { count: 1 }\n```\n\n여기 DOM 을 렌더링하는 대신에 우리의 state 를 console.log 로 표현해봅시다.\n\n그리고 Counter 컴포넌트의 API 를 노출해서 이벤트 핸들러를 적용하는 대신에 스크립트내에서 동작할 수 있도록 해봅시다. 이런 디자인은 컴포넌트 랜더링과 유저액션에 따른 반응을 시뮬레이션 해볼수 있습니다.\n\n### Stale Closure ( 부실한 클로저 )\n\n우리가 진짜 리액트 API 에 메칭하길 원한다면 우리 state 는 함수가 아니라 변수 여야 한다. 만약 간단하게 \\_val 함수로 감싸지 않고 노출시킨다면 버그가 생길 것입니다.\n\n```javascript\n// Example 0, revisited - this is BUGGY!\nfunction useState(initialValue) {\n  var _val = initialValue\n  // no state() function\n  function setState(newVal) {\n    _val = newVal\n  }\n  return [_val, setState] // directly exposing _val\n}\nvar [foo, setFoo] = useState(0)\nconsole.log(foo) // logs 0 without needing function call\nsetFoo(1) // sets _val inside useState's scope\nconsole.log(foo) // logs 0 - oops!!\n```\n\n이것은 부실 클로즈 문제의 한가지 형식입니다. 우리가 foo 를 디스트럭쳐링을 useState 의 output 으로 할때, 그것은 초기 useState 호출 시점의 \\_val 을 참조합니다.... 그리곤 다신 변하지 않습니다. 이것은 우리가 원하는것이 아닙니다. 우리는 일반적으로 현재의 state 가 반영된 컴포넌트가 필요합니다. 함수 호출 대신에 변수만 있는 동안에!! 이 두가지 목표는 정 반대처럼 보입니다.\n\n### Closure in Modules\n\n우리는 우리의 useState 수수께끼를 해결할 수 있습니다 ... 우리의 closure 를 다른 closure 안으로 이동하십시오!\n\n```javascript\n// Example 2\nconst MyReact = (function() {\n  let _val // hold our state in module scope\n  return {\n    render(Component) {\n      const Comp = Component()\n      Comp.render()\n      return Comp\n    },\n    useState(initialValue) {\n      _val = _val || initialValue // assign anew every run\n      function setState(newVal) {\n        _val = newVal\n      }\n      return [_val, setState]\n    },\n  }\n})()\n```\n\n여기에서 모듈 패턴을 사용해서 작은 React 복제본을 만들었습니다. React 와 마찬가지로, 이 함수는 Component 상태를 추적합니다. ( 이 예제에서는 \\_val 의 상태와 함께 하나의 component 만 추적합니다. ) 이 디자인을 사용하면 MyReact 가 함수 component 를 \"렌더링\" 할 수 있으므로 매번 올바른 클로져로 내부 \\_val 값을 할당 할 수 있습니다.\n\n이제 더 많은 React 훅을 알아보자.\n\n### Replicating useEffect\n\n지금까지, 우리는 useState 를 알아보았다. 이것은 첫번째 기본적인 React Hook 이다. 다음으로 중요한건 useEffect 이다. setSate 와는 다르게 useEffect 는 비동기적으로 실행되므로 클로저에 문제가 발생할 가능성이 커집니다.\n\n우리는 지금까지 구축 한 React 의 작은 모델을 이것을 포함하도록 확장 할 수 있습니다.\n\n```javascript\n// Example 3\nconst MyReact = (function() {\n  let _val, _deps // hold our state and dependencies in scope\n  return {\n    render(Component) {\n      const Comp = Component()\n      Comp.render()\n      return Comp\n    },\n    useEffect(callback, depArray) {\n      const hasNoDeps = !depArray\n      const hasChangedDeps = _deps\n        ? !depArray.every((el, i) => el === _deps[i])\n        : true\n      if (hasNoDeps || hasChangedDeps) {\n        callback()\n        _deps = depArray\n      }\n    },\n    useState(initialValue) {\n      _val = _val || initialValue\n      function setState(newVal) {\n        _val = newVal\n      }\n      return [_val, setState]\n    },\n  }\n})()\n\n// usage\nfunction Counter() {\n  const [count, setCount] = MyReact.useState(0)\n  MyReact.useEffect(\n    () => {\n      console.log('effect', count)\n    },\n    [count]\n  )\n  return {\n    click: () => setCount(count + 1),\n    noop: () => setCount(count),\n    render: () => console.log('render', { count }),\n  }\n}\nlet App\nApp = MyReact.render(Counter)\n// effect 0\n// render {count: 0}\nApp.click()\nApp = MyReact.render(Counter)\n// effect 1\n// render {count: 1}\nApp.noop()\nApp = MyReact.render(Counter)\n// // no effect run\n// render {count: 1}\nApp.click()\nApp = MyReact.render(Counter)\n// effect 2\n// render {count: 2}\n```\n\n디펜던시들을 추적하기 위해서(의존성이 바뀌면 useEffect 가 다시 실행되기 때문에), 우리는 \\_deps 를 도입한다.\n\n### Not Magic, just Arrays\n\n우리는 꽤 멋진 useState 와 useEffect 함수들을 복제해냈다. 하지만 이 두 함수는 심하게 싱글턴으로 구현이 되어있다. 이말인 즉슨, 오직 한개만 존재할수 있거나 버그가 발생할수 있다는 것이다.\n\n우리는 state 와 effect 들의 임의의 갯수를 받게끔 확장할 필요가 있다.\n\n다행스럽게도 React Hooks 는 마법이 아니며 배열에 불과합니다. 그래서 우리는 hooks 라는 배열을 가질것이며 이제 겹칠일이 없기 때문에 \\_val 과 \\_deps 를 없앨 수 있습니다.\n\n```javascript\n// Example 4\nconst MyReact = (function() {\n  let hooks = [],\n    currentHook = 0 // array of hooks, and an iterator!\n  return {\n    render(Component) {\n      const Comp = Component() // run effects\n      Comp.render()\n      currentHook = 0 // reset for next render\n      return Comp\n    },\n    useEffect(callback, depArray) {\n      const hasNoDeps = !depArray\n      const deps = hooks[currentHook] // type: array | undefined\n      const hasChangedDeps = deps\n        ? !depArray.every((el, i) => el === deps[i])\n        : true\n      if (hasNoDeps || hasChangedDeps) {\n        callback()\n        hooks[currentHook] = depArray\n      }\n      currentHook++ // done with this hook\n    },\n    useState(initialValue) {\n      hooks[currentHook] = hooks[currentHook] || initialValue // type: any\n      const setStateHookIndex = currentHook // for setState's closure!\n      const setState = newState => (hooks[setStateHookIndex] = newState)\n      return [hooks[currentHook++], setState]\n    },\n  }\n})()\n```\n\n여기서는 setStateHookIndex 사용법에 유의하십시오. 아무 것도 보이지 않지만 setState 가 currentHook 변수를 덮지 않도록 방지하는 데 사용됩니다! \n`setState`에서 사용해야 할 인덱스를 가둬둔다고 생각하면 된다. \nsetStateHookIndex 를 사용하지 않으면 setState 함수가 `newState => (hooks[currentHook] = newState)` 가 되게 되는데 여기서 currentHook 은 실행될때 참조 되므로 `App.type('bar')` 실행시때, currentHook 이 0 일때 실행하게 되어서 엉뚱한 state 변화를 초래하게 된다.\n\nhooks 배열에는 useState 때 사용하는 state 값이 , useEffect 때는 디펜던시 값이 존재한다. 특히 useState 에서 나오는 setState 함수에는 변화해야 할 값의 인덱스가 저장되어있는 인덱스를 각 함수마다 지니고 있다.\n\nhooks 배열을 들여다 보면 다음과 같다. \n\n```javascript\n// 만약 component에서 다음과 같이 훅을 실행 했을 때\nconst [count, setCount] = React.useState(1)\nconst [text, setText] = React.useState('apple')\n\n  // 랜더링 시 최초에 한 번만 실행된다.\n  // 배열 안에 관찰하고자 하는 상태를 전달하면 그 상태에 반응하여 콜백이 실행된다.\nReact.useEffect(() => {\n  console.log('side effect')\n}, ['apple'])\n  \n\n// hooks은 다음과 같이 셋팅이 된다. [2, \"banana\", ['apple']]\n```\n\n```javascript\n// Example 4 continued - in usage\nfunction Counter() {\n  const [count, setCount] = MyReact.useState(0)\n  const [text, setText] = MyReact.useState('foo') // 2nd state hook!\n  MyReact.useEffect(\n    () => {\n      console.log('effect', count, text)\n    },\n    [count, text]\n  )\n  return {\n    click: () => setCount(count + 1),\n    type: txt => setText(txt),\n    noop: () => setCount(count),\n    render: () => console.log('render', { count, text }),\n  }\n}\nlet App\nApp = MyReact.render(Counter)\n// effect 0 foo\n// render {count: 0, text: 'foo'}\nApp.click()\nApp = MyReact.render(Counter)\n// effect 1 foo\n// render {count: 1, text: 'foo'}\nApp.type('bar')\nApp = MyReact.render(Counter)\n// effect 1 bar\n// render {count: 1, text: 'bar'}\nApp.noop()\nApp = MyReact.render(Counter)\n// // no effect run\n// render {count: 1, text: 'bar'}\nApp.click()\nApp = MyReact.render(Counter)\n// effect 2 bar\n// render {count: 2, text: 'bar'}\n```\n\n그래서 기본 원리는 hooks 의 배열과 각 hook 이 호출될때 증가하거나 컴포넌트가 render 될때 reset 되는 인덱스를 지니고 있는 것이다.\n\n또한 custom hooks 도 쉽게 얻을 수있다.\n\n```javascript\n// Example 4, revisited\nfunction Component() {\n  const [text, setText] = useSplitURL('www.netlify.com')\n  return {\n    type: txt => setText(txt),\n    render: () => console.log({ text }),\n  }\n}\nfunction useSplitURL(str) {\n  const [text, setText] = MyReact.useState(str)\n  const masked = text.split('.')\n  return [masked, setText]\n}\nlet App\nApp = MyReact.render(Component)\n// { text: [ 'www', 'netlify', 'com' ] }\nApp.type('www.reactjs.org')\nApp = MyReact.render(Component)\n// { text: [ 'www', 'reactjs', 'org' ] }}\n```\n\n이것은 진정으로 \"매직이 아닌\" hook 이 되는 방식입니다. Custom Hooks 는 React 또는 우리가 구축 한 작은 복제품과 같은 프레임 워크가 제공하는 기본 요소에서 벗어납니다.\n\n### Deriving(파생) the Rules of Hooks\n\n여기에서 첫 번째 Hooks 규칙의 첫 번째 레벨 인 Call Hooks 를 쉽게 이해할 수 있습니다.\n우리는 currentHook 변수로 React 의 호출 순서 의존성을 명시 적으로 모델링했습니다. 우리의 구현을 염두에두고 규칙의 설명 전체를 읽고 모든 일들을 완전히 이해할 수 있습니다.\n\n\n두 번째 규칙 인 \"React Functions 로부터의 Call Hooks\"는 우리 구현의 필수 결과는 아니지만 코드의 어떤 부분이 Stateful 논리에 의존하는지 명확하게 구분하는 것이 좋습니다. (좋은 부작용으로 첫 번째 규칙을 따르는 툴링을 작성하는 것이 더 쉬워지며 루프 및 조건 내부의 일반 JavaScript 함수와 같은 상태 저장 함수를 래핑하여 실수로 자신을 쏠 수 없습니다. 규칙 2 는 규칙 1 을 따르는 데 도움이됩니다.)\n\n조건부로 훅이 호출되거나 루프 안에서 훅이 호출되어야 하는 경우 등이 있다면 인덱스의 순서를 보장할 수 없고, 상태의 관리도 보장할 수 없게 됩니다.\n\n여기서 리액트는 훅의 호출 순서에 의존을 하기 때문에 어떤 상태가 어떤 useState 호출에 대응하는지 알 수 있다. 또한 훅이 컴포넌트의 최상위 레벨에서 호출되어야만 하는 이유이기도 하다. \n[왜 호출 순서에 의존을 하는가?](https://overreacted.io/why-do-hooks-rely-on-call-order/)\n\n### Conclusion\n\n이 시점에서 우리는 가능한 한 많이 hook 을 작성해봤습니다. [하나의 라이너로 useRef 를 구현](https://www.reddit.com/r/reactjs/comments/aufijk/useref_is_basically_usestatecurrent_initialvalue_0/)하거나 [렌더링 함수가 실제로 JSX 를 사용하여 DOM 에 마운트하거나](https://www.npmjs.com/package/vdom) 또는 28 줄의 React Hooks 복제본에서 생략 한 기타 중요한 세부 사항을 만들 수 있습니다. 그러나 상황에 따라 클로저를 사용하여 경험을 쌓고 React Hooks 가 작동하는 방식을 설명하는 유용한 정신 모델을 얻었기를 바랍니다.\n\n\n## 정리 \n\n지금까지 내가 알았던 훅은 `original A => originA = A; A = function() { console.log('내가하고싶은거...'); originA()}` 이런 식으로 해당 작업을 직접 건드려서 훅을 만드는 것이였다. \n하지만 그러나 라이브리러나 어떤 시스템에서 해당 함수를 직접 건드리라고 시키겠는가 꼭 필요하다면 사용자로 하여금 훅을 등록시키는 방법을 통해서 내부적으로 호출해주는 방식을 만들 것 같다. 예로 git hook 도 등록 할 수 있는 훅들을 안내해주고 사용자로 하여금 등록하게 만든다. ","excerpt":"이글을 번역 및 분석 한 글입니다. 잘못된 번역이 있을 수 있습니다. Deep dive: How do React hooks really work? What are Closures? 클로져들은 JS 의 기본 컨셉입니다. 클로져는 다음과 같이 정의 내릴…","fields":{"slug":"/react-hook.md/"},"frontmatter":{"date":"Jul 18, 2019","title":"React Hooks","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n[이글](https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7)을 번역 및 분석 한 글입니다. 잘못된 번역 및 생략된 번역이 있을 수 있습니다.\n\n## The how and why on React’s usage of linked list in Fiber to walk the component’s tree\n\nFiber 의 아키텍처는 2 가지의 주요한 단계이 있다. reconcilation/render 와 commit 이다.\n소스코드 안에 있는 reconciliation 단계를 \"render pahse\" 라고 한다.\n\n이 단계에는 React 가 컴포넌트 트리를 탐색하면서 다음과 같은 일을 한다.\n\n- updates state and props, (state 와 props를 업데이트)\n- calls lifecycle hooks, (라이프 사이클 훅 호출)\n- retrieves the children from the component, (컴포넌트 자식을 탐색한다.)\n- compares them to the previous children, (이전 자식들과 비교한다.)\n- and figures out the DOM updates that need to be performed. (그리고 DOM update가 필요한지 확인한다.)\n\n**이 모든 행동들을 Fiber 안에서 작업이라고 합니다.**\n\n수행해야 할 작업의 타입은 React Element 에 따라 다릅니다. 예를들면 클래스 컴포넌트는 인스턴스화 해야하지만 함수 컴포넌트는 그렇지 않습니다.\n\n흥미가 있다면 [이글](https://github.com/facebook/react/blob/340bfd9393e8173adca5380e6587e1ea1a23cefa/packages/shared/ReactWorkTags.js#L29-L28)를 읽어봐라 여기서 Fiber 의 작업 타겟의 타입들을 볼수 있다.\n\n```javascript\nexport type WorkTag = 0 | 1 | 2 //....\n\nexport const FunctionalComponent = 0\nexport const ClassComponent = 2\nexport const HostRoot = 5 // Root of a host tree. Could be nested inside another node.\n```\n\n> UI를 다룰 때 문제는 한 번에 너무 많은 작업이 실행되면 애니메이션이 프레임을 떨어 뜨릴 수 있다는 것입니다.\n\n리액트는 컴포넌트를 동기적으로 순회하면서 각 컴포넌트에서 작업을 처리한다고 했을때 어플리케이션 로직은 16ms 초 이상이 될 수 있다. 그로 인해 프레임이 망가져 시각적 효과가 끊길수 있다.\n\n그래서 여기선 `requestIdleCallback` 이라는 글로벌 함수를 사용할 것이다. 브라우저가 idle 기간에 함수를 호출하게끔 큐를 사용하는 함수이다.\n\n```javascript\nrequestIdleCallback(deadline => {\n  console.log(deadline.timeRemaining(), deadline.didTimeout)\n})\n```\n\n이 코드를 실행 했을 때, 크롬 로그에서 `49.9 false` 가 나왔다면 그것은 나에게 이렇게 말하는 것과 같다. 내가 필요한 작업이 무엇이든 할수 있는 `49.9ms` 가 있고 나는 할당 된 시간을 모두 다 사용하지 않았다.\n\n반대는 `deadline.didTimeout` 이 true 일 것이다. `timeRemaining`는 브라우저가 어떤 작업을 수행하자마자 바뀔 수 있으므로 항상 확인해야합니다.\n\n만약 우리가 모든 컴포넌트의 수행을 `performWork` 함수에 넣고 작업 스케쥴을 위해 `requestIdleCallback` 을 사용할 수 있다면 다음과 같은 코드가 될것이다.\n\n```javascript\nrequestIdleCallback(deadline => {\n  // while we have time, perform work for a part of the components tree\n  while (\n    (deadline.timeRemaining() > 0 || deadline.didTimeout) &&\n    nextComponent\n  ) {\n    nextComponent = performWork(nextComponent)\n  }\n})\n```\n\n한 컴포넌트 작업을 수행한 후 다음 컴포넌트 수행을 위한 참조값을 리턴할것이다.\n우리는 모든 컴포넌트 트리의 절차를 동기적으로 수행할 수 없다. 이전 `reconciliation` 알고리즘 수행 처럼 그리고 그것의 문제를 앤드류는 이렇게 말하고 있습니다.\n\n> 이러한 API 를 사용하려면 우리는 증분 단위로 렌더링 작업을 나눠야 한다.\n\n그래서 이 문제를 해결하기 위해 React 는 **빌트인 스택에 의존하는 동기식 재귀 모델에서 연결된 리스트와 포인터가있는 비동기 모델로 트리를 이동하는 알고리즘**을 다시 구현해야했습니다.\n\n> 만약 빌트인된 콜 스택에 의존하게 된다면 그것은 스택이 비어질때까지 계속 실행해야 할 것입니다. 우리가 원하는대로 호출 스택을 중단하고 수동으로 스택 프레임을 조작 할 수 있다면 좋지 않을까요? 그것은 React Fiber 의 목적입니다. fiber 는 React 구성 요소에 특화된 스택의 재 구현입니다. 단일 fiber 가상 스택 프레임으로 생각할 수 있습니다.\n\n### A word about the stack\n\n호출 스택 개념에 익숙하다고 가정합니다. 이것은 중단 점에서 코드를 일시 중지하면 브라우저의 디버깅 도구에서 볼 수 있습니다. 다음은 Wikipedia 의 관련 인용문과 다이어그램입니다.\n\n> In computer science, a call stack is a stack data structure that stores information about the active subroutines of a computer program… the main reason for having call stack is to keep track of the point to which each active subroutine should return control when it finishes executing… A call stack is composed of stack frames… Each stack frame corresponds to a call to a subroutine which has not yet terminated with a return. For example, if a subroutine named DrawLine is currently running, having been called by a subroutine DrawSquare, the top part of the call stack might be laid out like in the adjacent picture.\n\n![call stack](./callStack.png)\n\n### Why is the stack relevant to React?\n\n스택이 React 와 관련이있는 이유는 무엇입니까?\n\n우리는 기사의 첫파트에 정의했었다. 리액트는 컴포넌트 트리를 reconciliation/render 단계동안 순회하고 몇몇 작업들을 수행한다. 이전에 동기적인 재귀 모델로 동작했던 reconciler 사용은 트리를 순회하기 위해서 빌트인된 stack 에 의존했었다.\n\n이것에 대해서 생각해보자. 각 재귀 호출이 frame 을 스택에 쌓게 되고 그것이 동기으로 동작한다는 것이다.\n\n다음과 같은 트리 구조가 있다고 가정해보자.\n\n![UI 트리구조](./tree1.png)\n\n각각은 render 함수가 있는 객체라고 하자. 다음과 같은 컴포넌트 인스턴스라고 생각 될 것이다.\n\n```javascript\nconst a1 = { name: 'a1' }\nconst b1 = { name: 'b1' }\nconst b2 = { name: 'b2' }\nconst b3 = { name: 'b3' }\nconst c1 = { name: 'c1' }\nconst c2 = { name: 'c2' }\nconst d1 = { name: 'd1' }\nconst d2 = { name: 'd2' }\n\na1.render = () => [b1, b2, b3]\nb1.render = () => []\nb2.render = () => [c1]\nb3.render = () => [c2]\nc1.render = () => [d1, d2]\nc2.render = () => []\nd1.render = () => []\nd2.render = () => []\n```\n\n리액트는 이 트리 순회가 필요하고 각 컴포넌트마다 작업을 수행해야 한다. 간단하게 말해서 할 일은 현재 구성 요소의 이름을 로그하고 그 하위를 검색하는 것입니다.\n\n### Recursive traversal\n\n재귀를 사용하는 방법을 보자.\n트리를 반복하는 주요 기능을 아래 구현에서 `walk` 라고합니다.\n\n```javascript\nwalk(a1)\n\nfunction walk(instance) {\n  doWork(instance)\n  const children = instance.render()\n  children.forEach(walk)\n}\n\nfunction doWork(o) {\n  console.log(o.name)\n}\n```\n\n그럼 다음과 같은 output 이 나올 것이다.\n\n```\na1, b1, b2, c1, d1, d2, b3, c2\n```\n\n만약 이런 재귀 방식이 혼동 된다면 [이 글](https://codeburst.io/learn-and-understand-recursion-in-javascript-b588218e87ea)을 참고하자.\n\n재귀적인 접근은 직관적이다 그리고 트리를 탐색하기에 적합하다. 하지만 그것은 제한적이다. 가장 큰 문제는 이 작업을 점진적인 단위로 나눌수가 없다는 것이다. 우리는 이 작업을 특별한 컴포넌트 지점에서 잠시 멈췄다가 이후에 다시 재개할 수가 없다. 이 접근은 리액트가 모든 컴포넌트 처리가 될때까지 이어지고 나서 스택이 비워진다.\n\n**그래서 어떻게 이런 재귀 없이 리액트는 트리 순환을 실행할수 있을까? 그것은 단일 링크드 리스트 트리 탐색 알고리즘을 사용합니다. 그것은 순회를 멈추고 스택의 증가를 멈추가 할 수 있습니다.**\n\n### Linked list traversal\n\n운좋게 여기서 알고리즘의 골자를 찾을 수 있었습니다. [https://github.com/facebook/react/issues/7942#issue-182373497](https://github.com/facebook/react/issues/7942#issue-182373497)\n\n이 알고리즘을 수행하려면 우리는 3 가지 필드를 가진 데이터 구조가 필요합니다.\n\n- child — reference to the first child\n- sibling — reference to the first sibling\n- return — reference to the parent\n\nReact 의 새로운 reconciliation 알고리즘과 관련하여 이 필드가있는 데이터 구조를 Fiber 라고합니다. Fiber는 queue에 작업을 구성하고 있는 React Element를 대표하는 것입니다.\n\n다음 다이어그램은 링크드 리스트를 통해 연결된 개체의 계층 구조와 개체 간의 연결 유형을 보여줍니다.\n\n![linked list](./linkedList1.png)\n\n그럼 첫번째로 우리의 커스텀 노드 생성자를 정의해 봅시다.\n\n```javascript\nclass Node {\n  constructor(instance) {\n    this.instance = instance\n    this.child = null // 가장 첫번째 자식만 가지고 있는다.\n    this.sibling = null // 두번째 자식을 접근하려고 하면 자식의 sibling으로 접근해야 한다.\n    this.return = null // 부모를 참조해둔다.\n  }\n}\n```\n\n그리곤 노드들의 배열을 받아서 그것들을 함께 엮는 함수를 봅시다.\n우리는 함수를 사용해서 `render` 메서드에서 반환된 children 을 연결할 것입니다.\n\n```javascript\n// 부모에다가 children[] 을 연결한다.\nfunction link(parent, elements) {\n  if (elements === null) elements = []\n\n  // node 하나를 리턴 받을 건데\n  // 이 node에는 sibling으로 쭈욱 연결된 리스트 들이 있다.\n  // 단일로 연결한다.\n  // 부모 - 자식 - 자식형제 - 자식형제 - 자식형제\n  parent.child = elements.reduceRight((previous, current) => {\n    const node = new Node(current)\n    node.return = parent\n    node.sibling = previous\n    return node\n  }, null)\n\n  return parent.child\n}\n```\n\n이 함수는 노드 배열에서 맨 마지막걸 시작으로 순회하고, 그것들을 단일 링크드 리스트로 연결한다.\n여기서 리스트의 가장 첫번째 sibling 이 리턴된다.\n\n여기 데모를 보자.\n\n```javascript\nconst children = [{ name: 'b1' }, { name: 'b2' }]\nconst parent = new Node({ name: 'a1' })\nconst child = link(parent, children)\n\n// the following two statements are true\nconsole.log(child.instance.name === 'b1')\nconsole.log(child.sibling.instance === children[1])\n```\n\n또한 노드에 대한 작업을 수행하는 도우미 함수를 구현합니다. 여기서는 component의 이름을 기록합니다. 그러나 그 외에도 구성 요소의 하위 항목을 검색하고 함께 연결합니다.\n\n```javascript\nfunction doWork(node) {\n  console.log(node.instance.name)\n  const children = node.instance.render() // children 배열\n  return link(node, children) // children 배열을 선형적으로 부모 노드에 연결 후 첫번째 자식 반환\n}\n```\n\n우리는 메인 탐색 알고리즘을 실행할 준비가 되었습니다. 부모를 처음으로 깊이 우선 구현입니다.\n\n깊이 우선 구현이란 먼저 아래 방향(깊이 우선)으로 child 를 활성화 노드를 시켜주면서 doWork() 로 계속 child 를 링크드 리스트로 연결한 후에 child 가 없으면 그때 sibling 을 활성화 노드를 시켜주고 다시 doWork()로 계속 child 를 링크드 리스트로 연결 더이상의 sibling 이 없다면 부모로 올라가 부모의 sibling 을 찾는다.\n\n```javascript\nfunction walk(o) {\n  let root = o\n  let current = o\n\n  while (true) {\n    // perform work for a node, retrieve & link the children\n    // node에 대한 작업 수행, children을 탐색 및 연결한다.\n    // current의 render 작업 후 current의 children을 선형적으로 current에 연결\n    let child = doWork(current) // current의 첫번째 자식을 반환\n\n    // if there's a child, set it as the current active node\n    // 만약 child 가 있으면 그것을 현재 활성 node로 설정한다.\n    if (child) {\n      current = child\n      continue // 다시 while 수행\n    }\n\n    // if we've returned to the top, exit the function\n    // 만약 여기서 child가 없고 현재값이 top이면 함수를 종료한다.\n    if (current === root) {\n      return\n    }\n\n    // keep going up until we find the sibling\n    // sibling을 찾을때까지 수행한다.\n    while (!current.sibling) {\n      // 형제가 없다면\n      // if we've returned to the top, exit the function\n      // 만약 return이 top이면 종료한다.\n      if (!current.return || current.return === root) {\n        return\n      }\n\n      // set the parent as the current active node\n      // 부모를 현재 활성 노드로 셋팅한다.\n      current = current.return\n    }\n\n    // if found, set the sibling as the current active node\n    // sibling을 발견하면 sibling을 현재 활성 노드로 셋팅한다.\n    current = current.sibling\n  }\n}\n```\n\n이 구현이 이해하기가 특히 어렵지는 않지만, 그것을 구현하기 위해서는 약간의 노력이 필요할 수 있습니다. 여기서 확인해보자. [https://stackblitz.com/edit/js-tle1wr](https://stackblitz.com/edit/js-tle1wr)\n\n아이디어는 현재 노드에 대한 참조를 유지하고 트리의 내림차순으로 분기 끝에 도달 할 때까지 다시 할당한다는 것입니다. 그런 다음 리턴 포인터를 사용하여 공통 부모로 리턴합니다.\n\n만약 이 실행을 콜스택으로 체크한다면 다음과 같을 것입니다.\n\n![예제1](./example01.gif)\n\n보시다시피 스택은 트리를 탐색하면서 증가하지 않습니다. 그러나 디버거를 `doWork` 함수에 넣고 노드 이름을 기록하면 다음과 같이 표시됩니다.\n\n![예제2](./example02.gif)\n\n**브라우저의 콜 스택과 같습니다.** 따라서이 알고리즘을 사용하면 브라우저의 호출 스택 구현을 자체 구현으로 효과적으로 대체 할 수 있습니다. 이것이 앤드류가 여기서 묘사 한 것입니다 :\n\n> Fiber 는 React 구성 요소에 특화된 스택의 재 구현입니다. 단일 fiber 를 가상 스택 프레임으로 생각할 수 있습니다.\n\n이제 최상위 프레임 역할을하는 노드에 대한 참조를 유지함으로써 스택을 제어하기 때문에\n\n```javascript\nfunction walk(o) {\n    let root = o;\n    let current = o;\n\n    while (true) {\n            ...\n\n            current = child;\n            ...\n\n            current = current.return;\n            ...\n\n            current = current.sibling;\n    }\n}\n```\n\n우리는 어떤 시간에도 탐색을 멈췄다가 다시 재개 할 수 있습니다. 이것이 바로 새로운 `requestIdleCallback` API 를 사용하기 위해 달성하고 싶은 조건입니다.\n\n### Work loop in React\n\n실제 리액트 안에서의 실행 코드이다. [여기 코드](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1118)\n\n```javascript\nfunction workLoop(isYieldy) {\n  if (!isYieldy) {\n    // Flush work without yielding\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork)\n    }\n  } else {\n    // Flush asynchronous work until the deadline runs out of time.\n    while (nextUnitOfWork !== null && !shouldYield()) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork)\n    }\n  }\n}\n```\n\n보시다시피, 위의 알고리즘과 잘 일치합니다. 상단 프레임으로 작동하는 `nextUnitOfWork` 변수에 현재 fiber 노드에 대한 참조를 유지합니다.\n\n이 알고리즘은 컴포넌트 트리를 **동기적**으로 순회하고 트리 (`nextUnitOfWork`)안에 각 fiber 노드에 대한 작업을 수행 할 수 있습니다. 이것은 대게 UI 이벤트 (클릭, 입력 등)로 인한 소위 대화 형 업데이트의 경우가 일반적입니다.\n\n또는 fiber 노드 작업을 수행 한 후 남은 시간이 있는지 여부를 **비동기식**으로 확인하여 구성 요소 트리를 탐색 할 수 있습니다. 함수 `shouldYield` 는 [`deadlineDidExpire`](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1806) 와 React 가 fiber 노드에 대해 작업을 수행함에 따라 지속적으로 업데이트되는 [`deadline`](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1809) 변수를 기반으로 결과를 반환합니다.\n\n다음 시리즈는 `performUnitOfWork` 함수에 대한 심도있는 설명 글입니다.\n","excerpt":"이글을 번역 및 분석 한 글입니다. 잘못된 번역 및 생략된 번역이 있을 수 있습니다. The how and why on React’s usage of linked list in Fiber to walk the component’s tree Fiber…","fields":{"slug":"/react-fiber01/"},"frontmatter":{"date":"Jul 18, 2019","title":"React Fiber part1","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Prototype in JavaScript: it’s quirky, but here’s how it works\n\n번역 : [https://www.freecodecamp.org/news/prototype-in-js-busted-5547ec68872/](https://www.freecodecamp.org/news/prototype-in-js-busted-5547ec68872/)\n\n다음 네 줄은 대부분의 JavaScript 개발자를 혼란스럽게합니다.\n\n```\nObject instanceof Function//true\n```\n\n```\nObject instanceof Object//true\n```\n\n```\nFunction instanceof Object//true\n```\n\n```\nFunction instanceof Function//true\n```\n\n자바 스크립트의 Prototype 은 가장 마음이 떨리는 개념 중 하나이지만이를 피할 수는 없습니다. 아무리 무시해도 JavaScript 가 실행되는 동안 prototype 퍼즐이 발생합니다.\n\n그럼 한번 직면해보자.\n\n기본 사항부터 JavaScript 에는 다음과 같은 데이터 유형이 있습니다.\n\n1. undefined\n2. null\n3. number\n4. string\n5. boolean\n6. object\n\n처음 5 가지는 기본 데이터 유형입니다. 이들은 boolean 과 같은 유형의 값을 저장하며 true 또는 false 가 될 수 있습니다.\n\n마지막 \"객체\"는 키 - 값 쌍의 집합으로 설명 할 수있는 참조 유형입니다 (그러나 훨씬 더 많습니다).\n\n자바 스크립트에서 새로운 객체들은 `toString ()` 및 `valueOf ()`와 같은 일반적인 메소드를 제공하는 **Object constructor function** (또는 객체 리터럴`{}`)을 사용하여 만들어집니다.\n\nJavaScript 의 함수는 **\"called\" ** 을 할 수있는 특별한 객체입니다. 우리는 그것들을 만들고 **Function constructor function** (또는 함수 리터럴)을 사용합니다. 이 ** 생성자 **가 함수뿐만 아니라 객체이기 때문에 닭이 먼저냐 달걀이 먼저냐 수수께끼가 같은 모든 사람들을 혼란스럽게하는 것과 같은 방식으로 항상 나를 혼란스럽게합니다.\n\n프로토 타입으로 시작하기 전에 JavaScript 에서 두 가지 프로토 타입이 있음을 분명히하고 싶습니다.\n\n1. **prototype :** JavaScript 로 작성한 모든 기능의 속성으로 지정된 특수 객체입니다. 여기서는 분명히 설명 하겠지만, JavaScript 가 제공하는 내부 함수 (및`bind`에 의해 반환 된 함수)에는 필수 항목이 아닌 모든 함수에 대해 이미 존재합니다. 이`prototype`은 (`new` 키워드를 사용하여) 그 함수에서 새로 생성 된 객체의`[[Prototype]]`(아래 참조)이 가리키는 것과 동일한 객체입니다.\n2. **[[Prototype]] :** 이것은 객체에서 읽혀지는 일부 속성을 사용할 수 없는 경우 실행중인 컨텍스트가 액세스하는 모든 객체의 숨겨진 속성입니다. 이 속성은 단순히 객체가 만들어진 함수의 `프로토 타입` 에 대한 참조입니다. 스크립트에는 **getter-setter** (다른 날 주제)라는 **proto**를 사용하여 액세스 할 수 있습니다.이 프로토 타입에 액세스하는 다른 새로운 방법이 있지만 간단히하기 위해 `[[Prototype]]` `__proto__`을 사용합니다.\n\n```\nvar obj = {}\nvar obj1 = new Object()\n```\n\n위의 두 문장은 새로운 객체를 만드는 데 사용될 때 equal 문이지만, 이 명령문 중 하나를 실행할 때 많은 일이 발생합니다.\n\n새로운 객체를 만들면 그것은 비어 있습니다. 사실 그것은`Object` 생성자의 인스턴스이기 때문에 비어 있지 않으며 새로 생성 된 객체의 `__proto__`가 가리키는 `Object`의`prototype` 참조를 가져옵니다.\n\n![https://cdn-media-1.freecodecamp.org/images/h04OjQTCA9CyQ5yXzbwg2-HYnz8RbCTUvtc6](https://cdn-media-1.freecodecamp.org/images/h04OjQTCA9CyQ5yXzbwg2-HYnz8RbCTUvtc6)\n\n`Object` 생성자 함수의 `prototype`을 살펴보면 `obj.` 의 `__proto__`와 똑같습니다. 실제로 그들은 같은 객체를 가리키는 두 포인터입니다.\n\n![](https://cdn-media-1.freecodecamp.org/images/2hy0s7jdEw-W66w8dWxo-8Ck2nBIBMWixr9t)\n\n```\nobj.__proto__ === Object.prototype//true\n```\n\n함수의 모든 `프로토 타입 (prototype)` 은 함수 자체에 대한 포인터 인 `생성자 (constructor)` 라는 고유 한 속성을 가지고 있습니다. `Object` 함수 의 경우, `prototype` 은 `Object`를 가리키는 `constructor`을 가지고 있습니다.\n\n```\nObject.prototype.constructor === Object//true\n```\n\n![](https://cdn-media-1.freecodecamp.org/images/rnUjw1hZdqdTpcSW2y3ZX8ptZ3OUcCzuaKbO)\n\n위의 그림에서, 왼쪽은 `Object` 생성자의 확장 된 뷰입니다. 당신은 이 모든 다른 기능들이 무엇인지 궁금 할 것입니다. 함수는 **object** 이므로 다른 객체처럼 속성을 가질 수 있습니다.\n\n자세히 보면, `Object` _(왼쪽)_ 자체는 `prototype` 을 가진 다른 생성자로부터`Object`가 만들어 졌음을 의미하는 `__proto__` 를 가지고 있습니다. `Object`는 함수 객체이기 때문에 , 그것은`Function` 생성자를 사용하여 만들어 졌음에 틀림 없습니다.\n\n![](https://cdn-media-1.freecodecamp.org/images/we607uLIJLuCdG4P0metYMcjf9PpNHvh22tm)\n\n`Object`의 `__proto__` 는 `Function` 의 `prototype` 과 같습니다. 두 함수의 동등성을 검사하면 같은 객체가됩니다.\n\n```\nObject.__proto__ === Function.prototype//true\n```\n\n자세히 살펴보면 `Function` 자체가 `__proto__` 을 가지고있는 것을 보게 될 것입니다. 즉, `Function` 생성자 함수는 `prototype` 을 가진 어떤 생성자 함수에서 만들어 졌음을 의미합니다. `Function` 자체는 **function** 이기 때문에 `Function` 생성자, 즉 그 자체로 만들어 져야합니다. 나는 그것이 이상하게 들린다는 것을 알고있다. 그러나 당신이 그것을 점검 할 때, 그것은 사실 인 것으로 판명됩니다.\n\n다시 정리하면, Function 생성자 함수에는 `__proto__` 프로퍼티가 있다. 이것이 의미하는건 `prototype` 속성을 지닌 어떤 생성자로 만들었다는걸 뜻하는 것이다.\n\n여기서 Function 은 사실 그 자체로 function(함수)이기 때문에 Function 생성자 함수는 Function 생성자를 이용해서 만들었을 것이다. 쉽게 이해하기 어렵지만 생각 해보면 우리가 함수를 만들면 그 함수는 Function 생성자를 이용해서 만들었을 것이다. 그렇다면 `Function.__proto__` 는 `Function.prototype` 과 같을 것이다. 실제로도 같다.\n\n아이러니 하지만 Function 생성자는 Function 생성자가 만들었다는 이야기가 된다.\n\n여기서 Function.prototype 은 빌트인 function 객체이다.\n\n```javascript\n// 내부적으로 Function 생성자로 person을 만들게 될 것이다.\nfunction person() {}\nperson.__proto__ === Function.prototype\nperson.__proto__.name === Function.prototype.name // (1)\n\nFunction.name === Function.prototype.name // (2)\n```\n\n위 처럼 우리는 함수 person 을 만들면 `__proto__` 로 Function.prototype 과 연결 되어서 Function.prototype 에 있는 속성과 메서드를 사용할 수 있게 된다.\n여기서 만약 Function 에 `__proto__` 가 없다면 (2) 번과 같이 Function 에서 바로 Function.prototype 을 사용 할 수 없을 것이다.\n\n![](https://cdn-media-1.freecodecamp.org/images/gHONmm8YNyMAgQYD3MQ88WsYsathI0Nr-cp8)\n\n사실 `Function` 의 `__proto__` 와 `Function` 의 `prototype` 은 사실 동일한 객체를 가리키는 두 개의 포인터입니다.\n\n```\nFunction.prototype === Function.__proto__\\\\true\n```\n\n앞서 언급했듯이 `prototype` 의 `constructor` 은 `prototype` 을 소유 한 함수를 가리켜 야합니다.`Function` 의 `prototype` 의 `constructor` 은 `Function` 자체를 가리 킵니다.\n\n```\nFunction.prototype.constructor === Function\\\\true\n```\n\n![](https://cdn-media-1.freecodecamp.org/images/ftvp4bDag11U4kaWjV3nG7UfkqQKjSQPA4i0)\n\n다시 말하지만, **Function** 의 **prototype** 은 `__proto__` 을 가지고 있습니다. 놀랍지도 않습니다 . `prototype` 은 객체입니다. 객체를 가질 수 있습니다. 그러나 객체의 _프로토 타입_ 을 가리키고 있음을 주목하십시오.\n\n```\nFunction.prototype.__proto__ == Object.prototype\\\\true\n```\n\n그래서 우리는 여기에 마스터 맵을 가질 수 있습니다 :\n\n![](https://cdn-media-1.freecodecamp.org/images/F86Ee6hanmaQuvSRBZ8S1rG6Cq1R-LVhA4Kl)\n\n```\ninstanceof Operator a instanceof b\n```\n\n`instanceof` 연산자는 `a` 에서 `constructor` ( _of_ chained `__proto__`) 중 하나가 가리키는 객체 `b` 를 찾습니다. 다시 읽어봅시다! 그러한 참조를 찾으면 `true`를 리턴하고 그렇지 않으면 `false`.\n\n이제 우리는 네 개의 `instanceof` 문장으로 돌아 간다. 나는 다음을 위해`instanceof` 가 `true` 를 리턴하도록 대응하는 문장을 작성했습니다 :\n\n```\nObject instanceof Function Object.__proto__.constructor === Function\n```\n\n```\nObject instanceof Object Object.__proto__.__proto__.constructor === Object\n```\n\n```\nFunction instanceof Function Function.__proto__.constructor === Function\n```\n\n```\nFunction instanceof Object Function.__proto__.__proto__.constructor === Object\n```\n\n휴! 스파게티도 덜 엉키지 만, 나는 상황이 더 명확 해지기를 바랍니다.\n\n여기에 이전에 지적하지 않은 것이 있는데,`Object` 의 `prototype` 은 `__proto__` 을 가지고 있지 않습니다.\n\n사실 그것은 `__proto__`을 가지고 있지만 `null`과 같습니다. 체인은 어딘가에서 끝나야하고 여기서 끝납니다.\n\n```\nObject.prototype.__proto__\\\\null\n```\n\n우리의 `Object` , `Function` , `Object.prototype` 과 `Function.prototype`도 `Object.assign` , `Object.prototype.hasOwnProperty` 와 `Function.prototype.call`. 이들은 프로토 타입이없고 `Function` 의 인스턴스이고`Function.prototype` 에 대한 포인터 인 `__proto__` 를 가진 내부 함수입니다.\n\n![](https://cdn-media-1.freecodecamp.org/images/fs6Q6b4ewNiWTuSehUQAY1Cf2OJTV0WyzHAB)\n\n```\nObject.create.__proto__ === Function.prototype\\\\true\n```\n\n`Array` 와 `Date` 와 같은 다른 생성자 함수를 탐색하거나 객체를 가져 와서`prototype` 과 `__proto__`를 찾을 수 있습니다. 모든 것이 어떻게 연결되어 있는지 확인할 수있을 것입니다.\n\n#### Extra queries:\n\n잠시 동안 나를 괴롭혔던 질문이 하나 더 있습니다. 왜 '객체'의 프로토 타입이 **객체**이고 '함수'의 프로토 타입이 **함수 객체** 입니까?\n\n[**Here**](https://stackoverflow.com/a/32929083/1934798) 같은 생각을하면 좋은 설명입니다.\n\n지금까지는 수수께끼일지도 모르는 또 다른 질문은 : 원시 데이터 타입이`toString ()`, `substr ()` 및 `toFixed ()` 와 같은 함수를 얻는 방법은 무엇입니까? 이것은 잘 설명되어 있습니다. (https://javascript.info/native-prototypes#primitives).\n\n`prototype` 을 사용하여 자바 스크립트에서 커스텀 객체로 상속 작업을 할 수 있습니다. 그러나 그것은 다른 날을위한 주제입니다.\n\n읽어 주셔서 감사합니다!\n","excerpt":"Prototype in JavaScript: it’s quirky, but here’s how it works 번역 : https://www.freecodecamp.org/news/prototype-in-js-busted-5547ec68872/ 다음…","fields":{"slug":"/javascript-prototype.md/"},"frontmatter":{"date":"Jul 15, 2019","title":"Prototype in JavaScript","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이 글은 [https://www.impressivewebs.com/javascript-try-catch/](https://www.impressivewebs.com/javascript-try-catch/) 의 번역 본입니다.\n\n내가 javascript app 들을 개발할때 꽤 도움이 되는 한가지 기술은 Javascript `try-catch` 문이라고 믿는다. ( 또는 `try-catch-finally` 라고도 불리운다. ) 나는 지난 년도에 try-catch 와 친해지게 되었는데, 비록 많이 쓴적은 없다. 그러다. 여러 환경에서 유용하다는 점을 발견했다.\n\n이 기사는 `try-catch` 를 설명하고 어떻게 사용하는지와 어떻게 web application 을 만들때 유저를 덜 화나게 만들 수 있는지를 알아볼 것이다.\n\n## Basic Syntax and Definition\n\n`try-catch` 문은 ECMA-262 3 판에서 예외 처리하는 방법으로 소개 되어졌다. 이 문법은 Java 프로그래밍 언어와 흡사하다.\n여기 기본적으로 어떻게 사용되어지는 지 볼수 있다.\n\n```js\ntry {\n  // code that might cause an error goes here\n} catch (error) {\n  // error message or other response goes here\n}\n```\n\n`try` 위치에는 error 를 던질 법한 어떤 코드가 와도 관계없다. 다른말로 하면, 모든 중요한 코드는 try 섹션 안에 위치 시켜야 한다.\n\n`catch` 위치 또한 코드를 위치 시킬수 있지만, 이 위치는 application 의 동작엔 치명적이지 않는다. 그래서 만약 `try-catch`문이 함께 제거 된다면 `try` 파트안에 코드는 그대로 일 것이다. 하지만 `catch`문 안에 있는 코드는 제거가 될 것이다.\n\n만약 `try` 파트에서 에러가 발생이 된다면 `try` 영역에서 빠져나와 `catch` 영역으로 넘어가 실행된다. `catch` 영역에서는 error 정보가 담긴 Javascript 객체를 받게 된다. `error` 식별자는 필요하다. 하지만 어떤 커스텀한 네임을 줄 순 있다. 예를 들면 다음 예제는 위 예제와 같다.\n\n```js\ntry {\n  // code that might cause an error goes here\n} catch (watermelon) {\n  // error message or other response goes here\n}\n```\n\n위 예제에서 \"error\" 식별자는 \"watermelon\"으로 바뀌었다. 하지만 이건 같은 결과를 나타낸다. 명확하게 \"watermelon\"은 비생산적이다. 그러나 이것은 간단하게 이름이 유연하다는것을 증명하는 셈이다. 꼭 필요한건 아니다.\n\n## Outputting the Exact Error That Occurred\n\n`error` 객체는 `message`라는 프로퍼티를 호출할 수 있다. 이것은 에러 발생의 디테일한 정보를 가리킨다. 그래서 다음과 같은 방법으로 커스텀 에러를 확인할 수 있다.\n\n```js\ntry {\n  doSomething() // this function doesn't exist\n} catch (error) {\n  alert(error.message)\n}\n```\n\n만약 위 코드가 동작할때, 브라우저는 alert 메세지를 “doSomething is not defined” 라고 나타낼것이다.\nerror 객체는 또한 `name` 이란 프로퍼티도 호출할 수있다. 이것은 error 를 좀 더 기술적인 관점에서 설명을 해준다. 하지만 실제로 그리 사용하진 않는다. 이 두개의 프로퍼티들은 크로스 브라우저에서 호환가능한 것들이다. 다른 브라우저들은 커스텀 프로퍼티들을 제공한다. 그 예로 파이어 폭스에서 제공하는 `lineNumber` 이다. 하지만 그장 최고는 `message` 프로퍼티 이다. 그것은 가장 호환성이 좋고 실용적인 것이기 때문입니다.\n\n## The Optional “finally” Clause\n\n`try-catch` 문을 사용하면 `finally` 절을 포함 할 수도 있습니다. `finally` 섹션의 코드는 무슨일이 있어도 실행됩니다. 이것은 `try` 섹션에서 사실이 아니기 때문에 유용합니다. 디버깅을 목적으로 (또는 다른 이유로) 오류가 발생하더라도 특정 코드 섹션을 실행해야 할 수 있습니다. 이러한 코드는 finally 섹션에 배치해야합니다. try 섹션이나 catch 섹션에서 finally 섹션이 실행되지 못하게하는 어떤 것도 없습니다. 각 섹션에 다른 return 문이있는 경우에도 마지막 return 문 (finally 섹션의 문) 만 실제로 \"반환\"됩니다.\n\n다음 예제를 보십시요.\n\n```js\nfunction testReturn() {\n  try {\n    return 'bananas'\n  } catch (error) {\n    return 'oranges'\n  } finally {\n    return 'watermelons'\n  }\n}\n\nalert(testReturn())\n```\n\n경고 메시지는 \"bananas\"(오류가 없으므로)라고 표시해야하지만 실제로는 \"watermelons\"을 출력합니다. 왜냐하면 finally 절은 오류와 상관없이 항상 실행되기 때문입니다. 물론 이것은 return 문의 특성 때문에 발생합니다. try 섹션은 여전히 ​​ 실행되지만 try 절의 반환은 finally 절의 반환에 의해 무시됩니다.\n\n다음은 약간 수정 된 동일한 코드입니다.\n\n```js\nfunction testReturn() {\n  try {\n    alert('bananas')\n  } catch (error) {\n    return 'oranges'\n  } finally {\n    return 'watermelons'\n  }\n}\n\nalert(testReturn())\n```\n\n이제 출력은 두 개의 경고문이됩니다. 첫 번째는 \"bananas\"이고 두 번째는 \"watermelons\"입니다. 재정의 된 return 문으로 인해 발생하는 문제를 방지하려면 try 및 finally 절에 return 문이 모두 포함되어 있지 않은지 확인하십시오. 그렇지 않으면 finally 반환 만 실제로 \"반환\"됩니다.\n\n## When Should You Use try-catch?\n\n`try-catch` 문은 유저로 부터 에러를 감추길 원한다거나 사용자의 이익을 위해서 custom error 들을 생성하길 원한다면 언제나 사용하는게 좋습니다. 만약 아직도 언제 `try-catch`문이 실행되어야 하는지 모르겠다면, 브라우저의 일반적인 에러 핸들링 메카니즘은 disable 될것입니다.\n\n대형 응용 프로그램을 빌드 할 때 이점을 볼 수 있습니다.\n모든 응용 프로그램의 흐름에서 가능한 모든 상황을 디버깅하는 것은 종종 시간이 많이 걸리고 많은 에러 가능성이 우연히 간과 될 수 있습니다. 물론 적절한 버그 테스트를 통해 어떤 영역도 간과해서는 안됩니다. 그러나 try-catch 문은 개발 중에 예상하지 못한 비정상적인 상황에서 실패 할 수있는 코드 영역에서 멋진 대체 기능으로 작동합니다.\n\ntry-catch 문이 제공하는 또 다른 이점은 과도하게 이해할 수 없는 사용자가 지나치게 기술적인 오류 메시지를 숨기는 것입니다.\n\ntry-catch 를 사용하는 가장 좋은시기는 어떤 이유에서 건 제어가 불가능한 오류가 의심되는 코드 부분에 있습니다.\n\n## When Should try-catch be Avoided?\n\n당신이 만약 error 가 발생될것을 알고 있다면 `try-catch`를 사용하지 말아야 한다. 왜냐하면 이런 경우에 이 문제를 아마 감추지 않고 디버그 하길 원할 것이기 때문이다. `try-catch` 문은 오류가 발생할 것으로 의심되는 코드 섹션에서만 실행되어야하며, 압도적 인 수의 상황으로 인해 오류가 발생할 것인지 또는 언제 발생될 것인지 완전히 확인할 수 없다. 후자의 경우`try-catch` 사용이 적절해 보일 것입니다.\n\n## Are There Performance Issues with try-catch?\n\n간단히 말하면 답은 yes 입니다. [MSDN 의 이 기사](<https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/ms973839(v=msdn.10)>)에서는 캐치 부분이 실제로 실행될 때만 성능에 영향을 미쳤다고 말합니다.\n\n[이 기사](https://stackoverflow.com/questions/1350264/try-catch-performance)에 대한이 반응은 그렇지 않다는 것을 암시합니다.\n\n[An article on the Opera Developer Community](https://dev.opera.com/articles/efficient-javascript/?page=2) 기사에서는 `try-catch-finally`는 성능에 중요한 함수 안에서는 피하라고 권장합니다.\n\n마지막으로, `try-catch` 구문은 좋지만, 제약들을 받는다. [bit of info on try-catch in relation to performance](https://books.google.co.uk/books?id=ED6ph4WEIoQC&lpg=PP1&dq=javascript+performance&pg=PA23&hl=ko#v=onepage&q&f=false), in Nicholas Zakas’ new book, High Performance JavaScript.\n\n뭐가 정확하다고 확신할순 없지만 가장 적절한 상황안에서 사용한다면 퍼포먼스 hits 는 최소한으로 영향을 미칠 것이다.\n\n전체적으로 try-catch 는 여러 가지 상황에서 유용 할 수 있습니다. 특히 개발자가 제어 할 수없는 상황을 만들 수있는 대규모 응용 프로그램을 만들 때 유용합니다.\n\n## 느낀점\n\n에러가 어떻게 터지는지는 알지만 언제 터질지 또는 에러가 진짜 발생될지 모른다면 try-catch 문을 사용해서 (확인된 예외) 예외를 처리하자. ( 사용자의 잘못된 조작으로 인한 예외 - 잘못된 파일을 선택 했을 경우, 서버 api 의 예측 못한 에러로 인한 예외 )\n반면, 에러가 언제 터질지 ( 특히 타입 체크 - 잘못된 타입이 들어왔을 경우 ) 알수 있다면 try-catch 문을 사용하지 말자.\n특히 catch 문은 특별히 간결하게 사용하자.\ntry 문을 하나의 트랜젝션으로 보고 일관성을 지킬 수 있는 작업 단위로 바라보자.\n","excerpt":"이 글은 https://www.impressivewebs.com/javascript-try-catch/ 의 번역 본입니다. 내가 javascript app 들을 개발할때 꽤 도움이 되는 한가지 기술은 Javascript  문이라고 믿는다. ( 또는 …","fields":{"slug":"/try-catch.md/"},"frontmatter":{"date":"Jun 07, 2019","title":"Using JavaScript’s Try-Catch Statement","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이 글은 아래 링크에 있는 글을 참조 했습니다.\n[참조](https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5)\n\n## Rendering DOM element\n\n우리가 render 할 때 필요한게 뭔지 설명하기 위해 plain JS object 를 하나 만들 것입니다.\n이것을 우리는 element 라고 부를 것입니다. 여기서는 `type` 과 `props`라는 2 개의 프로퍼티가 요구됩니다.\n`type`은 기본 string 또는 function 이 될 수 있고, props 는 비어있을 수 있는 객체가 될것입니다. null 은 오지 않습니다. 여기서 props 는 children 이라는 프로퍼티도 가질 것입니다. children 은 배열로 구성될 것입니다.\n\n예를 들면 아래와 같습니다.\n\n```javascript\nconst element = {\n  type: 'div',\n  props: {\n    id: 'container',\n    children: [\n      { type: 'input', props: { value: 'foo', type: 'text' } },\n      { type: 'a', props: { href: '/bar' } },\n      { type: 'span', props: {} },\n    ],\n  },\n}\n```\n\n위 객체는 아래 dom 을 설명하는 것이 됩니다.\n\n```html\n<div id=\"container\">\n  <input value=\"foo\" type=\"text\">\n  <a href=\"/bar\"></a>\n  <span></span>\n</div>\n```\n\nDOM Element 를 그려봅시다.\n\n다음 단계는 element 와 그 element 의 children 을 dom 에 그리는 일입니다. 여기서 우리는 element 와 dom container 를 받는 `render` 함수 (`ReactDom.render`와 같은 )를 이용할 것입니다. 이 함수는 element 에 정의된 dom sub-tree 를 생성하고 container 에 그것을 추가할 것입니다.\n\n```javascript\nfunction render(element, parentDom) {\n  const { type, props } = element\n  const dom = document.createElement(type)\n  const childElement = props.children || []\n\n  childElement.forEach(childElement => render(childElement, dom))\n  parentDom.appendChild(dom)\n}\n\nrender(element, document.getElementById('root'))\n```\n\n`render`함수는 root Dom 에 실제 element 를 실제 Dom 객체로 바꿔서 append 시킨다.\n위에서 빠뜨린 부분이 있다면 프로퍼티들과 이벤트 리스너이다. `props` 프로퍼티 이름들을 `Object.keys` 를 이용해서 순회하고 알맞게 셋팅해보자.\n\n```javascript\nfunction render(element, parentDom) {\n  const { type, props } = element\n  const dom = document.createElement(type)\n\n  // props setting start\n  const isListener = name => name.startWith('on')\n  Object.keys(props)\n    .filter(isListener)\n    .forEach(name => {\n      const eventType = name.toLowerCase().substring(2)\n      dom.addEventListener(eventType, props[name])\n    })\n\n  const isAttribute = name => !isListener(name) && name != 'children'\n  Object.keys(props)\n    .filter(isAttribute)\n    .forEach(name => {\n      dom[name] = props[name]\n    })\n\n  // end\n\n  const childElement = props.children || []\n  childElement.forEach(childElement => render(childElement, dom))\n  parentDom.appendChild(dom)\n}\n```\n\n다음은 DOM 의 Text Nodes 를 render 하는 방법이다.\n여기서 Text Node 를 표현하는 방법은 children 배열에 element 객체가 아닌 plain text 가 들어간 경우가 될 것입니다.\n이전 까지는 children 에 element 객체를 품은 배열이였습니다.\n\n```javascript\nconst reactElement = {\n  type: 'span',\n  props: {\n    children: ['Foo'],\n  },\n}\n```\n\n하지만 여기서 children 배열에 type 과 props 가 들어간 객체만 온다는 룰을 가지고 있으면 우린 더 적은 if 문을 만들 수 있을 것이다. 해서 text 타입은 \"TEXT ELEMENT\" 라고 props 에는 nodeValue 라는 프로퍼티를 갖게 만들어 봅시다.\n\n```javascript\nconst textElement = {\n  type: 'span',\n  props: {\n    children: [\n      {\n        type: 'TEXT_ELEMENT',\n        props: { nodeValue: 'Foo' },\n      },\n    ],\n  },\n}\n```\n\n여기서 우리가 정의한 text element 대로 render 하는 함수를 다시 수정해보자. 여기서 달라지는 점이 있다면 일반 dom type 일 경우에는 `createElement` 의 dom api 를 썼을텐데 text 는 `createTextNode` 라는 dom api 를 사용하자.\n\n```javascript\nfunction render(element, parentDom) {\n  const { type, props } = element\n\n  // Create DOM element\n  const isTextElement = type === 'TEXT ELEMENT'\n  // 타입에 따라 다른 api를 사용한다.\n  const dom = isTextElement\n    ? document.createTextNode('')\n    : document.createElement(type)\n\n  // Add event listeners\n  const isListener = name => name.startsWith('on')\n  Object.keys(props)\n    .filter(isListener)\n    .forEach(name => {\n      const eventType = name.toLowerCase().substring(2)\n      dom.addEventListener(eventType, props[name])\n    })\n\n  // Set properties\n  // 여기서 nodeValue도 셋팅한다.\n  const isAttribute = name => !isListener(name) && name !== 'children'\n  Object.keys(props)\n    .filter(isAttribute)\n    .forEach(name => {\n      dom[name] = props[name]\n    })\n\n  // Render children\n  const childElements = props.children || []\n  childElements.forEach(childElement => render(childElement, dom))\n\n  // Append to parent\n  parentDom.appendChild(dom)\n}\n```\n\n## Element creation and JSX\n\n```javascript\nconst element = {\n  type: 'div',\n  props: {\n    id: 'container',\n    children: [\n      { type: 'input', props: { value: 'foo', type: 'text' } },\n      {\n        type: 'a',\n        props: {\n          href: '/bar',\n          children: [{ type: 'TEXT ELEMENT', props: { nodeValue: 'bar' } }],\n        },\n      },\n      {\n        type: 'span',\n        props: {\n          onClick: e => alert('Hi'),\n          children: [\n            { type: 'TEXT ELEMENT', props: { nodeValue: 'click me' } },\n          ],\n        },\n      },\n    ],\n  },\n}\n```\n\n위 Element 를 좀 더 쉽게 만들기 위해 JSX 를 사용하면 쉽게 읽히면서도 쉽게 표현이 된다. 여기서 JSX 는 우리가 DOM 에 무엇을 표현하고 싶은지를 설명해주는 한 방법이다.\n\n바벨을 사용한다면 JSX 표현은 다음과 같이 변경된다.\n\n```javascript\nconst element = (\n  <div id=\"container\">\n    <input value=\"foo\" type=\"text\" />\n    <a href=\"/bar\">bar</a>\n    <span onClick={e => alert('Hi')}>click me</span>\n  </div>\n)\n```\n\n[try it on babel REPL](https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=react&targets=&browsers=&builtIns=false&debug=false&code=%2F**%20%40jsx%20createElement%20*%2F%0A%0Aconst%20element%20%3D%20%28%0A%20%20%3Cdiv%20id%3D%22container%22%3E%0A%20%20%20%20%3Cinput%20value%3D%22foo%22%20type%3D%22text%22%20%2F%3E%0A%20%20%20%20%3Ca%20href%3D%22%2Fbar%22%3Ebar%3C%2Fa%3E%0A%20%20%20%20%3Cspan%20onClick%3D%7Be%20%3D%3E%20alert%28%22Hi%22%29%7D%3Eclick%20me%3C%2Fspan%3E%0A%20%20%3C%2Fdiv%3E%0A%29%3B)\n\n```javascript\nconst element = createElement(\n  'div',\n  { id: 'container' },\n  createElement('input', { value: 'foo', type: 'text' }),\n  createElement('a', { href: '/bar' }, 'bar'),\n  createElement('span', { onClick: e => alert('Hi') }, 'click me')\n)\n```\n\n그래서 우린 `createElement` 함수를 만들어 줄 것이다. 첫번째 인자는 `type` 인자이고 두번째 인자는 `props` 이다. 그리고 나머지 인자들은 `children` 이다.\n`createElement` 함수는 `props` 객체를 만들어주고 두번째 인자의 값들을 전부 할당해 주어야 한다. 또, `children` 프로퍼티는 두번째 이후로 오는 인자들을(...args) 배열로 만들어서 `props` 의 `children` 프로퍼티에 셋팅해준다. 그리고 type 과 props 를 반환하면 된다.\n\n```javascript\nfunction createElement(type, props, ...args) {\n  const props = Object.assign({}, config)\n  const hasChildren = args.length > 0\n  props.children = hasChildren ? [].concat(...args) : []\n  return { type, props }\n}\n```\n\n위 createElement 함수에서 text node 에 해당하는게 하나 빠져있다. 위 함수대로 작동을 한다면 아래 span 의 text node 의 경우에 그냥 string 값이 들어갈 것이다.\n\n아까 우린 위에서 text node 도 `{ type: TEXT_ELEMENT, props: {nodeValue: 'test'}}` 로 만들어 주기로 했었다. 해서 createElement 를 수정해야 한다.\n\n```javascript\nconst spanElement = createElement(\n  'span',\n  { onClick: e => alert('Hi') },\n  'click me'\n)\n\nspanElement = {\n  type: 'span',\n  props: {\n    onClick: e => alert('Hi'),\n    children: ['click me'], // [{type: TEXT_ELEMTN, props: {nodeValue: 'click me'}}]\n  },\n}\n```\n\n수정해 보자.\n\n```javascript\nconst TEXT_ELEMENT = 'TEXT ELEMENT'\n\nfunction createElement(type, config, ...args) {\n  const props = Object.assign({}, config)\n  const hasChildren = args.length > 0\n  const rawChildren = hasChildren ? [].concat(...args) : []\n  // children 배열을 돌면서 textElement는 TEXT ELEMENT 타입으로 변환해서 넣어준다.\n  props.children = rawChildren\n    .filter(c => c != null && c !== false)\n    .map(c => (c instanceof Object ? c : createTextElement(c)))\n  return { type, props }\n}\n// text element 생성\nfunction createTextElement(value) {\n  return createElement(TEXT_ELEMENT, { nodeValue: value })\n}\n```\n\n## Instances, reconciliation and virtual DOM\n\n지금까지는 JSX 설명을 기반으로 dom 요소를 만드는 메커니즘을 구현했습니다. 이번에는 DOM 을 어떻게 업데이트 시키는지에 대해서 포커스를 둘 것입니다.\n우선 setState 를 설명하기 전까지 dom update 를 할수 있는 방법은 달라진 element 를 가지고 render 함수를 반복해서 시키는 방법입니다.\n\n```javascript\nconst rootDom = document.getElementById('root')\n\nfunction tick() {\n  const time = new Date().toLocaleTimeString()\n  const clockElement = <h1>{time}</h1>\n  render(clockElement, rootDom)\n}\n\ntick()\nsetInterval(tick, 1000)\n```\n\n[codepen](https://codepen.io/pomber/pen/KmXeXr?editors=0010)\n\n위에서 계속 바왔던 `render` 함수는 container 에 element 를 넘기면 element 를 dom 으로 만들어서 container 에 append 시키는 함수이다. element 의 children 도 `render` 재귀로 돌면서 실행하게 된다.\n\n기존 `render` 는 매 `tick`할 시에 같은 div 를 업데이트하는 대신에 새로운 것을 추가하는 방식이라서 update 에 적합하지가 않다.\n그래서 처음으로 바꿔야 할 부분은 각 업데이트에 대해 dom 을 replace 하는 작업이고, render 함수 마지막 부분에 우리는 parent 에 어떤 child 가 있다면 그것을 새롭게 element 로 만들어진 dom 으로 교체 되도록 한다.\n\n```javascript\nfunction render(element, parentDom) {\n  // ...\n  // Create dom from element\n  // ...\n\n  // Append or replace dom\n  // lastChild는 노드의 마지막 자식을 반환합니다.\n  if (!parentDom.lastChild) {\n    parentDom.appendChild(dom)\n  } else {\n    // replaceChild(newChild, oldChild);\n    parentDom.replaceChild(dom, parentDom.lastChild)\n  }\n}\n```\n\n[codepen](https://codepen.io/pomber/pen/eWGQRz?editors=0010)\n\n첫번째 render 시에 h1 에 TEXT_ELEMENT 를 먼저 append 하고 h1 을 root 컨테이너 dom 에 append 합니다.\n두번째 부터는 render 시에는 똑같이 h1 에 TEXT_ELEMENT 를 먼저 append 하고 만들어진 h1 을 root 컨테이너에 append 하기 전에 root 컨테이너에 lastchild 가 있다면 parentDom.lastchild 를 dom 으로 replace 한다.\n\n**여기서 문제점은 update 상황에서 render 시에 모든 children 을 재 생성해서 마지막 root container dom 에만 replace 한다는 점이다. render 에서 모든 element 타입에 대해서 새로 만들기 때문에 자식들의 부모의 lastChild 는 null 이 되어 appendChild 가 실행될 것이다. 그 상황에서 기존에 그려놨던 root 의 경우에는 이미 한번 그려져 있는게 있기 때문에 replace 로직으로 처리가 된다.**\n\n이런 작은 상황에서는 잘 동작하지만 좀 더 복잡한 케이스에서는 모든 child node 들을 재 생성 하는 퍼포먼스 비용이 만족스럽지 않습니다.\n그래서 우린 현재 **새로 생성한 elements tree 와 이전 render 를 호출했을 때 사용되었던 element tree 를 비교**해서 달라진 곳만 update 시켜야 한다.\n\n### Virtual DOM and Reconciliation\n\nReact 에서는 위에서 말한 달라진 곳을 비교하는 이 \"diffing\" 프로세싱을 **reconciliation** 이라 부릅니다. 우리도 이와같이 하기 위해서 **이전 render 에 사용 되었던 element tree 구조를 보관할 필요가 있고 이것을 새로운 element tree 구조와 비교할 것입니다. 다른말로 하면 우리의 virtual DOM 버젼을 계속 유지해 나갈 것이다.**\n\nvirtual DOM 안에 있는 \"노드들\"은 무엇을 해야 할까요? 한가지 옵션으로 단지 Elements 로 사용을 하는 것입니다. 이 Elements 들은 `props.children` 프로퍼티를 이미 가지고 있다. 이 프로퍼티는 tree 구조 처럼 element 들 탐색을 가능하게 합니다. 하지만 여기서 2 가지 문제점이 있는데, 하나는 reconciliation 을 좀 더 쉽게 진행하기 위해서 각 노드의 virtual DOM 에 실제 dom 을 참조하고 있어야 한다는 점이고, element 들을 immutable 하게 유지해야 한다. 두번째 문제는 우리는 나중에 본인만의 state 를 갖고 있는 Components 를 지원할 것이고 element 들이 그것을 다루지 못하게 해야한다.\n\n### Instances\n\n그래서 우리는 새로운 용어인 Instances 를 소개할 것입니다. **instance 는 DOM 에 렌더링 된 element 를 나타냅니다.** 또한 element, dom, 그리고 childInstances 의 프로퍼티들을 지닌 plain 객체 입니다. childInstances 는 children element 의 instancese 들을 지닌 배열입니다.\n\n각 DOM 노드는 매칭된 instance 를 가지고 있을 것입니다. reconciliation 알고리즘의 한가지 목표는 가능한한 많이 instance 를 creating 또는 removing 을 피하는 것입니다.\n여기서 instance 를 creating 그리고 removing 한다는 것은 DOM tree 를 수정해야 한다는 의미 일 것입니다.\ninstance 를 재사용할수록 DOM 트리를 수정하는 횟수가 줄어 듭니다.\n\n### Refactoring\n\n여기서 우리 render 함수를 reconciliation 알고리즘을 적용해보고, element 를 주어지면 instance 를 생성하는 instantiate 함수를 추가해보자.\n\n```javascript\nlet rootInstance = null\n\nfunction render(element, container) {\n  const prevInstance = rootInstance\n  const nextInstance = reconcile(container, prevInstance, element)\n  rootInstance = nextInstance\n}\n\n// reconcile ( 조정하다, 조화시키다, 일치시키다. )\nfunction reconcile(parentDom, instance, element) {\n  // 인자값 : 부모 real DOM, 이전 instance , 새로운 element\n  // 이전에 그려진 instance가 없다면 append\n  // 그려진 instance가 있다면 replace 작업을 한다.\n  if (instance == null) {\n    // 초기 render 시\n    const newInstance = instantiate(element)\n    parentDom.appendChild(newInstance.dom)\n    return newInstance\n  } else {\n    // update render 시\n    const newInstance = instantiate(element)\n    parentDom.replaceChild(newInstance.dom, instance.dom)\n    return newInstance\n  }\n}\n\n// element를 받아서 트리구조를 돌면서 instance 구조 {dom, element, childInstances}를 만든다.\nfunction instantiate(element) {\n  const { type, props } = element\n\n  // Create DOM element\n  const isTextElement = type === 'TEXT ELEMENT'\n  const dom = isTextElement\n    ? document.createTextNode('')\n    : document.createElement(type)\n\n  // Add event listeners\n  const isListener = name => name.startsWith('on')\n  Object.keys(props)\n    .filter(isListener)\n    .forEach(name => {\n      const eventType = name.toLowerCase().substring(2)\n      dom.addEventListener(eventType, props[name])\n    })\n\n  // Set properties\n  const isAttribute = name => !isListener(name) && name != 'children'\n  Object.keys(props)\n    .filter(isAttribute)\n    .forEach(name => {\n      dom[name] = props[name]\n    })\n\n  // Instantiate and append children\n  const childElements = props.children || []\n  const childInstances = childElements.map(instantiate)\n  const childDoms = childInstances.map(childInstance => childInstance.dom)\n  childDoms.forEach(childDom => dom.appendChild(childDom))\n\n  const instance = { dom, element, childInstances }\n  return instance\n}\n```\n\n이전과 코드는 같지만, 여기서 다른점은 마지막으로 호출한 render 에서 나온 instance 를 저장하고 있다는점이다. 또한 reconciliation 함수를 instantiation 으로 부터 분리 했습니다.\ndom nodes 를 재사용하기 위해서는, dom 프로퍼티들을 update 할 방법이 필요하다. ( className, style, onCLick, etc...) 등등의 업데이트 그래서 dom 프로퍼티를 update 하는 함수를 따로 분리해서 작성해보자.\n\n```javascript\n// element를 받아서 트리구조를 돌면서 instance 구조 {dom, element, childInstances}를 만든다.\nfunction instantiate(element) {\n  const { type, props } = element\n\n  // Create DOM element\n  const isTextElement = type === 'TEXT ELEMENT'\n  const dom = isTextElement\n    ? document.createTextNode('')\n    : document.createElement(type)\n\n  updateDomProperties(dom, [], props)\n\n  // Instantiate and append children\n  const childElements = props.children || []\n  const childInstances = childElements.map(instantiate)\n  const childDoms = childInstances.map(childInstance => childInstance.dom)\n  childDoms.forEach(childDom => dom.appendChild(childDom))\n\n  const instance = { dom, element, childInstances }\n  return instance\n}\n\n// dom을 만들고 나서 dom의 프로퍼티들을 셋팅할때 사용한다.\nfunction updateDomProperties(dom, prevProps, nextProps) {\n  const isEvent = name => name.startsWith('on')\n  const isAttribute = name => !isEvent(name) && name != 'children'\n\n  // Remove event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .forEach(name => {\n      const eventType = name.toLowerCase().substring(2)\n      dom.removeEventListener(eventType, prevProps[name])\n    })\n\n  // Remove attributes\n  Object.keys(prevProps)\n    .filter(isAttribute)\n    .forEach(name => {\n      dom[name] = null\n    })\n\n  // Set attributes\n  Object.keys(nextProps)\n    .filter(isAttribute)\n    .forEach(name => {\n      dom[name] = nextProps[name]\n    })\n\n  // Add event listeners\n  Object.keys(nextProps)\n    .filter(isEvent)\n    .forEach(name => {\n      const eventType = name.toLowerCase().substring(2)\n      dom.addEventListener(eventType, nextProps[name])\n    })\n}\n```\n\n`updateDomProperties` 함수는 이전 프로퍼티들을 모두 제거하고 새로운 것들을 추가한다. 이것은 프로퍼티가 변경되도 변화를 시키지 않으므로 불필요한 업데이트가 많이 발생하지만 단순하게하기 위해 지금은 그대로 두겠습니다.\n\n### Reusing DOM nodes\n\nreconciliation 알고리즘은 DOM nodes 를 가능하면 재 사용하는 것이라고 말했습니다. 그래서 type 이 같다면 해당 DOM node 를 재사용할 것입니다. ( 프로퍼티만 update 할것이다. )\n\n```javascript\nfunction reconcile(parentDom, instance, element) {\n  if (instance == null) {\n    // Create instance\n    const newInstance = instantiate(element)\n    parentDom.appendChild(newInstance.dom)\n    return newInstance\n  } else if (instance.element.type === element.type) {\n    // Update instance\n    // 여기서 instance dom은 기존에 render 되었던 이전 instance 이다.\n    // 이전 instance에 Real dom을 재사용해서 프로퍼티들만 update 시켜준다.\n    updateDomProperties(instance.dom, instance.element.props, element.props)\n    instance.element = element\n    return instance\n  } else {\n    // Replace instance\n    const newInstance = instantiate(element)\n    parentDom.replaceChild(newInstance.dom, instance.dom)\n    return newInstance\n  }\n}\n```\n\n### Children Reconciliation\n\nreconcile 함수에서 가장 중요한 작업을 놓쳤습니다. children 을 실행시키지 않았다는 점이다.\nChildren reconciliation 은 주요 기술중 하나이다. 여기서는 이전과 현재 tree 구조에서 children 을 매칭 하기 위해 key 라는 추가 프로퍼티가 요구됩니다.\n여기서는 오직 같은 children 배열에서 같은 위치의 children 끼리만 비교하겠습니다. 이것이 의미하는 바는 children 순서가 달라지면 DOM nodes 를 재사용하지 못한다는 비용이 든다는 점입니다.\n\nChildren reconciliation 을 실행하기 위해선 이전 child instances 인 `instance.childInstances` 와 새로운 element 의 children `element.props.children`을 매칭시킬 것입니다. 그리곤 재귀적으로 reconcil 함수를 호출할 것입니다. 또한 reconcile 에서 리턴된 모든 instances 들을 유지해서 childInstances 를 업데이트 할 수 있습니다.\n\n```javascript\nfunction reconcile(parentDom, instance, element) {\n  if (instance == null) {\n    // Create instance\n    const newInstance = instantiate(element)\n    parentDom.appendChild(newInstance.dom)\n    return newInstance\n  } else if (instance.element.type === element.type) {\n    // Update instance\n    // 타입이 같을때 dom을 재사용한다.\n    updateDomProperties(instance.dom, instance.element.props, element.props)\n    // 그리곤 children에 대해서 reconcile을 적용한다.\n    // children 은 배열이기 때문에 배열 처리를 위한 reconcileChildren 함수를 활용한다.\n    instance.childInstances = reconcileChildren(instance, element)\n    instance.element = element\n    return instance\n  } else {\n    // Replace instance\n    // 부모가 기존 인스턴스에서 새로운 인스턴스로 replace 한다면 그 부모 children 들도 새로 instance를 생성한다.\n    const newInstance = instantiate(element)\n    parentDom.replaceChild(newInstance.dom, instance.dom)\n    return newInstance\n  }\n}\n\nfunction reconcileChildren(instance, element) {\n  const dom = instance.dom\n  const childInstances = instance.childInstances\n  const nextChildElements = element.props.children || []\n  const newChildInstances = []\n  const count = Math.max(childInstances.length, nextChildElements.length)\n  for (let i = 0; i < count; i++) {\n    const childInstance = childInstances[i] // 이미 그려져 있는 children instance들.\n    const childElement = nextChildElements[i] // 새로 그려야 할 children element들\n    const newChildInstance = reconcile(dom, childInstance, childElement)\n    newChildInstances.push(newChildInstance)\n  }\n  return newChildInstances\n}\n```\n\n위 코드에서 reconcile 함수 안에서 instance 를 새로 생성하는 경우 ( 맨 처음 render 가 된다거나 type 이 바뀌는 replace 의 경우) 해당 부모의 자식(children) 들도 새로이 instance 를 생성한다. 즉, 부모가 instance 가 만들어지면 그 자식들도 새롭게 instance 를 만든다. 자식이 type 이 같더라도 부모가 바뀌었기 때문에 재 사용하지 못한다. <br/>\n\n대신에 부모 element 의 type 이 같아서 dom 을 재사용 할때는 자식들을 하나하나 reconcile 처리 해준다. 이때, 자식도 type 이 같다면 재사용 가능.\n\n### Removing DOM nodes\n\n만약에 `nextChildElements`가 `childInstances` 보다 length 가 더 길다면 reconcileChildren 함수는 reconcile 함수를 호출할 때 instance 를 `undifined`로 해서 호출할 것이다. 그러면 `if(instance == null)` 에 걸려서 새로운 instance 를 생성할 것이다. 반면에 반대가 된다면 어떨까?\n\n`childInstances`가 `nextChildElements` 보다 length 가 더 길다면 reconcile 함수에서 childElement 인자를 `undefined`를 보낼 것이다. 이때 reconcile 함수에서는 `element.type` 체크시 에러가 발생하게 된다.\n\ndom 이 제거되는걸 고려하지 않았기 때문이다. 그래서 두가지를 체크 할 것이다. 하나는 reconcile 함수에서 element 가 null 인 경우와 reconcileChildren 함수에서 newChildInstance 가 null 인 경우를 필터해줄 것이다.\n\n```javascript\nfunction reconcile(parentDom, instance, element) {\n  if (instance == null) {\n    // Create instance\n    // 기존에 그려진 instance가 없는 경우 element 값이 들어왔으면 새로이 추가한다.\n    const newInstance = instantiate(element)\n    parentDom.appendChild(newInstance.dom)\n    return newInstance\n  } else if (element == null) {\n    // Remove instance\n    // 이전에 그려졌던 instance 가 있는데 element가 null 이라는건 새로운 수정사항이 dom을 삭제했다는 것이다.\n    // 그래서 그에 매칭 되는 instance.dom 을 제거해주자.\n    parentDom.removeChild(instance.dom)\n    // 여기서 null 을 리턴해주기 때문에 reconcileChildren 함수에서 null을 filter 처리 한다.\n    return null\n  } else if (instance.element.type === element.type) {\n    // Update instance\n    updateDomProperties(instance.dom, instance.element.props, element.props)\n    instance.childInstances = reconcileChildren(instance, element)\n    instance.element = element\n    return instance\n  } else {\n    // Replace instance\n    // 이미 그려진 instance가 있고 element도 새로 들어왔는데 type이 다르다면 새로 만들어서 교체한다.\n    const newInstance = instantiate(element)\n    parentDom.replaceChild(newInstance.dom, instance.dom)\n    return newInstance\n  }\n}\n\n// 인스턴스의 childInstance가 배열이기 때문에 이 배열을 돌면서 reconcile 처리.\nfunction reconcileChildren(instance, element) {\n  const dom = instance.dom // 기존에 그려졌던 dom\n  const childInstances = instance.childInstances\n  const nextChildElements = element.props.children || []\n  const newChildInstances = []\n  const count = Math.max(childInstances.length, nextChildElements.length)\n  for (let i = 0; i < count; i++) {\n    const childInstance = childInstances[i]\n    const childElement = nextChildElements[i]\n    const newChildInstance = reconcile(dom, childInstance, childElement)\n    newChildInstances.push(newChildInstance)\n  }\n  // reconcile 함수에서 childElement가 null인 경우에 dom이 제거됬다고 간주하고 null 을 반환할 것이다.\n  return newChildInstances.filter(instance => instance != null)\n}\n```\n\n[codepen](https://codepen.io/pomber/pen/WjLqYW?editors=0010)\n\n여기까지 정리를 해보면 처음에 `element` 를 받아서 무조건 dom 을 만들고 dom tree 구조를 render 함수 내에서 구조를 잡고 진행하게 되는데 맨 처음에는 render 를 모두 진행하고 나서 `parentDom.appendChild(dom)` 를 진행했다. 이러면 발생되는 문제는 계속 root dom 화면에 동일한 구조가 추가가 된다는 점이다.\n\n이러면 안되기 때문에 replace 를 추가 하게 된다. `parentDom.replaceChild(dom, parentDom.lastChild)` 라는 로직을 추가 하게 되는데 조건은 `parentDom.lastChild`의 유무로 판단하게 된다. 이렇게 되면 root dom 밑으로 replace 가 이뤄져서 tick 같은 app 에서 원하는 조건(동일한 자리에 update 된 화면)을 달성 할 수 있다.\n\n여기서 또 한가지의 문제는 그리고자 하는 트리형 dom 이 원하는 자리에 replace 가 되지만, 그 dom 의 `children` 에 대해서는 계속 새롭게 그린다는 점이다. 그러니깐 통으로 새로 그려서 화면의 같은자리에 replace 하고 다시 update 가 필요할땐 통으로 dom 을 새로 만들어 다시 replace 를 한다는 점이다. 변화가 필요한 dom 만 그리지 않고 전부 다시 그리는 셈이 되므로 복잡한 UI 의 경우 비용이 많이 들게 되어있다.\n\n그래서 update 시 dom type 이 같다면 새로 create 하는 것이 아닌 dom 의 속성(props)만 update 하고 기존의 dom 은 그대로 쓰는 `reconcile` 함수를 만들었으며, 기존 그려졌던 `element`의 type 비교와 더불어 dom 의 재사용을 위한 새로운 개념인 `instance : {dom, element, childInstances }` 라는것을 도입했다. 또한 한번 그려진 이전 `instance`는 별도로 저장을 해둔다.\n여기서 reconcile 함수의 역할은 parentDom, 이전의 그려졌던 instance, 새로운 element 받아서 조건에 맞게끔 dom 에 그려준다.\n\n그래서 reconcile 의 함수에는 다음과 같은 조건이 붙는다.\n\n* 이전에 그려놓은 `instance` 가 없다면 새로 `instance` 를 만들고 만들어진 dom 을 append 시킨다.\n* 새로 그려지는 `element` 가 null 이라면 매칭되는 `parentDom` 에서 자식들을 삭제한다.\n* 이전에 그려놓은 `instance` 의 element type 과 새로 그릴려는 `element type` 이 같으면 이전에 그려 놓은 `instance` 의 dom 에 prop 만 업데이트 한다. 그리고 나서 해당 `instance` 의 `children` 을 `reconcil` 을 한다. 여기서 따로 `reconcileChildren` 함수가 존재하는 이유는 `children` 이 배열 타입이기 때문이다.\n* 그 외 모든 경우에는 `parentDom` 기준으로 새롭게 `instance` 를 만들어서 replace 한다.\n\n여기까지의 문제는 dom 을 재사용하긴 했다지만 모든 변화에 대해서 전체 dom 에 대한 render 를 진행한다는 것이다.\n\n## Components and State\n\n위 코드에서는 몇몇 가지 문제사항이 있었다.\n\n* 모든 변화에 전체 virtual DOM tree 를 reconciliation 을 진행합니다.\n* State 가 글로벌하게 존재합니다.\n* state 가 변화 된 후 render 함수를 좀 더 명시적으로 호출해야 합니다.\n\nComponents 는 이러한 이슈를 해결하는데 도움을 줄수 있습니다.\n\n* JSX 를 이용해 Custom tag 를 정의 할 수 있습니다.\n* lifecycle 이벤트에 Hook 을 걸수 있습니다.\n\n먼저해야 할 일은 컴포넌트가 확장 될 Component 기본 클래스를 제공하는 것입니다. 우리는 구성 요소 상태를 업데이트하는 데 사용할 `partialState`를 받는 `setState` 메서드와 props 매개 변수가있는 생성자가 필요합니다.\n\n```javascript\nclass Component {\n  constructor(props) {\n    this.props = props\n    this.state = this.state || {}\n  }\n\n  setState(partialState) {\n    this.state = Object.assign({}, this.state, partialState)\n  }\n}\n```\n\n어플리케이션 코드에서는 이 클래스를 상속받을 것입니다. 그 후에 div 와 span 같이 `<MyComponent>` 처럼 사용할 것입니다.\n여기서 중요한건 우리가 만들었던 `createElement` 수정이 필요 없습니다. element `type`으로 class 컴포넌트를 받고 `props`를 다룰것입니다.\n우리는 요소가 주어진 컴포넌트 인스턴스( public instances 라고 부릅니다.) 를 생성하는 함수가 필요합니다.\n여기서 `public instance` 라고 하는건 class 컴포넌트의 인스턴스입니다.\n\n```javascript\nfunction createPublicInstance(element, internalInstance) {\n  // type이 class 일 경우\n  const { type, props } = element\n  const publicInstance = new type(props)\n  publicInstance.__internalInstance = internalInstance\n  return publicInstance\n}\n```\n\npublic instance 생성하는 것 외에도 internal instance(from the virtual DOM) 의 레퍼런스를 추가적으로 가지고 있기 때문에 public instance state 가 변경 되었을때 해당 인스턴스 하위트리만 (instance sub-tree) 업데이트 할 수 있어야 합니다.\n\n```javascript\nclass Component {\n  constructor(props) {\n    this.props = props\n    this.state = this.state || {}\n  }\n\n  setState(partialState) {\n    this.state = Object.assign({}, this.state, partialState)\n    // this.__internalInstance는 가상 DOM { dom, element, childInstance, publicInstance }\n    updateInstance(this.__internalInstance)\n  }\n}\n\nfunction updateInstance(internalInstance) {\n  const parentDom = internalInstance.dom.parentNode\n  const element = internalInstance.element\n  // 보통은 render시에 reconcile을 진행하지만\n  // setState가 있을 시에도 reconcile을 진행 할 수 있다.\n  reconcile(parentDom, internalInstance, element)\n}\n```\n\n`instantiate` 함수도 update 가 필요합니다. components 들은 public instace 로 생성하고 component 의 `render` 함수를 child element 를 얻기 위해 호출해준다. 그리곤 해당 element 를 다시 `instantiate` 함수로 호출해준다.\n\n```javascript\n// element를 받아서 트리구조를 돌면서 instance 구조 {dom, element, childInstances}를 만든다.\n// element : {type: Component , props: { ... , children: []}}\nfunction instantiate(element) {\n  const { type, props } = element\n  const isDomElement = typeof type === 'string'\n\n  if (isDomElement) {\n    // Instantiate DOM element\n    const isTextElement = type === TEXT_ELEMENT\n    const dom = isTextElement\n      ? document.createTextNode('')\n      : document.createElement(type)\n\n    updateDomProperties(dom, [], props)\n\n    const childElements = props.children || []\n    // childElements 는 배열로 들어오기 때문에 map 돌리면서 instantiate 함수 호출해줌.\n    const childInstances = childElements.map(instantiate)\n    const childDoms = childInstances.map(childInstance => childInstance.dom)\n    childDoms.forEach(childDom => dom.appendChild(childDom))\n\n    const instance = { dom, element, childInstances }\n    return instance\n  } else {\n    // element.type이 class 일 경우.\n    // Instantiate component element\n    const instance = {}\n    const publicInstance = createPublicInstance(element, instance)\n    // childElement은 배열이 아니다.\n    const childElement = publicInstance.render()\n    // child 인스턴스가 하나임.\n    const childInstance = instantiate(childElement)\n    const dom = childInstance.dom\n    // instance 에 publicInstance를 넣기 위해서 Object.assign을 사용\n    Object.assign(instance, { dom, element, childInstance, publicInstance })\n    return instance\n  }\n}\n```\n\ncomponent elements 와 dom elements 를 위한 internal instances(this.\\_\\_internalInstance)는 다르다. Component internal instance 들은 오직 하나의 child(render 함수에서 리턴되는) 만 가지고 있다. 그래서 internal instance 들은 dom instances 들이 가지고 있는 `childInstances` 배열 인스턴스들 대신에 `childInstance` 프로퍼티 하나를 가지고 있다. 또한, component internal instance 들은 public instance (class 컴포넌트의 인스턴스) 를 가지고 있을 필요가 있다. 그래야 render 함수가 reconciliation 하는 동안 불려질수 있기 때문이다.\n\n한가지 놓친것이 있다면 component instance 의 reconciliation 를 다루는 것이다. 그래서 우린 reconciliation algorithm 에 한가지 케이스를 더 추가할 것이다. children reconciliation 을 다루지 않아도 되는 한가지 child 만 가지고 있는 component instance 가 주어졌을때, 우린 public instance 의 props 를 update 시키고 child 를 re-render 시켜주면 된다.\n\n```javascript\n// dom을 어떤 방식으로 그릴지를 결정하는 함수\nfunction reconcile(parentDom, instance, element) {\n  if (instance == null) {\n    // Create instance\n    const newInstance = instantiate(element)\n    parentDom.appendChild(newInstance.dom)\n    return newInstance\n  } else if (element == null) {\n    // Remove instance\n    parentDom.removeChild(instance.dom)\n    return null\n  } else if (instance.element.type !== element.type) {\n    // Replace instance\n    const newInstance = instantiate(element)\n    parentDom.replaceChild(newInstance.dom, instance.dom)\n    return newInstance\n  } else if (typeof element.type === 'string') {\n    // Update dom instance\n    updateDomProperties(instance.dom, instance.element.props, element.props)\n    instance.childInstances = reconcileChildren(instance, element)\n    instance.element = element\n    return instance\n  } else {\n    //Update composite instance\n    instance.publicInstance.props = element.props\n    const childElement = instance.publicInstance.render()\n    const oldChildInstance = instance.childInstance\n    const childInstance = reconcile(parentDom, oldChildInstance, childElement)\n    instance.dom = childInstance.dom\n    instance.childInstance = childInstance\n    instance.element = element\n    return instance\n  }\n}\n```\n\n이게 전부이다. 이 코드를 사용해서 활용한 예제이다. : [codepen](https://codepen.io/pomber/pen/RVqBrx)\n\nclass Component 에서 setState 를 사용하면 해당 컴포넌트를 기준으로 children 에 대한 `reconcile`을 진행한다.\n`reconcile`을 진행한다는 것은 이전 instance 와 새로 들어온 element 를 비교해서 어떤 방법으로 dom 을 렌더링 할지를 결정하게 되는 것이다.\n`instantiate`를 실행한다는 것은 새롭게 들어온 element 가 이전 그려논거랑 완전히 달라졌을 때를 실행하게 된다.\n\n## Fiber: Incremental reconciliation\n\n리액트 16 버젼이 출시 되었다. 그것은 리액트의 코드 대부분을 재 작성해야 할 필요가 생긴 새로운 내부적인 아키텍쳐를 가지고 있다.\n이것은 예전 아키텍처로는 개발하기 힘든 일부 기능이 선적되었음을 의미합니다. 또한 이 시리즈에서 작성한 대부분의 코드는 현재 가치가 없다는 것을 의미합니다.\n\n이제는 16 에서 사용하는 새로운 아키텍쳐를 사용해서 다시 코드를 작성해볼 예정이다. 특히, 구조, 변수들, 함수이름들을 리액트 코드베이스로 부터 가져와서 작성할 것입니다.\n여기서 우리가 건들지 않아도 되는 API 는 다음과 같습니다.\n\n* createElemetn()\n* render() (오직 DOM 을 rendering 하는 함수)\n* Component ( setState() 메서드를 포함한. context 나 life cycle 은 미포함)\n\n이제 왜 우리가 예전 코드를 다시 작성해야 하는지를 설명하겠다.\n\n### Why Fiber\n\n브라우저의 메인 쓰레드는 시간을 많이 쓰는 무엇인가로 인해 매우 바쁘게 움직이고 있다고 할때, 매우 중요한 task 들은 끝날때 까지 기다려야 한다.\n\n이런 문제를 위해서 몇가지 데모를 준비했다. [데모](https://pomber.github.io/incremental-rendering-demo/react-sync.html)에서 행서들이 도는걸 유지하기 위해서 메인 쓰레드는 매 16ms 마다 사용가능 하도록 유지 시켜주어야 한다. 만약 이 메인쓰레드가 다른 무엇인가로 blocked 당했다고 한다면 여기서 매 200ms 라고 해봅시다. 메인 쓰레드가 다시 자유로워 질때 까지 행성들이 멈춰있고 해당 프레임이 사라지는걸 확인 할 수 있을 것입니다.\n\n에니메이션을 부드럽고 UI 응답을 유지하기 위해 예비의 마이크로 초도 둘수없게 무엇이 메인쓰레드를 바쁘게 했을까요?\n\n`reconciliation` 코드를 기억합니까? 한번 `reconciliation` 코드를 실행하면 멈추지 않습니다. 메인 스레드가 다른 작업을 수행해야하는 경우 `reconciliation` 코드는 대기 해야합니다. 그리고 이 `reconciliation` 코드는 많은 재귀 호출로 인해서 지연될 수 있는 코드 입니다. 이런 이유로 우리는 해당 코드를 재귀 호출을 루프로 교체 가능한 새로운 데이터 구조를 사용하는 `reconciliation` 코드를 재 작성해야 합니다.\n\n### Scheduling micro-tasks\n\n우린 이제 작업을 작은 단위로 나눌 필요가 있습니다. 이것들은 짧은 시간동안 동작하기 위한 조각들입니다. 메인 스레드가 더 우선 순위가 높은 작업을 수행하게하고 보류중인 작업이 있으면 작업을 끝내기 위해 다시 돌아옵니다.\n이 작업을 돕기 위해서 `requestIdelCallback()` 함수를 이용 할 것입니다. 이것은 `callback` 함수를 큐에 넣어 두는데 이것은 브라우저가 idle 타임에 호출이 되고, 얼만큼 이용가능한 시간인지 설명해주는 `deadline` 파라미터를 포함하고 있다.\n\n```javascript\nconst ENOUGH_TIME = 1 // milliseconds\n\nlet workQueue = []\nlet nextUnitOfWork = null\n\nfunction schedule(task) {\n  workQueue.push(task)\n  requestIdleCallback(performWork)\n}\n\n// requestIdleCallback 인자로 들어갈 함수\n// 이 함수는 브라우저가 idle 시점에 호출되고\n// deadline 파라미터로 적절한 시간이 남았는지를 확인해서 해당 로직을 수행한다.\nfunction performWork(deadline) {\n  // 다음 작업이 남아있는지를 확인\n  if (!nextUnitOfWork) {\n    nextUnitOfWork = workQueue.shift()\n  }\n\n  // 다음 작업이 있고 시간이 충분히 남았다면 작업 수행\n  while (nextUnitOfWork && deadline.timeRemaining() > ENOUGH_TIME) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)\n  }\n\n  if (nextUnitOfWork || workQueue.length > 0) {\n    requestIdleCallback(performWork)\n  }\n}\n```\n\n실제 작업은 `performUnitOfWork` 함수에서 일어납니다. `performUnitOfWork` 안에 우리의 **reconciliation code** (이전 instance 와 새로 들어온 element 를 비교해서 어떤 방법(replace, append,...)으로 dom 을 렌더링할지를 결정) 를 작성할 필요가 있습니다.\n`performUnitOfWork` 함수는 작업의 조각을 동작시켜야 합니다. 그리곤 다음에 작업을 다시 시작하는 데 필요한 모든 정보를 반환해야 햡니다.\n\n이런 작업의 조각들을 추적하기위해 `fiber` 들을 사용할 것입니다. 즉, `fiber` 는 일련의 작업을 다시 시작하기 위해 만들어졌고 이것을 작업 정보 명세서라고 생각하면 될거 같습니다.\n\n### The fiber data structure\n\n우리는 render(그려지기)를 원하는 각 컴포넌트에 대해 fiber 를 생성할 것입니다. `nextUnitOfWork` 는 우리가 원하는 다음 작업인 next fiber 를 위한 참조 값입니다. `performUnitOfWork` 는 fiber 대한 작업을하고 완료가 되면 모든 작업이 끝날때 까지 새로운 fiber 를 리턴합니다.\n\nfiber 는 어떻게 생겼는가?\n\n```javascript\nlet fiber = {\n  tag: HOST_COMPONENT,\n  type: 'div',\n  parent: parentFiber,\n  child: childFiber,\n  sibling: null,\n  alternate: currentFiber,\n  stateNode: document.createElement('div'),\n  props: { children: [], className: 'foo' },\n  partialState: null,\n  effectTag: PLACEMENT,\n  effects: [],\n}\n```\n\n이것은 보통의 자바스크립트 객체입니다.\n\n우리는 `parents`, `child` 그리고 `sibling` 프로퍼티를 사용하여 component 의 tree 를 설명 하는 fiber 들의 tree 를 구축합니다.\n\n`stateNode`는 component instance 에 대한 참조 값이다. 이 값으론 DOM element (createDomElement) 또는 유저가 정의한 class component 의 instance (createInstance) 를 가질 수 있습니다.  \n\n예를 들면 :\n\n![fiber01.png](./fiber01.png)\n\n위 예제에서 우리가 지원할 서로 다른 3 가지 종류의 컴포넌트들을 볼수 있습니다.\n\n* `b`,`p` 그리고 `i` 를 위한 fiber 들은 **host components** 표현합니다. 이들의 식별자는 tag 에 `HOST_COMPONENT` 라고 지칭 할것이다. `type`은 string(html element 의 태그) 이 될것입니다. `props`는 속성값과 해당 element 의 이벤트 리스너가 되겠습니다.\n* `Foo` fiber 는 **class component** 를 표현합니다. 이것의 `tag`는 `CLASS_COMPONENT` 가 될 것이고, `type`은 유저가 정의한 `Didact.Component`를 상속한 `class` 의 참조값이 될것이다.\n* `div`를 위한 fiber 는 **host root** 를 표현합니다. 이것은 위에서 언급한 host component 과 유사한데 그 이유는 `stateNode` 와 같은 DOM element 를 지니고 있기 때문입니다. 그러나 이 host root 는 트리의 root 가 되어서 특별하게 다뤄질 것입니다. `tag`는 `HOST_ROOT`가 될것입니다. 이 fiber 의 `stateNode` 는 `Didact.render()`로 전달 받은 DOM node 이다.\n\n다른 중요한 프로퍼티는 `alternate` 입니다. 이 `alternate` 가 필요한 이유는 대부분의 시간동안에 두가지의 fiber tree 를 가져야 하기 때문입니다.\n**한가지 tree 는 우리가 이미 render 한 DOM 에 관한 것이고, 이것을 우린 current tree 또는 old tree 라고 부를 것이다. 또 다른 하나는 우리가 `setState()` 또는 `Didact.render()` 호출을 통해서 새로운 update 작업을 할때 생성되는 tree 이다. 이것을 우린 _work-in-progress_ tree 라고 부를 것입니다.**\n\nwork-in-progress tree 는 old tree 를 가진 어떤 fiber 와도 공유하지 않습니다. (이것은 work-in-progress tree 를 만들때 매번 새로운 객체 fiber 로 만든다는 이야기 이다.) 일단 work-in-progress tree 를 완성하고 필요한 DOM 을 변화를 만들 필요성을 가지면, 다시 이 work-in-progress tree 가 old tree 가 됩니다.\n\n따라서 `alternate`는 work-in-progress tree fiber 들을 old tree 에 상응하는 fiber 들과 연결하기 위해 사용합니다. fiber 와 그것의 `alternate`는 같은 `tag`, `type` 그리고 `stateNode`를 공유합니다. 때론 새로운 rendering 작업이 있을떈 fiber 들은 `alternate`를 안가지고 있을 수 있습니다.\n\n여기서 `alternate`는 처음에 dom 에 그릴땐 어떤한 값을 안가지고 있다가 dom 을 그리고 나고 다시 render 시에는 \\_rootContainerFiber 값을 `alternate`에 할당합니단. 그 이후에 `reconcileChildrenArray` (children 돌면서 fiber 를 만들어 줌) 메서드 실행시에 `wipFiber.alternate.child`를 `oldFiber`로 활용합니다.\n\n마지막으로, `effects`리스트와 `effectTag`를 갖습니다. work-in-progress tree 안에서 DOM 이 변화할 필요가 있는 fiber 를 찾았을때 `effectTag`를 `PLACEMENT`, `UPDATE` 또는 `DELETION`으로 설정합니다. 모든 DOM 변화를 손쉽게 처리하기 위해 `effectTag`를 가지고 있는 모든 자식 fiber 들의 목록(fiber 하위 트리로부터 나온 fiber 들)을 `effects`에 유지합니다.\n\n### Didact call hierarchy\n\n우리가 작성하려고하는 코드의 흐름을 이해하려면이 다이어그램을 살펴보십시오.\n\n![fiber02.png](./fiber02.png)\n\n`render()` 및 `setState()` 에서 시작하여 `commitAllWork()` 에서 끝나는 흐름을 따릅니다.\n\n### Old code\n\n대부분의 코드를 재 작성해야 한다고 이야기 했었습니다. 하지만 먼저 수정하지 않을 코드가 있는지 살펴봅시다.\n\n트랜스파일된 JSX 가 사용하는 함수인 `createElement` 함수를 작성했습니다. 우리가 작성한 `createElement()` 함수는 변할 필요가 없다. 우린 계속 동일한 element 들을 사용할 것이기 때문입니다. 여기서 element 는 `type`,`props` 그리고 `children`을 가진 평범한 자바스크립트 객체였습니다.\n\n우린 노드의 DOM 프로퍼티를 갱신 하기 위해 `updateDomProperties()` 도 작성했었습니다. 또 DOM element 들을 생성하기 위해 `createDomElement()` 함수도 추출했습니다. 이 두 함수 모두 [이곳](https://gist.github.com/pomber/c63bd22dbfa6c4af86ba2cae0a863064)에서 볼수 있습니다.\n\nbase class 인 `Component` 도 작성했었습니다. 여기서 `setState()`가 `scheduleUpdate()` 를 호출하게 만들고 `createInstance()` 가 instance 에 fiber 를 참조하도록 만듭시다.\n\n```javascript\nclass Component {\n  constructor(props) {\n    this.props = props || {}\n    this.state = this.state || {}\n  }\n\n  setState(partialState) {\n    scheduleUpdate(this, partialState)\n  }\n}\n\nfunction createInstance(fiber) {\n  const instance = new fiber.type(fiber.props)\n  instance.__fiber = fiber\n  return instance\n}\n```\n\n이 코드로 시작하고 나머지는 처음부터 다시 작성하지 않습니다.\n\n![fiber03.png](./fiber03.png)\n\n`Component` 클래스와 `createElement()` 외에도 `render()`와 `setState()`라는 두 개의 공용 함수가 있으며 `setState()`가 `scheduleUpdate()`를 호출하는 것을 보았습니다.\n`render()` 및 `scheduleUpdate()` 도 비슷합니다. 이 두 함수들은 새 업데이트 할것을 받고 대기열(큐)에 넣습니다.\n\n```javascript\n// Fiber tags\nconst HOST_COMPONENT = 'host'\nconst CLASS_COMPONENT = 'class'\nconst HOST_ROOT = 'root'\n\n// Global state\nconst updateQueue = []\nlet nextUnitOfWork = null\nlet pendingCommit = null\n\n// render 함수\n// 아래서 render 함수라는건 이 함수를 가리킴\n// 이 render는 처음에 딱 한번 실행함.\nfunction render(elements, containerDom) {\n  updateQueue.push({\n    from: HOST_ROOT,\n    dom: containerDom,\n    newProps: { children: elements },\n  })\n  requestIdleCallback(performWork)\n}\n\nfunction scheduleUpdate(instance, partialState) {\n  updateQueue.push({\n    from: CLASS_COMPONENT,\n    instance: instance,\n    partialState: partialState,\n  })\n  requestIdleCallback(performWork)\n}\n```\n\n`updateQueue` 배열을 사용해서 보류중인 update 추적할 것입니다. 매 `render()` 또는 `scheduleUpdate()` 호출은 새로운 업데이트를 `updateQueue` 큐에 넣습니다.\n각 업데이트들의 업데이트 정보는 다르고 이것을 우리가 나중에 `resetNextUnitOfWork()` 에서 어떻게 사용할지 볼 수 있을것입니다.\n\n업데이트를 큐에 넣고 나서, `performWork()`에 대한 지연(deferred) 호출을 트리거합니다.\n\n![fiber04.png](./fiber04.png)\n\n```javascript\nconst ENOUGH_TIME = 1 // milliseconds\n\n// render 또는 scheduleUpdate 에서\n// requestIdleCallback(performWork) 로 호출함.\nfunction performWork(deadline) {\n  // cpu 시간이 괜찮을때까지 loop 돌면서 작업 수행\n  workLoop(deadline)\n  \n  // cpu에 시간이 안괜찮아서 workLoop 탈출\n  // 남은 작업이 있으면 performWork를 다시 호출함\n  if (nextUnitOfWork || updateQueue.length > 0) {\n    requestIdleCallback(performWork)\n  }\n}\n\n// nextUnitOfWork은 처음에 null로 셋팅되어 있음.\nfunction workLoop(deadline) {\n  if (!nextUnitOfWork) {\n    // 여기서 처음에 nextUnitOfWork 을 셋팅함.\n    resetNextUnitOfWork()\n  }\n  while (nextUnitOfWork && deadline.timeRemaining() > ENOUGH_TIME) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)\n  }\n  if (pendingCommit) {\n    commitAllWork(pendingCommit)\n  }\n}\n```\n\n여기 우리가 앞서 보았던 `performUnitOfWork()` 패턴을 사용합니다.\n\n`requestIdleCallback()`은 deadline 파라미터를 함께 가진 타겟 함수를 호출합니다. `performWork()` deadline 을 받아서 `workLoop()` 로 전달해줍니다. `workLoop()` returns 후에, `performWork()` 작업 준비가 되었는지 체크를 합니다. 만약 준비가 됬다면, 자기 자신을 새로운 지연 호출로 스케줄링 시킵니다.\n\n`workLoop()` 은 시간을 주시하는 함수입니다. 만약 deadline 이 너무 가깝다면(마감시간), 루프 작업은 멈추고 다음 업데이트 해야할 작업을 남겨둡니다. 그래서 다시 다음 타임에 재개 될 수 있도록 합니다.\n\n> `deadline.timeRemaining()`이 다른 작업 단위를 실행하기에 충분한지 아닌지 확인하기 위해 `ENOUGH_TIME` (1ms 상수, React 와 동일)을 사용합니다. `performUnitOfWork()`가 그 이상을 수행하면 마감 시간이 초과 될것입니다. deadline 은 브라우저의 제안 일 뿐이므로 몇 밀리 초 동안 초과실행 하는것은 그렇게 나쁘지 않습니다.\n\n`performUnitOfWork()`는 업데이트를위한 work-in-progress 트리를 만들고 DOM 에 적용해야 할 변경 사항을 남겨둡니다. **이것은 한 번에 한 fiber 씩 점진적으로 이루어질 것입니다.**\n\n`performUnitOfWork()`가 현재 업데이트에 대한 모든 작업을 완료하면 null 을 반환하고 보류중인 DOM 변경 사항을 `pendingCommit`에 남겨 둡니다. 마침내 `commitAllWork()`는 `pendingCommit` 에서 `effects`를 받아 DOM 을 변경합니다.\n\n`commitAllWork()`는 루프 외부에서 호출됩니다. `performUnitOfWork()`에서 수행 된 작업은 DOM 을 변경하지 않으므로 분할하는 것이 좋습니다. 반면에, `commitAllWork()`는 DOM 을 돌연변이시킬 것이고 일관성없는 UI 를 피하기 위해 한번에 모두 완료되어야합니다.\n\n우리는 여전히 어디서 `nextUnitOfWork`를 처음으로 불러오는지 보지 못했습니다.\n\n![fiber05.png](./fiber05.png)\n\n업데이트를 받아서 첫 번째 `nextUnitOfWork`로 변환하는 `resetNextUnitOfWork()` 함수 입니다.\n`resetNextUnitOfWork()` 함수는 첫 root fiber 를 만드는 함수라고 생각하면 된다. `render()` 함수 또는 `scheduleUpdate()`함수에서 `performWork() 함수`를 시작할때 `nextUnitOfWork` 가 없다면 root fiber 를 만들어서 `performUnitOfWork(nextUnitOfWork)` 를 수행한다.\n\n`nextUnitOfWork` 이거는 곧 fiber 라고 생각하면 되겠다. 여기서 `performUnitOfWork` 의 매개 변수 명이 `wipFiber` 이다.\n\n```javascript\n// render 할때나 scheduleUpdate 호출될때 updateQueue에 update를 넣게 되는데\n// 이때 처음으로 updateQueue에 있는 update 를 꺼내오는 함수.\n// update 를 꺼내와서 nextUnitOfWork 의 fiber를 만들어줌.\nfunction resetNextUnitOfWork() {\n  const update = updateQueue.shift()\n\n  // render\n  // {\n  //   from: HOST_ROOT,\n  //   dom: containerDom,\n  //   newProps: { children: elements },\n  // }\n\n  // scheduleUpdate\n  // {\n  //   from: CLASS_COMPONENT,\n  //   instance: instance,\n  //   partialState: partialState,\n  // }\n\n  if (!update) {\n    return\n  }\n\n  // Copy the setState parameter from the update payload to the corresponding fiber\n  // 여기서 instance는 component의 public instance를 가리킴.\n  // partialState 이것은 update할 새로운 값 (setState로 넘어오는 인자)\n  if (update.partialState) {\n    update.instance.__fiber.partialState = update.partialState\n  }\n\n  // 그런 다음 old fiber tree의 root를 찾습니다.\n  // _rootContainerFiber 이것은 한번 그려졌던 dom 이라면 이전 fiber이다.\n  const root =\n    update.from == HOST_ROOT\n      ? update.dom._rootContainerFiber\n      : getRoot(update.instance.__fiber)\n\n  // 새로운 fiber\n  // 새로운 work-in-progress tree의 root\n  // update에 dom값이 있으면 처음 render 함수 호출하는거\n  // update에 newProps 값이 있으면 처음 render 함수 호출하는거.\n  nextUnitOfWork = {\n    tag: HOST_ROOT,\n    stateNode: update.dom || root.stateNode,\n    props: update.newProps || root.props,\n    alternate: root,\n  }\n}\n\nfunction getRoot(fiber) {\n  let node = fiber\n  while (node.parent) {\n    node = node.parent\n  }\n  return node\n}\n```\n\n`resetNextUnitOfWork()`는 대기열에서 첫 번째 업데이트를 가져 와서 시작합니다.\n\nupdate 객체에 `partialState`가 있다면 컴포넌트 인스턴스에 속해있는 fiber 에 그것을 저장 시켜 놓습니다. 그래서 나중에 컴포넌트의 `render()`를 호출 할 때 사용할 수 있습니다.\n\n그런 다음 old fiber tree 의 root 를 찾습니다. 처음 호출되는 `render()`함수로 update 객체들이 넘어왔을 경우에는 루트 fiber 가 없으므로 `root`가 `null`이 됩니다. `render()`에 대한 후속 호출에서 오는 경우 DOM 노드의 `_rootContainerFiber` 속성에서 루트를 찾을 수 있습니다. 그리고 업데이트가 `setState()`에서 오는 경우에는, 부모가없는 fiber 가 발견 될 때까지 인스턴스 fiber 에서 위로 이동해야합니다.\n\n그런 다음 `nextUnitOfWork`에 새 fiber 를 할당합니다. **이 fiber 는 새로운 work-in-progress tree 의 root 입니다.**\n\n만약 old root 가 없다면(이미 그려진 DOM 이 없다면), `stateNode`(component instance)는 `render()` 호출할때 매개 변수로 받은 DOM 노드(containerDom)입니다. `props` 는 update 객체의 `newProps`가 됩니다 : 여기서 `newProps`는 element(render() 함수의 element 매개변수 값)들을 가지고있는 children 프로퍼티를 가진 객체이다(위 `render` 함수 참고 : newProps: { children: elements }). `alternate`은 null 이 될 것입니다. 왜냐하면 처음으로 호출되는 `render` 이기 때문에 이전에 그렸던 루트 fiber 가 없다.\n\n만약 old root 가 있다면 `stateNode`는 이전 루트의 DOM 노드가됩니다. `props`는 다시 `newProps` 가 null 이 아니면 `newProps`로 할당되고 그렇지 않으면 이전 루트에서 `props` 복사합니다. `alternate`는 이전 루트 fiber 가 됩니다.\n\n이제 우리는 work-in-progress tree 의 root 을 가지고 나머지 부분을 만들기 시작합시다.\n\n![fiber06.png](./fiber06.png)\n\n```javascript\n// wipFiber 는 처음에 아래와 같은 객체입니다.\n// {\n//   tag: HOST_ROOT,\n//   stateNode: update.dom || root.stateNode,\n//   props: update.newProps || root.props,\n//   alternate: root,\n// }\n\n// beginWork는 전위 탐색으로 탐색되고\n// completeWork는 후위 탐색으로 탐색된다.\nfunction performUnitOfWork(wipFiber) {\n  beginWork(wipFiber)\n  if (wipFiber.child) {\n    return wipFiber.child\n  }\n\n  // No child, we call completeWork until we find a sibling\n  let uow = wipFiber\n  while (uow) {\n    completeWork(uow)\n    if (uow.sibling) {\n      // Sibling needs to beginWork\n      return uow.sibling\n    }\n    uow = uow.parent\n  }\n}\n```\n\n`performUnitOfWork()`는 진행중인 작업 트리를 탐색합니다.\n\n`beginWork()`를 호출한다. --이것은 새로운 fiber 의 children 을 만들기 위한 작업이다.-- 그리고 나서 첫번째 child 을 리턴한다. 그리고나서 그것을 `nextUnitOfWork` 에 대입한다.\n\n만약 어떤 child 도 없다면, `completeWork()`를 호출하고 `nextUnitOfWork`가 될 `sibling`을 리턴한다.\n\n만약 `sibling`가 없다면, parents 로 올라가서 해당 parents 를 인자로 `completeWork()`를 호출한다. 이 작업은 `sibling`을 찾을때 또는 root 에 도달했을 때까지 반복한다.\n\n`performUnitOfWork()`를 여러 번 호출하면 자식(children)이 없는 파이버를 찾을 때까지 각 파이버의 첫번째 자식의 자식들을 생성하면서 계속해서 트리의 하위로 내려갑니다. 그리고 오른쪽으로 옮겨서 siblings 에도 같은 작업을 수행합니다. 그리고 다시 위로 올라와서 같은 작업을 수행합니다.\n\n![fiber-search.png](./fiber-search.png)\n\n위 처럼 트리구조가 있을때 순서는 다음과 같습니다.\n파란색 순서는 `beginWork()` 가 호출되는 순서이고 빨간색 순서는 `completeWork()` 가 호출되는 순서입니다.\n`beginWork` 는 전위 탐색으로 탐색되고 `completeWork` 는 후위 탐색으로 호출 됩니다.\n\n![fiber07.png](./fiber07.png)\n\n```javascript\n// wipFiber 는 처음에 아래와 같은 객체입니다.\n// {\n//   tag: HOST_ROOT,\n//   stateNode: update.dom || root.stateNode,\n//   props: update.newProps || root.props,\n//   alternate: root,\n// }\n\nfunction beginWork(wipFiber) {\n  if (wipFiber.tag == CLASS_COMPONENT) {\n    updateClassComponent(wipFiber)\n  } else {\n    updateHostComponent(wipFiber)\n  }\n}\n\nfunction updateHostComponent(wipFiber) {\n  if (!wipFiber.stateNode) {\n    wipFiber.stateNode = createDomElement(wipFiber)\n  }\n  const newChildElements = wipFiber.props.children\n  reconcileChildrenArray(wipFiber, newChildElements)\n}\n\nfunction updateClassComponent(wipFiber) {\n  let instance = wipFiber.stateNode\n  if (instance == null) {\n    // Call class constructor\n    instance = wipFiber.stateNode = createInstance(wipFiber)\n  } else if (wipFiber.props == instance.props && !wipFiber.partialState) {\n    // No need to render, clone children from last time\n    cloneChildFibers(wipFiber)\n    return\n  }\n\n  instance.props = wipFiber.props\n  instance.state = Object.assign({}, instance.state, wipFiber.partialState)\n  wipFiber.partialState = null\n\n  const newChildElements = wipFiber.stateNode.render()\n  reconcileChildrenArray(wipFiber, newChildElements)\n}\n```\n\n`beginWork()`는 두가지를 합니다:\n\n* `stateNode`를 가지고 있지 않다면 생성해줍니다.\n* component children (fiber.props.children) 을 가져와 `reconcileChildrenArray()`에 그것들을 넘겨준다.\n\n두가지 타입의 component 를 우리가 다루기 때문에 우리는 2 가지로 나눠야 한다. `updateHostComponent()` 와 `updateClassComponent()` 이다.\n\n`updateHostComponent()`는 host component 들과 root component 를 다룬다. 그것은 필요하다면 새로운 DOM 을 만들어내고 **fiber props 에서 나온 child element 들을 이용해서 `reconcileChildrenArray()`를 호출한다.**\n\n`updateClassComponent()`는 class component instance 들을 다룬다. 그것은 필요하다면 component 의 생성자를 호출해서 instance 를 만들어낸다. **instance 의 props 와 state 를 업데이트를 하고 `render()`를 호출해서 새로운 children 을 얻는다.**\n\n`updateClassComponent()` 또한 `render()`를 호출하는것이 맞는지 확인합니다. 이것은 `shouldComponentUpdate()`의 간단한 버전이다. 만약 re-render 할 필요가 없어 보인다면, 어떠한 reconciliation 없이 현재 sub-tree 를 work-in-progress 트리로 복사합니다.\n\n이제 `newChildElements`를 가지고있고, work-in-grogress fiber 를 위한 child fiber 들을 만들 준비가 되었습니다.\n\n![fiber08.png](./fiber08.png)\n\n이것이 이 library 의 심장입니다. work-in-progress 트리가 커지며 커밋 단계에서 DOM 에 대해 어떤 변경 작업을 수행할지 결정합니다.\n\n```javascript\n// Effect tags\nconst PLACEMENT = 1\nconst DELETION = 2\nconst UPDATE = 3\n\nfunction arrify(val) {\n  return val == null ? [] : Array.isArray(val) ? val : [val]\n}\n\nfunction reconcileChildrenArray(wipFiber, newChildElements) {\n  const elements = arrify(newChildElements)\n\n  let index = 0\n  let oldFiber = wipFiber.alternate ? wipFiber.alternate.child : null\n  let newFiber = null\n  // 새롭게 들어온 element 또는 oldFiber가 없을때까지 반복\n  while (index < elements.length || oldFiber != null) {\n    const prevFiber = newFiber\n    const element = index < elements.length && elements[index]\n    const sameType = oldFiber && element && element.type == oldFiber.type\n\n    if (sameType) {\n      newFiber = {\n        type: oldFiber.type,\n        tag: oldFiber.tag,\n        stateNode: oldFiber.stateNode,\n        props: element.props,\n        parent: wipFiber,\n        alternate: oldFiber,\n        partialState: oldFiber.partialState,\n        effectTag: UPDATE,\n      }\n    }\n\n    if (element && !sameType) {\n      newFiber = {\n        type: element.type,\n        tag:\n          typeof element.type === 'string' ? HOST_COMPONENT : CLASS_COMPONENT,\n        props: element.props,\n        parent: wipFiber,\n        effectTag: PLACEMENT,\n      }\n    }\n\n    if (oldFiber && !sameType) {\n      oldFiber.effectTag = DELETION\n      wipFiber.effects = wipFiber.effects || []\n      wipFiber.effects.push(oldFiber)\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling\n    }\n\n    // Fiber 연결\n    if (index == 0) {\n      wipFiber.child = newFiber\n    } else if (prevFiber && element) {\n      prevFiber.sibling = newFiber\n    }\n\n    index++\n  }\n}\n```\n\n시작하기 전에 `newChildElements`가 배열인지 확인하십시오. (이전의 reconciliation 알고리즘과 달리 `reconcileChildrenArray`는 항상 자식 배열과 함께 작동합니다. 즉, 이제 component 의 `render()` 함수에서 배열을 반환 할 수 있습니다.)\n\n그 후에 old fiber tree 의 children 들을 새로운 element 와 비교하기 시작합니다. (fiber 와 element 를 비교하는 것이다.) old fiber tree 의 children 들은 `wipFiber.alternate` 의 children 이다. 새로운 element 들은 `wipFiber.props.children` 에서 얻어 오거나 또는 `wipFiber.stateNode.render()` 호출해서 얻어온 것입니다.\n\nreconciliation 알고리즘은 첫번째 old fiber(`wipFiber.alternate.child`)와 첫번째 child element(`element[0]`) 를 일치 시키고, 두번째 old fiber(`wipFiber.alternate.child.sibling`) 두번째 child element(`element[1]`)도 반복합니다. 각각 oldFiber-element 쌍을 이루게 합니다.\n\n* 만약 oldFiber 와 element 가 타입이 같다면, 이것은 좋은 소식입니다, 이것은 기존의 stateNode 를 유지할수 있다는 뜻이다. 우리는 new fiber 를 예전거 기반에서 생성합니다. `UPDATE`를 `effectTag`에 추가시킨다. 그리고 새로운 fiber 를 work-in-progress tree 에 덧붙입니다.\n\n* 만약 element 의 type 이 oldFiber 와 다르거나 oldFiber 가 없다면(왜냐하면 기존 자식들보다 새로운 자식들을 많이 가지고 있는 경우), 우리가 가지고 있는 element 정보를 가지고 새로운 fiber 를 생성합니다. 이 새로운 fiber 는 `alternate` 와 `stateNode`를 가지고 있지 않는다. (`stateNode`는 `beginWork()`에서 생성됩니다.) 이 fiber 의 `effectTag` 는 `PLACEMENT` 입니다.\n\n* 만약 oldFiber 와 element 가 다른 type 이거나 이 oldFiber 를 위한 어떠한 element 도 없는 경우(왜냐하면 기존 자식들이 새로운 자식들 보다 많이 가지고 있기 때문) oldFiber 는 DELETION 태그를 붙입니다. 이 fiber 는 작업 중(work-in-progress) 트리의 일부가 아니기 때문에, 그것을 추적할 수 없게끔 wipFiber.effets 목록에 추가해야 합니다.\n\n> 리액트와는 달리 재조정을 위해 keys 를 사용하지 않으므로, 이전 위치에서 벗어난 자식이 있는지 알 수 없습니다.\n\n![fiber09.png](./fiber09.png)\n\n`updateClassComponent()` 는 재조정을 하는 대신 지름길로 old fiber 하위 트리를 work-in-progress 트리로 복제하는 특별한 경우가 있습니다.\n\n```javascript\nfunction cloneChildFibers(parentFiber) {\n  const oldFiber = parentFiber.alternate\n  if (!oldFiber.child) {\n    return\n  }\n\n  let oldChild = oldFiber.child\n  let prevChild = null\n  while (oldChild) {\n    const newChild = {\n      type: oldChild.type,\n      tag: oldChild.tag,\n      stateNode: oldChild.stateNode,\n      props: oldChild.props,\n      partialState: oldChild.partialState,\n      alternate: oldChild,\n      parent: parentFiber,\n    }\n    if (prevChild) {\n      prevChild.sibling = newChild\n    } else {\n      parentFiber.child = newChild\n    }\n    prevChild = newChild\n    oldChild = oldChild.sibling\n  }\n}\n```\n\n`cloneChildFibers()` 는 각 `wipFiber.alternate` 자식들(children)을 복제하고 work-in-progress 트리에 추가합니다. 아무것도 변경하지 않아도 되므로 어떠한 `effectTag` 도 추가할 필요가 없습니다.\n\n![fiber10.png](./fiber10.png)\n\n`performUnitOfWork()` 에서 wipFiber 가 새로운 자식들(children)을 가지고 있지 않거나 이미 모든 자식들이 이미 작업을 완료 했을 때, `completeWork()`를 호출합니다.\n\n```javascript\nfunction completeWork(fiber) {\n  if (fiber.tag == CLASS_COMPONENT) {\n    fiber.stateNode.__fiber = fiber\n  }\n\n  if (fiber.parent) {\n    const childEffects = fiber.effects || []\n    const thisEffect = fiber.effectTag != null ? [fiber] : []\n    const parentEffects = fiber.parent.effects || []\n    fiber.parent.effects = parentEffects.concat(childEffects, thisEffect)\n  } else {\n    pendingCommit = fiber\n  }\n}\n```\n\n`completeWork()`는 먼저 클래스 컴포넌트의 인스턴스와 관련된 fiber 에 대한 참조를 업데이트합니다. (솔직히 말해서, 여기 있을 필요는 없지만 어딘가에 있어야 합니다.)\n\n그런 다음 `effects` 목록을 작성합니다. 이 목록에는 effectTag 가 있는 work-in-progress 서브 트리의 모든 fiber 들이 포함됩니다. (DELETION effectTag 를 가진 이전 하위 트리의 파이버도 포함). 이 아이디어는 effectTag 가 있는 모든 fiber 를 root `effects` 목록에 누적하는 것입니다.\n\n자신 fiber 의 자식들 effect, 내 effect, 부모 fiber effect 를 한데 모아서 내 부모 fiber 의 effect 로 모아준다.\n\n마지막으로 fiber 에 부모(`parent`)가 없다면, work-in-progress 트리의 루트에 위치 해 있는것 입니다. 따라서 우리는 업데이트에 대한 모든 작업을 완료하고 모든 effects 를 수집했습니다. `workLoop()`이 `commitAllWork()`를 호출 할 수 있도록 `pendingCommit` 에 root 를 대입합니다.\n\n![fiber11.png](./fiber11.png)\n\n이제 마지막으로 남은건 DOM 을 변경하는 것입니다.\n\n```javascript\nfunction commitAllWork(fiber) {\n  fiber.effects.forEach(f => {\n    commitWork(f)\n  })\n  fiber.stateNode._rootContainerFiber = fiber\n  nextUnitOfWork = null\n  pendingCommit = null\n}\n\nfunction commitWork(fiber) {\n  if (fiber.tag == HOST_ROOT) {\n    return\n  }\n\n  let domParentFiber = fiber.parent\n  while (domParentFiber.tag == CLASS_COMPONENT) {\n    domParentFiber = domParentFiber.parent\n  }\n  const domParent = domParentFiber.stateNode\n\n  if (fiber.effectTag == PLACEMENT && fiber.tag == HOST_COMPONENT) {\n    domParent.appendChild(fiber.stateNode)\n  } else if (fiber.effectTag == UPDATE) {\n    updateDomProperties(fiber.stateNode, fiber.alternate.props, fiber.props)\n  } else if (fiber.effectTag == DELETION) {\n    commitDeletion(fiber, domParent)\n  }\n}\n\nfunction commitDeletion(fiber, domParent) {\n  let node = fiber\n  while (true) {\n    if (node.tag == CLASS_COMPONENT) {\n      node = node.child\n      continue\n    }\n    domParent.removeChild(node.stateNode)\n    while (node != fiber && !node.sibling) {\n      node = node.parent\n    }\n    if (node == fiber) {\n      return\n    }\n    node = node.sibling\n  }\n}\n```\n\n`commitAllWork()` 먼저 각각의 모든 루트 `effects` 를 순회하여 `commitWork()` 반복해서 호출합니다. `commitWork()`는 각 fiber 의 `effectTag` 를 검사합니다.\n\n* `PLACEMENT` 인 경우 우리는 부모 DOM 노드를 찾은 다음 단순히 fiber 의 stateNode 를 추가합니다.\n\n* `UPDATE` 인 경우 stateNode 를 이전 props 및 새 props 와 함께 전달하고 `updateDomProperties()`가 업데이트 할 항목을 결정하도록 합니다.\n\n* `DELETION` 이고 fiber 가 호스트 컴포넌트인 경우 간단합니다. 그저 `removeChild()`를 호출하면 됩니다. 그러나 fiber 가 클래스 컴포넌트인 경우 `removeChild()`를 호출하기 전에 fiber 하위 트리에서 모든 호스트 컴포넌트를 찾아서 제거해야 합니다.\n\n모든 effects 가 끝나면 `nextUnitOfWork` 및 `pendingCommit` 을 초기화 할 수 있습니다. work-in-progress 트리는 작업중인 트리가 아닌 이전 트리가 되므로 루트를 \\_rootContainerFiber 에 할당합니다. 이제 우리는 현재의 업데이트가 끝냈고 다음 업데이트를 시작할 준비가 되었습니다.\n\n### fiber 정리\n\nfiber root 를 가지고 처음엔 `beginWork(rootFiber)` 를 작업한다.\n\n여기서 `beginWork()` 한다는 것은 `stateNode` 생성해주고 자식들을 `reconcileChildrenArray()` 실행해준다.\n그러면 `reconcileChildrenArray()` 이 하는 일은 여러명의 자식중에 첫번째 자식은\nrootFiber.child 에 childFiber01 로 넣고 나머지는 이전 작업했던 childFiber01 에 sibling 으로 childFiber02 를 넣는다.\n\n예를 들면 아래 와 같은 구조를 구성한다.\n\n```javascript\nrootFiber.child = childFiber01\n\nchildFiber01.parent = rootFiber\nchildFiber01.sibling = childFiber02\n\nchildFiber02.parent = rootFiber\nchildFiber02.sibling = childFiber03\n```\n\n그래서 `beginWork()` 이 작업을 통해서 한 부모 fiber 의 자식 fiber 들을 생성해주는 역할을 합니다. 이 역할이 끝나고 나서 fiber.child 가 발견 되면 다시 `beginWork()` 를 수행한다. 끝까지 child 가 나오지 않는다면 그때부턴 fiber 를 `complateWork()`를 실행합니다. 실행도중 fiber.sibling 가 발견되면 다시 `beginWork()`를 수행하게 되어 child fiber 를 만들게 됩니다.\n\n그래서 결론적으로는 `performUnitOfWork()`의 반복 수행으로 전체 fiber 트리 구조를 잡아준다.\n\n정리하면 트리 구조의 왼쪽 맨 아래쪽으로 내려가면서 fiber 를 만들게 됩니다. 이때, 더이상의 child 를 만나지 않으면 `complateWork()` 를 실행하고 부모로 올라가 `complateWork()` 를 실행합니다. 이때, 해당 fiber 에서 sibling 들을 만나게 되면 해당 sibling 을 리턴해서 다시 `beginWork()` 작업을 하게 되고 child 가 없을때 다시 `complateWork()`를 실행해줍니다. 이 작업을 반복해서 실행합니다.\n\n`complateWork()` 이 하는 일은 해당 fiber 에 부모가 존재한지 확인한 후에 자신(fiber)의 자식들 effect 에 자신의 effect 를 만들고 부모가 가진 effect 를 concat(합쳐서) 부모 fiber 에 effect 로 넘겨줍니다.\n이렇게 하면 최종적으로 root fiber 의 effect 에는 배열로 각 fiber 의 정보가 수집되게 됩니다.\n\n마지막으로는 `commitAllWork()` 함수가 root fiber 의 effect 리스트들을 돌면서 `commitWork()`를 수행합니다.\n`commitWork()` 에서는 `effectTag`를 보면서 적절한 DOM 변이를 처리 합니다.\n\n최종적으론 fiber tree 구조를 만들면서 순회를 합니다. 이때, 각 필요한 DOM 변이를 최종 root fiber 의 effects 배열로 전달해준다. 이 작업은 재귀 없이 분할작업으로 처리를 한다.\n그렇게 해서 완성된 root fiber effects 를 가지고 실제 DOM 변이를 일으킨다. 이 작업은 나누지 않고 한번에 작업하도록 한다.\n\n## 최종 정리\n\nfiber 알고리즘이 적용 되기 전까지는 dom 의 재사용성을 위한 `instance`라는 개념을 도입 (`{dom, element, childInstances}`) 했다. 여기서 `instance`는 dom 에 그려진 `element`를 나타냅니다.\nrender 또는 setState 시 에 발동되는 `reconcile` 라는 \"diff\" 알고리즘을 사용합니다. 여기서 `reconcile` 함수는 이미 그려진 `instance` 와 새롭게 그려질 element 를 비교한다. 이런 비교를 통해서 dom 을 업데이트 할지 새로 추가할지, 교체할지를 정한다. dom 에 새로 추가 또는 type 이 달라서 replace 처리 하게 될 땐 새로 element 받아서 `instance`를 만든다음에 append or replace 를 단행한다. 반대로 type 이 같다면 dom property 를 update 처리 하고 `reconcileChildren` 함수를 통해서 자식들의 reconcile 을 진행한다.\n\n여기서 중요한 문제는 한번 **reconcile 이 이뤄지면 끊지 않고 화면에 rendering 까지 진행한다는 점이다.** 여기서 재귀적으로 함수들이 호출 되기 때문에 더더욱 중간에 끊을 수 없고 계속 진행해야 한다는 점이다. 그래서 이 작업이 오래 걸려서 단일 쓰레드를 점령하고 있으면 다른 작업(ex. css animation 같은 작업)이 멈출 수 있다.\n\n이 문제를 해결하고자 fiber 알고리즘을 적용한다.\n\n기존에 instance 를 대체하는 fiber 구조를 사용한다. **fiber 알고리즘에선 이전 재귀적으로 실행했던 reconcile 을 iteration 구조로 바꿨다고 보면 된다.** 그래서 재귀 구문이 없을 뿐더러 while 구문이 많이 보인다. 그래서 `requestIdleCallback`을 이용해서 분할작업을 진행할 수 있고 다음작업에 대해서 `nextUnitOfWork`를 전역으로 보관하고 있다. 처음으로 `requestIdleCallback(performWork)`를 수행해서 `workLoop(deadline)`를 수행한다.\n`workLoop(deadline)`에서는 브라우저 idle 타임을 보고 계속 `performUnitOfWork(nextUnitOfWork)`를 수행한다. 그러다가 시간이 부족하게 된다면 다음 이어서 해야할 작업을 `nextUnitOfWork`에 담아두고 `workLoop(deadline)` 를 빠져나온다. 그리고 나서 다음 작업이 남았다면 다시 `requestIdleCallback(performWork)`을 수행해서 브라우저 대기열에 넣어 둡니다. 그리고 시간이 되면 다시 수행합니다.\n\n`workLoop()`에서는 `resetNextUnitOfWork()`를 처음에 수행해서 root 의 fiber 를 만들고 `performUnitOfWork(nextUnitOfWork)`를 수행한다.\n`performUnitOfWork(nextUnitOfWork)` 에서는 fiber 를 받아서 `beginWork()` 와 `completeWork()` 를 수행한다.\n\n`beginWork()` 는 fiber 를 받아서 fiber 의 stateNode 프로퍼티에 값을 셋팅해주고 해당 fiber 의 children 들을 fiber 로 만들어준다. ( 1 단 트리만 구성 ) 그리고 나서 `performUnitOfWork(nextUnitOfWork)` 에선 fiber 에 child 가 존재하면 리턴시켜서 다음 작업(`nextUnitOfWork`)이 child 를 root 로 진행해야한다는걸 알린다.\n이런 수행은 child 가 없을때 까지 진행되며 `beginWork()`을 실행시켜서 fiber 트리 일부를 구성한다.\n더이상의 child 가 없다면 그때부턴 `completeWork()`를 수행한다.\n`completeWork()`는 Effect 들을 모아서 부모로 넘겨주는 작업을 한다. 모으는 대상은 자신의 effect 와 children 의 effect 를 모은다.\n그런 다음 sibling 이 있는지 확인하는데 있다면 다시 리턴해서 다음 작업(`nextUnitOfWork`)이라는걸 알린다. 이때 다시 `beginWork()`를 수행해서 sibling 의 children 들을 fiber 로 만들어준다.\n\n위 작업이 복잡하지만 간단히 생각해보면 root 와 root 의 children 들을 한 작업 단위로 beginWork()로 fiber 를 만든다.\n다음 작업땐 그 root 의 child (보통 첫번째 child 이다.)를 새로운 root 로 삼고 children 을 fiber 를 만든다.\n\n```javascript\nroot = rootFiber\nroot.child = childFiber01\nchildFiber01.parent = root\nchildFiber01.sibling = childFiber02\n\nchildFiber02.parent = root\nchildFiber02.sibling = childFiber03\n\nchildFiber03.parent = root\n```\n\n위와 같은 구조가 되겠다.\nchild 가 없는 구조까지 도달하면 마지막 fiber 의 Effect 와 그의 자식들이 모인 effects 를 부모에게 전달한다.\n그리고 나서 sibling 이 있다면 다음 작업을 sibling 으로 넘긴다. sibling 으로 가서 다시 child 를 탐색하고 Effect 를 모으고 하는 작업들을 반복해서 진행한다.\n\n![react-fiber 도식화](./react-fiber.png)\n\n재귀 방식이 아닌 iterator 작업 방식이기 때문에 이렇게 Effect 를 모으는 작업을 분할해서 작업할 수 있다.\n그 후에 root 에 모인 Effect 를 `commitAllWork()` 를 수행해서 한번에 화면에 rendering 을 진행한다.\n","excerpt":"이 글은 아래 링크에 있는 글을 참조 했습니다.\n참조 Rendering DOM element 우리가 render 할 때 필요한게 뭔지 설명하기 위해 plain JS object 를 하나 만들 것입니다.\n이것을 우리는 element 라고 부를 것입니다…","fields":{"slug":"/build-react.md/"},"frontmatter":{"date":"Jun 03, 2019","title":"build-react","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n자바스크립트는 재귀 깊이가 너무 깊어지면 오류가 발생한다. 호출 스택을 펼쳐서 재귀 호출을 루프처럼 펼쳐주는 기법을 사용하면 이런 오류를 막을 수 있다.\n\n컴파일러는 _꼬리 재귀(tail recursion)_ 이라는 특별한 형태의 재귀 호출을 스택 깊이를 키우지 않고 처리하도록 최적화해줄 수 있다.\n컴파일러가 최적화를 제공하지 않으면 _트램폴린(trampoline)_ 과 _스트림(stream)_ 등의 기법을 사용해 재귀를 수동으로 최적화할 수 있고, 스택이나 리스트 등의 데이터 구조와 함께 재귀를 루프로 바꾸는 일반적인 규칙을 활용하면 재귀를 기계적으로 루프로 바꿀 수 있다.\n\n> 여기서 stack 이란 ? 함수를 호출한 후에 원래 자리로 돌아오려면, 원래 자리를 어딘가에 저장해둬야 하는데, 그 어딘가가 바로 Stack 이다.\n\n```javascript\nfunction fibonacci(n) {\n    if (n < 2)\n        return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n```\n\n피보나치 수열과 단순한 합을 구하는 재귀함수에서 문제는 두가지 이다.\n\n1. 피보나치 수열은 재귀 호출을 두겹으로 호출하기 때문에 함수 호출 횟수가 많다.\n2. 단순한 합을 구하는 재귀함수에서는 stack 의 깊이가 너무 깊어진다.\n\n```javascript\n// 단순 합을 재귀로 해결한 예제.\nfunction sum(n) {\n  if (n < 2) return n\n  return n + sum(n - 1)\n}\n```\n\n첫번 째 문제는 한겹으로 재귀를 호출 할 수 있다면 함수 호출을 줄일 수 있을 것이다.\n두번 째 문제의 해결책은 두가지가 있을 수 있는데 다음과 같다.\n\n* stack 을 쓰지 말자. 즉, 함수 호출을 하지말자.\n* stack 을 쓰되 누적해서 쓰지말고 있는걸 재활용하자.\n\n피보나치 수열에서 해결은 **반복 단계별 계산 결과를 반복이 끝날 때까지 어떤 변수(여기서는 previousFibo)에 계속 저장한다.** 방식으로 해결이 된다.\n피보나치 수열을 재귀가 아닌 반복문을 이용해서 풀어보자. 바로 해결이 될 것이다.\n\n프로그램이 stack 을 쓰는 이유는 함수 실행 후 돌아갈 원래 자리를 stack 에 저장을 하기 때문이다.\n그렇다면 왜 원래 자리로 돌아가는가??\n\n바로 **원래 자리에서 해야 할 일이 남아있기 때문이다.**\n바꿔 말하면, **원래 자리에서 해야할 일이 남아있지 않다면 돌아갈 원래 자리를 Stack 에 추가로 저장할 필요가 없다.**\n\n```javascript\nfunction fibonacci(n) {\n  if (n < 2) return n\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n```\n\n`fibonacci(n - 1)`를 호출한 후에 바로 리턴하는 것이 아니라 다시 한 번 `fibonacci(n - 2)`를 실행해서 두 값을 더한 후에 리턴한다. 다시 말해, 원래 자리로 돌아와서 해야할 일이 남아있으므로 돌아올 원래 자리의 정보를 Stack 에 추가해서 저장해야 한다.\n\n그렇다면 원래 자리에서 해야할 일을 남겨두지 않는 방법은 무엇인가? 그 방법이 바로 Tail Call(꼬리 호출)이다.\n\n```javascript\nfunction a() {\n  var v = 0\n  return b(v)\n}\nfunction b(n) {\n  return n + 1\n}\na()\n```\n\n_Tail Call 은 함수를 호출해서 값을 반환 받은 후 아무 일도 하지 않고 바로 반환하게 하기 위해 논리적으로 가장 마지막(꼬리) 위치에서 함수를 호출하는 방식을 말한다._\n_Tail Call 방식을 적용하려면 두 겹인 재귀 호출을 한 겹으로 줄여야만 한다._\n\n즉, 반환 받은 후 아무일도 하지 않게끔 하는 Tail Call 방식으로 짜는 것까지는 프로그래머가 할 수 있는 일이지만, Tail Call 방식으로 짰다고 해도 그런 코드를 돌리는 실행 환경에서는 내부적으로 여전히 Stack 을 새로 만들어 추가하는 비효율적인 방식으로 동작할 수도 있다.\n\n> tail Call 방식으로 짜여지면 Stack 을 새로 만들지 않고 이미 있는 Stack 속의 값만 대체해서 Stack 을 재사용하는 방식으로 동작하도록 최적화 할 수 있다. 이러한 최적화를 Tail Call Optimization(또는 Tail Call Elimination)이라고 하며 언어의 실행 환경에서 지원해줘야 한다.\n\nTail Recursion 의 경우에는 *Tail Call 의 특별한 경우로서 Tail Call 로 호출하는 함수가 자기 자신인 경우*에 해당한다.\n이제 Tail Recursion 으로 fibonacci 수를 구하는 코드를 짜보자. 앞에서 재귀 호출 방식을 반복 방식으로 바꾸는 작업을 직접 해봤다면 크게 어렵지 않을 것이다.\n\n```javascript\nfunction fibonacciTailRecursion(n, previousFibo, previousPreviousFibo) {\n  var currentFibo\n  if (n < 2) return n * previousFibo\n\n  // 이번 호출의 피보나치 수를 구하고\n  currentFibo = previousFibo + previousPreviousFibo\n\n  // 다음번 재귀 호출을 위해 앞의 피보나치 수를 앞의앞의 피보나치 수로 한 칸 미루고\n  previousPreviousFibo = previousFibo\n\n  // 다음번 재귀 호출을 위해 현재의 피보나치 수를 앞의 피보나치 수로 한 칸 미룬다.\n  previousFibo = currentFibo\n\n  return fibonacciRecursion(n - 1, previousFibo, previousPreviousFibo)\n}\n```\n\n```javascript\nfunction fibonacciTailRecursion(n, previousFibo, previousPreviousFibo) {\n  if (n < 2) return n * previousFibo\n  return fibonacciTailRecursion(\n    n - 1,\n    previousFibo + previousPreviousFibo,\n    previousFibo\n  )\n}\n```\n\n재귀 호출을 반복이나 Tail Recursion 방식으로 구현하려면 다음의 사항을 꼭 기억하자.\n반복이나 꼬리 호출 단계별 계산 결과를 어딘가에 계속 저장한다.\n\n반복 방식에서는 previousFibo 이 반복문 외부에서 선언되었고, Tail Recursion 방식에서는 previousFibo 이 함수의 파라미터로 사용된다는 점만 다를 뿐, 반복이나 꼬리 호출 단계별 계산 결과를 어딘가에 저장해둔다는 점은 똑같다.\n\n인터프리터 / 컴파일러는 호출 스택에서 과거 함수 호출을 제거하여 재귀를 최적화합니다. 하지만 자바 스크립트에서 꼬리 재귀는 인식되지 않고 여전히 호출 스택에 배치가 되는 문제점을 가지고 있다.\n\n## Trampoline\n\n일반적인 Tail Recursion 에서는 tail position 에서 함수 스스로를 계속 호출을 하고 그 결과를 바로 다시 자기 자신 함수의 결과로 넘겨서 호출하곤 했었다.\n이때 컴파일러가 tail positon 호출을 위한 optimizations 이 안되어 있다면 스택은 계속 쌓여만 간다.\n\nTail Recursion 으로 짠 factorial\n\n```javascript\nfunction factorial(n) {\n  var recur = function(result, n) {\n    if (n === 1) return result\n\n    return recur(result * n, n-1)\n  }\n  return recur(1, n)\n}\n// So factorial(4) = recur(1, 4) = recur(4 * 1, 3) = recur(4 * 3, 3) = recur(12 * 2, 2) = recur(24 * 1, 1) = 24.\n```\n\n위 코드에서 `factorial(100000000)` 실행시키면 Maximum call stack size exceeded 에러가 발생한다.\n\n그래서 한가지 방법중에 하나가 `trampoline` 이라고 불리는 패턴이다.\n만약 위에서 말한 계속 호출하는 방식이 아닌 호출할 함수를 리턴해준다면, 우리는 tramploine 을 사용해서 계속적으로 실행할 수 있다.\n\n`trampoline` 자바스크립트에서 tail recursion 을 실행시켜주는 `helper function` 이다.\n보통 다른 문서들에서 `thunk` 와 `tramploining` 이란 단어를 들어 봤을 것이다.\n`thunk`는 아직 호출되지 않는 함수를 말한다. 즉, 다른 함수에 대한 호출을 래핑하는 함수이다. 간단하게는 `currying` 과 `binding` 에서 이런 기능을 볼 수 있다. ( ex. redux-thunk s)\n`trampoline function`에 `thunk` 를 전달을 하면 `bound function` 이 나오고, 해당 인자 값과 함께 `while-loop` 를 통해서 `bound function` 이 더 이상 함수가 아닐때 까지 그것의 `recursive function` 을 호출한다.\n\n```javascript\nfunction trampoline(fn) {\n  while (fn && fn instanceof Function) {\n  //continue if fn is not undefined/null and if it is still a function\n    fn = fn(); // recur.bind(null,1*4,3) 을 실행.. 이 함수도 thunk 함수이다. 함수 호출 이후에 함수를 리턴함으로\n  }\n  // we call the function and assign the result of called previous fn to new fn\n  // when we are done return fn when fn is the result and no longer function.\n  return fn;\n}\n\nfunction factorial(n) {\n  var recur = function(result, n) {\n    if (n === 1)\n      return result;\n    return recur.bind(null, result * n, n-1);\n  }\n  return trampoline(recur(1, n));\n}\n```\n\n위 예에서 `factorical(4)` 를 호출한다고 가정을 해보고 호출을 따라가보자.\n여기서 위에서 설명한 `thunk 함수`는 `recur 함수`이다.\n`recur(1,n)` 을 `trampoline` 함수에 인자로 넘겼을 때, `recur(1,4)` 를 호출 후에 우리는 사실 `recur.bind(null,1*4,3)` 을 넘기게 됩니다.\nwhile 반복문은 recur 가 undefined/null 이지 않고, 함수인지를 체크한다. 여기서 recur 이 bounded 되고 나서도 recur 함수는 Function object 의 인스턴스로 여전히 남아있게 된다.\n\n```javascript\nconsole.log(recur.bind(null, 1 * 4, 3)) // [Function: bound recur]\n```\n\n루프에 2 가지 상태를 확인한 후에 fn 을 호출한다. 그리곤 그것의 결과를 다시 fn 에 할당한다.\n그러면 fn 은 `recur.bind(null,4*3,2)` 가 된다. 이 루프는 `recur.bind(null,12*2,1)` 이 될때까지 동작하게 된다. 그리곤 24 를 리턴한다. 여기서 24 값은 undefined/null 이 아니다, 그래서 while 루프 상태값에서 통과가 되지만 24 값은 function 이 아니기에 while 루프가 중지된다. `trampoline` 함수는 결국 24 인 fn 을 반환하게 된다.\n\n이 과정에서 우리는 함수 호출을 쌓을 필요가 없습니다. 각 함수가 호출되어 바운드 함수를 반환 한 다음 호출 스택에서 제거됩니다. 그런 다음 `trampoline` 의 while 루프를 사용하여 바운드 함수를 호출하여 각 재귀 적 단계로 건너 뛰게 됩니다.\n\nwhile 문을 돌면서 fn 이 함수가 아닌 값으로 떨어질때까지 호출하고 리턴하고를 반복한다. fn 을 만들때에는 해당 조건이 완성되지 않았을 때는 계속 함수를 리턴하도록 해준다.\n\n결과적으로 같이 `factorial(100000000)`을 실행할 경우에 call stack 에러가 뜨지 않습니다.\n\n## 예시\n\n트리 구조로 되어있는 것을 flat 하게 만들자.\n\n예시\n\n```javascript\nconst tree = {\n  name: 'root',\n  children: [\n    {\n      name: 'subtree1',\n      children: [{ name: 'child1' }, { name: 'child2' }],\n    },\n    { name: 'child3' },\n    {\n      name: 'subtree2',\n      children: [\n        {\n          name: 'child1',\n          children: [{ name: 'child4' }, { name: 'child5' }],\n        },\n        { name: 'child6' },\n      ],\n    },\n  ],\n}\n```\n\n맨 처음에는 재귀 함수를 사용했었다.\n\n재귀 함수가 퍼포먼스 측면에서 느린건 잘 모르겠으나 자바스크립트에서 stack 이 overflow 날 위험이 있다.\n브라우저 쪽에서 tail call optimization 을 지원한다면 stack 이 과다하게 차지 않아도 될듯 싶은데 아직은 그런 기능이 없는거 같다.\n\n< 처음 짠 재귀 함수 >\n\n```javascript\nconst makeFlatTreeStructureData = (treeData = []) => {\n  const result = []\n\n  function insertItem(root) {\n    root.forEach(item => {\n      if (item) {\n        result.push(item)\n        if (item.child && item.child.length > 0) {\n          insertItem(item.child)\n        }\n      }\n    })\n  }\n\n  insertItem(treeData)\n\n  return result\n}\n```\n\n여기서 stack 이 overflow 나지 않게 트릭을 하나 쓸수 있는데 바로 trampoline 패턴이다.\n근데 이 trampoline 패턴의 방식은 큰 약점이 있는데 그것은 느리다는 것이다.\n\n각 재귀 마다 새로운 함수를 만들어내고 많은 재귀는 당연히 많은 함수를 만든다는 것이다.\n그래서 이방식은 오류를 방지할 순 있지만 느리다는게 최대 단점이다.\n\n참조: [https://marmelab.com/blog/2018/02/12/understanding-recursion.html](https://marmelab.com/blog/2018/02/12/understanding-recursion.html)\n\n참고로 아직 trampoline 방식으로 구현을 어떻게 해야할지 구현을 못해봤다. ( 5 월 16 일 )\n\n구현을 따로 해봐야 할 꺼 같다.\n\n```javascript\n// trampoline 방식\n// 재귀 함수를 스택을 늘리지 않고 호출 할 수 있게끔 하는 helper 함수.\nconst trampoline = fn => {\n  while (fn && fn instanceof Function) {\n    //continue if fn is not undefined/null and if it is still a\n    //function\n    fn = fn()\n  }\n  //we call the function and assign the result of called previous fn\n  //to new fn\n  return fn\n  //when we are done return fn when fn is the result and no longer\n  //function.\n}\n\n// 구현..\n```\n\n마지막으로 할 수 있는 방법은 이 재귀 적인 로직을 iteration 로직으로 바꾸는 방법이다.\n\n우선 stack 에 처음 해당 데이터를 넣는다. shift 로 첫번째 요소를 제거하고 반환시킨다.\n그럼 처음에는 root 가 나올것이다. root 를 result 결과에 넣어두고 child 가 존재하면 root 자리에 있었던 곳에 child 를 다 풀어서 stack 에 쌓아둔다. 그리고 다시 stack 에서 가장 첫번째껄 확인한다.\n\n만약 아래와 같은 간단한 구조였다면\n\n```javascript\nconst data = {\n  id: 'us'\n  child: [\n    {id:'kor', child:[\n      {id: 'ab'},\n      {id: 'cd'}\n    ]},\n    {id:'jp'},\n  ]\n}\n\n// stack의 움직임\n// 1.\n[data]\n// data를 result에 넣어두고 data있었던 자리에 child를 풀어서 다시 스택에 넣는다.\n[{id:'kor'...},{id: 'jp'...}]\n\n// 2.\n// 첫번째 데이터(id:'kor')를 빼내어서 다시 result에 넣어두고 child가 있기에 다시 풀어서 stack에 넣는다.\n[{id:'ab'}, {id:'cd'}, {id:'jp'..}]\n\n// 지금까지의 result는\n[{id:'us'}, {id:'kor'}]\n\n// 이렇게 해서 순서대로 flat하게 만들 수 있다.\n```\n\n< iteration 로직 >\n\n```javascript\n// 중첩된 데이타를 재귀를 피하고 iteration logic으로 풀어서 함.\nconst getFlatDataListFromNestedData = nestedData => {\n  const stack = [nestedData] // add the initial tree to the stack\n  const result = [] // initialize the result accumulator\n\n  while (stack.length) {\n    const currentTree = stack.shift() // 첫번째 요소 제거 후 반환\n    if (currentTree) result.push(currentTree) // 첫번째 요소가 존재하면 push\n    if (currentTree.child) {\n      stack.unshift(...currentTree.child) // 해당 첫번째 요소에 child가 존재하면 그 첫번째 요소 자리에 child으로 다시 매꾼다.\n    }\n  }\n\n  return result\n}\n\nconst getFlatDataListFromNestedDataList = (rootTreeDataList = []) => {\n  return rootTreeDataList.flatMap(getFlatDataListFromNestedData)\n}\n```\n\n## 참고\n\n[https://medium.com/@cukejianya/functional-js-trampolines-tails-88723b4da320](https://medium.com/@cukejianya/functional-js-trampolines-tails-88723b4da320)\n[https://homoefficio.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/](https://homoefficio.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/)\n[https://www.datchley.name/recursion-tail-calls-and-trampolines/](https://www.datchley.name/recursion-tail-calls-and-trampolines/)\n[https://marmelab.com/blog/2018/02/12/understanding-recursion.html](https://marmelab.com/blog/2018/02/12/understanding-recursion.html)\n","excerpt":"자바스크립트는 재귀 깊이가 너무 깊어지면 오류가 발생한다. 호출 스택을 펼쳐서 재귀 호출을 루프처럼 펼쳐주는 기법을 사용하면 이런 오류를 막을 수 있다. 컴파일러는 꼬리 재귀(tail recursion) 이라는 특별한 형태의 재귀 호출을 스택 깊이를…","fields":{"slug":"/tail-recursion.md/"},"frontmatter":{"date":"May 16, 2019","title":"꼬리 재귀","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 중복 코드\n\n중복 코드의 가장 단순한 예는 한 클래스의 두 메서드 안에 같은 코드가 들어 있는 경우 이다.\n이럴땐 `메서드 추출` 기법을 적용해서 겹치는 코드를 빼내어 별도의 메서드로 만들고 그 메서드를 두곳에서 호출하면 된다.\n\n또 다른 상황은 한 클래스의 두 하위클래스에 같은 코드가 들어있는 경우다.\n이럴 때는 `메서드 추출` 기법을 적용해서 중복을 없앤 후 `메서드 상향` 기법을 적용하면 된다.\n\n코드가 똑같지 않고 비슷하다면 `메서드 추출`기법을 적용해서 같은 부분과 다른 부분을 분리해야 한다.\n그런다음, 경우에 따라 템플릿 메서드 형성 기법을 적용해야 할 수도 있다.\n\n두 메서드가 알고리즘만 다르고 기능이 같다면 개발자는 그 두 알고리즘 중에서 더 간단한 것을 택해서 `알고리즘 전환`을 적용하면 된다.\n중복코드가 가운데에 있다면 주변 `메서드 추출`을 적용하면 된다.\n\n서로 상관없는 두 클래스 안에 중복 코드가 있을 때는 한 클래스 안의 중복코드를 `클래스 추출`이나 `모듈 추출`을 적용해제 3 의 클래스나 모듈로 떼어낸 후 그것을 다른 클래스에서 호출하는 방법이 있다. 아니면 중복 코드를 빼서 메서드로 만든 후 그 메서드를 두 클래스 중 하나에 넣고 다른 클래스에서 그 메서드를 호출하거나, 코드를 빼내어 만든 메서드를 제 3 의 클래스에 넣고 그걸 두 클래스에서 호출하는 방법도 있다.\n\n## 장황한 메서드\n\n최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메서드 길이가 짧다.\n주석을 달아야 할 것 같은 부분에 주석을 넣는 대신 메서드를 작성한다. 메서드 안에 주석을 단 코드를 넣고, 그 메서드 명은 기능 수행 방식이 아니라 목적(즉, 기능자체)을 나타내는 이름으로 정한다.\n\n메서드를 줄이려면 십중팔구는 `메서드 추출` 기법을 적용해야 한다. 메서드에서 하나로 묶으면 좋을 만한 부분들을 찾아내어 메서드로 만드는 것이다.\n\n메서드에 매개변수와 임시변수가 많으면 `메서드 추출`을 실시하기가 까다롭다.\n메서드 추출을 하려면 수많은 매개변수와 임시변수를 새로 만든 메서드의 매개변수로 넘겨야 하는데, 그렇게 되면 가독성에서 원래의 코드와 별 다를게 없어진다. 웬만한 경우에는 `임시변수를 메서드 호출 전환`기법이나 `임시변수를 메서드 체인으로 전환` 기법을 적용하면 임시변수가 제거된다.\n길게 열거된 매개변수는 `매개변수 세트를 객체로 전환` 기법과 `객체를 통째로 전달` 기법을 적용하면 간결해진다.\n\n이런 노력에도 불구하고 임시변수와 매개변수가 너무 많을 때는 `메서드를 메서드 객체로 전환` 기법을 적용하면 된다.\n\n조건문을 추출하려면 `조건문 쪼개기` 기법을 사용해야 한다.\n루프를 `컬렉션 클로저 메서드로 전환`을 실시한 후 그 클로저 메서드 호출과 클로저 자체에 `메서드 추출`을 실시하면 된다.\n\n## 방대한 클래스\n\n기능이 지나치게 많은 클래스는 보통 엄청난 수의 인스턴스 변수가 들어 있다.\n클래스에 인스턴스 변수가 너무 많으면 중복 코드가 반드시 존재하게 마련이다.\n\n`클래스 추출`을 실시하면 수 많은 인스턴스 변수를 하나로 묶을 수 있다. 쉽게 말해 한 클래스 안의 일부 변수가 접두어나 접미어가 같다면 하나의 클래스로 추출하는게 좋다. `하위클래스로 추출`하는 것이 적합할 것 같으면 `하위클래스 추출`을 실시하는 것이 더 간단하다.\n만약 추출할 클래스가 대리자로 부적절할 것 같으면 `모듈 추출`을 실시하면 된다.\n\n인스턴스 변수를 계속해서 모두 사용하지 않는 클래스도 간혹 있다. 그런 경우에는 `클래스 추출`, `모듈 추출`, `하위클래스 추출` 중 하나를 여러번 적용하는 방법도 있다.\n만약 100 줄짜리 메서드 5 개가 있다면 그것들을 원래 메서드에서 추출한 2 줄짜리 메서드 10 개가 들어있는 10 줄짜리 메서드 5 개로 바꾸는 방법도 있다.\n\n클라이언트가 그 클래스를 어떻게 사용하게 할지 결정하고, 그러한 각 사용방법마다 `인터페이스 추출`을 실시하는 편법도 자주 쓰인다.\n\n만약 방대한 클래스가 GUI 클래스라면 데이터와 기능을 서로 다른 도메인 객체로 옮겨야 할 수도 있다. 이를 위해 두 곳에 있는 일부 중복 데이터는 놔두고그 데이터와 싱크를 유지해야할 수도 있다. 이것은 `관측 데이터 복제` 기법을 실시하면 해결된다.\n\n## 과다한 매개변수\n\n초보 시절 루틴에 필요한 모든 걸 매개변수를 사용해 전달하라고 배웠지만, 객체의 등장으로 인해 상황은 달라졌다.\n필요한 데이터가 없을 때는 그것을 가져오도록 항상 다른 객체에 요청하면 되기 때문이다. 그래서 객체를 사용할 때는 메서드에 필요한 모든 데이터를 전달하는 게 아니라 *그 모든 데이터를 가져올 수 있는 메서드만 전달*하면 된다. 메서드가 필요로 하는 각종 데이터는 그 메서드가 속한 클래스에 들어 있다.\n\n매개변수 세트가 간결하다는 것은 장점이다.\n\n이미 알고 있는 객체에 요청하여 한 매개변수에 들어있는 데이터를 가져올 수 있을 때는 `매개변수 세트를 메서드로 전환`을 적용하면 된다. 이 객체는 인스턴스 변수일 수도 있고 다른 매개변수일 수도 있다.\n객체에 있는 데이터 세트를 가져온 후, 데이터 세트를 그 객체 자체로 전환하려면 `객체를 통째로 전달`을 적용하면 된다.\n여러 데이터항목에 논리적 객체가 없다면 `매개변수 세트를 객체로 전환`을 적용하면 된다.\n\n이 기법들이 적용할 때 예외가 하나 있는데, 그것은 바로 호출되는 객체가 호출 객체에 의존하면 안 될 때다. 이럴 때는 데이터를 개별적으로 빼서 매개변수로 전달하는 것이 바람직하지만, 그렇게 하려면 어려움이 따른다. 나열된 매개변수 세트가 너무 길거나 자주 바뀐다면 불가피하게 종속 구조를 유지하는 것도 생각해야 한다.\n\n## 수정의 산발\n\n어떤 클래스를 보던 중 '새 데이터베이스를 생성할 때마다 이 3 개의 메서드를 수정해야 하고, 새 금융 상품을 추가할 때마다 이 4 개의 메서드를 수정해야 하네!' 하는 생각이 들면 그 하나의 클래스를 여러 개의 변형 객체로 분리하는 것이 좋다. 그러면 각 객체는 한 종류의 수정에 의해서만 변경된다.\n이렇게 변경할 때는 한 개의 클래스나 모듈만 변경해야 하며, 새 클래스나 모듈 안에는 반드시 그 변경사항을 표시해야 한다.\n이것을 정리하려면 특정 원인으로 인해 변하는 모든 부분을 찾은 후 `클래스 추출`을 적용해서 그 부분들을 합쳐 한 클래스로 빼내야 한다.\n\n## 기능의 산재\n\n기능의 산재는 수정의 산발과 비슷하지만 정 반대다. 수정할 때마다 여러 클래스에서 수많은 자잘한 부분을 고쳐야 한다면 이 문제를 의심할 수 있다. 수정할 부분이 여기저기에 있다면 찾기도 힘들 뿐더러 꼭 수정해야 하는 부분을 놓치기 쉽다.\n\n이럴 때는 `메서드 이동`과 `필드 이동`을 적용해서 수정할 부분들을 전부 하나의 클래스 안에 넣어야 한다.\n기존의 클래스 중 어느 것에 넣기에도 부적절해 보일 때는 새 클래스를 만들어야 한다. 대게는 `클래스 내용 직접 삽입`을 적용해서 별도 클래스에 분산되어 있던 모든 기능을 한 곳으로 가져와도 된다.\n\n## 잘못된 소속\n\n객체의 핵심은 데이터와 그 데이터에 사용되는 프로세스를 한 데 묶는 기술이라는 점이다. 전통적으로 어떤 메서드가 자신이 속하지 않은 클래스에 더 많이 접근한다면 잘못된 소속의 구린내가 풍길 것이다.\n\n소속이 잘못된 메서드는 더 많이 접근하는 클래스에 들어가는 것이 마땅하니, `메서드 이동`기법을 실시해서 더 자주 접근하는 클래스로 옮겨야 한다. 간혹 메서드의 일부분만 소속이 잘못된 경우도 있는데, 이럴 때는 그 부분에 `메서드 추출`을 적용한 후 `메서드 이동`을 적용해서 적절한 클래스로 옮기면 된다.\n\n이 규칙을 따르지 않는 복잡한 패턴도 일부 있다. `전략 패턴`과 `방문자 패턴`, `자가 위임 패턴`이 그렇다. 이 패턴들은 수정의 산발이 의심될 때 해결책으로 쓰인다. 기본 규칙은 함께 수정되는 것들을 하나로 뭉치는 것이다. 데이터와 그 데이터를 참조하는 기능은 대체로 함께 수정되지만 예외도 있다.\n그런 예외가 발생하는 기능은 옮겨서 한 곳에서 수정해야 한다. `전략 패턴`과 `방문자 패턴`은 재정의가 필요한 일부 기능을 따로 빼내기 때문에 기능을 수정하기는 쉬워지지만, 대신 인다이렉션이 늘어나는 단점이 있다.\n\n> 인다이렉션 (indirection, 간접접근) 은 코드에 있는 값을 바로 사용 하지 말고 그 값을 가리키는 포인터를 사용한라는 뜻의 단어.\n\n> 방문자 패턴은 각각의 Element 에 로직이 다른 visitor 가 들어가면(방문하면) Element 가 자기 자신을 넘기면서 visitor 가 공통으로 정해놓은 함수를 실행하게 된다. visitor.visit(this: Element), 자동차를 예를 들면 왼쪽 바퀴, 오른쪽 바퀴 하나 하나가 Element 로 생각하면 되고, visitor 는 만드는사람, 정비공 등등.. 이라고 생각하면 된다. 각각의 Element 들이 만드는 사람을 만나면 A 를 수행하게 될것이고 정비공을 만나면 B 를 수행하게 될것이다.\n\n## 데이터 뭉치\n\n두 클래스에 들어 있는 인스턴스 변수나 여러 메서드 시그니처에 들어 있는 매개변수처럼, 동일한 3~4 개의 데이터 항목이 여러 위치에 몰려 있는 경우가 많다. 이렇게 _몰려 있는 데이터 뭉치는 객체로 만들어야 한다._\n\n우선 데이터 뭉치가 필드처럼 보이는 부분을 찾아야 한다. 이 뭉치를 객체로 전환하려면 그 필드들을 대상으로 `클래스 추출` 기법을 사용해야 한다. 그러고 나서 메서드 시그니처를 대상으로 `매개변수 세트를 객체로 전환` 기법과 `객체를 통째로 전달` 기법을 적용하여 간결하게 만들어야 한다. 이렇게 하면 매개변수가 적어져서 부수적으로 메서드 호출 코드가 간결해지는 효과도 누릴 수 있다. 새로 생긴 객체의 속성들 중 일부만 이용하는 데이터 뭉치라 해도 이 방법으로 효과를 볼 수 있다. 둘 이상의 필드를 객체로 전환하면 코드가 개선된다.\n\n그러한 효과는 여러 데이터 값 중 하나를 삭제해보면 확실히 알 수 있다. 그렇게 했을 때 나머지 데이터 값들이 제대로 돌아가지 않는다면 그 객체를 없애고 새로 만들어야 한다.\n\n인스턴스 변수 세트와 매개변수 세트를 줄이면 분명히 의심되는 문제점도 없어지지만, 일단 객체로 전환하고 나면 전체적 성능이 개선될 여지도 있다. 이렇게 하고 나면 `잘못된 소속`의 구린내가 풍기는 부분들을 찾을 수 있는데, 이런 부분의 기능은 새 클래스로 빼내야 한다.\n\n## 강박적 기본 타입 사용\n\n대개의 프로그래밍 환경을 구성하는 데이터는 두 종류다. 하나는 레코드 타입인데, 이것을 사용해서 데이터를 의미 있는 그룹들로 묶어 구조화할 수 있다. 기본 타입은 한마디로 초석이라고 할 수 있다. 레코드에는 항상 일정 양의 오버헤드가 따른다. 여기서 레코드란 데이터베이스 테이블일 수도 있지만, 그 외의 것이라면 한두 가지 목적만을 위해 생성하기엔 어중간할 수도 있다.\n\n객체의 주요 장점 중 하나가 바로 기본 타입 클래스와 응용 클래스 간의 경계를 허문다는 점이다. 언어에 내장된 기본 타입과 구별하기 힘든 작은 클래스를 손쉽게 작성할 수 있다.\n\n객체를 처음 접하는 사람은 보통 숫자와 통화를 연동하는 돈 관련 클래스나 전화번호와 우편번호 같은 특수 문자열 클래스등의 사소한 작업에는 작은 객체를 잘 사용하지 않으려는 경향이 있다. 이러한 우물 안 개구리를 벗어나려면 `데이터 값을 객체로 전환(값 객체로 전환)`을 실시하면 된다. 데이터 값이 분류 부호일 땐 그 값이 기능에 영향을 주지 않는다면 `분류 부호를 클래스로 전환`을 실시하자. 그리고 조건문에 분류 부호가 사용될 땐 `분류 부호를 하위클래스로 전환` 기법이나 `분류 부호를 상태/전략 패턴`으로 전환 기법을 적용하자.\n\n뭉쳐 다녀야 할 여러 개의 필드가 있다면 `클래스 추출` 기법을 적용해야 한다. 이런 기본 타입이 매개변수 세트에 들어 있다면 `매개변수 세트를 객체로 전환` 기법을 적용하면 된다. 배열 때문에 불편하다면 `배열을 객체로 전환` 기법을 적용하면 된다.\n\n## switch 문\n\n객체지향 코드의 확연한 특징 중 하나는 switch-case 문이 비교적 적게 사용된다는 점이다.\nswitch 문의 단점은 반드시 중복이 생긴다는 점이다. 같은 switch 문이 프로그램 곳곳에 있을 때가 많다.\n\n이 문제점을 해결할 수 있는 최상의 방법은 객체지향 개념 중 하나인 다형성, 즉 재정의를 이용하는 것이다.\n대부분의 switch 문은 고민할 필요 없이 재정의로 바꿔야 한다. 문제는 재정의를 넣을 위치다.\n\nswitch 문에는 분류 부호가 흔히 사용되는데, 그럴 땐 분류 부호 값이 들어 있는 메서드나 클래스가 있어야 한다.\n이럴 때는 `메서드 추출`을 실시해서 swtich 문을 메서드로 빼낸 후 `메서드 이동`을 실시해서 그 메서드를 재정의해야 할 클래스에 옮겨 넣으면 된다.\n\n그와 동시에 `분류 부호를 하위클래스로 전환` 기법과 `분류 부호를 상태/전략 패턴으로 전환` 기법 중 어느 것을 적용할지 판단해야 한다. 상속 구조를 만들었다면 `조건문을 재정의로 전환` 기법을 적용하면 된다.\n\n하나의 메서드에 영향을 미치는 case 문이 2~3 개 밖에 없고 나중에 그 모든 case 문을 수정할 일이 없을 것 같으면, 재정의로 전환하는 것은 과하다. 그럴 때는 `매개변수를 메서드로 전환`을 적용하는 편이 낫다. 조건문이 들어 있는 여러 case 문 중 하나가 널일 때는 `Null 검사를 널 객체에 위임`을 실시하면 된다.\n\n## 평행 상속 계층\n\n평행 상속 계층은 사실 `기능의 산재`의 특수한 상황이다. 이 문제점이 있으면 한 클래스의 하위클래스를 만들 때마다 매번 다른 클래스의 하위클래스도 만들어야 한다. 서로 다른 두 상속 계층의 클래스명 접두어가 같으면 이 문제를 의심할 수 있다.\n\n중복 코드 부분을 제거하려면 보통은 한 상속 계층의 인스턴스가 다른 상속 계층의 인스턴스를 참조하게 만들면 된다.\n`메서드 이동`과 `필드 이동`을 실시하면 참조하는 클래스에 있는 계층이 제거된다.\n\n## 직무유기 클래스\n\n하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다. 따라서 비용만큼의 기능을 수행하지 못하는 비효율적 클래스는 없애야 한다. 기존에는 비용 대비 효율성이 좋았으나 리팩토링 실시로 인해 기능이 축소된 클래스, 또는 수정할 계획으로 작성했으나 수정을 실시하지 않아 쓸모없어진 클래스가 바로 이런 직무유기 클래스에 해당된다.\n\n비용 대비 효율이 떨어지는 하위클래스나 모듈이 있을 때는 `계층 병합`을 실시하면 된다. 거의 쓸모없는 구성요소에는 `클래스 내용 직접 삽입`이나 `모듈 내용 직접 삽입` 기법을 적용해야 한다.\n\n## 막연한 범용 코드\n\n'그래, 조만간 이런 기능이 필요하겠구만'하는 막연한 생각에 아직은 필요 없는 기능을 수행하고자 온갖 호출과 case 문을 넣으려 하는 그 순간 막연한 범용 코드의 구린내가 풍긴다.\n\n별다른 기능이 없는 클래스나 모듈이 있다면 `계층 병합`을 실시해야하고 불필요한 위임을 제거하려면 `클래스 내용 직접 삽입을 실시`해야 한다. 메서드에 사용되지 않는 매개변수가 있으면 `매개변수 제거`를 실시해야 하며, 메서드명이 이상하다면 `메서드명 변경`을 실시해야 한다.\n\n## 임시 필드\n\n어떤 객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹 있다. 개발자는 객체가 그 안에 들어 있는 모든 변수를 이용하리라 생각하기 마련이므로 이런 코드는 파악하기 힘들다. 사용되지 않을 것 같은 변수가 어째서 거기 있는지 이해하려다 보면 스트레스를 받을 수 밖에 없다.\n\n이런 가엾은 떠돌이 변수들이 서식할 집을 마련해 주려면 `클래스 추출`을 실시해야 한다. 그렇게 작성한 클래스에 그 변수들과 관련된 코드를 전부 넣어야 한다. Null 검사를 `널 객체에 위임`을 실시해서 그 변수들의 값이 올바르지 않을 경우를 대비한 대체 컴포넌트를 작성하면 경우에 따라 조건문 코드를 없앨 수 있다.\n\n개발자는 수많은 매개변수를 전달하는 것을 꺼린 나머지, 매개변수를 필드에 대입한다. 그런데 이 인스턴스 변수는 해당 알고리즘이 실행되는 동안에만 효력이 있고 다른 때는 코드를 복잡하게 만들 뿐이다. 이럴 때는 인스턴스 변수와 그 변수를 사용하는 메서드 전부에 대해 `클래스 추출`을 적용하면 된다. 그러면 `메서드 객체`가 새로 생성된다.\n\n## 메시지 체인\n\n메시지 체인은 클라이언트가 한 객체에 제 2 의 객체를 요청하면, 제 2 의 객체가 제 3 의 객체를 요청하고, 제 3 의 객체가 제 4 의 객체를 요청하는 식으로 연쇄적 요청이 발생하는 문제점을 뜻한다. 이러한 메시지 체인은 수많은 코드 행이 든 getThis 메서드나 임시변수 세트라고 봐도 된다. 이런 요청의 왕래로 인해 클라이언트는 그 왕래 체제에 구속된다. 그 사이의 관계들에 수정이 발생할 때마다 클라이언트도 수정해야 한다.\n\n이럴 때는 대리 `객체 은폐`를 실시해야 한다. 이 기법은 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 그렇게 하면 모든 중간 객체가 중개 메서드로 변해서 `과잉중개 메서드`의 구린내를 풍기는 문제가 흔히 발생한다.\n그래서 차라리 결과 객체가 어느 대상에 사용되는지를 알아내는 방법이 더 낫다. 그렇게 알아낸 객체가 사용되는 코드 부분을 `메서드 추출`을 통해 별도의 메서드로 빼낸 후 `메서드 이동`을 실시해서 체인 아래로 밀어낼 수 있는지 여부를 검사해야 한다.\n만약 체인에 속한 객체 중 한 객체의 여러 클라이언트가 나머지 객체들에 왕래한다면 그 기능을 수행하는 메서드를 추가하면 된다.\n\n## 과잉 중개 메서드\n\n객체의 주요 특징 한가지는 바로 캡슐화다. 캑슐화란 내부의 세부적인 처리를 외부에서 볼 수 없게 은폐하는 작업을 뜻한다. 캡슐화할 때는 대게 위임이 수반된다. 직원이 부장에게 회의 참석이 가능한지 물어보면, 부장은 그 내용을 자신의 다이어리에 위임하고 직원에게 대답한다. 이 얼마나 깔끔한 절차인가! 부장이 다이어리를 사용하는지, PDA 를 이용하는지, 비서에게 챙기라고 지시하는지 알 필요도 없으니 말이다.\n\n그러나 이것도 지나치면 문제가 된다. 어떤 클래스의 인터페이스를 보니까 그 안의 절반도 넘는 메서드가 기능을 다른 클래스에 위임하고 있다면, 조만간 `과잉 중개 메서드 제거`를 실시해서 원리가 구현된 객체에 직접 접근하자. 일부 메서드에 별 기능이 없다면 `메서드 내용 직접 삽입`을 실시해서 그 메서드들의 내용을 호출 객체에 직접 삽입하게 하면 된다.\n부수적인 기능이 있다면 `위임을 상속으로 전환 기법`을 실시해서 중개 메서드를 실제 객체의 하위클래스로 전환하면 된다. 이렇게 하면 모든 위임을 추적하지 않고 기능을 확장할 수 있다.\n\n## 지나친 관여\n\n간혹 클래스끼리 관계가 지나치게 밀접한 나머지 서로의 은밀한 부분을 알아내느라 과도한 시간을 낭비하게 될 때가 있다.\n\n서로 지나치게 관여하는 클래스는 고전에 나오는 비운의 연인처럼 갈라놔야 한다. `메서드 이동`과 `필드 이동`을 실시해서 각 클래스를 분리해서 지나친 관여를 줄여야 한다. `클래스의 양방향 연결을 단방향으로 전환`기법을 적용할 수 있는지 판단해서 만약 해당 클래스들이 공통으로 필요로 하는 부분이 있다면, `클래스 추출`을 실시해서 공통 필요 부분을 별도의 안전한 클래스로 빼내면 된다. 아니면 `대리 객체 은폐`를 실시하여 다른 클래스가 중개 메서드 역할을 하게 만들어도 된다.\n\n상속으로 인해 지나친 관여가 발생하는 경우가 많다. 하위클래스는 항상 상위클래스가 공개하는 것보다 많은 데이터를 필요로 한다. 상위클래스에서 하위클래스를 빼내야 할 경우에는 `상속을 위임으로 전환 기법`을 적용해야 한다.\n\n## 인터페이스가 다른 대용 클래스\n\n기능은 같은데 시그니처가 다른메서드에는 `메서드 변경`을 실시해야 한다.\n클래스에 여전히 충분한 기능이 구현되어 있지 않기 때문에 대체로 이 기법만 적용해선 충분하지 않다.\n프로토콜이 같아질 때까지 `메서드 이동`을 실시해서 기능을 해당 클래스로 옮겨야 한다. 단, 코드를 너무 어려 번 옮겨야 한다면 `상위클래스 추출`을 실시하면 된다.\n\n> 시그니처란 함수의 원형에서 함수와 인자들의 이름을 제외한 나머지를 시그니처라고 부른다. (ex. sum2(int, int, double)) 시그니처는 다음을 포함한다. parameters 와 그들의 types , 반환값과 타입, 던져지거나 콜백으로 반환되는 exceptions, object-oriented 프로그램에서 메서드의 접근 권한에 대한 정보 (public, static, or prototypes) : https://developer.mozilla.org/ko/docs/Glossary/Signature/Function\n\n## 미흡한 라이브러리 클래스\n\n많은 이들이 재사용을 객체의 목적이라고 생각하는데, 그게 재사용을 과대평가해서 나온 생각인거 같다. 물론 프로그래머가 단순 정렬 알고리즘도 잊어버릴 정도로 라이브러리 클래스에 의존한다는 점은 부인할 수 없다.\n\n라이브러리 클래스 제작자라 해도 모든 걸 알 수는 없다. 자신이 직접 대부분의 라이브러리 클래스를 완성하지 않는 이상 설계를 파악한다는 것이 거의 불가능하다는 점에서, 라이브러리 제작자라는 직업은 그만큼 힘들다. 문제는 라이브러리 클래스를 원하는 기능을 수행하게 수정하는 것이 보통은 불가능하다는 것이다. 이 때문에 `메서드 이동` 같은 검증된 방법이 무용지물이 된다.\n\n이 문제를 해결하기 위한 특수 목적의 기법이 두 개 있다. 라이브러리 클래스에 넣어야 할 메서드가 두 개뿐이라면 `외래 클래스에 메서드 추가` 기법을 실시하고, 부가 기능이 많을 때는 `국소적 상속확장 클래스 사용` 기법을 실시하자.\n\n## 데이터 클래스\n\n_데이터 클래스는 필드와 필드 읽기/쓰기 메서드만 들어 있는 클래스다._ 그런 클래스는 오로지 데이터 보관만 담당하며, 거의 대부분의 구체적 데이터 조작은 다른 클래스가 수행한다. 처음엔 이 클래스들은 어쩌면 public 필드였을 수도 있다. 만일 그렇다면 누군가가 제보하기 전에 즉시 `필드 캡슐화 기법`을 실시해야 한다. 컬렉션 필드가 있으면 그 필드가 적절히 캡슐화되어 있는지 확인해서 캡슐화되어 있지 않다면 `컬렉션 캡슐화 기법`을 적용하자. 변경되지 않아야 하는 필드에는 `쓰기 메서드 제거`를 적용하자.\n\n이런 읽기/쓰기 메서드가 다른 클래스에 의해 사용되는 부분을 찾아서, `메서드 이동`을 실시하여 기능을 그 데이터 클래스로 옮겨야 한다. 만약 메서드 전체를 옮길 수 없다면 `메서드 추출`을 실시해서 옮길 수 있는 메서드를 작성하면 된다. 그러고 나서 읽기/쓰기 메서드에 `메서드 은폐`를 적용하면 된다.\n\n데이터 클래스는 어린애 같아서 처음엔 괜찮지만, 성숙한 객체로서의 역할을 하려면 어느 정도의 책임을 감당해야 한다.\n\n## 방치된 상속물\n\n하위클래스는 부모 클래스의 메서드와 데이터를 상속받는다. 그런데 그렇게 상속받은 메서드나 데이터가 하위클래스에서 더 이상 쓰이지 않거나 필요 없을 땐 어떻게 될까? 그럴 경우 하위클래스는 상속물을 전부 받아 그 중에서 필요한 것 외엔 방치해버리는 문제가 생긴다.\n\n기존에는 이 문제의 원인이 잘못된 계층구조 때문이라고 설명했다. 이럴 경우, 새 대등 클래스를 작성하고 메서드 하향과 필드 하향 실시해서 사용되지 않는 모든 메서드를 그 형제 클래스에 몰아넣어야 한다. 이렇게 하면 상위클래스에는 공통 코드만 들어 있게 된다.\n\n위에서 '기존에는'이라는 한정적 표현을 사용했는데, 앞으로는 앞의 문제점을 최소한의 경우에만 지적할 것임을 암시한다.\n일부 기능을 언제든 재사용하고자 하위클래스로 몰아 넣는 작업을 하는데, 이 방법이 매우 효과적임을 깨닫곤 한다. 그래서 방치된 상속물로 인해 코드가 복잡해지거나 문제가 생길 때는 위에서 설명한 기존 방법을 따르길 권한다. 그러나 이 방법을 항상 반드시 적용해야 하는 것은 아니다. 이 문제는 심각하지 않은 경우가 대부분이기 때문에 리팩토링이 별로 필요하지 않다.\n\n방치된 상속물의 구린내는 하위클래스가 기능은 재사용하지만 상위클래스의 인터페이스를 지원하지 않을 때 훨씬 심하게 풍긴다. 상속구현을 거부하는 것은 상관없지만, 인터페이스를 거부하는 것은 심각한 문제다. 하지만 그렇다고 계층구조를 건드려서는 안 되고, `상속을 위임으로 전환` 기법을 적용해서 계층구조를 없애야 한다.\n\n## 불필요한 주석\n\n어떤 코드 구간의 기능을 설명할 주석이 필요할 때는 메서드 추출을 실시해야 한다.\n메서드가 이미 추출된 상태임에도 기능을 설명할 주석이 여전히 필요하다면, 메서드명 변경을 실시해야 한다. 시스템의 필수적인 상태에 관해 약간의 규칙을 설명해야 할 때는 어설션 넣기를 실시하면 된다.\n\n_주석을 넣어야겠다는 생각이 들 땐 먼저 코드를 리팩토링해서 주석을 없앨 수 있게 만들어라_\n\n주석은 무슨 작업을 해야 좋을지 모를 때만 넣는 것이 좋다. 주석을 넣으면 돌아가는 원리를 적어둘 수도 있고 확실치 않은 부분을 표시할 수도 있다. 어떤 코드를 넣은 이유를 메모해 놓을 경우에도 주석을 넣는 것이 적절하다. 이런 정보나 특히 잊기 쉬운 사항을 주석으로 작성해 놓으면 나중에 수정하게 될 사람들이 보고 쉽게 이해할 수 있다.\n","excerpt":"중복 코드 중복 코드의 가장 단순한 예는 한 클래스의 두 메서드 안에 같은 코드가 들어 있는 경우 이다.\n이럴땐  기법을 적용해서 겹치는 코드를 빼내어 별도의 메서드로 만들고 그 메서드를 두곳에서 호출하면 된다. 또 다른 상황은 한 클래스의 두 하위…","fields":{"slug":"/refactoring.md/"},"frontmatter":{"date":"May 10, 2019","title":"(리팩토링) 리팩토링 요점 정리","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 고전적인 방법\n\n나쁜 예\n\n```javascript\nfunction handleClick(event) {\n  var popup = document.getElementById('popup')\n  popup.style.left = event.clientX + 'px'\n  popup.style.top = event.clientY + 'px'\n  popup.className = 'reveal'\n}\n\naddListener(element, 'click', handleClick)\n```\n\n위 예제는 이벤트 객체에서 clientX, clientY 프로퍼티만 사용한다. 이 코드만 으로는 간단하고 문제 없어 보이지만, 실제 활용하기에는 제한 사항이 많아서 사용하기 어려운 나쁜 패턴이다.\n\n### 규칙 1. 애플리케이션 로직을 분리한다.\n\n위 예제는 이벤트 핸들러가 애플리케이션 로직을 포함하는 문제가 있다. \n애플리케이션 로직은 사용자의 액션보다는 애플맄메이션 자체에 대한 기능을 다루어야 합니다. 그런데 위 코드의 애플리케이션 로직은 팝업창을 특정 위치에 보여주고 있다. 이 코드가 다른 곳에서도 필요할 수도 있다.\n나중에 다른 사용자가 액션에서 이 로직이 필요하면 재사용할 수 있어야 하므로 이벤트 핸들러에서 애플리케이션 로직은 무조건 분리해야 한다.\n\n예를 들면 나중에 클릭할 때뿐만 아니라 특정 요소 위에서 커서가 움직이거나 키보드의 특정 키를 눌렀을 때도 팝업창을 나타나게 해야하는데 이때 실수로 다른 이벤트에 마우스 클릭 이벤트에 맞춰 개발된 핸들러를 등록 하는 일이 생길 수도 있다.\n\n또 이벤트 핸들러에 애플리케이션 로직이 있으면 테스트 하기 어려워 진다. \n\n```javascript\n// 더 나은 방법\nvar Myapp = {\n  handleClick: function(event) {\n    this.showPopup(event)\n  }\n\n  showPopup: function (event) {\n    var popup = document.getElementById('popup')\n    popup.style.left = event.clientX + 'px'\n    popup.style.top = event.clientY + 'px'\n    popup.className = 'reveal'\n  }\n}\n\naddListener(element, 'click', function(event) {\n  Myapp.handleClick(event)\n})\n```\n\n### 규칙 2. 이벤트 객체를 바로 전달하지 않는다.\n\n이벤트 객체에는 수많은 이벤트 정보가 있지만 이 코드에서는 그중 단 두개만 사용합니다. 애플리케이션 로직은 다음과 같은 이유로 event 객체에 의존해서는 안됩니다.\n\n- 메서드의 인터페이스만 봐서는 어떤 데이터가 필요한지 알기 어렵다. 좋은 API는 자신이 어떤 데이터가 필요한지 명확하게 나타낼 수 있어야 합니다. event 객체를 인자로 넘기는 방법으로는 이 메서드에서 필요한 데이터가 무엇인지 알 수 없습니다.\n- 같은 맥락으로, 메서드를 테스트할 때 event 객체를 새로 만들어야 합니다. 테스트를 정확하게 하려면 메서드에서 필요한 데이터가 무엇인지 확실하게 알아야 합니다.\n\n```javascript\nvar Myapp = {\n  handleClick: function(event) {\n\n    event.preventDefault()\n    event.stopPropagation()\n    \n    this.showPopup(event.clientX, event.clientY)\n  }\n  // 어플리케이션 로직\n  showPopup: function (x, y) {\n    var popup = document.getElementById('popup')\n    popup.style.left = x+ 'px'\n    popup.style.top = y + 'px'\n    popup.className = 'reveal'\n  }\n}\n\naddListener(element, 'click', function(event) {\n  Myapp.handleClick(event)\n})\n```\n","excerpt":"고전적인 방법 나쁜 예 위 예제는 이벤트 객체에서 clientX, clientY 프로퍼티만 사용한다. 이 코드만 으로는 간단하고 문제 없어 보이지만, 실제 활용하기에는 제한 사항이 많아서 사용하기 어려운 나쁜 패턴이다. 규칙 1. 애플리케이션 로직을…","fields":{"slug":"/event-handling/"},"frontmatter":{"date":"May 02, 2019","title":"(읽기 쉬운 자바스크립트) 이벤트 처리","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 에러의 본질\n\n프로그래밍 언어는 코드가 정해진 기본 규칙에서 벗어나면 개발자에게 코드를 수정하라는 의미로 에러를 발생합니다.\n만약 에러가 발생하지 않고 개발자에게 알려주지도 않으면 디버깅은 거의 불가능해지며 에러 수정은 고사하고 문제 발생을 알아차리기까지 한참이 걸릴 수 있습니다.\n\n### 에러 던지기\n\nthrow 연산자에 에러로 던질 객체를 넣으면 에러를 발생시킬 수 있습니다. 어느 타입의 객체든 에러로 던질 수 있지만, 보통 Error 객체를 가장 많이 사용한다.\n\n```javascript\nthrow new Error('에러예요')\n```\n\n기본 내장된 Error 생성자는 에러 메시지를 인자로 받습니다. \n브라우저마다 에러 표시 방법이 다르지만 모든 브라우저에서 확실하게 사용자 에러 메시지를 보여주는 방법은 Error 객체를 사용하는 것이다.\n\n### 에러는 언제 던져야 할까\n\n자바스크립트는 타입이나 인자 값 검사가 없어 많은 개발자가 모든 함수에서 타입 검사를 해야 한다고 잘못 알고 있습니다. 이렇게 코드를 작성하면 실용적이지도 않고 스크립트의 전체적인 성능에 악영향을 줄 수 있습니다.\n\n물론 정적 프로그래밍 언어를 따라해 모든 함수의 인자 값 검사를 하는 것이 좋다고 생각할 수 있지만, 너무 지나칠 수 있다. 실행 중 실패하거나 에러가 발생할 여지가 있는 곳을 찾는 것이 핵심이다. 즉, 에러가 이미 발생한 곳에서만 에러를 던집니다. \n\n```javascript\n// 나쁜 예\n\nfunction addClass(element, className) {\n  if(!element || typeof element.className !== 'string') {\n    throw new Error('addClass(): First argument must be a DOM element')\n  }\n  if(typeof className !== 'string') {\n    throw new Error('addClass(): Second argument must be a string')\n  }\n\n  element.className += ' ' + className\n}\n```\n\n두 번째 인자는 null, 숫자, 불린이 와도 이를 문자열로 반환하여 에러가 발생되지는 않는다. 하여 첫 번째 인자인 DOM 요소에 대한 값만 검사하면 된다.\n\n```javascript\n\nfunction addClass(element, className) {\n  if(!element || typeof element.className !== 'string') {\n    throw new Error('addClass(): First argument must be a DOM element')\n  }\n  element.className += ' ' + className\n}\n```\n\n물론 외부에서 접근할 수 없는 비공개 함수에서만 가능한 일이지만 함수에 어떤 html 엔티티가 들어올지 알고 있을때는 사실상 에러 검사가 필요 없다. \n하지만 어디서 함수를 호출할지 미리 알 수 없으면 에러 검사를 해서 에러를 던지도록 코드를 작성하면 여러모로 이점이 많습니다.\naddClass() 함수와 같은 유틸리티 성격의 함수는 자바스크립트 라이브러리처럼 보편적인 스크립트 환경에서 동작해야 하고 많은 곳에서 호출하는 함수이므로 에러를 던지기 적합하다.\n\n외부에서 접근 가능한 공개 인터페이스를 작성할 때, 예측할 수 있는 모든 에러 발생 상황에서 에러를 던지도록 코드를 작성해야 한다. \n큰 규모의 라이브러리에서는 우리가 언제, 어디서 함수를 호출할지 모든 경우의 수를 예측하는 건 불가능하다. 그래도 사용자가 무엇이 잘못되었는지 원인을 찾으러 라이브러리 코드까지 디버깅 하는 일은 없어야 하기에 우리가 '삽질'을 하고 있으면 라이브러리는 우리가 잘못하고 있다고 알려주어야 합니다.\n에러의 호출 스택은 라이브러리의 인터페이스에서 끝나야지 더 깊게 들어가서는 안된다. \n\n라이브러리의 목표는 개발자를 조금 더 편하게 해주는 것이며 이 목표는 지저분한 세부 구현 사항을 추상화시켜 개발자에게 제공하면 달성할 수 있다. \n이때, 지저분한 세부 구현사항을 개발자로부터 안전하게 숨기려면 에러를 던지도록 코드를 작성하면 된다. \n\n에러를 던질 때 추천하는 좋은 방법이 몇 가지 있다.\n\n- 디버깅하기 어려운 에러를 수정하면 거기에 사용자 정의 에러를 추가하자.문제가 다시 발생하면 해결하는데 큰 도움이 된다.\n- 코드를 작성할 때, 발생하면 안된다고 생각하는 일이 발생하면 에러를 던진다. ( 예를 들어 두 수를 나누는 함수가 있는데 분모의 값이 0으로 입력된 경우에 에러를 던진다.)\n- 모르는 사람이 사용할 코드를 작성할 때는 함수를 잘못 사용할 수 있는 경우를 생각해보고 그 경우에 에러를 던지도록 코드를 작성하자. \n\n\n### try...catch...finally\n\nfinally 절은 다루기에 살짝 까다로울 때가 있다. 예를 들어 try 절에 return 문이 있으면 finally 절이 실행된 후에야 return 문이 실행된다. \n\n### throw를 쓸 것인가 try...catch를 쓸 것인가.\n\n에러는 애플리케이션 스택의 가장 깊은 곳인 자바스크립트 라이브러리에서 발생시켜야 한다. 애플리케이션 로직을 다루는 코드에서는 라이브러리에서 던진 에러를 잡아서 잘 처리할 수 있어야 하므로 에러 처리 기능을 잘 갖춰야 한다. \n<br />\n에러 처리를 잘하려면 애플리케이션 로직을 작성할 때 왜 이함수를 호출하는지 알아야 합니다. \ncatch 절이 비어있는 try...catch는 코드 상에 절대 있으면 안 되고 어떠한 방식으로든 에러 처리를 해야 합니다. \n에러가 발생하면 어떻게 에러를 복구할지도 생각해 두어야 한다.\n\n\n\n\n\n","excerpt":"에러의 본질 프로그래밍 언어는 코드가 정해진 기본 규칙에서 벗어나면 개발자에게 코드를 수정하라는 의미로 에러를 발생합니다.\n만약 에러가 발생하지 않고 개발자에게 알려주지도 않으면 디버깅은 거의 불가능해지며 에러 수정은 고사하고 문제 발생을 알아차리기…","fields":{"slug":"/user-error-throwing/"},"frontmatter":{"date":"May 02, 2019","title":"(읽기 쉬운 자바스크립트) 사용자 에러 던지기","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n변수에 필요한 값이 할당되었는지 확인할 때 `null`과 비교하는 방법은 흔히 잘못 사용하는 패턴이다.\n\n```javascript\nvar Controller = {\n  process: function(items) {\n    if(items !== null) {\n      items.sort()\n      items.forEach(function(itme) {\n        // do Something...\n      })\n    }\n  }\n}\n```\n\n위 코드는 items 변수에 sort() 와 forEach() 를 사용하는 것을 보아 items 변수가 배열이라는 전제하에 작성한 코드인 듯합니다. \n코드 의도는 명확하지만, items 변수가 배열이 아니면 로직을 수행할 수 없습니다. \n\n변수를 단순히 null과 비교하면 변수 값에 대한 정보가 부족해 로직을 계속 진행해도 안전한지 알 수 없습니다. 다행이 자바스크립트는 변수에 원하는 값이 할당되었는지 확인하는 방법을 다양하게 제공합니다.\n\n## 기본 데이터 타입 알아내기\n\n- typeof를 문자열에 사용하면 'string'을 반환합니다.\n- typeof를 숫자에 사용하면 'number'을 반환합니다.\n- typeof를 불린에 사용하면 'boolean'을 반환합니다.\n- typeof를 undefined에 사용하면 'undefined'을 반환합니다.\n\ntypeof 연산자는 선언되지 않은 변수에 사용해도 에러가 발생하지 않습니다. 선언한 변수이든, 선언하지 않은 변수이든 값이 undefined이면 둘다 'undefined'로 반환합니다.\n\nnull은 변수에 값이 할당되었는지 확인할 때 사용하면 안됩니다. 단순히 변수를 null 값으로만 비교하면 무슨 값을 원하는지 알 수 없습니다. \n단, null 비교가 허용되는 예외 사항이 있는데 기대 하는 값이 정말 null 이라면 null을 직접 사용해도 됩니다. 여기서 null 값과 비교할 때는 반드시 비교 연산자로 === 또는 !== 을 사용해야 합니다.\n\n```javascript\nvar element = document.getElementyById('my-div')\nif( element !== null ) {\n  element.className = 'found'\n}\n```\n\n위 코드에서는 조건에 맞는 DOM 요소가 없으면 document.getElementById() 메서드는 실제로 null을 반환합니다. 이 메서드는 확실히 null을 반환하거나 요소를 반환합니다. \nnull은 기대하던 값중 하나이므로 !== 연산자를 사용해 null 과 비교해도 됩니다. \n\n## 객체 참조 타입 알아내기\n\n참조 타입이 무엇인지 판단하려면 `instanceof` 연산자를 사용합니다.\n\n```javascript\n값 instanceof todtjdwkaud\n```\n\n```javascript\n// Date 객체인지 확인\nif(value instanceof Date) {\n  console.log(value.getFullYear())\n}\n\nif(value instanceof Error) {\n  throw valeu\n}\n```\n\n`instanceof` 연산자는 객체를 생성할 때 사용한 생성자뿐만 아니라 프로토타입 체인도 같이 검사를 합니다.\n\n```javascript\nvar now = new Date()\n\nconsole.log(now instanceof Object) // true\nconsole.log(now instanceof Date) // true\n```\n\n### 함수 알아내기\n\n```javascript\nfunction myFunc() {}\n\n// 권장\nconsole.log(typeof myFunc === 'function') // true\n\n// IE 하위에는 querySelectorAll typeof로 확인시 'object'로 뜸\n// DOM 메서드 인지 확인\nif('querySelectorAll' in document) {\n  images = document.querySelectorAll('img')\n}\n```\n\n### 배열 알아내기\n\n프레임 간 배열을 전달할 때 instanceof Array를 사용하면 결과 값이 잘못 나온다. 각 프레임이 각각 Array 생성자를 가지고 있고 한 프레임의 인스턴스는 다른 프레임에서 인식할 수 없기 때문이다. \n그래서 더글라스 크락포드는 덕 타이핑을 권장했는데, 이는 sort() 메서드가 있는지만 확인하는 방법이다.\n\n```javascript\n// arrays 덕 타이핑\nfunction isArray(value) {\n  return typeof value.sort === 'function'\n})\n```\n\n배열 타입인지 정확하게 알아내기 위해서는 수많은 검사를 해야하지만 Kangax라고 알려진 유리 자이체프는 다음과 같은 명쾌한 해결책을 내놨다.\n\n```javascript\nfunction isArray(value) {\n  return Object.prototype.toString.call(value) === '[object Array]'\n})\n```\n\n### 프로퍼티 알아내기 \n\n객체에 프로퍼티가 있는지 확인할 때 보통 null이나 undefined를 자주 사용한다.\n하지만 이는 버그를 유발 할 수 있다.\n\n프로퍼티가 존재하는지 확인할 때는 in 연산자를 사용하는 것이 가장 좋다.\n상속받는 프로퍼티는 제외하고 객체 인스턴스에 프로퍼티가 있는지 검사하려면 hasOwnProperty() 메서드를 사용한다. \n참고로 IE8 이하 버전의 DOM 객체는 Object를 상속받지 않아 hasOwnProperty() 메서드가 없다. \n\n```javascript\nif('related' in object){\n  if(object.hasOwnProperty('related')) {\n    // do Something..\n  }\n}\n```\n\n","excerpt":"변수에 필요한 값이 할당되었는지 확인할 때 과 비교하는 방법은 흔히 잘못 사용하는 패턴이다. 위 코드는 items 변수에 sort() 와 forEach() 를 사용하는 것을 보아 items 변수가 배열이라는 전제하에 작성한 코드인 듯합니다. \n코드 …","fields":{"slug":"/no-null-comparison/"},"frontmatter":{"date":"May 02, 2019","title":"(읽기 쉬운 자바스크립트) null 비교 금지","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n해당 글은 `리팩토링 (코드 품질을 개선하는 객체지향 사고법)` 에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다.\n\n# 상속 구조 정리\n\n하나의 상속 계층이 두 작업을 동시에 수행할 땐 상속 계층을 하나 더 만들어서 위임을 통해 다른 계층을 호출하자.\n\n상속구조로 만들면 하위클래스 안에 작성할 코드가 상당히 줄어든다.\n메서드 하나는 비록 크기는 작지만 상속 계층에 들어 있다는 것만으로 상당히 중요하다.\n\n이것을 오용하게 되면 모르는 사이 쌓여간다. 사소한 기능의 작은 하위클래스를 하나 추가하고, 다음 날은 계층구조의 다른 부분을 같은 기능의 다른 하위클래스를 몇 개 추가하는 식으로 하다가, 나중에는 상속 구조를 풀기 힘들 정도로 복잡하게 얽힌다.\n\n개발자는 \"이 계층구조가 여기서 결과를 산출한다\" 라고 추상적으로 말해선 안 되고, \"이 계층구조가 결과를 산출하고, 표 형태로 출력하는 하위클래스들이 있고, 그 하위엔 국가를 구별하는 하위클래스가 있다.\" 라고 섬세하게 이야기 해야한다.\n\n계층구조의 특정 계층에 있는 모든 클래스의 하위클래스들이 이름 앞에 같은 형용사가 붙어 있다면 한 계층으로 두 개능을 수행하는 것이다.\n\n### 예제\n\n복잡하게 얽힌 계층 구조 예제는 다음과 같다.\n\n```javascript\nclass Deal {}\n// 거래유형\nclass ActiveDeal extends Deal {}\nclass PassiveDeal extends Deal {}\n// 표현 스타일\nclass TabularActiveDeal extends ActiveDeal {} // 각각의 거래를 표로 표현\nclass TabularPassiveDeal extends PassiveDeal {}\n```\n\n이 계층구조는 Deal 이 원래 하나의 거래를 표시하는 용도로만 사용되다 보니 이렇게 된것이다.\n이후에 누군가가 *여러 개의 거래*를 *하나의 표*로 표시하면 좋겠다는 아이디어를 떠올려서 작성한 구조이다.\n\n간단한 하위클래스 `ActiveDeal`을 작성해서 실험해보면 정말 사소한 작업으로 표 형식을 표시할 수 있음을 알게 된다.\n`PassiveDeal`의 표를 표시하는 것도 문제 없다. 작은 하위클래스를 하나 더 작성하면 된다.\n\n이렇게 작성하다 표현 스타일에서 중복코드가 생겨서 문제가 생겨 복잡하다.\n두달 후 표 코드는 복잡해졌지만, 늘 그렇듯이 그 코드를 간단히 넣을 곳이 없고 시간은 촉박하다. 표현 로직과 엉켜서 이제 새로운 종류의 Deal 을 추가하기가 어려워졌다.\n\n이 문제를 해결하기 위해선 이 상황에서 우선 상속 계층에 의해 처리되는 기능들을 확인하자.\n첫번째 기능은 거래 유형에 따른 변화를 감지하는 것이고, 두번째 기능은 표현 스타일에 따른 변화를 감지하는 것이다.\n\n| Deal         | Active Deal | Passive Deal |\n| ------------ | ----------- | ------------ |\n| Tabular Deal |             |              |\n\n물건 거래가 표현 스타일보다 훨씬 중요하므로 Deal 만 남겨두고 표현 스타일을 별도의 상속 계층으로 빼낸다.\n\n```javascript\nclass Deal {}\n// 거래유형\nclass ActiveDeal extends Deal {}\nclass PassiveDeal extends Deal {}\n\n// 별도의 표현 클래스\nclass PresentationStyle {}\n// 표현의 차이는 몇개의 변수로 처리도 가능하다. 하여 밑에 있는 하위클래스 계층을 제거해도 된다. \nclass TabularPresntationStyle extends PresentationStyle {}\nclass SinglePresntationStyle extends PresentationStyle {}\n```\n\n메서드 이동과 필드 이동을 실시해서 Deal 하위클래스에 들어있는 표현 관련 메서드와 변수를표현 스타일 클래스로 옮기자.\nDeal 클래스에서 PresentationStyle의 인스턴스를 포함하고 있거나 참조하고 있으면 되겠다. \n\n\n## 절차 코드를 객체로 전환\n\n코드가 절차식으로 작성되어 있을 땐 데이터 레코드를 객체로 바꾸고, 기능을 쪼개서 각각의 객체로 옮기자.\n\n각 레코드 타입을 읽기/쓰기 메서드만 있는 더미 데이터 객체로 바꾸자.\n모든 절차 코드를 하나의 클래스에 넣자. \n긴 프로시저(그냥 리턴 값이 없는 함수라고 생각하자) 대상으로 메서드 추출과 관련된 래픽토링 기법을 실시해서 쪼개자.\n프로시저를 쪼개면서 메서드 이동을 적용해서 각각을 적절한 더미 데이터 클래스로 옮기자. \n\n## 도메인 로직을 표현과 분리\n\n도메인 로직이 들어있는 GUI 클래스가 있을 땐 도메인 로직을 별도의 도메인 클래스로 떼어내자.\n\nMVC 패턴의 핵심은 사용자 인터페이스 코드(뷰, 표현)와 도메인 로직(모델)을 분리하는 것이다. 표현 클래스에는 사용자 인터페이스 처리에 필요한 로직만 들어간다. \n도메인 객체에는 표현이나 시각적 코드는 전혀 들어가지 않고 비즈니스 로직만 들어간다. \n\n이렇게 하면 프로그램의 복잡한 두 부분이 수정하기 쉬운 조각으로 분리되며, 하나의 미즈니스 로직에 여러 개의 표현을 구현할 수도 있다. \n\n## 계층구조 추출\n\n한 클래스에 기능이 너무 많고 일부분에라도 조건문이 많을 땐 각 조건에 해당하는 하위클래스를 작성해서 계층 구조를 만들자. \n\n캔을 따는 기능에서 시작하여 작은 나뭇가지를 자르는 기능과 프레젠테이션 항목에 레이저로 포인팅하는 기능까지 추가된 맥가이버칼 클래스가 있다면, 어떤식으로든 그 세 가지 기능을 따로따로 분리해야 한다. 그렇게 하는 방법은 조건문이 객체의 수명 동안 지속될 때만 효력이 있다. 그렇지 않으면 아마 각 기능을 분리하기 전에 클래스 추출을 실시해야 할 수도 있다. \n\n### 예제\n\n전기요금을 계산하는 프로그램부터 살펴보자. \n\n```javascript\nclass Customer{\n  constructor() {\n    this.bill = new BillingScheme\n  }\n}\n\nclass BillingScheme{\n  createBill(customer){}\n}\n```\n\n전기요금 계산 클래스엔 다양한 상황별 요금 계산을 위한 수많은 조건문이 있다. 이렇듯 로직이 복잡하다 보니 `BillingScheme` 클래스가 복잡해지는게 당연하다.\n\n우선 조건문에서 차이 나는 부분을 골라야 한다. 차이 나는 부분은 어쩌면 소비자가 장애인 요금을 적용받고 있는지에 따른 다양한 조건일 수 있다. \n이런 차이 나는 부분을 빼낼 하위클래스를 작성하자. 따라서 `BillingScheme`의 생성자를 팩토리 메서드로 전환을 실시한 후 해당되는 경우에 장애인 요금을 반환하는 절을 작성하자. \n\n`BillingScheme` 클래스에 있는 각종 메서드를 살피면서 장애인 요금 기준에 따라 다른 코드를 실행하는 조건문이 들어 있는 메서드를 찾자. \n`createBill` 메서드도 조건문이 들어 있으니 하위클래스로 복사하자.\n\n그럼 `createBill` 메서드는 이렇게 변경 될 수 있다.\n\n```javascript\n// As-is\ncreateBill(customer) {\n  if(disabilityScheme()) doSomthing...\n}\n\n// To-be\ncreateBill(customer) {\n  doSomthing...\n}\n```\n목적은 같되 다른 기능의 메서드 호출을 넣을 수 있는 상황은 구분해야한다. 두 경우의 세금 계산법도 달라질 수 있다. \n이때 메서드 일부 코드만 다를 땐 다른 부분에만 메서드 추출을 적용해서 메서드로 빼내자.\n다른 기능 부분을 더 많이 메서드로 빼낼수록, 비슷한 메서드와 다른 메서드가 안정화 되며 나중에 차이 나는 기능을 새로 넣기도 더 쉽다.","excerpt":"해당 글은  에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다. 상속 구조 정리 하나의 상속 계층이 두 작업을 동시에 수행할 땐 상속 계층을 하나 더 만들어서 위임을 통해 다른 계층을 호출하자. 상속구조로 만들면 하위클래스 안에…","fields":{"slug":"/complex-refactoring/"},"frontmatter":{"date":"Apr 28, 2019","title":"(리팩토링) 복합 리팩토링","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n해당 글은 `리팩토링 (코드 품질을 개선하는 객체지향 사고법)` 에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다.\n\n일반화 관련 리팩토링 기법은 별도로 분류할 수 있다. 일반화는 주로 상속 계층구조나 상속 계층의 위나 아래로, 즉 상위클래스나 하위클래스로 메서드를 옮기는 기법이다.\n\n## 필드 상향\n\n```\nclassDiagram\n\nEmployee <|-- Salesman\nEmployee <|-- Engineer\nSalesman : string name\nEngineer : string name\n```\n\n위 상황을 아래 처럼 수정하자.\n\n```\nclassDiagram\n\nEmployee <|-- Salesman\nEmployee <|-- Engineer\nEmployee : string name\n```\n\n두 하위클래스에 같은 필드가 들어 있을 땐 필드를 상위 클래스로 옮기자.\n\n각각의 하위클래스를 따로 개발중이거나 리팩토링을 적용해서 연결할 경우, 여러 하위클래스에 중복된 기능이 들어 있는 경우가 많다.\n특히 특정한 몇 개의 필드가 중복될 수 있다. 중복된 필드는 이름이 서로 비슷할 때도 있다. 어느 필드가 무슨 용도로 쓰이는지 알려면,\n필드를 살펴보면서 다른 메서드에 어떤 식으로 사용되는지 보면 된다. 중복된 필드가 서로 비슷한 방식으로 사용된다면 그 필드를 일반화 화면 된다.\n일바화란 상위클래스로 옮기는 작업을 말한다.\n\n여기서 만약 필드가 private 이면 상위클래스 필드를 protected 로 수정해서 하위클래스가 참조할 수 있게 하자.\n\n## 메서드 상향\n\n기능이 같은 메서드가 여러 하위클래스에 들어 있을땐 그 메서드를 상위클래스로 옮기자.\n\n메서드 상향을 적용해야 할 가장 단순한 상황은 메서드의 내용이 마치 복사해서 붙여 넣은 것처럼 서로 같을 때다.\n메서드 상향은 다른 리팩토링 단계를 마친 후 적용하는 것이 일반적이다. 다른 클래스에 들어 있는 두 개의 메서드가 매개변수로 전환되어 결국 실제론 같은 메서드가 될 수도 있다. 이럴 때 가장 작은 단계는 각 메서드를 따로따로 매개변수로 전환한 후 상위클래스로 옮기면 된다.\n\n메서드를 매개변수로 전환 -> 메서드 안의 로직은 비슷하고 어떤 특정한 값만 다를때 그 값을 매개변수로 전달 받는 메서드를 하나 작성하자. 여기서 추가 메서드가 생겨날 수도 있고 2 개의 메서드가 하나의 메서드로 합쳐질 수 도 있다. ( 메서드 호출 단순화 참조 )\n\n메서드 상향을 실시해야 할 특수한 상황은 하위클래스 메서드가 상위클래스 메서드를 재정의함에도 불구하고 기능이 같을 때다.\n\n### 예제\n\n```javascript\nclass Customer {\n  constructor(){\n    this.lastBillData\n  }\n\n  addBill()\n\n}\n\n// 일반 고객\nclass RegularCustomer extends Customer {\n  // 상위로 올려 보낼 메서드\n  createBill(date) {\n    const chargeAmount = this.chargeFor(this.lastBillDate, date)\n    this.addBill(data, charge)\n  }\n  // 하위 클래스마다 로직이 다 다르다.\n  chargeFor() {\n\n  }\n}\n\n// 단골 고객...\nclass PreferredCustomer extends Customer {\n\n}\n```\n\n이때 `createBill` 메서드는 그냥 상위클래스로 올려보낼 수 없다. 왜냐하면 `this.chargeFor` 메서드가 하위클래스 마다 다르기 때문이다. 이때, 하위 메서드에서 `chargeFor` 메서드를 구현하지 않는다면 문제가 생길 수 있다.\n그래서 자바에서는 `Custom` 클래스에 `abstract chargeFor` 메서드를 정의하지만 javascript 에서는 그냥 상위 클래스에 정의한다.\n\n## 생성자 내용 상향\n\n하위클래스마다 거의 비슷한 내용의 생성자가 있을 땐 상위클래스에 생성자를 작성하고, 그 생성자를 하위클래스의 메서드에서 호출하자.\n\n개발자는 여러 하위클래스에 같은 기능의 메서드가 든 것을 발견하면 우선적으로 공통적인 부분을 메서드로 빼낸 후 상위클래스로 옮길 생각을 하게 된다.\n그러나 하위클래스는 대체로 공통적인 기능이 생성 기능이다. 이럴 땐 하위클래스에서 생성자 메서드를 작성하고 상위클래스로 올려서 하위클래스들이 호출하게 해야한다. `super()`\n대부분 공통적인 기능은 생성자 내용 전체다. 생성자는 상속이 불가능하기 때문에 메서드 상향(메서드를 부모에게 정의한다.)을 적용할 수 없다.\n\n### 예제\n\n```javascript\n// as-is\nclass Manager extends Employee {\n  constructor(name, id, grade) {\n    this._name = name\n    this._id = id\n    this._grade = grade\n  }\n}\n\n// to-be\nclass Manager extends Employee {\n  constructor(name, id, grade) {\n    super(name, id)\n    this._grade = grade\n  }\n}\n```\n\n나중에 공통적인 코드가 발견될 땐 조금 달라진다. 아래와 같은 코드가 있다고 하자.\n\n```javascript\nclass Employee {\n  constructor(name, id) {\n    this._name = name\n    this._id = id\n  }\n  isPriviliged() {}\n  assignCar() {}\n}\n\nclass Manager extends Employee {\n  constructor(name, id, grade) {\n    super(name, id)\n    this._grade = grade\n    if (isPriviliged) this.assignCar() // 모든 하위클래스의 공통 기능\n  }\n\n  isPriviliged() {\n    return this._grade > 4\n  }\n}\n```\n\n여기서 `assingCar` 메서드의 기능은 상위클래스 생성자 안으로 옮길 수 없다. 왜냐하면 `grade`가 `_grade` 필드에 대입된 후 실행되어야 하기 때문이다.\n따라서 메서드 추출과 메서드 상향을 적용해야 한다.\n\n```javascript\nclass Employee {\n  initialize() {\n    if (this.isPriviliged()) this.assignCar()\n  }\n}\n\nclass Manager extends Employee {\n  constructor(name, id, grade) {\n    super(name, id)\n    this._grade = grade\n    this.initialize()\n  }\n}\n```\n\n## 메서드 하향\n\n상위클래스에 있는 기능을 일부 하위클래스만 사용할 땐 그 기능을 관련된 하위클래스 안으로 옮기자.\n메서드 하향은 메서드 상향과는 반대되는 기법이다. 이 기법은 상위 클래스의 기능을 특정 하위클래스로 옮겨야 할 때 사용한다.\n\n## 필드 하향\n\n일부 하위클래스만이 사용하는 필드가 있을 땐 그 필드를 사용하는 하위클래스로 옮기자.\n필드 하향은 필드 상향과 정반대다. 이 기법은 필드가 상위클래스엔 필요 없고 하위클래스에만 필요할 때 사용하자.\n\n## 하위클래스 추출\n\n일부 인스턴스에만 사용되는 기능이 든 클래스가 있을 땐 그 기능 부분을 전담하는 하위클래스를 작성하자.\n\n```\nclassDiagram\n\nJobItem : getTotalPrice\nJobItem : getUnitPrice\nJobItem : getEmployee\n```\n\n위 상황을 아래 처럼 수정하자.\n\n```\nclassDiagram\n\nJobItem <|-- LaborItem\nJobItem : getTotalPrice\nJobItem : getUnitPrice\n\nLaborItem : getUnitPrice\nLaborItem : getEmployee\n```\n\n하위클래스 추출은 주로 클래스의 기능을 그 클래스의 일부 인스턴스만 사용할 때 적용한다.\n이 기법 대신 클래스 추출을 사용할 수 있다. 이 두 기법은 위임이냐 상속이냐의 차이이다. 하위클래스 추출기법이 보통은 더 간단하지만 단점이 있다.\n첫째, 객체가 생성된 후에는 객체의 클래스 기반 기능을 수정할 수 없다. 클래스 기반 기능을 수정하려면 단순히 다른 각종 컴포넌트를 연결해서 클래스 추출을 실시하면 된다.\n둘째, 하위클래스를 사용해서 한가지 변형만을 표현할 수도 있다. 클래스가 다양하게 변하게 하려면 하나가 아닌 모두를 대상으로 위임을 적용해야 한다.\n\n### 예제\n\n동네 정비소에서 작업 종류별 가격을 구하는 JobItem 클래스는 다음과 같다.\n\n```javascript\nclass JobItem {\n  constructor(unitPrice, quantity, isLabor, employee) {\n    this._unitPrice = unitPrice\n    this._quantity = quantity\n    this._isLabor = isLabor\n    this._employee = employee\n  }\n\n  getTotalPrice() {\n    this.getUnitPrice() * this._quantity\n  }\n\n  getUnitPrice() {\n    return this._isLabor ? this._employee.getRate() : this._unitPrice\n  }\n\n  getQuantity() {\n    return this._quantity\n  }\n\n  getEmployee() {\n    return this._employee\n  }\n}\n\nclass Employee {\n  constructor(rate) {\n    this._rate = rate\n  }\n\n  getRate() {}\n}\n```\n\n위 클래스에서 LaborItem 하위클래스를 추출하자. 그래야 하는 이유는 기능과 데이터 중 일부가 LaborItem 클래스에만 사용되기 때문이다.\n\n```javascript\nclass LaborItem extends JobItem {\n  constructor(unitPrice, quantity, isLabor, employee) {\n    super(unitPrice, quantity, isLabor, employee)\n  }\n}\n```\n\n하지만 생성자가 지저분해진다. `LaborItem` 에 어떤 인자들은 필요하고 어떤 인자들은 필요하지 않다.\n또한 `isLabor` 필드의 경우에는 `Labor` 인지 아닌지에 대한 정보를 위한 값이기 때문에 재정의 상수 메서드로 따로 빼둔다.\n`unitPrice` 필드의 경우 Labor 는 0 의 값으로 고정이다.\n`employee` 필드는 내려간 하위 클래스 에서만 값이 설정되게 상위클래스 생성자를 정리하자.\n밖의 호출 중 `LaborItem` 의 생성자가 대신 호출되어야 할 경우들을 찾아서 다음과 같이 수정하자.\n\n```javascript\nconst j1 = new LaborItem(10, kent)\n\nclass JobItem {\n  constructor(unitPrice, quantity, isLabor) {\n    this._unitPrice = unitPrice\n    this._quantity = quantity\n    this._isLabor = isLabor\n    // this._employee = employee\n  }\n\n  isLabor() {\n    return false\n  }\n\n  // 기존 조건문.\n  // getUnitPrice() {\n  //   return this._isLabor ? this._employee.getRate() : this._unitPrice\n  // }\n  getUnitPrice() {\n    return this._unitPrice\n  }\n}\n\nclass LaborItem extends JobItem {\n  constructor(quantity, employee) {\n    super(0, quantity, true)\n    this._employee = employee\n  }\n\n  isLabor() {\n    return true\n  }\n\n  getUnitPrice() {\n    return this._employee.getRate()\n  }\n}\n```\n\n`getUnitPrice` 메서드의 경우에는 조건문을 재정의로 전환을 적용해야 한다. (여기서 조건문에 해당되는 각 로직들을 해당 조건 타입의 클래스에게 해당 메서드를 재 정의 함으로써 조건문을 분리시킬 수 있는 기법이다.)\n일부 데이터를 사용하는 메서드들을 하위클래스로 내린 후 데이터에 필드 하향을 적용하자. 어떤 메서드가 그 데이터를 사용해서 개발자가 그 메서드를 사용할 수 없다면,\n추가로 메서드 하향이나 조건문을 재정의로 전환을 실시해야 한다.\n`unitPrice` 필드는 근로(labor)와 관련 없는 항목들에만 사용되므로 `JobItem` 을 대상으로 하위클래스 추출을 다시 실시해서 `PartsItem` 클래스를 만들면 된다.\n작업을 완료하면 `JobItem` 클래스는 `abstract` 타입이 된다.\n\n## 상위클래스 추출\n\n기능이 비슷한 두 클래스가 있을 땐 상위클래스를 작성하고 공통된 기능들을 그 상위클래스로 옮기자.\n\n중복된 코드의 한 형태는 비슷한 작업을 같은 방식이나 다른 방식으로 수행하는 두 클래스다. \n객체에는 상속을 이용하여 이전 상황을 단순화해주는 기본 메커니즘이 있다. 그러나 클래스 몇개를 다 작성하기 전까지 공통점을 눈치채지 못할 때가 많은데,\n이럴 때는 나중에 상속 구조로 만들어야 한다. \n\n상위클래스 추출을 적용할 수 없을땐 클래스 추출을 적용하면 된다. 두 클래스가 기능뿐 아니라 인터페이스도 같다면 상속 방식이 더 간단하다.\n상위클래스 추출을 적용한게 잘못된 선택이였다면, 나중에 상속을 위임으로 전환을 실시하면 된다.\n\n### 예제\n\n`Employee` 클래스와 `Department` 클래스가 있다.\n\n```javascript\nclass Employee {\n  constructor(name, id, annualCost) {\n    this._name = name\n    this._id = id\n    this._annualCost = annualCost\n  }\n\n  getAnnualCost() {\n    return this._annualCost\n  }\n  getId() {\n    return this._id\n  }\n  getName() {\n    return this._name\n  }\n}\n\nclass Department {\n  constructor(name) {\n    this._name = name\n    this._staff // 사원 컬렉션 ( java new Vector )\n  }\n\n  getTotalAnnualCost() {\n    const e = this.getStaff() // iterator\n    let result = 0\n    for( let p of e) {\n      each = e.value\n      result += each.getAnnualCost()\n    }\n\n    return result\n  }\n\n  getHeadCount() {\n    return this._staff.size()\n  }\n  getStaff() {\n    return this._staff.elements()\n  }\n  addStaff(employee) {\n    this._staff.addElement(employee)\n  }\n  getName() {\n    return this._name\n  }\n}\n```\n\n위 코드에서 두 클래스는 공통된 부분이 두가지다.\n첫번째, 사원과 부서는 둘다 이름이 있다는 점이다.  \n두번째, 계산 메서드가 약간 다르긴 하지만 두 클래스 모두 연간 경비가 있다. \n\n새 상위 클래스를 만들어서 두 클래스를 하위클래스로 넣자.\n\n`Department.getTotalAnnualCost` 메서드와 `Employee.getAnnualCost` 메서드는 기능(목적) 이 같으므로 이름이 같아야 한다. 하여 이 두 메서드의 이름을\n`getAnnualCost`으로 같게 하자.\n\n`getAnnualCost` 메서드의 내용이 다르므로 상향을 적용할 수는 없다. 하지만 상위클래스의 선언을 통해서 오류가 나는것을 방지할 순 있다. (자바에선 abstract로 선언으로 하위클래스에서 구현을 하도록 강제 할 수있다.)\n\n여기서 `Department` 클래스와 `Employee` 클래스를 컴포지트의 패턴으로 취급을 할 수도 있다. 이러면 `_staff` 필드의 이름을 더 적절한 것으로 수정했을 것이다. 그러면 `addStaff`도 이름을 변경했을 것이다. 왜냐하면 `_staff`는 이제 `Vector` 클래스를 쓰는 것이 아닌 추상 인터페이스의 타입(`Node`)을 지니게 되므로 `_childNode` 이정도가 될듯 싶다.\n\n여기서 컴포지트의 패턴이란 예로 디렉토리 구조를 구성하는 예를 생각해보자. 디렉토리 안에는 파일과 또다른 디렉토리를 구성해야한다. \n이때 디렉토리와 파일을 동일 취급을 위한 공통인터페이스를 작성하고 디렉토리 클래스는 또 다른 디렉토리 또는 파일을 포함하고 관리할 수 있는 메서드를 만든다.\n\nNode인터페이스, File, Directory 클래스를 비유로 든다면 \n- Component는 모든 표현하는 추상적인 인터페이스. Node 인터페이스\n- Leaf는 Component로 지정된 인터페이스를 구현한 것. File 클래스\n- Composition은 Composite 요소는 Component 요소를 자식으로 가집니다. 따라서 Component 요소를 관리하기 위한 메소드들을 추가적으로 구현해줘야 한다. Directory 클래스\n\n개별적인 객체들과 객체들의 집합간의 처리 방법의 차이가 없을 경우 사용하면 된다. 여기서 컴포지트의 의미는 일부 또는 그룹을 표현하는 객체들을 트리 구조로 구성한다는 겁니다. \n\n만약에 이렇게 컴포지트 패턴으로 작성하게 되면 `Department.headCount` 메서드도 재귀 메서드로 만들어야 한다. 왜냐하면 `this._staff`엔 `size` 메서드가 없을거기 때문이다. 이럴 경우에는 `Employee` 클래스에 단순히 1을 반환하는 `headCount`메서드를 작성하고, 부서에 속한 사원수를 합산하는 로직을 `Department.headCount` 에 넣으면 될듯 싶다.\n\n\n```javascript\n// 상위 클래스\nclass Party() {\n  // protected\n  constructor(name) {\n    this._name = name\n  }\n\n  getName() {\n    return this._name\n  }\n}\n\nclass Employee extends Party{\n  constructor(name, id, annualCost) {\n    super(name)\n    this._id = id\n    this._annualCost = annualCost\n  }\n}\n\nclass Department extends Party{\n  constructor(name) {\n    super(name)\n  }\n\n  // getTotalAnnualCost() {\n  getAnnualCost() {}\n    const e = this.getStaff() // iterator\n    let result = 0\n    for( let p of e) {\n      each = e.value\n      result += each.getAnnualCost()\n    }\n\n    return result\n  }\n\n  getHeadCount() {\n    return this._staff.size()\n  }\n}\n```\n\n## 인터페이스 추출\n\n클래스 인터페이스의 같은 부분을 여러 클라이언트가 사용하거나, 두 클래스에 인터페이스의 일부분이 공통으로 들어 있을 땐 공통 부분을 인터페이스로 빼내자. \n인터페이스 추출은 공통된 코드를 빼내는 것이 아니라 공통된 인터페이스만 빼내는 기법이다.\n인터페이스 추출을 적용하면 중복 코드의 구린내가 날 수도 있따. 이 구린내를 줄이려면 클래스 추출을 적용해서 기능을 컴포넌트에 넣고 그 컴포넌트로 위임하면 된다. \n컴포넌트는 각각 독립된 모듈을 뜻한다.\n\n클래스를 사용한다는 건 주로 클래스의 담당 기능 전반을 사용함을 뜻한다. 하지만 여러 클라이언트가 클래스 기능 중 특정 부분만 사용할 때도 있고, \n한 클래스가 각 요청을 처리할 수 있는 특정한 클래스들과 공조해야 할 때도있다.\n\n일부분만 사용하는 경우와 특정 기능의 여러 클래스를 함께 사용하는 경우엔, 클래스 기능 중 사용되는 부분을 분리해서 시스템을 사용할 때 사용되는 부분을 확실히 알 수 있게 하는 것이 좋다. \n그렇게 하면 해당 기능들이 어떤 기능들이 어떤 식으로 나뉘는지 더욱 쉽게 알 수 있다. 또한 새 클래스들이 해당 부분을 보조해야 할 경우엔 해당 부분에 무슨 클래스가 적절할지 정확히 알아내기가 더 쉽다.\n\n클래스가 서로 다른 상황에서 서로 다른 역할을 담당할 때 인터페이스를 사용하면 좋다. 각 역할마다 인터페이스 추출을 적용하자. 클래스 밖으로 빼낸 인터페이스, 즉 그 클래스가 서버에서 하는 작업을 기술해야 할 때도 인터페이스를 사용하면 좋다. 나중에 다른 종류의 서버를 허용해야 할 땐 단지 그 인터페이스를 상속구현하기만 하면 된다. \n\n### 예제 \n\nTimeSheet 클래스는 사원비를 산출한다. 이를 위해 TimeSheet 클래스는 사원 평점과 특수 기술 보유 여부를 알아야 한다. \n`charge`메서드에 emp 가 Employee 타입으로 보이게 된다면 Employee의 모든 기능을 다 사용할 수 있는 것으로 간주 될것이다. \n하여, Employee 클래스의 기능 중 `Billable` 기능만 사용됨을 보이고자 보여야 한다. \n\n안타깝게도 자바스크립트에서는 반환 값의 타입을 따로 지정을 하지 않기에 주석으로 처리를 해주면 좋을꺼 같다.\n\n```javascript\n//interface\nclass Billable {\n  getRate(){}\n  hasSpecialSkill()\n}\n\n/**\n * @param {Billable} emp\n */\n\nclass Employee extends Billable{\n  charge(emp, days) { \n    const base = emp.getRate() * days\n    if(emp.hasSpecialSkill()) {\n      return base * 1.05\n    } else return base\n  }\n}\n  \n```\n\n## 계층 병합\n\n상위클래스와 하위클래스가 거의 다르지 않을 땐 둘을 합치자.\n\n## 템플릿 메서드 형성\n\n하위클래스 안의 두 메서드가 거의 비슷한 단계들을 같은 순서로 수행할 땐 그 단계들을 시그니처가 같은 두 개의 메서드로 만들어서 두 원본 메서드를 같게 만든 후, \n두 메서드를 상위클래스로 옮기자.\n\n상속은 중복된 기능을 없애는 강력한 수단이다. 하위클래스에 들어 있는 두 메서드가 비슷하다면 둘을 합쳐서 하나의 상위클래스로 만드는 것이 좋다.\n그러나 두 메서드가 완전히 똑같지 않다면 어떻게 해야 할까? 그래도 중복된 부분은 가능한 전부 없애고 차이가 있는 필수 부분만 그대로 둬야 한다. \n\n두 메서드가 똑같지는 않지만 거의 비슷한 단계를 같은 순서로 수행하는 경우가 제일 흔하다. 이럴 땐 그 순서를 상위클래스로 옮기고 재정의를 통해 각 단계가 고유의 작업을 다른 방식으로 수행하게 하면 된다. \n이런 메서드를 템플릿 메서드라고 한다. \n\n### 예제\n\n```javascript\nclass Site {\n\n}\n\nclass ResidentialSite extends Site {\n  getBillableAmount(){\n    const base = this._units * this._rate * 0.5\n    const tax = base * Site.TAX_RATE * 0.2\n    return base + tax\n  }\n}\nclass LifelineSite extends Site {\n  getBillableAmount(){\n    const base = this._units * this._rate\n    const tax = base * Site.TAX_RATE\n    return base + tax\n  }\n}\n\n```\n\n위 코드를 아래처럼 바꾼다. 이때 \n\n```javascript\nclass Site {\n  getBillableAmount() {\n    return this.getBaseAmount() + this.getTaxAmount()\n  }\n  getBaseAmount() {}\n  getTaxAmount() {}\n}\n\nclass ResidentialSite extends Site {\n  getBaseAmount() {\n    return this._units * this._rate * 0.5\n  }\n  getTaxAmount() {\n    return base * Site.TAX_RATE * 0.2\n  }\n}\nclass LifelineSite extends Site {\n  getBaseAmount() {\n    return this._units * this._rate\n  }\n  getTaxAmount() {\n    return base * Site.TAX_RATE \n  }\n \n}\n```\n\n이 기법의 핵심은 메서드 추출로 두 메서드의 다른 부분을 추출해서 다른 코드를 비슷한 코드와 분리하는 것이다. 추출할 때마다 내용은 다르고 시그니처는 같은 메서드를 작성하자. \n여기서 시그니처는 위 예제에서 `getBillableAmount` 메서드 이다.\n\n\n## 상속을 위임으로 전환\n\n하위클래스가 상위클래스 인터페이스의 일부만 사용할 때나 데이터를 상속받지 않게 해야 할 땐 \n상위클래스에 필드를 작성하고, 모든 메서드가 그 상위클래스에 위임하게 수정한 후 하위클래스를 없애자.\n\n상속은 훌륭한 기능이지만 간혹 적합하지 않을 때도 있다. 주로 한 클래스에서부터 상속을 시작했다가, 나중에 가서 대부분의 상위클래스 작업이 하위클래스엔 별로 적절하지 않음을 깨닫는다. 이것은 클래스의 기능이 인터페이스에 제대로 반영되지 않았거나, 하위클래스로 적절하지 않은 많은 데이터를 상속하게 작성했거나 상위클래스의 protected 메서드가 하위클래스에 사용되지 않기 때문일 수 있다. \n\n상속 대신 위임을 이용하면 위임받은 클래스의 일부만 사용하려는 의도가 더욱 확실해진다. 인터페이스의 어느 부분을 사용하고 어느 부분을 무시할지를 개발자가 제어할 수 있다. 단지 위임하는 메서드를 추가로 작성하면 된다. \n\n쉽게 상속은 `extends`를 통해서 상위클래스에서 하위클래스로 상속하는 것이고 위임은 해당 클래스에 위임받을 클래스 인스턴스를 지니고 있는 것이다. \n\n### 예제\n\n```javascript\nclass MyStack extends Vector {\n  push(element) {\n    this.insertElementAt(element,0) // Vector에 있는 메서드\n  }\n\n  pop() {\n    const result = this.firstElement()\n    this.removeElementAt(0)\n    return result\n  }\n}\n```\n\n위의 클래스를 사용하는 부분을 보다가, 클라이언트가 스택으로 네 개의 메서드 push, pop, size, isEmpty만 호출함을 발견했다.\nsize와 isEmpty 메서드는 Vector 클래스에서 상속된다. \n\n이것을 위임으로 바꾸게 되면 `this._vector`에 위임받을 Vector 인스턴스를 담아두자.\n\n```javascript\nclass MyStack {\n  constructor() {\n    this._vector = new Vector()\n  }\n\n  push(element) {\n    this._vector.insertElementAt(element,0)\n  }\n\n  pop() {\n    const result = this._vector.firstElement()\n    this._vector.removeElementAt(0)\n    return result\n  }\n\n  size() {\n    return this._vector.size()\n  }\n\n  isEmpty() {\n    return this._vector.isEmpty()\n  }\n}\n```\n\n## 위임을 상속으로 전환\n\n위임을 이용 중인데 인터페이스 전반에 간단한 위임으로 도배하게 될 땐 위임 클래스를 대리 객체의 하위클래스로 만들자.\n예를 들어 `Employee` 클래스 안에 `Person` 클래스 인스턴스를 가지고 있다면(위임상태) 이 `Employee` 클래스를 `Person(대리 객체)`의 하위클래스로 만들자.\n\n두 가지 주의사항을 염두에 두자. `위임하려는 클래스(Person)`의 모든 메서드를 사용하는 게 아닐 경우엔 위임을 상속으로 전환을 적용해선 안된다.\n왜냐하면 하위클래스는 반드시 상위클래스의 인터페이스를 따라야 하기 때문이다. \n\n위임 메서드가 거치적 거리면 다른 방법도 있다. _과잉 중개 메서드 제거_를 적용해서 클라이언트가 대리를 직접 호출하게 하는 것이다. \n여기서 _과잉 중개 메서드 제거_란 `A 클래스`에서 `B 클래스`를 숨기기 위해 대신해서 작업을 도왔다면 이제 그냥 `A 클래스`에서 `B클래스`를 내보내는 메서드를 만들어 `getB` 클라이언트가 직접 호출하게 만드는 기법이다.\n\n하위클래스 추출(하위클래스를 만드는 것)을 적용해서 공통 인터페이스를 분리한 후 새 클래스에서 상속받으면 된다. 비슷한 방법으로 인터페이스 추출을 적용해도 된다.\n\n또 한가지 주의할 상황은 위임상황에서 대리 객체를 둘 이상의 객체가 사용하고 변경 가능할 때다. **이럴 땐 데이터를 더 이상 공유할 일이 없어서 위임을 상속으로 바꿀 수 없다.**\n데이터 공유는 상속으로 되돌릴 수 없는 작업이다. 반면, 객체가 변경 불가일 땐 바로 복사할 수도 있고 다른 부분에선 모르기 때문에 데이터 공유가 문제되지 않는다.\n+\n\n### 예제\n\n`Employee 클래스`는 간단한 `Person 객체`에 위임한다.\n\n```javascript\nclass Employee {\n  constructor () {\n    this._person = new Person()\n  }\n\n  getName() {\n    return this._person.getName()\n  }\n\n  setName(arg) {\n    return this._person.setName(arg)\n  }\n  toSting(){\n    return `사원 : ${this._person.getLastName()}`\n  }\n}\n\nclass Person {\n  constructor() {\n    this._name\n  }\n\n  getName() {\n    return this._name\n  }\n\n  setName(arg) {\n    this._name = arg\n  }\n\n  getLastName() {\n    return this._name.substring(this._name.lastIndexOf(' ') + 1)\n  }\n}\n```\n\n위와 같은 코드를 상위클래스 - 하위클래스 관계로 전환하자.\n\n```javascript\nclass Employee extends Person {\n  //...\n}\n```","excerpt":"해당 글은  에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다. 일반화 관련 리팩토링 기법은 별도로 분류할 수 있다. 일반화는 주로 상속 계층구조나 상속 계층의 위나 아래로, 즉 상위클래스나 하위클래스로 메서드를 옮기는 기법이다…","fields":{"slug":"/generalization-processing/"},"frontmatter":{"date":"Apr 22, 2019","title":"(리팩토링) 일반화 처리","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n해당 글은 `리팩토링 (코드 품질을 개선하는 객체지향 사고법)` 에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다.\n\n객체에서 가장 중요한 것은 인터페이스다. 이해와 사용이 쉬운 인터페이스를 작성하는 기술이야 말로 좋은 객체지향 소프트웨어 개발에 꼭 필요하다.\n\n## 메서드 변경\n\n메서드명을 봐도 기능을 알 수 없을땐 메서드명을 직관적인 이름으로 바꾸자.\n\n중요한 부분은 복잡한 과정을 여러 작은 메서드로 잘게 쪼개는 것이다. 또한 메서드 명을 잘 지어야한다.\n메서드명만 봐도 그 메서드의 의도를 한눈에 알 수 있어야 한다.\n메서드 기능을 설명하기 위해 넣는 주석을 떠올린 후 그 주석을 메서드명으로 바꾸면 이러한 메서드명을 쉽게 정할 수 있다.\n\n### 예제\n\n전화번호를 가져오는 메서드는 다음과 같다.\n\n```javascript\ngetTelephoneNumber() {\n  return `( ${this._officeAreaCode} ) ${this._officeNumber}`\n}\n```\n\n앞의 메서드명을 `getOfficeTelephoneNumber`로 변경해야 한다고 가정하자. 우선 새 매서드를 작성하고 위의 메서드 내용을 새로 작성한 메서드로 복사하자.\n그리고 원본 메서드를 다음과 같이 새 메서드를 호출하게 수정하자.\n\n```javascript\nclass Person {\n  getTelephoneNumber() {\n    this.getOfficeTelephoneNumber()\n  }\n\n  getOfficeTelephoneNumber() {\n    return `( ${this._officeAreaCode} ) ${this._officeNumber}`\n  }\n}\n```\n\n이제 원본 메서드 호출 부분을 찾아서 새 메서드 호출로 바꾸자. 모두 수정했으면 원본 메서드를 삭제해도 된다.\n\n## 매개변수 추가\n\n메서드가 자신을 호출한 부분의 정보를 더 많이 알아야 할 땐객체에 그 정보를 전달할 수 있는 매개변수를 추가하자.\n\n기존 매개변수 세트를 살펴보자.\n\n* 그 객체 중 하나에 필요한 정보를 요청할 수 있나?\n* 그럴수 없다면 필요한 정보를 가져오는 메서드를 그런 객체에 추가하는것이 합리적인가?\n* 필요한 정보는 무슨 용도로 사용되는가?\n* 그 정보 이용 기능이 해당 정보가 들어있는 다른 객체에 있어야 하나?\n\n기존 매개변수 세트를 살펴보면서 새 매개변수를 추가하면 어떻게 될지 생각해보자.\n\n## 매개변수 삭제\n\n메서드가 어떤 매개변수를 더 이상 사용하지 않을 땐 그 매개변수를 삭제하자.\n\n재정의 메서드에 주의해야한다. 이런 상황에서 그 메서드의 다른 재정의 메서드에서 매개변수가 사용되진 않는지 살펴봐야한다.\n\n## 상태 변경 메서드와 값 반환 메서드를 분리\n\n값 반환 기능과 객체 상태 변경 기능이 한 메서드에 들어 있을 땐 질의 메서드와 변경 메서드로 분리하자.\n\n값을 반환하는 모든 메서드는 눈에 띄는 부작용이 없어야 한다는 규칙을 따르는 것이 좋다.\n값을 반환하는 메서드가 있는데 그 메서드에 부작용이 있다면 상태 변경 부분과 값 반환 부분을 별도의 메서드로 각각 분리해야 한다.\n\n흔히 사용되는 최적화 방법은 반복되는 호출 성능을 개선하고자 필드에 들어있는 반환 값을 캐시에 저장하는 방식이다.\n이렇게 하면 객체의 상태가 캐시를 통해 변경되지만, 그 변경사항이 눈에 띄지 않는다. 연속되는 어떠한 질의라도 항상 같은 결과를 반환하게 된다.\n\n### 예제\n\n보안 시스템의 침입자가 이름을 알려주고 경고 메세지를 보내는 함수는 다음과 같다. 이 함수의 규칙은 침입자가 둘 이상일 때도 경고가 한번만 송신되어야 한다는 점이다.\n\n```javascript\nfoundMiscreant(people=[]) {\n  for(let i = 0; i< people.length; i++) {\n    if(people[i].equals('Don')) {\n      sendAlert()\n      return 'Don'\n    }\n\n    if(people[i].equals('John')) {\n      sendAlert()\n      return 'John'\n    }\n  }\n\n  return ''\n}\n\n// 위 메서드를 호출하는 메서드는 다음과 같다.\n\ncheckSecurity(people=[]) {\n  const found = foundMiscreant(people)\n  someLaterCode(found)\n}\n```\n\n위 `foundMiscreant` 메서드에서 값 반환 코드를 상태 변경 코드와 분리하려면 우선 변경 메서드와 같은 값을 반환하되 부작용이 없는 적절한질의 메서드를 다음과 같이 작성하자.\n\n```javascript\nfoundPerson(people=[]) {\n  for(let i = 0; i< people.length; i++) {\n    if(people[i].equals('Don')) {\n      return 'Don'\n    }\n\n    if(people[i].equals('John')) {\n      return 'John'\n    }\n  }\n  return ''\n}\n\ncheckSecurity(people=[]) {\n  foundMiscreant(people) // 변경 메서드\n  const found = foundPerson(people) // 값 반환 메서드\n  someLaterCode(found)\n}\n```\n\n`foundMiscreant` 메서드는 아무것도 반환하지 않는 메서드로 만들자. 그리고 `foundMiscreant` 이 메서드 네이밍을 `sendAlert` 로 변경중복되는 코드 발생도 알고리즘 전환을 적용하자.\n\n```javascript\n// 상태 변경 메서드\n// foundMiscreant -> sendAlert\nsendAlert(people=[]) {\n\n  // 중복코드 발생\n  // for(let i = 0; i< people.length; i++) {\n  //   if(people[i].equals('Don')) {\n  //     sendAlert()\n  //     return\n  //   }\n\n  //   if(people[i].equals('John')) {\n  //     sendAlert()\n  //     return\n  //   }\n  // }\n  if(! this.foundPerson(people).equals('')) {\n    sendAlert()\n  }\n}\n\nfoundPerson(people=[]) {\n  for(let i = 0; i< people.length; i++) {\n    if(people[i].equals('Don')) {\n      return 'Don'\n    }\n\n    if(people[i].equals('John')) {\n      return 'John'\n    }\n  }\n  return ''\n}\n\ncheckSecurity(people=[]) {\n  foundMiscreant(people) // 변경 메서드\n  const found = foundPerson(people) // 값 반환 메서드\n  someLaterCode(found)\n}\n```\n\n## 메서드를 매개변수로 전환\n\n여러 메서드가 기능은 비슷하고 안에 든 값만 다를 땐 서로 다른 값을 하나의 매개변수로 전달받는 메서드를 하나 작성하자.\n\n여러 메서드를 대체할 수 있는 매개변수 메서드를 작성하자.\n\n기능은 비슷하지만 몇가지 값에 따라 결과가 달라지는 메서드가 여러 개 있을때 각 메서드를 전달된 매개변수에 따라 다른 작업을 처리하는 하나의 메서드로 만들면 편리하다.\n이렇게 수정하면 중복코드가 없어지고 매개변수 추가를 통해 다양한 것을 처리할 수 있어서 유연하다.\n\n### 예제\n\n간단한 예제는 다음과 같다\n\n```javascript\nclass Employee {\n  tenPercentRaise() {\n    this.salary *= 1.1\n  }\n\n  fivePercentRaise() {\n    this.salary *= 1.05\n  }\n\n  // 하나로 만들자.\n  raise(factor) {\n    this.salary *= 1 + factor\n  }\n}\n```\n\n조금 더 복잡한 예제\n\n```javascript\nbaseCharge() {\n  let result = Math.min(lastUsage(), 100) * 0.03\n  if(lastUsage() > 100) {\n    result += (Math.min(lastUsage(), 200) - 100) * 0.05\n  }\n  if(lastUsage() > 200) {\n    result += (lastUsage() -200) * 0.07\n  }\n\n  return new Dollars(result)\n}\n```\n\n다음과 같이 수정하자.\n\n```javascript\nbaseCharge() {\n  let result = Math.min(lastUsage(), 100) * 0.03\n  // if(lastUsage() > 100) {\n  //   result += (Math.min(lastUsage(), 200) - 100) * 0.05\n  // }\n  result += this.usageInRange(100,200) * 0.05\n  // if(lastUsage() > 200) {\n  //   result += (lastUsage() -200) * 0.07\n  // }\n  result += this.usageInRange(200, Number.MAX_VALUES) * 0.07\n\n  return new Dollars(result)\n}\n\nusageInRange(start, end) {\n  if( lastUsage() > start) return Math.min(lastUsage(), end) - start\n  else return 0\n}\n```\n\n매개변수로 전달받을 수 있는 몇 개의 값을 기준으로 반복되는 코드를 찾는 것이 요령이다.\n\n## 매개변수를 메서드로 전환\n\n매개변수로 전달된 값에 따라 메서드가 다른 코드를 실행할 땐 그 매개변수로 전달될 수 있는 모든 값에 대응하는 메서드를 각각 작성하자.\n\n이 기법은 일반적으로 한 매개변수의 값이 여러 개가 될 수 있을때 조건문 안에서 각 값을 검사하여 다른 기능을 수행하는 메서드에 적용된다.\n호출하는 부분은 매개변수에 값을 지정하여 무엇을 수행할지 판단해야 하므로, 여러 메서드를 작성하고 조건문은 없애는게 좋다.\n\n### 예제\n\n전달받은 매개변수를 토대로 Employee 의 하위 클래스를 작성하면 다음과 같다. 이런 형태의 코드는 주로 생성자를 팩토리 메서드로 전환을 실시하면 얻어진다.\n\n```javascript\nclass Employee {\n  static ENGINEER = 0\n  static SALESMAN = 1\n  static MANAGER = 2\n\n  static create(type) {\n    switch (type) {\n      case ENGINEER:\n        return new Engineer()\n      case SALESMAN:\n        return new Salesman()\n      case MANAGER:\n        return new Manager()\n      default:\n    }\n  }\n}\n```\n\n위 상황에서 메서드는 팩토리 메서드라서 생성자를 조건문을 재정의로 전환 기법을 적용할 수 없다. 왜냐하면 객체를 아직 작성하지 않았기 때문이다.\n\n```javascript\nclass Employee {\n  static create(type) {\n    // 이렇게 호출이 되고 해당 타입에 따라 실행하는 로직은 하위 클래스로 빼두어야 하는데\n    // Employee.create() 를 호출할 상황에서는 Employtee 내부에 this._type이라는 객체 즉, 직업군에 해당하는 객체를\n    // 따로 생성하지 않았기 때문에 조건문을 재정의 기법을 사용하기가 어렵다.\n    this._type.create()\n  }\n}\n```\n\n새 하위 클래스가 별로 많지 않을 것 같으므로 명시적 인터페이스가 적절하다.\n\n```javascript\nclass Employee {\n  static createEngineer() {\n    return new Engineer()\n  }\n\n  static createSalesman() {\n    return new Salesman()\n  }\n\n  static createManager() {\n    return new Manager()\n  }\n}\n```\n\n위 처럼 작성하면 `create` 메서드는 삭제가능하고 상수들 역시 삭제 가능하다.\n원본 `create` 메서드를 호출하는 부분을 다음과 같이 수정하자.\n\n```javascript\n// as-is\nconst kent = Empolyee.create(ENGINEER)\n// to-be\nconst kent = Empolyee.createEngineer()\n```\n\n## 객체롤 통째로 전달\n\n객체에서 가져온 여러 값을 메서드 호출에서 매개변수로 전달할 땐 그 객체를 통째로 전달하게 수정하자.\n\n객체가 한 객체에 든 여러 값을 메서드 호출할 때 매개변수로 전달하고 있다면 이 리팩토링 기법을 적용해야 한다.\n이럴 땐 호출된 객체가 나중에 새 데이터 값을 필요로 할 때마다 이 메서드를 호출하는 모든 부분을 찾아서 수정해야 한다는 문제가 있다.\n\n객체를 통째로 전달하는 방식에도 단점은 있다. 값을 전달할 때 호출되는 객체가 그 값들에 의존하게 되지만 값이 추출된 객체에는 의존하지 않게 된다는 점이다.\n통 객체를 전달하면 통 객체와 호출된 객체가 서로 의존하게 된다.\n\n호출하는 객체가 자체의 데이터 값 여러개를 매개변수로 전달하는 코드를 흔히 보게 된다. 이럴 땐 적절한 속성 접근 메서드가 있고 의존성에 대한 걱정이 없다면,\n호출하면서 여러개의 데이터 값 대신 this 를 전달하면 된다.\n\n### 예제\n\n하루 동안의 최고기온과 최저기온을 기록하는 Room 객체는 다음과 같다. 이 온도 범위를 미리 정의한 난방 계획의 온도 범위와 비교해야한다.\n\n```javascript\nclass Room {\n  withinPlan(plan) {\n    const low = this.daysTempRange().getLow()\n    const high = this.daysTempRange().getHigh()\n    return plan.withinRange(low, high)\n  }\n}\n\nclass HeatingPlan {\n  constructor() {\n    this._range\n  }\n  // 범위 정보를 low, high 개개인으로 넘기고 있다.\n  withinRange(low, high) {\n    return low >= this._range.getLow() && high <= this._range.getHigh()\n  }\n}\n```\n\n범위 정보를 일일이 전달할 것이 아니라 범위 객체를 통째로 전달하면 된다.\n\n```javascript\nclass Room {\n  withinPlan(plan) {\n    // HeatingPlan\n    // const low = this.daysTempRange().getLow()\n    // const high = this.daysTempRange().getHigh()\n    return plan.withinRange(this.daysTempRange())\n  }\n}\n\nclass HeatingPlan {\n  constructor() {\n    this._range = new TempRange(10, 30)\n  }\n\n  withinRange(roomRange) {\n    // TempRange\n    // return (low >= this._range.getLow() && high <= this._range.getHigh())\n    return this._range.includes(roomRange)\n  }\n}\n\nclass TempRange {\n  includes(arg) {\n    // TempRange\n    return arg.getLow() >= this.getLow() && arg.getHigh() <= this.getHigh()\n  }\n}\n```\n\n## 매개변수 세트를 메서드로 전환\n\n객체가 A 메서드를 호출해서 그 결과를 B 메서드에 매개변수로 전달하는데,\n결과를 매개변수로 받는 B 메서드도 직접 A 메서드를 호출할 수 있을 땐매개변수를 없애고 A 메서드를 B 메서드가 호출하게 하자.\n\n전달할 매개변수를 줄이려면 같은 계산을 수신 메서드도 할 수 있는지 검사해야 한다.\n객체가 자신의 메서드를 호출하지만 호출한 메서드의 매개변수가 계산에 전혀 사용되지 않는다면,\n그 계산을 별도의 메서드로 만들고 매개변수를 삭제할 수 있다. 호출하는 객체를 참조하는 다른 객체에 있는 메서드를 호출할 떄도 마찬가지다.\n\n### 예제\n\n할인 주문 예제이다.\n\n```javascript\ngetPrice() {\n  const basePrice = this._quantity * this._itemPrice\n  let discountLevel\n  // 할인 등급 계산 부분\n  if(this._quantity > 100) discountLevel = 2\n  else discountLevel = 1\n  // 할인 등급 계산 부분\n  const finalPrice = this.discountePrice(basePrice, discountLevel)\n  return fianlPrice\n}\n\ndiscountePrice(basePrice, discountLevel) {\n  if(discountLevel === 2) return basePrice * 0.1\n  else return basePrice * 0.05\n}\n```\n\n할인 등급 계산 부분을 메서드(`getDiscountLevel`)로 추출하자. 그리고 임시변수인 `discountLevel`를 삭제시켜 보자.\n\n```javascript\ngetPrice() {\n  const basePrice = this._quantity * this._itemPrice\n  // getDiscountLevel 생성 및 임시변수 삭제\n  // this.getDiscountLevel 계산을 this.discountPrice 메서드도 할 수 있다.\n  // let discountLevel = this.getDiscountLevel()\n\n  // const finalPrice = this.discountePrice(basePrice, discountLevel)\n  const finalPrice = this.discountePrice(basePrice)\n  return fianlPrice\n}\n\ngetDiscountLevel() {\n  if(this._quantity > 100) return 2\n  else 1\n}\n\ndiscountePrice(basePrice) {\n  // discountLevel 변수보단 직접 쓰게 만들자.\n  if(this.getDiscountLevel() === 2) return basePrice * 0.1\n  else return basePrice * 0.05\n}\n```\n\n`getBasePrice()` 메서드를 만들어서 나머지 `basePrice` 변수도 없애보자.\n\n```javascript\ngetPrice() {\n  // return this.discountePrice()\n  // 메서드 내용이 간단하기 때문에 discountePrice 메서드를 따로 사용 안했다.\n  if(this.getDiscountLevel() === 2) return this.getBasePrice() * 0.1\n  else return this.getBasePrice() * 0.05\n}\n\ngetDiscountLevel() {\n  if(this._quantity > 100) return 2\n  else 1\n}\n\n// discountePrice(basePrice) {\n//   if(this.getDiscountLevel() === 2) return this.getBasePrice() * 0.1\n//   else return this.getBasePrice() * 0.05\n// }\n\ngetBasePrice() {\n  return this._quantity * this._itemPrice\n}\n```\n\n## 매개변수 세트를 객체로 전환\n\n여러 개의 매개변수가 항상 붙어 다닐 땐 그 매개변수들을 객체로 바꾸자.\n\n특정 매개변수들이 늘 함께 전달되는 경우를 흔히 볼 수 있다. 즉, 항상 쌍으로 붙어다니는 매개변수가 있을 것이다. 이럴땐 여러 메서드가 한 클래스나 여러 클래스에서 이 매개변수 집합을 사용할 가능성이 있다.\n이런 클래스들은 데이터 뭉치이므로 그 모든 데이터가 든 객체로 바꿀 수 있다.\n데이터를 그룹으로 묶으려면 이 매개변수들을 객체로 바꾸는 것이 좋다. 이 리팩토링 기법을 실시하면 매개변수 세트가 짧게 줄어서 좋다. 새 객체에 정의된 속성 접근 메서드로 인해 코드의 일관성도 개선되고, 결과적으로 코드를 알아보거나 수정하기도 쉬워진다.\n\n더불어 매개변수를 한 덩이로 만들면 기능을 새 클래스로 옮길 수 있어서 훨씬 좋다. 메서드 안에 매개변수 값에 대한 공통적인 조작을 넣는 경우가 많다. 이 동작을 새 객체로 옮기면 상당량의 중복 코드를 없앨 수 있다.\n\n### 예제\n\nEntry 클래스는 단순히 데이터 클래스다.\nAccount 클래스엔 입금액 컬렉션이 들어 있고, 두 날짜 사이의 계좌 입출금 현황을 알아내는 메서드가 들어 있다.\n\n```javascript\nclass Entry {\n  constructor(value, chargeDate) {\n    this._value = value\n    this._chargeDate chargeDate\n  }\n\n  getDate() {\n    return this._chargeDate\n  }\n\n  getValue() {\n    return this._value\n  }\n}\n\nclass Account {\n  constructor(){\n    this._entries\n  }\n\n  getFlowBetween(start, end) {\n    let result = 0\n    const e = this._entries.elements()\n    for(let p of e) {\n      const each = p.value\n      if(each.getDate().equals(start) || each.getDate().equals(end) || (each.getDate().after(start) && each.getDate().before(end))) {\n        result += each.getValue()\n      }\n    }\n    return result\n  }\n}\n\n// 클라이언 코드\nconst flow = anAccount.getFlowBetween(startDate, endDate)\n```\n\n대체할 매개변수 그룹에 해당하는 새 클래스를 작성하고, 그 클래스를 변경 불가로 만들자.\n그 클래스는 범위를 처리하는 단순 데이터 클래스를 선언하자.\n`DateRange` 클래스는 변경불가로 만들어야 한다.\n\n```javascript\nclass DateRange {\n  constructor(start, end) {\n    this._start = start\n    this._end = end\n  }\n\n  getStart() {\n    return this._start\n  }\n\n  getEnd() {\n    return this._end\n  }\n}\n```\n\n이 `DateRange` 클래스를 이용하면 다음과 같이 고칠 수 있다.\n\n```javascript\nclass Entry {\n  //위 코드와 동일\n}\n\nclass DateRange {\n  constructor(start, end) {\n    this._start = start\n    this._end = end\n  }\n\n  getStart() {\n    return this._start\n  }\n\n  getEnd() {\n    return this._end\n  }\n\n  includes(arg) {\n    return (\n      arg.equals(this._start ||\n      arg.equals(this._end) ||\n      (arg.after(this._start) &&\n        arg.before(this._end))\n    )\n  }\n}\n\nclass Account {\n  constructor() {\n    this._entries\n  }\n\n  // DateRange range 매개변수\n  getFlowBetween(range) {\n    let result = 0\n    const e = this._entries.elements()\n    for (let p of e) {\n      const each = p.value\n      // 조건문 안쪽 코드도 DateRange 코드쪽으로 보내자.\n      // 메서드 추출과 메서드 이동을 적용하면 코드가 다음과 같아진다.\n      if (range.includes(each.getDate())) {\n        result += each.getValue()\n      }\n    }\n    return result\n  }\n}\n\n// 클라이언 코드\nconst flow = anAccount.getFlowBetween(new DtateRange(startDate, endDate))\n```\n\n## 쓰기 메서드 제거\n\n생성할 때 지정한 필드 값이 절대로 변경되지 말아야 할 땐 그 필드를 설정하는 모든 쓰기 메서드를 삭제하자.\n\n쓰기 메서드가 있다는건 필드 값을 변경할 수 있다는 얘기다. 객체가 생성된 후에는 필드가 변경되지 말아야 한다면, 쓰기 메서드를 작성하지 않아야 한다.\n그렇게 하면 확실히 의도가 달성되고 필드가 수정될 가능성을 차단할 수 있다.\n\njava 에서는 final 과 private 키워드들이 존재하지만 자바스크립트에서는 존재하지 않기에 네이밍 규칙으로써 이를 표현해본다.\n\n### 예제\n\n간단한 예를 들어보자. 생성할때 지정한 필드 값이 절대로 변경되지 말아야 한다.\n\n```javascript\nclass Account {\n  constructor(id) {\n    this.setId(id)\n  }\n\n  setId(id) {\n    this._id = id\n  }\n}\n```\n\n위와 같은 코드가 있다고 할때 `this._id`는 private 한 변수이다. 이를 절대 변하지 않도록 상수화 시킨다면\n\n```javascript\n// set 메서드를 만들어 두지 않는다.\nfunction accountContainer() {\n  let ID\n  return class Account {\n    constructor(id) {\n      ID = id\n    }\n\n    getId() {\n      return ID\n    }\n  }\n}\n```\n\n문제는 여기서 매개변수로 계산을 수행할때 이다. 계산식이 복잡하거나 그럴땐 별도의 메서드를 두고 호출해야한다.\n이때 메서드 이름은 의도가 확살히 드러나게 정해야 한다.\n\n```javascript\nfunction accountContainer() {\n  let ID\n  return class Account {\n    constructor(id) {\n      initializeId(id)\n    }\n\n    getId() {\n      return ID\n    }\n\n    initializeId(id) {\n      ID = 'ZZ' + id\n    }\n  }\n}\n```\n\n이번에는 하위클래스가 상위 클래스의 private 변수를 초기화 하는 예이다.\n\n```javascript\nfunction accountContainer() {\n  let ID\n  return class Account {\n    constructor(id) {\n      initializeId(id)\n    }\n\n    getId() {\n      return ID\n    }\n\n    initializeId(id) {\n      ID = 'ZZ' + id\n    }\n  }\n}\n\nconst Acc = accountContainer()\n\nclass interestAccount extends Acc {\n  constructor(id, rate) {\n    // 상위 클래스 생성자 이용.\n    super(id)\n\n    // 또는 관련 메서드 이용.\n    this.initializeId(id)\n\n    this._interest = rate\n  }\n}\n```\n\n## 메서드 은폐\n\n메서드가 다른 클래스에 사용되지 않을 땐 그 메서드의 반환 타입을 private 로 만들자.\n다른 클래스가 그 메서드를 사용한다면 개방도를 높여야 한다. 하지만 메서드의 개방도를 어떨 때 낮춰야 할지를 판단하기는 비교적 어렵다.\n\njavascript 에서는 메서드도 \\_(underbar)를 이용해서 private 를 표시해두자.\n\n## 생성자를 팩토리 메서드로 전환\n\n객체를 생성할 때 단순환 생성만 수행하게 해야 할 땐 생성자를 팩토리 메서드로 교체하자.\n\n이 리팩토링을 해야할 가장 확실한 상황은 분류 부호를 하위클래스로 바꿀 때 발생한다. 분류 부호를 사용해 작성한 객체가 있는데 현 시점에서 하위클래스가 필요해졌다.\n어느 하위 클래스를 사용할지는 분류 부호에 따라 달라진다. 하지만 생성자는 요청된 객체의 인스턴스 반환만 할 수 있다. 따라서 생성자를 팩토리 메서드로 바꿔야 한다.\n\n생성자가 너무 제한되는 다른 상황에서도 팩토리 메서드를 사용할 수 있다. 팩토리 메서드는 값을 참조로 전환을 실시하기 위해 꼭 필요하다.\n팩토리 메서드는 매개변수의 숫자와 타입을 벗어나는 다른 생성 동작을 나타낼 때도 사용할 수 있다.\n\n### 예제\n\n사원 급여 시스템 예제를 다시 보자.\n\n```javascript\nclass Employee {\n  static ENGINEER = 0\n  static SALESMAN = 1\n  static MANAGER = 2\n\n  constructor(type) {\n    this._type = type\n  }\n}\n```\n\n각 분류 부호에 해당하는 Employee 클래스의 하위 클래스를 작성하려 한다. 이를 위해 팩토리 메서드를 작성한다.\n\n```javascript\nclass Employee {\n  static create(type) {\n    return new Employee(type)\n  }\n}\n\n// 클라 코드\nconst eng = Employee.create(Employee.ENGINEER)\n```\n\n### 예제: 문자열을 사용하는 하위클래스 작성\n\n나중에 분류 부호를 하위클래스로 전환을 적용해서 분류 부호를 Employee 의 하위클래스로 전환할 경우, 팩토리 메서드를 사용하면 이 하위클래스를 클라이언트가볼 수 없게 은폐할 수 있다.\n\n한가지 단점은 switch 문이 생긴다는 것이다.\n\n```javascript\nclass Employee {\n  static create(type) {\n    switch (type) {\n      case ENGINEER:\n        return new Engineer()\n      case SALESMAN:\n        return new Salesman()\n      case MANAGER:\n        return new Manager()\n      default:\n    }\n  }\n}\n```\n\n이럴 땐 문자열을 받아서 자동으로 객체를 생성해주는 녀석을 하나 만들어서 사용할 수 있을 듯 싶다.\n\n```javascript\nclass Employee {\n  static create(name) {\n    try {\n      // 사실 자바스크립트에선 이런 메서드가 없다.\n      return Class.forName(name).newInstance()\n    } catch (e) {\n      throw new Error('')\n    }\n  }\n}\n\n// as-is\nEmployee.create(ENGINEER)\n// to-be\nEmployee.create('Engineer')\n```\n\n위와 같은 방법은 오타로 인한 에러가 발생할 수 있고 하위 클래스 이름이 클라이언트에 노출된다는 것이다.\n\n### 예제: 메서드를 사용하는 하위클래스 작성\n\n이 방법은 변하지 않는 두세 개의 하위클래스만 있을 때 사용가능하다.\n\n```javascript\nclass Person {\n  static createMale() {\n    return new Male()\n  }\n\n  static createFemale() {\n    return new Female()\n  }\n}\n\nconst kent = Person.createMale()\n```\n\n## 에러 부호를 예외 통지로 교체\n\n메서드가 에러를 나타내는 특수한 부호를 반환할 땐 그 부호 반환 코드를 예외 통지 코드로 바꾸자.\n\n에러 코드를 만났을 때 프로그램을 중단되게 할 수 있다. 하지만 이것은 비행기를 놓쳤다고 자살하는 것이나 다를 바 없다.\n물론 소프트웨어를 중단시키는 방식에도 장점은 있다. 프로그램 충돌이 사소하고 사용자도 인내심이 많아면 프로그램을 중단시키는 방법이 괜찮지만, 그보다 중요한 프로그램이라면좀 더 확실한 방법이 필요하다.\n\n문제는 프로그램에서 에러를 찾는 코드 부분에 반드시 그 에러를 처리하는 기능이 들어 있는 것은 아니란 점이다.\n에러 찾기 루틴은 에러를 발견하면 자신을 호출한 부분에 그것을 알리며, 호출한 부분이 그 에러를 상위 호출 코드로 보낼 수도 있다.\n\n예전 시스템은 과거 어떤 루틴의 성공이나 실패를 표시하기 위해 반환 코드를 사용하는데 (ex, -1 , 0)\n예외는 에러 처리를 일반적인 처리와 확실히 분리시키기 때문에 좋다. 예외와 일반로직의 관심사가 분리되는 것이다.\n\n### 예외 종류 (java)\n\n**사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외** 들은 **확인 에러** 들이다. 컴파일러가 체크하는 예외를 말한다. 예를들어 존재하지 않는 파일의 이름을 사용자가 입력할때 발생한다. <br/>\n**개발자의 실수에 의해 발생되는 예외** 들은 **미확인 예외(런타임 에러)** 들이다. 즉, 컴파일러가 체크되지 않는 예외를 말한다. 예를 들어 0 으로 나눠서 에러가 발생한다거나 배열범위 등이 있겠다. 이런것들은 개발자가 조금만 더 신경쓰면 예외가 발생하지 않는 예외들이다.\n\nchecked 예외(`확인 예외`) 는 컴파일 단계에서 확인되며 반드시 처리해야 하는 예외입니다. 프로그램 실행 흐름상 예외 발생 가능성이 있는 상황을 표현. 주로 외부의 영향으로 발생할 수 있는것들. 프로그램의 사용자들의 동작에 의해서 발생하는 경우가 많다. 예를 들면 존재하지 않는 파일을 처리한다던지, 클래스 이름을 잘못 적었다 던지, 입력한 데이터 형식이 잘못 되었다던지 하는 경우이다.<br />\nUnchecked 예외(`미확인 예외`) 는 실행 단계에서 확인되며 명시적인 처리를 강제하지는 않는 예외입니다. 이 예외는 발생 할수도 안 할수도 있는 경우에 작성한다. 이는 개발자가 만든 논리 오류를 나타낸다. 이를테면 null 에러는 검사 대상이 아니다. 거의 모든 메서드가 null 을 던질 수 있기 때문이다. 그러므로 개발자는 이 예외를 잡아내는데 시간을 낭비하면 안된다. 그보다는 우선 null 참조를 따라가지 않게 하는 것이 더 중요하다. 여기서는 try/catch 문을 사용하기 보다는 프로그래머들이 주의 깊게 작성하여 예외가 발생하지 않도록 해야 할것.\n\n구현자가 검사 예외를 던질지, 비검사 예외를 던질지 결정해야 할 때도 있다. integer.parseInt(str) 메서드는 str 이 유효한 정수를 담고 있지 않으면 비검사 예외를 던지게 된다.\n한편 class.forName(str) 은 str 이 유효한 클래스 이름을 담고 있지 않으면 검사 예외를 던진다.\n이렇게 다른 이유는 integer.parseInt 를 호출하기 전에는 문자열이 유효한 정수인지 검사할 수 있다. 하지만 실제로 클래스를 로드해보기 전에는 해당 클래스를 로드할 수 있는지 알 수 없기 때문이다.\n\nChecked Exception 과 Unchecked Exception 의 가장 명확한 구분 기준은 ‘꼭 처리를 해야 하느냐’이다. Checked Exception 이 발생할 가능성이 있는 메소드라면 반드시 로직을 try/catch 로 감싸거나 throw 로 던져서 처리해야 한다.\n<br/>\n반면에 Unchecked Exception 은 명시적인 예외처리를 하지 않아도 된다. 이 예외는 피할 수 있지만 개발자가 부주의해서 발생하는 경우가 대부분이고, 미리 예측하지 못했던 상황에서 발생하는 예외가 아니기 때문에 굳이 로직으로 처리를 할 필요가 없도록 만들어져 있다.\n\n체크 예외가 발생할 수 있는 메소드를 사용할 경우, 복구가 가능한 예외들이기 때문에 반드시 예외를 처리하는 코드를 함께 작성해야 한다. catch 문으로 예외를 잡든, throws 로 예외를 자신을 호출한 클래스로 던지는 방법으로 해결 <br/>\n언체크 예외는 따로 catch 문으로 잡거나, throws 로 선언하지 않아도 된다. 이러한 예외는 코드에서 미리 예방할 수 있다. 언체크 예외는 프로그램에 오류가 있을 때 발생하도록 의도된 것들이다. 그래서 굳이 catch, throws 를 이용해서 처리하지 않아도 되도록 만들었다.\n\n확인 예외시 메서드를 호출하는 쪽을 변경하는 방법은 다음과 같다.\n\n1. 호출하는 쪽에서 에러를 처리한다면 try...catch\n2. 호출하는 쪽에서 에러를 처리하지 않는다면 throws 절 추가\n\n미확인 예외시 메서드를 호출하는 쪽을 변경하는 방법은 다음과 같다.\n\n1. 호출하기 전에 조건 판정\n\n이 두 속성 중에 어느 것을 사용할 것인가에 대한 판단은 메서드를 호출한 객체가 해당 에러를 다룰 수 있는가를 판단하고, 가능하다면 checked, 아니면 unchecked 에러를 던집니다.\n그리고 메소드를 호출한 객체는 예외를 처리할 수 있을 때, 혹은 다른 예외 타입으로 변경이 필요할 때 해당 예외를 try/catch 구문으로 잡아서 처리할 수 있습니다.\n\n참조 :\n\n* [http://www.nextree.co.kr/p3239/](http://www.nextree.co.kr/p3239/)\n* [https://plus4070.github.io/nhn%20entertainment%20devdays/Exception.html](https://plus4070.github.io/nhn%20entertainment%20devdays/Exception.html)\n* [https://nesoy.github.io/articles/2018-05/Java-Exception](https://nesoy.github.io/articles/2018-05/Java-Exception)\n* [https://brunch.co.kr/@kd4/5](https://brunch.co.kr/@kd4/5)\n* [https://m.blog.naver.com/PostView.nhn?blogId=kbh3983&logNo=220826883989&proxyReferer=https%3A%2F%2Fwww.google.com%2F](https://m.blog.naver.com/PostView.nhn?blogId=kbh3983&logNo=220826883989&proxyReferer=https%3A%2F%2Fwww.google.com%2F)\n\n### 방법\n\n* 확인된 예외와 미확인 예외 중 어느 것을 사용해야 할지 판단하자.\n  * 호출 전에 호출하는 부분이 조건을 검사해야한다면 미확인 예외로 하자.\n  * 예외가 확인된 것이면 새 예외를 작성하거나 기존 예외를 사용하자.\n* 호출 부분을 전부 찾아서 그 예외를 사용하게 수정하자.\n  * 미확인 예외일 땐 **호출 부분이 메서드 호출 전에 적절한 검사** 를 하게 하자. 하나씩 수정할 때마다 컴파일과 테스트를 실시하자.\n  * 확인된 예외일 땐 호출 부분이 try 절 안에서 메서드를 호출하게 하자.\n\n### 예제\n\n```javascript\nclass Account {\n  withdraw(amount) {\n    if (amount > this._balance) {\n      return -1\n    } else {\n      this._balance -= amount\n      return 0\n    }\n  }\n}\n```\n\n위 코드가 예외를 사용하게 수정하려면 우선 확인된 예외와 미확인 예외 중 어느것을 사용할지 정해야 한다.\n이 결정은 출금 전의 잔액 검사하는 기능을 _호출 코드_ 가 담당하는지 _출금 메서드_ 가 담당하는지에 따라 달라진다.\n\n호출부의 책임인 경우에는 인출하기 전에 잔액 검사(미확인 예외)를 인출 루틴의 책임인 경우에는 인터페이스에 예외를 선언한다.(확인 예외)\n_미확인 예외_ 라면, 호출하는 부분에서 메서드를 호출하기 전에 검사를 한다.\n_확인된 예외_ 라면, 호출하는 부분에서 try 블록안에서 메소드를 호출하도록 조정한다.\n\n여기서 계좌 잔액 검사가 호출 부분에서 이뤄진다면 withdraw 메서드에 잔액보다 큰 금액을 전달하면서 호출하는 건 프로그래밍 에러다.\n즉 호출하는 사람, 사용하는 사람의 에러다. 이 프로그래밍 에러, 즉 버그는 **미 확인 예외** 를 사용해야 한다.\n반대로 잔액검사가 withdraw 메서드에서 이뤄진다면 예외를 반드시 인터페이스 안에 선언해야 한다.\n\n### 예제: 미확인 예외 (UncheckedException)\n\n_미확인 예외를 사용_ 하는 메서드를 사용하는 경우를 보자.\n호출하는 쪽에서 검사를 담당할 것이다. 반환 코드를 사용하는 부분이 없어야 한다. 그건 프로그래머 에러이기 때문이다.\n\n```javascript\n// 잔액 검사를 호출하는 부분에서 이뤄진다.\n// as-is\nif (account.withdraw(amount) === -1) {\n  handleOverdrawn()\n} else {\n  doTheUsalThing()\n}\n\n// 위 코드를 다음과 같이 수정해야 한다.\n// canWithdraw 메서드로 확인한다.\n// to-be\nif (!account.canWithdraw(amount)) {\n  handleOverdrawn()\n} else {\n  account.withdraw(amount)\n  doTheUsalThing()\n}\n```\n\n이제 에러코드를 삭제하고 에러 상황에 대한 예외를 통지해야 한다.\n기능은 정의에 따른다는 점에서 예외적이므로 다음과 같이 조건 검사에 감시 절을 넣어야 한다.\n조건이 특이한 조건이라면 그 조건을 검사해서 조건이 true 일때 반환하는 이런 식의 검사를 감시절 guard clause 이라고 한다.\n\n```javascript\nclass Account {\n  withdraw(amount) {\n    // 감시 절\n    // throw new IllegalArgumentException('액수가 너무 큽니다.')\n    // IllegalArgumentException 는 런타임 에러\n    if (amount > this._balance) throw new Error('액수가 너무 큽니다.')\n    this._balance -= amount\n  }\n}\n\n// 어셜션을 넣어서 한결 정확하게 표현\nclass Account {\n  withdraw(amount) {\n    // 감시 절\n    Assert.isTrue('잔액이 충분합니다', amount <= this._balance)\n    this._balance -= amount\n  }\n\n  canWithdraw() {\n\n  }\n}\n\nAssert {\n  static isTrue(comment, test) {\n    if(!test) {\n      // throw new RuntimeException('어셜션 실패' + comment)\n      throw new Error('어셜션 실패' + comment)\n    }\n  }\n}\n```\n\n### 예제: 확인된 예외 (CheckException)\n\n_확인된 예외_ 를 사용할땐 처리방법이 약간 다르다. 해당 메서드 사용자로 하여금 에러를 잡도록 유도한다.\n메서드를 만들 당시 호출해보지 않은 상태에서 확인되는 예외일때 예외를 발생한다.\n`withdraw` 메서드 안쪽에서 검사를 하고 예외를 발생시키기 때문에 호출하는 부분에서는 `try...catch`를 이용해서 예외를 잡아내야 한다.\n\n```javascript\n// 새 예외 객체 작성\nclass BalanceException extends Exception {}\n\n// 호출부분을 다음과 같이 수정하자.\ntry {\n  account.withdraw(amount)\n  doTheUsalThing()\n} catch(e) {\n  handleOverdrawn()\n}\n\n// 그 다음 예외를 사용하게 하자.\nwithdraw() {\n  if (amount > this._balance) throw new BalanceException();\n  this._balance -= amount\n}\n```\n\n요즘엔 확인된 예외를 사용하면 OCP(Open Closed Principle)을 위반하게 된다. 메소드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메소드 선언부를 고쳐야 한다. 이는 캡슐화를 깨버리는 현상이 발생하는 원인이 되기때문에 미확인 예외를 사용하라고 권장함.\n최하위 함수를 변경해 새로운 오류를 던진다 -> 선언부에 throws 절 추가 -> 연쇄 수정 발생\n\n결과적으로 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다.\n\n자바스크립트에는 따로 이런 구분되는 예외가 따로 없다. 여기서 느끼는 부분은 사용자에 의해 에러가 날 수 있는 부분은 확실하게 error 처리를 해주자.\n또한 프로그래머가 작성하는 일련의 코드들에 대한 예외 처리에 대해선 주의해서 작성해야 하며, 특히 해당 함수 호출 전에 적절한 검사를 하고 나서 호출을 처리하자.\ntry...catch는 개발 중에 예쌍하지 못한 비정상적인 상황에서 실패할 수 있는 코드 영역에서 사용하자. try...catch를 사용하기 가장 좋은 시기는 어떤 이유에서 건 제어가 불가능한 오류가 의심되는 코드에 적용하는 것이 좋다.\n\n## 예외 처리를 테스트로 교체\n\n호출 부분에 사전 검사 코드를 넣으면 될 상황인데 예외 통지를 사용했을 땐 호출 부분이 사전 검사를 실시하게 수정하자.\n\n**예외 처리는 예외적 기능, 즉 예기치 못한 에러에 사용해야 한다.** 예외 처리를 조건문 대용으로 사용해선 안된다.\n호출 부분이 메서드를 호출하기 전에 당연히 조건을 검사할 것으로 예상한다면, 개발자는 테스트를 작성해야 하고 호출 부분은 그 테스트를 사용해야 한다.\n\n### 예제\n\n각종 리소스를 관리하는 객체를 사용하겠다. 데이터베이스 접속이 좋은 예다.\n리소스 관리 객체는 두개의 리소스 풀이 들어 있다. 하나는 가용 리소스 풀이고 또 하나는 할당 리소스 풀이다.\n클라이언트가 리소스를 요청하면 리소스 관리 객체는 리소스를 넘겨주고 가용 풀에 있던 리소스를 할당 풀로 전달한다.\n\n클라이언트가 리소스를 해제하면 관리 객체는 거꾸로 할당 풀의 리소스를 가용 풀로 전달한다.\n클라이언트가 리소스를 요청했는데 사용 가능한 리소스가 없다면 관리 객체는 새 리소스를 생성한다.\n\n```javascript\nclass ResourcePool {\n  constructor() {\n    this._available // stack\n    this._allocated // stack\n  }\n\n  getResource() {\n    let result\n    try {\n      result = this._available.pop()\n      this._allocated.push(result)\n      return result\n    } catch (e) {\n      result = new Resource()\n      this._allocated.push(result)\n      return result\n    }\n  }\n}\n```\n\n여기서 **리소스 고갈은 예기치 못한 일이 아니므로** 예외 처리를 사용하면 안된다.\n\n```javascript\nclass ResourcePool {\n  constructor() {\n    this._available // stack\n    this._allocated // stack\n  }\n\n  getResource() {\n    let result\n\n    if (this._available.isEmpty()) {\n      result = new Resource()\n      this._allocated.push(result)\n      return result\n    } else {\n      result = this._available.pop()\n      this._allocated.push(result)\n      return result\n    }\n  }\n}\n```\n\n조건문의 공통 실행 코드 빼내기를 적용한다.\n\n```javascript\nclass ResourcePool {\n  constructor() {\n    this._available // stack\n    this._allocated // stack\n  }\n\n  getResource() {\n    let result\n\n    if (this._available.isEmpty()) {\n      result = new Resource()\n    } else {\n      result = this._available.pop()\n    }\n    this._allocated.push(result)\n    return result\n  }\n}\n```\n","excerpt":"해당 글은  에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다. 객체에서 가장 중요한 것은 인터페이스다. 이해와 사용이 쉬운 인터페이스를 작성하는 기술이야 말로 좋은 객체지향 소프트웨어 개발에 꼭 필요하다. 메서드 변경 메서드명…","fields":{"slug":"/simplifying-method-calls/"},"frontmatter":{"date":"Apr 15, 2019","title":"(리팩토링) 메서드 호출 단순화","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n자바스크립트는 메모리에 있는 데이터 구조의 전체 접근 권한을 주지 않는다.\n하지만 언어차원에서 reference types 는 존재한다.\nvalue 와 reference types 의 혼합은 원하지 않은 사이드 이펙트나 버그를 유발하기도 한다.\nvalue 와 reference types 를 이해는 강력한 프로그래밍을 작성하는데 중요한 역활을 한다.\n\n이 기사는 자바스크립트의 value 와 reference types 를 입문단계에서 소개한다.\n\n### Value and Reference types\n\nNumbers, booleans, strings, null and undefined 은 원시타입들이다. 모든 원시 타입들은 값에 의해 전달된다. Objects, arrays, and functions 들은 참조로 전달된다.\n\nStrings 은 자바스크립트에서 특별한 존재이다. 다른 많은 언어와 달리 string 은 character 의 배열처럼 정의 되지 않는다. 무엇보다 character 타입이 자바스크립트에는 존재하지 않는다. Strings 는 변화하지 않는 데이터 타입으로 문자 배열처럼 보이게 하는 인터페이스를 지니고 있다. 실제로 문자열을 수정하면 새로운 불변의 값이 생겨난다.\n\n다음 콘솔로그의 결과를 함께 알아보자.\n\n```javascript\nvar people = [{ name: 'John Hill', age: 22 }, { name: 'Jack Chill', age: 27 }]\n\nvar getInitials = function(name) {\n  // Reusing the name argument makes little sense in general.\n  // We are making this assignment here for demonstrating\n  // the difference between value types and reference types.\n  name = name\n    .split(' ')\n    .map(function(word) {\n      return word.charAt(0)\n    })\n    .join('')\n  console.log(name)\n  return name\n}\n\nvar increaseAge = function(person) {\n  person.age += 1\n}\n\nvar addPerson = function(people, name, age) {\n  people.push({ name: name, age: age })\n}\n\n// Part 1: getInitials\nconsole.log(getInitials(people[0].name))\nconsole.log(people[0].name)\n\n// Part 2: increaseAge\nincreaseAge(people[1])\nconsole.log(people[1].age)\n\n// Part 3: addPerson\naddPerson(people, 'Jim Gordon', 32)\nconsole.table(people)\n```\n\n**Question**: 무엇이 콘솔에 기록이 될까?\n**Answer**:\n\n* 첫번째 파트에서 name 의 이니셜들은 `getInitials` 함수에 의해서 구성이 된다. 문자열 값은 함수에 복사 되서 전달됩니다. 이 복사된 값은 함수 안에서 접근되고 수정됩니다. 이 수정들은 원본 `people[0].name` 에 영향을 끼치지 않는다.\n* `increaseAge` 함수는 객체를 받는다. 이 객체들은 reference types 이기 때문에 `person`의 레퍼런스 값이 복사되어서 전달된다. 이 객체 레퍼런스의 멤버들을 수정할때, 이 변화들은 함수 실행 이후로도 유지된다. 이러한 변경 사항은 각 참조를 통해 액세스 할 수 있다.\n* Arrays 들도 reference types 이다. array 에 element 를 추가하면 이 변화는 계속 지속이 된다.\n\n```javascript\nJH\nJH\nJohn Hill\n28\n\n(index)  name  age\n0  \"John Hill\"  22\n1  \"Jack Chill\"  28\n2  \"Jim Gordon\"  32\n```\n\n정리:\n\n* `console.table`은 나이스한 로깅 유틸리티이다. 이것은 모던 브라우저에서 object 를 배열의 테이블 처럼 표시해준다.\n\n### 실수: value type 을 reference type 으로 다루다.\n\n`increaseAge` 메서드를 잘못 사용하는 경우이다.\n\n```javascript\nfunction increaseAge(age) {\n  age += 1\n}\nconsole.log('Before:', people[0].age)\nincreaseAge(people[0].age)\nconsole.log('After:', people[0].age)\n```\n\n이 `increaseAge`를 실행시켜도 나이는 22 로 유지된다. 원시 타입은 값으로 전달되기 때문이다. 복사된 값의 변화는 원본에 아무런 영향을 끼치지 않는다. 항상 변화되길 원한다면 array 나 object 로 원하는 필드를 감싸야 한다.\n\n다른 예는 person 을 다른 person 으로 변화시키려는 시도이다.\n`replacePerson` 함수는 3 가지의 매개변수를 받는다. person 을 새로운 name 과 age 를 가지고 변화시키는 로직이 있다.\n\n```javascript\nfunction replacePerson(person, name, age) {\n  person = { name: name, age: age }\n}\nreplacePerson(people[1], 'Jack Newtown', 35)\nconsole.table(people)\n```\n\n이 함수는 person 매개변수에 새로운 값을 할당받았으므로 people 객체에 아무것도 하지 않는다. people 데이터 구조는 그대로 유지된다. 함수 안에 있는 person 은 완전히 새로운 객체를 할당받게 됩니다. 함수가 종료후 이 새로운 객체는 버려지게 됩니다.\n\n### 실수: reference type 을 value type 으로 다루다.\n\n고객이 슈퍼마켓에 들어가서 츄잉껌을 구입한다고 가정하자. 고객은 또한 빈병을 부지런히 수집했으며 1000 유로 바우처에 가치가 있는 4000 병을 현금으로 바꿔 왔다. 계산원이 지불금을 수락 할 수있는 충분한 자금이 있는지 확인하고 있다. 이 검사는 boolean 결과를 반환하는 canChange 함수에 의해 수행된다.\n\n```javascript\nvar shopTransaction = {\n  items: [{ name: 'Astro Mint Chewing Gum' }],\n  price: 1,\n  amountPaid: 1000,\n}\n\nvar cashier = {\n  units: [500, 200, 100, 50, 20, 10, 5, 2, 1],\n  quantity: [0, 0, 5, 4, 5, 10, 10, 20, 9],\n}\n\nfunction canChange(shopTransaction, cashier) {\n  var amount = shopTransaction.amountPaid - shopTransaction.price\n  for (var i = 0; i < cashier.units.length; ++i) {\n    var unit = cashier.units[i]\n    while (amount >= unit && cashier.quantity[i] > 0) {\n      amount -= unit\n      cashier.quantity[i] -= 1\n    }\n  }\n  return amount === 0\n}\nconsole.log(canChange(shopTransaction, cashier))\nconsole.log(cashier.quantity)\n```\n\n이 함수는 우리가 기대하는 값을 반환하지만 여전히 문제가 있다. `canChange` 함수를 실행하면 side effect 이 발생하여 모든 기록이 cashier 에서 사라졌다. 왜?\n\n문제는 `cashier`이 참조 유형이라는 것이다. cashier 내부의 필드에 대한 모든 변경 사항은 함수 종료 후에도 유지된다.\n\n가능한 해결책은 새로운 변수를 생성하고이를 `cashier.quantity[i]`와 동일시하는 것이다. 이것은 우리가 원시 타입을 다루고 있기 때문에 `cashier.quantity[i]`의 값을 메모리의 새로운 위치에 복사 할 것이다.\n\n```javascript\nfunction canChange(shopTransaction, cashier) {\n  var amount = shopTransaction.amountPaid - shopTransaction.price\n  for (var i = 0; i < cashier.units.length; ++i) {\n    var unit = cashier.units[i]\n    var currentQuantity = cashier.quantity[i]\n    while (amount >= unit && currentQuantity > 0) {\n      amount -= unit\n      currentQuantity -= 1\n    }\n  }\n  return amount == 0\n}\n```\n\n이론적으로, 값을 변경하기위해 지원하지 않는 함수에서 모든 참조 유형을 깊이 복제 할 수도 있다. 깊은 복제는 말은 쉽지만 그렇지 않다. 우리는 다음 기사에서 다양한 유형의 복제를 탐색 할 것이다.\n\n### 요약\n\n기본 유형은 값으로 전달 된다. 배열, 객체 및 함수는 참조로 전달된다. 두 가지를 섞어 본 적이 있다면 위의 예를 살펴봐야 합니다. 예제에서 이야기 한 이야기를 함수가 가질 수있는 여러 유형의 인수와 연관 시켜야 한다. 실수를 피하기 위해 이러한 개념이 자연스럽게 나타날 때까지 계속 연습하자.\n","excerpt":"자바스크립트는 메모리에 있는 데이터 구조의 전체 접근 권한을 주지 않는다.\n하지만 언어차원에서 reference types 는 존재한다.\nvalue 와 reference types 의 혼합은 원하지 않은 사이드 이펙트나 버그를 유발하기도 한다.\nva…","fields":{"slug":"/value-and-reference.md/"},"frontmatter":{"date":"Apr 07, 2019","title":"Javascript의 Value와 Reference Types 이해","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n해당 글은 `리팩토링 (코드 품질을 개선하는 객체지향 사고법)` 에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다.\n\n## 조건문 쪼개기 (Decompose Conditional)\n\n복잡한 조건문(if-then-else)이 있을땐 if, then, eles 부분을 각각 메서드로 빼내자.\n\n```javascript\n// bad\nif (data.before(SUMMER_START) || data.after(SUMMER_END)) {\n  charge = quantity * _winterRate + _winterServiceCharge\n} else {\n  charge = quantity * _summerRate\n}\n\n// good\nif (notSummer(date)) {\n  charge = winterCharge(quantity)\n} else {\n  charge = summerCharge(quantity)\n}\n```\n\n큰 덩어리의 코드를 잘게 쪼개고 각 코드 조각을 용도에 맞는 이름의 메서드 호출로 바꾸면 코드의 용도가 분명히 드러난다.\n이 과정을 조건문의 if 절, then 절, else 절 각각에 대해 수행하면 더 큰장점을 얻을 수 있다.\n\n## 중복 조건식 통합 (Consolidate Conditional Expression)\n\n여러 조건 검사식의 결과가 같을 땐 하나의 조건문으로 합친 후 메서드로 빼내자.\n\n서로 다른 여러 개의 조건 검사식이 있는데 조건에 따른 결과가 모두 같을 때가 간혹 있다. 이럴 때는 논리 연산자 AND 와 OR 을 사용해서 여러 조건 검사를 하나로 합쳐야 한다.\n조건문을 합쳐야 하는 이유는 두가지 이다.\n첫째, 조건식을 합치면 여러 검사를 OR 연산자로 연결해서 실제 하나의 검사 수행을 표현해서 무엇을 검사하는지 더 확실히 이해할 수 있다.\n둘째, 이러한 조건식 통합 리팩토링 기법을 실시하면 메서드 추출을 적용할 수 있는 기반이 마련된다.\n\n조건 검사식이 독립적이고 하나의 검사로 인식되지 말아야 할 땐 이방법을 사용하지 말자.\n\n### 예제: 논리합(OR) 연산자\n\n다음과 같은 상태의 코드가 있다.\n\n```javascript\ndisabilityAmount() {\n  if(this._seniority < 2) return 0\n  if(this._monthsDisabled > 12) return 0\n  if(this._isPartTime) return 0\n  // 장애인 공제액 산출\n}\n```\n\n이럴때 조건문이 여러 개 있고 모두 같은 값 0 을 반환한다. 조건문이 이렇게 순차적일 땐 다음과 같이 논리합 연산자인 ||로 연결한 하나의 조건문으로 만들 수 있다.\n\n```javascript\ndisabilityAmount() {\n  if(this._seniority < 2 || this._monthsDisabled > 12 || this._isPartTime) return 0\n  // 장애인 공제액 산출\n}\n```\n\n이제 조건문을 보면 이 조건이 무엇을 찾으려는 것인지 한눈에 알 수 있게 메서드 추출을 적용하자.\n\n```javascript\ndisabilityAmount() {\n  if(this.isNotEligibleForDisability()) return 0\n  // 장애인 공제액 산출\n}\n\nisNotEligibleForDisability() {\n  return (this._seniority < 2 || this._monthsDisabled > 12 || this._isPartTime)\n}\n```\n\n### 예제: 논리곱(AND) 연산자\n\n연산자 && 으로도 마찬가지로 여러 조건문을 하나로 연결할 수 있다.\n\n```javascript\nif (onVacation()) if (lengthOfService() > 10) return 1\nreturn 0.5\n```\n\n이 코드에서 겹친 조건문을 논리곱 연산자로 다음과 같이 연결할 수 있다.\n\n```javascript\nif (onVacation() && lengthOfService() > 10) return 1\nelse return 0.5\n```\n\n조건식 안의 루틴이 단순히 조건을 검사해서 값을 반환할 땐 다음과 같이 삼항연산자를 사용해서 그 루틴을 한줄의 return 문으로 만들자.\n\n```javascript\nreturn onVacation() && lengthOfService() > 10 ? 1 : 0.5\n```\n\n## 조건문의 공통 실행 코드 빼내기 (Consolidate Duplicate Conditional Fragments)\n\n조건문의 모든 절에 같은 실행 코드가 있을 땐 같은 부분을 조건문 밖으로 빼자.\n\n### 예제\n\n```javascript\n// bad\nif (isSpecialDeal()) {\n  total = price * 0.95\n  send()\n} else {\n  total = price * 0.98\n  send()\n}\n\n// good\nif (isSpecialDeal()) {\n  total = price * 0.95\n} else {\n  total = price * 0.98\n}\nsend()\n```\n\n## 제어 플래그 제거 (Remove Control Flag)\n\n여러 조건문이 사용된 코드에는 조건문을 빠져나갈 시점을 결정하는 제어 플래그가 흔히 사용된다.\n논리 연산식의 제어 플래그 연할을 하는 변수가 있을땐 그 변수를 break 문이나 return 문으로 바꾸자.\n\nbreak 문이나 continue 문이 있는 언어에서도 메서드 추출 후 return 문으로 바꾸는 방법을 선호한다.\n대체로 return 문을 사용할 수 있는 코드가 있으면 무슨 수를 써서라도 그 부분을 메서드로 추출해야 한다.\n\n### 예제: 간단한 제어 플래그를 break 문으로 교체\n\n```javascript\n  checkSecurity(people) {\n    let found = false\n    for(let i = 0; i < people.length; i++) {\n      if(!found) {\n        if(people[i].equals('Don')) {\n          sendAlert()\n          found = true // 제어 플래그\n        }\n\n        if(people[i].equals('John')) {\n          sendAlert()\n          found = true\n        }\n      }\n    }\n  }\n```\n\n여기서 제어 플래그는 found 변수에 true 값을 대입하는 부분이 제어 플래그다. 그 부분들을 한번에 한 부분씩 break 문으로 바꾸자.\n\n```javascript\ncheckSecurity(people) {\n  for(let i = 0; i < people.length; i++) {\n    if(people[i].equals('Don')) {\n      sendAlert()\n      break\n    }\n    if(people[i].equals('John')) {\n      sendAlert()\n      break\n    }\n  }\n}\n```\n\n### 예제: 제어 플래그를 return 문으로 교체\n\n제어 플래그를 결괏값으로 사용하게 변형한 코드는 다음과 같다.\n\n```javascript\n  checkSecurity(people) {\n    let found = ''\n    for(let i = 0; i < people.length; i++) {\n      if(!found) {\n        if(people[i].equals('Don')) {\n          sendAlert()\n          found = 'Don'\n        }\n\n        if(people[i].equals('John')) {\n          sendAlert()\n          found = 'John'\n        }\n      }\n    }\n\n    someLaterCode(found)\n  }\n```\n\n여기서 `found` 는 결과를 나타내기도 하고 제어 플래그 역할도 한다. 이럴땐 `found` 변수를 알아내는 코드를 메서드로 빼내자.\n\n```javascript\ncheckSecurity(people) {\n  let found = foundMiscreant(people)\n  someLaterCode(found)\n }\n\ncheckSecurity(people) {\n  for(let i = 0; i < people.length; i++) {\n\n    if(people[i].equals('Don')) {\n      sendAlert() // 상태 변경 관련 코드\n      return 'Don' // 값 반환 코드\n    }\n\n    if(people[i].equals('John')) {\n      sendAlert()\n      return 'John'\n    }\n  }\n  return ''\n}\n```\n\n이 메서드의 기능엔 아직 부작용이 있다. 그래서 `상태 변경 메서드와 값 반환 메서드를 분리` 기법을 실시해야 한다.\n\n## 여러 겹의 조건문을 감시 절로 전환 (Replace Nested Conditional with Guard Clauses)\n\n메서드에 조건문이 있어서 정상적인 실행 경로를 파악하기 힘들 땐 모든 특수한 경우에 감시 절을 사용하자.\n\n조건식은 주로 두 가지 형태를 띤다. 첫째는 어느 한 경로가 정상적인 동작의 일부인지 검사하는 형태이고, 둘째는 조건식 판별의 한 결과만 정상적인 동작을 나타내고 나머지는 비정상적인 동작을 나타내는 형태다.\n\n_만약 둘다 정상 동작의 일부분이라면 if 절과 else 절로 구성된 조건문을 사용하고, 조건문이 특이한 조건이라면 그 조건을 검사해서 조건이 true 일 경우 반환하자. 이런 식의 검사를 감시 절이라고 한다._\n\n여러 겹의 조건문을 감시 절로 전환기법의 핵심은 강조 부분이다. if-then-else 문을 사용하면 if 절과 else 절의 비중이 동등하다.\n따라서 코드를 보는 사람은 if 절과 else 절의 비중이 같다고 판단하게 된다.\n그와 달리, 감시 절은 \"이것은 드문 경우이니 이 경우가 발생하면 작업을 수행한 후 빠져나와라\" 하고 명령한다.\n\n유일한 진입점은 현대의 프로그래밍 언어에 표준처럼 굳어졌지만, 유일한 이탈점 규칙은 별로 바람직하지 않다.\n메서드의 이탈점을 하나만 사용해서 더 명확해진다면 그렇게 해야겠지만, 그렇지 않을 때는 굳이 한 개의 이탈점을 고집하지 말자.\n\n### 예제\n\n사망직원, 해고직원, 은퇴직원의 경우 특수 규칙이 적용되는 급여 정산 시스템을 실행한다고 가정하자.\n\n```javascript\ngetPayAmount() {\n  let result\n  if(this._isDead) result = deadAmount()\n  else {\n    if(this._isSeparated) result = separatedAmount()\n    else {\n      if(this._isRetired) result = retiredAmount()\n      else result = normalPayAmount()\n    }\n  }\n\n  return result\n}\n```\n\n조건문으로 인해 정상적인 실행 경로를 알기가 쉽지 않다. 이럴 땐 감시 절을 사용하면 코드를 이해하기 쉬워진다.\n\n```javascript\ngetPayAmount() {\n  if(this._isDead) return deadAmount()\n  if(this._isSeparated) return separatedAmount()\n  if(this._isRetired) return retiredAmount()\n  return normalPayAmount()\n}\n```\n\n메서드에 더 이상 중요한 작업이 남아 있지 않다면, 그 메서드를 빠져나오게 해서 관심이 없음을 나타낸다.\n\n### 예제: 조건문을 역순으로 만들기\n\n```javascript\ngetAdjustedCapital() {\n  let result = 0.0\n  if(this._capital > 0.0) {\n    if(this._intRate > 0.0 && this._duration > 0.0) {\n      result = (this._income / this._duration) * ADJ_FACTOR\n    }\n  }\n  return result\n}\n```\n\n다음과 같이 변형한다.\n\n```javascript\ngetAdjustedCapital() {\n  if(this._capital <= 0.0) return 0.0\n  if(this.intRate <= 0.0 || this._duration <= 0.0) return 0.0\n  return (this._income / this._duration) * ADJ_FACTOR\n}\n```\n\n## 조건문을 재정의로 전환 (Replace Conditional with Polymorphism)\n\n객체 타입에 따라 다른 기능을 실행하는 조건문이 있을 땐 조건문의 각 절을 하위클래스의 재정의 메서드 안으로 옮기고, 원본 메서드는 abstract 타입으로 수정하자.\n\n객체 관련 전문용어 중 가장 웅대한 표현은 다형성이다. 재정의의 본질은 타입에 따라 기능이 달라지는 여러 객체가 있을 때 일일이 조건문을 작성하지 않아도 다형적으로 호출되게 할 수 있다는 것이다.\n그래서 분류 부호에 따라 다른 코드를 실행하는 switch 문이나 문자열에 따라 다른 코드를 실행하는 it-then-else 문은 객체지향 프로그램에서 별로 사용하지 않는다.\n\n이런 조건문 덩어리가 프로그램의 여러 곳에 있을 때 가장 큰 효과를 볼 수 있다. 새 타입을 추가하려면 모든 조건문을 찾아서 수정해야 한다. 그러나 하위클래스를 사용하면 새 하위클래스를 작성하고 적당한 메서드만 넣으면 된다. 클래스 사용 부분은 그 하위클래스를 알 필요가 없어서 시스템 내부의 의존성이 줄어들고 수정이 쉬워진다.\n\n이것을 적용할 조건문은 switch-case 문이나 if 문이다.\n\n### 예제\n\n사원 월급 예제를 보자. `분류 부호를 상태/전략 패턴으로 전환` 예제를 참고하자.\nEmployee 클래스의 `payAmount 메서드`의 switch 문을 리펙토링 해보자.\n\n```javascript\nclass Employee {\n  // 여기에 정의 내렸던 분류 부호 정의를 삭제\n  // EmployeeType 클래스 참조를 넣자.\n  // ...\n  getType() {\n    // 이제 _type은 EmployeeType의 인스턴스다.\n    return this._type.getTypeCode()\n  }\n\n  setType(type) {\n    this._type = EmployeeType.newType(type)\n  }\n\n  // 이제 payAmount 메서드에 `조건문을 재정의로 전환 기법`을 적용할 수 있다.\n  payAmount() {\n    switch (this.getType()) {\n      case EmployeeType.ENGINEER:\n        return this._monthlySalary\n        break\n      case EmployeeType.SALESMAN:\n        return this._monthlySalary + this._commission\n        break\n      case EmployeeType.MANAGER:\n        return this._monthlySalary + this._bonus\n        break\n      default:\n    }\n  }\n}\n```\n\n위 코드에서 `payAmount` 메서드를 `EmployeeType` 클래스로 옮기고 `Employee 클래스의 데이터`가 필요하므로 Employee 클래스를 인자로 전달해야한다.\n\n```javascript\nclass Employee {\n  payAmount() {\n    return this._type.payAmount(this)\n  }\n\n  getType() {\n    // 이제 _type은 EmployeeType의 인스턴스다.\n    return this._type.getTypeCode()\n  }\n\n  setType(type) {\n    this._type = EmployeeType.newType(type)\n  }\n}\n\nclass EmployeeType {\n  static ENGINEER = 0\n  static SALESMAN = 1\n  static MANAGER = 2\n\n  payAmount(emp) {\n    // emp는 Employee 인스턴스\n    switch (this.getTypeCode()) {\n      case ENGINEER:\n        return emp.getMonthlySalary()\n        break\n      case SALESMAN:\n        return emp.getMonthlySalary() + emp.getCommission()\n        break\n      case MANAGER:\n        return emp.getMonthlySalary() + emp.getBonus()\n        break\n      default:\n    }\n  }\n}\n```\n\n위의 코드에서 `payAmount`메서드를 정리해보자.\n하나씩 case 문의 ENGINEER 절 코드를 `Engineer` 클래스로 코드를 복사하자.\n그리고 `EmployeeType` 클래스(상위클래스)에 payAmount 메서드는 추상 메서드로 선언하자.\n\n```javascript\nclass Employee {\n  payAmount() {\n    return this._type.payAmount(this)\n  }\n\n  getType() {\n    // 이제 _type은 EmployeeType의 인스턴스다.\n    return this._type.getTypeCode()\n  }\n\n  setType(type) {\n    this._type = EmployeeType.newType(type)\n  }\n}\n\nclass EmployeeType {\n  static ENGINEER = 0\n  static SALESMAN = 1\n  static MANAGER = 2\n\n  payAmount(emp) {} // abstract 추상메서드로 남겨두자.\n\n  static newType(type) {\n    switch (type) {\n      case ENGINEER:\n        return new Engineer()\n        break\n      case SALESMAN:\n        return new Salesman()\n        break\n      case MANAGER:\n        return new Manager()\n        break\n      default:\n    }\n  }\n}\n\nclass Engineer extends EmployeeType {\n  getTypeCode() {\n    return EmployeeType.ENGINEER\n  }\n\n  payAmount(emp) {\n    // emp는 Employee 인스턴스\n    return emp.getMonthlySalary()\n  }\n}\n\nclass Salesman extends EmployeeType {\n  getTypeCode() {\n    return EmployeeType.ENGINEER\n  }\n\n  payAmount(emp) {\n    // emp는 Employee 인스턴스\n    return emp.getMonthlySalary() + emp.getCommission()\n  }\n}\n\nclass Manager extends EmployeeType {\n  getTypeCode() {\n    return EmployeeType.ENGINEER\n  }\n\n  payAmount(emp) {\n    // emp는 Employee 인스턴스\n    return emp.getMonthlySalary() + emp.getBonus()\n  }\n}\n```\n\n## Null 검사를 널 객체에 위임 (Introduce Null Object)\n\nnull 값을 검사하는 코드가 계속 나올 땐 null 값을 널 객체로 만들자.\n\n### 예제\n\n공공설비 업체는 공공 설비 서비스를 이용하는 주택가와 아파트 단지 등의 지역을 파악하고 있다. 한 지역에 있는 고객은 반드시 하나다.\n\n```javascript\nclass Site {\n  constructor() {\n    this._customer\n  }\n\n  getCustomer() {\n    return this._customer\n  }\n}\n\nclass Customer {\n  getName() {} // return\n  getPlan() {} // return BillingPlan 객체\n  getHistory() {} // return PaymentHistory 객체\n}\n\nclass PaymenHistory {\n  getWeeksDelinquentInLastYear() {}\n}\n\n// 위와 같은 코드가 있을때 클라이언트는 다음과 같은 데이터에 접근가능하다.\n// 하지만 고객이 없는 지역도 있기에 Customer 클래스를 사용하는 코드에 다음과 같은 null 처리를 해야한다.\n\nconst customer = site.getCustomer()\nlet plan\n\nif (customer === null) plan = BillingPlan.basic()\nelse plan = customer.getPlan()\n\n// ...\n\nlet customerName\nif (customer === null) customerName = 'occupant'\nelse customerName = customer.getName()\n\n// ...\n\nlet weeksDelinquent\nif (customer === null) weeksDelinquent = 0\nelse weeksDelinquent = customer.getHistory().getWeeksDelinquentInLastYear()\n```\n\n이때 모든 부분에서 null 검사해서 null 을 발견할 때마다 같은 작업을 수행해야 할 수도 있다. 따라서 널 객체가 필요하다.\n\n```javascript\nclass NullCustomer extends Customer {\n  isNull() {\n    return true\n  }\n}\n\nclass Customer {\n  isNull() {\n    return false\n  }\n\n  // 팩토리 메서드\n  static newNull() {\n    return new NullCustomer()\n  }\n}\n\n// 이때부터 null이 예상될 때마다 새 널 객체를 반환하고 foo === null 형태의 null 검사 코드를\n// foo.isNull() 형태의 코드로 수정하자.\n\nclass Site {\n  getCustomer() {\n    return this._customer === null ? Cusomer.newNull() : this._customer\n  }\n}\n\n// 클라이언트는 아래와 같이 코드를 작성한다.\nconst customer = site.getCustomer()\nlet plan\n\nif (customer.isNull()) plan = BillingPlan.basic()\nelse plan = cusomter.getPlan()\n\n// ...\n\nlet customerName\nif (customer.isNull()) customerName = 'occupant'\nelse customerName = customer.getName()\n\n// ...\n\nlet weeksDelinquent\nif (customer.isNull()) weeksDelinquent = 0\nelse weeksDelinquent = customer.getHistory().getWeeksDelinquentInLastYear()\n```\n\n아직 장점이 와 닿지 않는다. 그 장점은 `NullCustomer`로 기능을 옮기고 조건문을 삭제해야 느낄 수 있다. 이 과정은 한번에 하나씩 실시하면 된다.\n`NullCustomer` 클래스에 적합한 name 읽기 메서드를 추가하자.\n\n```javascript\nclass NullCustomer {\n  isNull() {\n    return true\n  }\n\n  getName() {\n    return 'occupant'\n  }\n\n  setPlan(arg) {}\n\n  getHistory() {\n    return PaymentHistory.newNull() // 여기서 아래 NullPaymentHistory 객체를 반환.\n  }\n}\n// 이렇게 작성하면 클라이언트 코드에서 다음과 같이 바뀔 수 있다.\n// 조건문 코드는 삭제해도 된다. 한줄로만 작성이 가능하다.\ncustomerName = customer.getName()\n\n// 변경 메서드들도 다음과 같이 처리할 수 있다.\nif (!customer.isNull()) {\n  customer.setPlan(BillingPlan.special())\n}\n// 위와 같은 코드는 아래처럼 바꿀 수 있다.\ncustomer.setPlan(BillingPlan.special())\n\n// 아래와 같은 코드는 어떻게 하면 처리 할 수 있을까?\nlet weeksDelinquent\nif (customer.isNull()) weeksDelinquent = 0\nelse weeksDelinquent = customer.getHistory().getWeeksDelinquentInLastYear()\n\n// NullPaymentHistory 라는 클래스를 만든다.\nclass NullPaymentHistory extends PaymentHistory {\n  getWeeksDelinquentInLastYear() {\n    return 0\n  }\n}\n// 위 처럼 작성해놓으면 조건문을 삭제할 수 있다.\n// 널 객체가 다른 널 객체를 반환하는 일은 자주 있다.\nlet weeksDelinquent = customer.getHistory().getWeeksDelinquentInLastYear()\n```\n\n이 리팩토링 기법을 실시할 때 null 이 여러 종류일 수도 있따. customer 가 없는 것은 입주하지 않은 새 건물과 같고 미지의 customer 가 있는 것은 누군가 살지만 그게 누구인지 모르는 것과 같다.\n이렇게 다른 두 null 상황에 대한 클래스를 각각 작성하면 된다.\n\n## 어설션 넣기 (Introduce Assertion)\n\n일부 코드가 프로그램의 어떤 상태를 전제할 땐 어설션을 넣어서 그 전제를 확실하게 코드로 작성하자.\n\n특정 조건이 참일 때만 코드의 일부분이 실행되는 경우가 많다. 객체를 사용할 때 적어도 하나의 필드엔 값이 들어있다고 가정할 수 있다.\n그런 전제는 대개 코드로 작성되어 있지 않고 알고리즘을 두루 살펴야 알 수 있고, 가끔은 주석으로 처리되어 있을 때도 있다. 이런 전제는 어설션을 넣어 명확히 드러나게 하는 것이 좋다.\n\n어설션이란 항상 참으로 전제되는 조건문을 뜻한다. 어설션이 실패하면 그건 프로그래머가 오류를 범한 것이다. 그래서 어셜션이 실패할 경우 반드시 예외를 통지하게 해야 한다.\n어셜션은 대개 제품화 단계에서 삭제한다.\n\n어설션은 의사소통과 디버깅에 도움을 준다.\n\n### 예제\n\n간단한 개발 비용 한도 코드는 다음과 같다. 직원에게는 개인별 경비 한도를 부여할 수 있다.\n직원이 주요 프로젝트를 맡게 된다면 해당 주요 프로젝트에 대한 경비 한도를 사용할 수 있다.\n직원에게 경비 한도와 주요 프로젝트가 모두 주어질 필요는 없지만, 둘 중 하나는 반드시 주어져야 한다.\n경기 한도를 사용하는 코드에서는 이 전제가 당연하다.\n\n```javascript\nclass Employee {\n  static NULL_EXPENSE = -1.0\n\n  constructor() {\n    this._expenseLimit = NULL_EXPENSE\n    this._primaryProject\n  }\n\n  getExpenseLimit() {\n    return this._expenseLimit !== NULL_EXPENSE\n      ? this._expenseLimit\n      : this._primaryProject.getMemeberExpenseLimit()\n  }\n\n  withinLimit(expenseAmount) {\n    return expenseAmount <= this.getExpenseLimit()\n  }\n}\n```\n\n위 코드에서 직원에게 프로젝트나 개인 경비 한도 중 하나가 주어져 있따는 명시적 가정이 들어있다. 이런 어설션은 다음과 같이 코드로 확실히 나타내야 한다.\n\n```javascript\ngetExpenseLimit() {\n  Assert.isTrue(this._expenseLimit !== NULL_EXPENSE || this._primaryProject !== null)\n  return (this._expenseLimit !== NULL_EXPENSE) ? this._expenseLimit : this._primaryProject.getMemeberExpenseLimit()\n}\n// Assert 메서드의 매개변수로 전달하는 모든 표현식이 그대로 실행되는 문제가 있기에 그 표현식을 실행하지 않기 위해선 다음과 같은 코드를 작성한다.\n// Assert.ON 상수가 false일 경우 뒤 표현식은 실행되지 않는다.\ngetExpenseLimit() {\n  Assert.isTrue(Assert.ON && this._expenseLimit !== NULL_EXPENSE || this._primaryProject !== null)\n  return (this._expenseLimit !== NULL_EXPENSE) ? this._expenseLimit : this._primaryProject.getMemeberExpenseLimit()\n}\n```\n\nAssert 클래스엔 용도를 알기 쉬운 이름으로 된 각종 메서드가 들어 있어야 한다. isTrue 메서드 외에도 equals 메서드나 shouldNeverReachHere 메서드를 넣을 수도 있다.\n","excerpt":"해당 글은  에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다. 조건문 쪼개기 (Decompose Conditional) 복잡한 조건문(if-then-else)이 있을땐 if, then, eles 부분을 각각 메서드로 빼내자. …","fields":{"slug":"/concise-conditionals/"},"frontmatter":{"date":"Apr 03, 2019","title":"(리팩토링) 조건문 간결화","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n번역 : http://blog.brew.com.hk/not-everything-in-javascript-is-an-object/\n\n\n\n자바스크립트가 OOP(객체 지향 언어인지 함수형 언어인지 많은 혼란들이 있다. 실제로 Javascript 는 이 두가지 모두 사용할 수 있다.\n\n그러나 사람들은 자바스크립트 모든것이 객체인지?, 함수는 무엇인지 질문하곤 한다.\n이 포스트가 이것들을 명확하게 할것이다.\n\n## 시작해보자.\n\n자바스크립는 여섯가지 원시 데이터 타입이 있다.\n\n* Booleans - `true` or `false`\n* `null`\n* `undefined`\n* `number` - double-precision 64-bit float. **There are no integers in JavaScript**.\n* `string`\n* `symbol` (new in ES6)\n\n원시타입 외에도, ECMAScript 스탠다드는 `object` 타입을 정의합니다. 이것은 간단하게 키 벨류의 저장소 입니다.\n\n```javascript\nconst Object = {\n  key: 'value',\n}\n```\n\n간단하게는, 원시타입이 아닌 어떤것들을 `Object` 이라한다. 그리고 이것은 함수와 배열을 포함하고 있다.\n\n모든 함수들은 객체들이다.\n\n```javascript\n// Primitive types\ntrue instanceof Object // false\nnull instanceof Object // false\nundefined instanceof Object // false\n0 instanceof Object // false\n'bar' instanceof Object // false\n\n// Non-primitive types\nconst foo = function() {}\nfoo instanceof Object // true\n```\n\n## 원시타입\n\n원시타입 들은 원시타입에 붙어있는 메서드를 가지지 않는다. 그래서 절대 `undefined.toString()` 이라는 문법을 볼 수 없을 것이다. 또한 이 원시타입들은 값을 을 변화시키는 메서드를 지니고 있지 않기 때문에 원시타입들은 불변함의 성격을 지니고 있다.\n\n사용자들은 원시타입을 변수에 재 할당할수 있다. 하지만 그것은 새로운 값이 될것이다. 예전의 것이 아니며 변할수도 없다. 즉, 변수에 원시타입을 대입하는 것은 새로운 값이 되는것이지 이전의 값이 변한것이 아니다.\n\n```javascript\nconst answer = 42\nanswer.foo = 'bar'\nanswer.foo // undefined\n```\n\n> 원시 타입들은 불변함을 지닌다.\n\n게다가 원시 타입들은 참조값을 저장하는 객체와는 다르게 값 자체로 저장이 된다. 이것은 같은 검사를 수행할때 여향을 미친다.\n\n```javascript\n\"dog\" === \"dog\"; // true\n14 === 14; // true\n\n{} === {}; // false\n[] === []; // false\n(function () {}) === (function () {}); // false\n```\n\n> 원시 타입들은 값으로 저장이 되고, 객체는 참조값으로 저장이 된다.\n\n## 함수\n\n함수는 `constructor` , `call` 과 같은 몇몇 특별한 프로퍼티들을 가진 object 타입이다.\n\n```javascript\nconst foo = function(baz) {}\nfoo.name // \"foo\"\nfoo.length // 1\n```\n\n그리고 평범한 객체와 같이 새로운 프로퍼티들을 추가할 수 있다.\n\n```javascript\nfoo.bar = 'baz'\nfoo.bar // \"baz\"\n```\n\n### Methods\n\n메서드는 함수처럼 행동하는 객체의 프로퍼티이다.\n\n```javascript\nconst foo = {}\nfoo.bar = function() {\n  console.log('baz')\n}\nfoo.bar() // \"baz\"\n```\n\n## 생성자 함수\n\n만약 당신이 몇몇 같은 수행을 공유하는 객체를 가지고 있다면, 생성자 함수 내부에 그 로직을 놓을 수 있다. 그리고 생성자 함수로 그 객체들을 만들수 있다.\n\n생성자 함수는 다른 함수들과 다르지 않다. 이 함수는 new 키워드 뒤에 사용될 때 생성자 함수로 사용된다.\n\n> 모든 함수라도 생성자 함수가 될수 있다.\n\n```javascript\nconst Foo = function() {}\nconst bar = new Foo()\nbar // {}\nbar instanceof Foo // true\nbar instanceof Object // true\n```\n\n생성자 함수는 객체를 리턴 할 것이다. 여기 이 함수안에 있는 `this`는 객체에 새로운 프로퍼티를 할당하는데 사용 될 수 있다.\n\n그래서 만약 우리가 초기에 `bar`라는 프로퍼티에 `baz` 값을 할당하고 싶은 많은 객체를 만들길 원한다면 해당 로직을 지닌 새로운 `Foo`라는 로새로운 생성자를 만들 수 있다.\n\n```javascript\nconst Foo = function() {\n  this.bar = 'baz'\n}\nconst qux = new Foo()\nqux // { bar: \"baz\" }\nqux instanceof Foo // true\nqux instanceof Object // true\n```\n\n> 당신은 생성자 함수를 새로운 객체를 만드는데 사용할 수 있다.\n\n생성자 함수가 단순히 new 가 없이 일반 함수 `Foo()` 처럼 동작한다면 해당 함수 안에 있는 이 `this` 는 실행 컨텍스트에 해당되게 됩니다. 그래서 모든 함수들 밖에서 `Foo()`를 호출하게 되면 사실 `window` 객체 가 수정되게 될것이다.\n\n```javascript\nFoo() // undefined\nwindow.bar // \"baz\"\n```\n\n반대로, 일반 함수를 생성자 처럼 실행하게 된다면 이전에 바왔던 새로운 빈 객체가 나오게 된다.\n\n```javascript\nconst pet = new String('dog')\n```\n\n## 래퍼 객체\n\n`String`, `Number`, `Boolean`, `Function` 등등 이런 함수들은 혼란을 가져온다.\n이것들을 `new` 와 함께 호출한다면 원시타입 대한 *wrpper object*가 생성된다.\n\n`String`은 주어진 매개변수를 원시 문자열을 만들수 있는 글로벌 함수이다. 그것은 매개변수를 문자열로 변환할 수 있다.\n\n```javascript\nString(1337) // \"1337\"\nString(true) // \"true\"\nString(null) // \"null\"\nString(undefined) // \"undefined\"\nString() // \"\"\nString('dog') === 'dog' // true\ntypeof String('dog') // \"string\"\n```\n\n하지만 `String`함수를 생성자 함수처럼 사용할 수도 있다.\n\n```javascript\nconst pet = new String('dog')\ntypeof pet // \"object\"\npet === 'dog' // false\n```\n\n그리고 이것은 문자열 `\"dog\"`를 표현하는 새로운 객체를 만들어 낸다. 다음과 같은 프로퍼티들을 지닌다.\n\n```javascript\n{\n  0: \"d\",\n  1: \"o\",\n  2: \"g\",\n  length: 3\n}\n```\n\n## 자동 박싱\n\n흥미로운 점은 기본 문자열과 객체 모두의 생성자가 둘 다 String 함수라는 것이다.\n훨씬 더 흥미로운 사실은 기본 문자열에서 `.constructor`를 호출할 수 있다는 점이다. 우리가 원시타입은 메서드를 가질수 없다고 알고있었다.\n\n```javascript\nconst pet = new String('dog')\npet.constructor === String // true\nString('dog').constructor === String // true\n```\n\n이런 절차가 발생되는것을 우리는 *autoboxing*이라 부른다. 우리가 원시 타입안에서 메서드나 프로퍼티를 호출할 때, 자바스크립트는 먼저 일시적으로 *wrapper object*로 변환시킨다. 그리고 그 프로퍼티와 메서드에 원래의 값에 영향없이 접근한다.\n\n```javascript\nconst foo = 'bar'\nfoo.length // 3\nfoo === 'bar' // true\n```\n\n위 예제에서 `length`프로퍼티에 접근한다. 자바스크립트는 `foo`를 wapper object 로 autoboxed 를 시킨다. 그리곤 해당 객체의 length 에 접근한다. 그리곤 그 객체를 버립니다. 이것은 foo 에 영향 없이 진행됩니다.\n\n이것이 우리가 원시타입에 프로퍼티를 접근하려들려 할때 자바스크립트가 에러를 뱉지 않는 이유이다. 그 원시 타입 자신을 건들지 않고 임시 래퍼 객체에 할당했기 때문이다.\n\n```javascript\nconst foo = 42\nfoo.bar = 'baz' // Assignment done on temporary wrapper object\nfoo.bar // undefined\n```\n\n만약 `undefined`나 `null`같이 래퍼객체가 없는 타입으로 이같은 시도를 했다면 에러가 났을 것이다.\n\n```javascript\nconst foo = null\nfoo.bar = 'baz' // Uncaught TypeError: Cannot set property 'bar' of null\n```\n\n## 요약\n\n1. 자바스크립트의 모든것이 객체가 아니다.\n2. 자바스크립트에는 6 가지 원시 타입이 있다.\n3. 원시타입 모두가 객체는 아니다.\n4. 함수는 특별한 타입의 객체이다.\n5. 함수는 새로운 객체를 만드는데 사용될 수 있다.\n6. String, booleans 그리고 numbers 는 원시타입으로 대표될 수 있지만 객체이기도 하다.\n7. 확실한 원시타입( strings. numbers, booleans ) 는 마치 객체처럼 보여지기도 하다. 이는 자바스크립트의 autoboxin 이라고 불리오는 특징 때문이다.\n\n```\n일부 의역이 들어간 경우도 있으므로 해당 원문의 내용과 조금 다를 수 있습니다. <br/>\n문제가 될 소지가 있다거나 혹은 수정이 필요한 사항이 있다면 있다면 issues 보내주세요.\n```\n","excerpt":"번역 : http://blog.brew.com.hk/not-everything-in-javascript-is-an-object/ 자바스크립트가 OOP(객체 지향 언어인지 함수형 언어인지 많은 혼란들이 있다. 실제로 Javascript 는 이 두가지 …","fields":{"slug":"/javascript-object.md/"},"frontmatter":{"date":"Apr 01, 2019","title":"Javascript 의 모든것은 Object 이다? 아니다?","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n해당 글은 `리팩토링 (코드 품질을 개선하는 객체지향 사고법)` 에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다.\n\n## 클래스의 단방향 연결을 양방향으로 전환 (Change Unidirectional Association to Bidirectional)\n\n두 클래스가 서로의 기능을 사용해야 하는데 한 방향으로만 연결되어 있을 땐 역 포인터를 추가하고 두 클래스를 모두 업데이트할 수 있게 접근 한정자를 수정하자.\n\n애초에 두 클래스를 설정할 때 한 클래스가 다른 클래스를 참조하게 해놓은 경우가 있을 수 있다. 나중에 이 포인터를 역방향으로 참조해야할 경우도 생긴다.\n\n### 예제\n\n`Order` 클래스가 `Customer` 클래스를 참조하는 간단한 프로그램이 있다.\n이때 `Customer` 에는 `Order` 클래스를 참조하는 코드가 들어 있지 않다.\n\n여기서는 `Customer`에는 `Order` 참조가 여러 개이므로 `Order` 클래스를 연결제어 객체로 택한다.\n`Order` 객체에 연결제어 기능을 구현하자.\n\n```javascript\n// 연결제어 객체\nclass Order {\n  constructor() {\n    this._customer\n  }\n\n  getCustomer() {\n    return this._customer\n  }\n\n  setCustomer(customer) {\n    //this._customer = customer\n    // 다른 객체에 이 객체의 포인터를 제거하도록 전달하고\n    if (this._customer !== null) this._customer.friendOrders().remove(this)\n    // 이 객체의 포인터를 새 객체에 할당한 후 이 객체로의 포인터를 추가하게 해서 새 객체에 명령해야 한다.\n    this._customer = customer\n    if (this._customer !== null) this._customer.friendOrders().add(this)\n  }\n}\n\n// 고객 한명이 여러 건의 주문을 할 수 있으므로 _orders는 Set 셋팅\n// Customer에는 Order 참조가 여러개\nclass Customer {\n  constructor() {\n    this._orders = new Set()\n  }\n\n  friendOrders() {\n    // 연결을 변경할 때 Order에 의해서만 사용되어야 함\n    return this._orders\n  }\n\n  // Customer 클래스를 거쳐서 연결을 변경하려면 Customer 클래스 안에 제어 메서드 호출 코드를 넣으면 된다.\n  addOrder(order) {\n    order.setCustomer(this)\n  }\n}\n```\n\n만약 하나의 주문을 여러고객이 할 수 있다면 연결이 다대다가 되므로 다음과 같이 된다.\n\n```javascript\nclass Order {\n  constructor() {\n    // 하나의 주문에 여러고객에 있을수 있으니.\n    this._customers = new Set()\n  }\n\n  // 연결 제어 메서드\n  addCustomer(customer) {\n    customer.friendOrders().add(this)\n    this._customers.add(customer)\n  }\n\n  removeCustomer(customer) {\n    customer.friendOrders().remove(this)\n    this._customers.remove(customer)\n  }\n}\n\nclass Customer {\n  addOrder(order) {\n    order.addCustomer(this)\n  }\n\n  removeOrder(order) {\n    order.removeCustomer(this)\n  }\n}\n```\n\n## 클래스의 양방향 연결을 단방향으로 전환 (Change Bidirectional Association to Unidirectional)\n\n두 클래스가 양방향으로 연결되어 있는데 한 클래스가 다른 클래스의 기능을 더 이상 사용하지 않게 됐을 땐 불필요한 방향의 연결을 끊자.\n\n양방향 연결로 인해 두 클래스는 서로 종속된다. 한 클래스를 수정하면 다른 클래스도 변경된다. 종속성이 많으면 시스템의 결합력이 강해져서 사소한 수정에도 예기치 못한각종 문제가 발생한다.\n\n### 예제\n\n이전 예제와 같이 양방향으로 연결된 Customer 와 Order 클래스는 다음과 같다.\n\n```javascript\nclass Order {\n  constructor(customer) {\n    this._customer = customer\n  }\n\n  getCustomer() {\n    return this._customer\n  }\n\n  // 이전에 맺었던 customer와의 관계는 끊고 새로운 customer와 관계를 맺는다.\n  setCustomer(arg) {\n    // Customer\n    if (this._customer !== null) this._customer.friendOrder().remove(this)\n    this._customer = arg\n    if (this_customer !== null) this._customer.friendOrder().add(this)\n  }\n}\n\nclass Customer {\n  constructor() {\n    this._order = new Set()\n  }\n\n  addOrder(arg) {\n    // Order\n    arg.setCustomer(this)\n  }\n\n  friendOrder() {\n    // 연결을 변경할 때 Order 클래스를 통해서만 사용되어야 함\n    return this._order\n  }\n}\n```\n\n위 코드를 보면 customer 가 먼저 있어야만 order 가 있음을 알 수 있다.\n따라서 Order 클래스에서 Customer 클래스로 가는 연결을 끊어야 한다. 즉, Order 클래스에 Customer 객체를 참조하는 코드를 빼야한다.\n한 명령을 Customer 객체에 하나의 매개변수로 전달하는 방법을 사용할 때가 많다. 이것을 간단한 예로 들면 다음과 같다.\n\n```javascript\nclass Order {\n  getDiscountedPrice() {\n    // customer를 참조하는 코드.\n    return getGrossPrice() * (1 - this._customer.getDiscount())\n  }\n}\n\n// as-is\nclass Order {\n  getDiscountedPrice(customer) {\n    // 매개변수로 전환\n    return getGrossPrice() * (1 - customer.getDiscount())\n  }\n}\n```\n\n위 코드는 기능이 Customer 클래스를 통해 호출될 때 특히 효과가 있다. 왜냐하면 기능 자체를 하나의 인자로 전달하는 것이 수월하기 때문이다.\n\n```javascript\nclass Customer {\n  getPriceFor(order) {\n    Assert.isTrue(this._order.contains(order))\n    return order.getDiscountedPrice()\n  }\n}\n```\n\n따라서 위 코드를 아래처럼 수정하면 된다.\n\n```javascript\nclass Customer {\n  getPriceFor(order) {\n    Assert.isTrue(this._order.contains(order))\n    // customer 의 인스턴스인 this를 넘긴다.\n    return order.getDiscountedPrice(this)\n  }\n}\n```\n\n또는 속성 읽기 메서드를 수정해서 필드를 사용하지 않고 customer 를 가져오게 할 수도 있다. 이렇게 하면 Order.getCustomer 메서드의 코드에 다음과 같이 알고리즘 전환을적용할 수 있다.\n\n```javascript\nclass Order {\n  // Customer 인스턴스들을 모조리 가져와서 내 Order가 들었나 안들었나 확인\n  getCustomer() {\n    const iter = Customer.getInstances()[Symbol.iterator]()\n    for (let i of iter) {\n      const each = i.value\n      if (each.containsOrder(this)) return each\n    }\n\n    return null\n  }\n}\n```\n\n## 마법 숫자를 기호 상수로 전환 (Replace Magic Number with Symbolic Constant)\n\n특수 의미를 지닌 리터럴 숫자가 있을 땐 의미를 살린 이름의 상수를 작성한 후 리터럴 숫자를 그 상수로 교체하자.\n\n### 예제\n\n```javascript\n// bad\nconst potentialEnergy = (mass, height) => {\n  return mass * 9.81 * height\n}\n\n// good\nconst GRAVITATIONAL_CONSTANT = 9.81\nconst potentialEnergy = (mass, height) => {\n  return mass * GRAVITATIONAL_CONSTANT * height\n}\n```\n\n## 필드 캡슐화 (Encapsulate Field)\n\npublic 필드가 있을 땐 그 필드를 private 로 만들고 필드용 읽기 메서드와 쓰기 메서드를 작성하자.\n자바스크립트에는 아직 public, private 가 없기 때문에 `_(언더바)`로 표시하자.\n\n## 컬렉션 캡슐화 (Encapsulate Collection)\n\n메서드가 컬렉션을 반환할 땐 그 메서드가 읽기전용 뷰를 반환하게 수정하고 추가 메서드와 삭제 메서드를 작성하자.\n\n클래스에 여러 인스턴스로 구성된 컬렉션이 들어 있는 경우를 흔히 볼 수 있다. 그 컬렉션은 배열, 리스트, 세트, 벡터중 하나일텐데그럴 땐 십중팔구 컬렉션을 읽고 쓸 수 있는 평범한 읽기 메서드와 쓰기 메서드가 있기 마련이다.\n\n그러나 컬렉션은 다른 종류의 데이터와는 약간 다른 읽기/쓰기 방식을 사용해야 한다.\n읽기 메서드에서는 컬렉션 객체 자체를 반환해선 안된다. 왜냐하면 컬렉션 참조 부분이 컬렉션의 내용을 조작해도 그 컬렉션이 든 클래스는 무슨 일이 일어나는지는 모르기 때문이다.\n이로 인해 컬렉션 참조 코드에게 그 객체의 데이터 구조가 지나치게 노출된다. 갑싱 여러개인 속성을 읽는 읽기 메서드는 컬렉션 조작이 불가능한 형식을 반환하고불필요하게 자세한 컬렉션 구조 정보는 감춰야 한다.\n\n그리고 컬렉션 쓰기 메서드는 절대 있으면 안 되므로, 원소를 추가하는 메서드와 삭제하는 메서드를 대신 사용해야 한다.\n\n### 예제\n\n아래 예제에서는 한 사람이 여러 과정을 수강한다. 수강 과정을 나타내는 Course 클래스는 다음과 같이 아주 간단하다.\n\n```javascript\nclass Course {\n  constructor(name, isAdvanced) {\n    //...\n  }\n\n  isAdvanced() {\n    // return boolean\n  }\n}\n\nclass Person {\n  constructor() {\n    this._courses = new Set()\n  }\n\n  getCourses() {\n    return this._courses\n  }\n\n  setCourses(courses) {\n    this._courses = courses\n  }\n\n  addCourse(course) {\n    this._courses.add(course)\n  }\n\n  removeCourse(course) {\n    this._courses.remove(course)\n  }\n}\n\n// 위 처럼 코드가 있을때 우리는 아래처럼 사용할 수 있겠다.\nconst kent = new Person()\nconst s = new Set()\ns.add(new Course('스몰토크 프로그래밍', false))\ns.add(new Course('싱글몰트 음미하기', true))\nkent.setCourses(s)\nconst refact = new Course('리펙토링', true)\nkent.addCourse(refact)\n\n// 고급과정을 알아내는 코드\nconst iter = kent.getCourses()[Symbol.iterator]()\nlet count = 0\nfor (let p of iter) {\n  if (p.done) break\n  if (p.value.isAdvaned()) count++\n}\n```\n\n`setCourses` 메서드에서 해당 참조 값을 여러군데에서 쓰이고 이 메서드가 많이 사용된다면이 메서드 내용을 추가/삭제 기능의 코드로 바꿔야 한다.\n즉, 쓰기 메서드 내용을 추가 메서드 내용으로 바꿔주면 된다.\n이렇게 하면 컬렉션을 지닌 객체가 컬렉션의 원소 추가와 삭제를 통제할 수 있다.\n\n또한 `getCourses`의 읽기 메서드는 수정이 불가한 객체로 바꿔줘야 하는데 자바스크립트에서는 그 객체를 복사한 다른 객체를내보내 줘서 `this._courses`에 영향이 없도록 해야한다.\n\n```javascript\nclass Person {\n  constructor() {\n    this._courses = new Set()\n  }\n\n  // 읽\n  getCourses() {\n    //return this._courses\n    return clone(this._courses)\n  }\n\n  // 쓰기 메서드는 절대 있으면 안된다.\n  // setCourses(courses) {\n  //   this._courses = courses\n  // }\n\n  // 추가내용으로 바꾸자.\n  initializeCourses(courses) {\n    const iter = courses[Symbol.iterator]()\n    for (let p of iter) {\n      this.addCourse(p.value)\n    }\n  }\n\n  addCourse(course) {\n    this._courses.add(course)\n  }\n\n  removeCourse(course) {\n    this._courses.remove(course)\n  }\n\n  numberOfAdvancedCourses() {\n    const iter = this.getCourses()[Symbol.iterator]()\n    let count = 0\n    for (let p of iter) {\n      if (p.value.isAdvaned()) count++\n    }\n  }\n}\n```\n\n추가적으로 고급과정을 알아내는 코드의 경우에도 `Person` 클래스 데이터만 사용하므로 응당 `Person` 클래스로 옮겨 마땅하다.\n\n## 분류 부호를 클래스로 전환 (Replace Type Code with Class)\n\n기능에 영향을 미치는 숫자형 분류 부호가 든 클래스가 있을 땐 그 숫자를 새 클래스로 바꾸자.\n\n분류부호 이름을 상징적인 것으로 정하면 코드가 상당히 이해하기 쉬워진다.\n문제는 상징적 이름은 단지 별명에 불과하다는 점이다.\n\n_숫자형 분류부호를 클래스로 빼내면 컴파일러는 그 클래스 안에서 종류 판단을 수행할 수 있다._\n그 클래스 안에 팩토리 메서드를 작성하면 유효한 인스턴스만 생성되는지와 그런 인스턴스가 적절한 객체로 전달되는지를 정적으로 검사할 수 있다. 그 전까지 Person 클래스 메서드 들은 int 타입만 받아왔었는데 이 기법을 사용하면 명시적으로\n`BloodGroup` 타입을 받는지 확인할 수 있다.\n\n분류 부호가 클래스로 만드는 건 _분류 부호가 순수한 데이터일 때만_ 실시해야 한다. 다시말해, 분류부호가 switch 문안에 사용되어 다른 기능을 수행하거나 메서드를 호출할 땐 클래스로 전환하면 안된다.\n\nswitch 문에는 임의로 클래스를 사용할 수 없으며 오직 정수 타입만 사용 가능하므로 클래스로 전환은 실패를 맞게 된다.\n더 중요한건, 모든 switch 문은 `조건문을 재정의로 전환` 기법을 적용해 전부 없애야 한다는 사실이다.\n\n조건문을 재정의로 전환 기법을 실시하려면 우선 `분류 부호를 하위 클래스로 전환`이나 `분류 부호를 상태/전략 패턴으로 전환`기법을 적용해서 분류 부호부터 처리해야 한다.\n\n### 예제\n\n다음과 같은 코드가 있다고 하자.\n`Person` 클래스엔 다음과 같이 분류 부호로 나타낸 혈액형 그룹이 들어 있다.\n\n여기서 특징은 분류 부호 클래스는 데이터 클래스로써만 사용 된다는 것이고 Person 클래스 안에서도 데이터를 저장만 하고 그 데이터에 따른 어떠한 다른 부가 로직도 보이지 않는다는 것이다.\n\n```javascript\nclass Person {\n  static O = 0\n  static A = 1\n  static B = 2\n  static AB = 3\n\n  constructor(bloodGroup) {\n    this._bloodGroup = bloodGroup\n  }\n\n  setBloodGroup(bloodGroup) {\n    this._bloodGroup = bloodGroup\n  }\n\n  getBloodGroup() {\n    return this._bloodGroup\n  }\n}\n// 사용하는 코드\nconst thePerson = new Person(Person.A)\nthePerson.getBloodGroup()\nthePerson.setBloodGroup(Person.AB)\n```\n\n먼저 혈액형 그룹을 판단할 `BloodGroup` 클래스를 작성하고, 분류 부호 숫자가 든 인스턴스를 생성하자.\n\n```javascript\nclass BloodGroup {\n  static O = new BloodGroup(0)\n  static A = new BloodGroup(1)\n  static B = new BloodGroup(2)\n  static AB = new BloodGroup(3)\n  static _values = [O, A, B, AB]\n\n  constructor(code) {\n    this._code = code\n  }\n\n  getCode() {\n    return this._code\n  }\n\n  static code(arg) {\n    return _values[arg]\n  }\n}\n// 이제 BloodGroup을 사용하게 변경하자.\nclass Person {\n  // 삭제\n  // static O = BloodGroup.O.getCode()\n  // static A = BloodGroup.A.getCode()\n  // static B = BloodGroup.B.getCode()\n  // static AB = BloodGroup.AB.getCode()\n\n  constructor(bloodGroup) {\n    this._bloodGroup = bloodGroup\n  }\n\n  // 삭제\n  // setBloodGroup(bloodGroup) {\n  //   // this._bloodGroup = bloodGroup\n  //   this._bloodGroup = BloodGroup.code(bloodGroup)\n  // }\n  // 삭제\n  // 메서드 이름 변경\n  // getBloodGroupCode() {\n  //   return this._bloodGroup.getCode()\n  // }\n\n  getBloodGroup() {\n    return this._bloodGroup\n  }\n}\n\nconst thePerson = new Person(BloodGroup.A)\nthePerson.getBloodGroup().getCode()\nthePerson.setBloodGroup(BloodGroup.AB)\n```\n\n## 분류 부호를 하위클래스로 전환 (Replace Type Code with Subclasses)\n\n클래스 기능에 영향을 주는 변경불가 분류 부호가 있을 땐 분류 부호를 하위클래스로 만들자.\n\n클래스 기능에 영향을 주지 않는 분류 부호가 있을 땐 분류 부호를 클래스 전환 기법을 실시하면 된다. 그러나 분류 부호가 클래스 기능에 영향을 준다면 재정의를 통해 조금씩 다른 기능을 처리하는 것이 최선이다.\n\n분류 부호가 클래스 기능에 영향을 미치는 현상은 case 문 같은 조건문이 있을 때 주로 나타난다. 그런 조건문은 switch 문 아니면 if-then-else 문이다. 어느 조건문이든 분류 부호의 값을 검사해서 그 값에 따라 다른 코드를 실행한다.\n이런 조건문은 `조건문을 재정의로 전환`을 실시해서 재정의로 바꿔야 한다.\n\n이런 기법이 효과를 보려면 분류부호를 다형화된 기능이 든 상속 구조로 고쳐야 한다.\n\n이 기법의 장점은 클래스 사용 부분에 있던 다형적인 기능 관련 데이터가 클래스 자체로 이동한다는 데 있다. 변형된 새 기능을 추가할땐 하위클래스만 하나 추가하면 되기 때문이다. 다형성, 즉 재정의를 이용하지 않는다면 조건문을 전부 찾아서 일일이 수정해야 한다.\n\n### 예제\n\n아래 Employee 클래스의 분류 부호인 `this._type` 변수를 없애고 각 타입들을 하위클래스로 빼는데 목적이 있다. 왜냐하면 Employee 클래스 로직에는 저 타입에 따른 여러가지 다른 코드를 실행하는 코드들이 얽힐 것이기 때문이다.\n그래서 각 타입에 따른 코드 실행은 각 하위 클래스에 정리하도록 한다.\n\n```javascript\nclass Employee {\n  static ENGINEER = 0\n  static SALESMAN = 1\n  static MANAGER = 2\n\n  // Employee 클래스의 생성자 메서드가 분류 부호를 매개변수로 받으니까,\n  // 그 생성자 메서드를 다음과 같이 팩토리 메서드로 바꿔야 한다.\n  static create(type) {\n    return new Employee(type)\n  }\n\n  constructor(type) {\n    this._type = type // 분류 부호\n  }\n\n  getType() {\n    return this._type\n  }\n}\n\n// 사용\n\nconst engineer = Employee.create(Employee.ENGINEER)\n```\n\n먼저 `분류부호 ENGINNER` 변수를 `Engineer` 하위클래스로 만들자. 다음과 같이 하위클래스를 작성하고 `ENGINEER 분류 부호`에 해당하는 재정의 메서드를 작성하자.\n\n```javascript\n// 하위클래스 Engineer\nclass Engineer extends Employee {\n  // 재정의 메서드\n  getType() {\n    return Employee.ENGINEER\n  }\n}\n\n// 적절한 객체를 생성하게 팩토리 메서드도 다음과 같이 고친다.\n\nclass Employee {\n  static ENGINEER = 0\n  static SALESMAN = 1\n  static MANAGER = 2\n\n  static create(type) {\n    if (type === ENGINEER) return new Engineer()\n    else return new Employee(type)\n  }\n}\n\n// 위 식으로 나머지 분류 부호도 한번에 하나씩 하위클래스로 수정하자.\n// 한번더 정리하면 Employee 클래스의 분류부호 필드를 삭제하고 팩토리 메서드는 다음과 같다.\n\nclass Employee {\n  // Employee 클래스의 분류 부호 필드를 삭제\n  static ENGINEER = 0\n  static SALESMAN = 1\n  static MANAGER = 2\n\n  // 불가피하게 인스턴스를 생성할 때만 딱 한번 사용\n  static create(type) {\n    switch (type) {\n      case ENGINEER:\n        return new Engineer() // 하위 클래스\n        break\n      case SALESMAN:\n        return new Salesman()\n        break\n      case MANAGER:\n        return new Manager()\n        break\n      default:\n    }\n  }\n  // abstract 타입\n  getType() {}\n}\n\n// 사용\nconst engineer = Employee.create(Employee.ENGINEER)\n```\n\n하위클래스를 작성했으면 `메서드 하향`과 `필드하향`을 실시해서 Employee 클래스의 특정 분류 부호에만 관련된 모든 메서드와 필드를 특정 부호에 해당하는 하위클래스로 옮겨야 한다.\n\n## 분류 부호를 상태/전략 패턴으로 전환 (Replace Type Code with State/Strategy)\n\n분류 부호가 클래스의 기능에 영향을 주지만 하위클래스로 전환할 수 없을 땐 그 분류 부호를 상태 객체로 만들자.\n\n_분류 부호가 객체 수명주기 동안 변할 때나 다른 이유로 하위 클래스로 만들 수 없을 때 사용한다._ 이 기법은 상태 패턴이나 전략 패턴중 하나를 사용한다.\n조건문을 재정의로 전환으로 하나의 알고리즘을 단순화해야할 때는 전략이 더 적절하며, 상태별 데이터를 이동하고 객체를 변화하는 상태로 생각할 때는 상태 패턴이 더 적절하다.\n\n여기서 말하는 상태/전략 패턴이란 전략을 설정하는 부분 따로 실행하는 부분 따로 두고 전략을 설정해두면 실행하기 전까지 자유롭게 전략을 바꿔나갈수 있는 방법이다.\n간단한 예시를 들면\n\n```javascript\nclass Strategy {\n  constructor() {\n    this._strategy = null\n  }\n\n  setStrategy(s) {\n    this._strategy = s\n  }\n\n  getStrategyState() {\n    return this._strategy.getState()\n  }\n}\n// 전략 상태를 따로 빼둔다.\nclass StrategyState {\n  static LAND = 0\n  static SHIP = 1\n\n  getState() {}\n}\n\nclass LandStrategyState extends StrategyState {\n  getState() {\n    return StrategyState.LAND\n  }\n}\n\nclass ShipStrategyState extends StrategyState {\n  getState() {\n    return StrategyState.SHIP\n  }\n}\n\nconst s = new Strategy()\n// 전략을 바꿀 수 있다.\ns.setStrategy(new LandStrategyState())\ns.setStrategy(new ShipStrategyState())\ns.getStrategyState()\n```\n\n### 예제\n\n```javascript\nclass Employee {\n  static ENGINEER = 0\n  static SALESMAN = 1\n  static MANAGER = 2\n\n  constructor(type) {\n    this._type = type\n  }\n\n  // 앞의 코드를 사용해 조건별로 기능을 실행하는 코드이다.\n  payAmount() {\n    switch (this._type) {\n      case ENGINEER:\n        return this._monthlySalary\n        break\n      case SALESMAN:\n        return this._monthlySalary + this._commission\n        break\n      case MANAGER:\n        return this._monthlySalary + this._bonus\n        break\n      default:\n    }\n  }\n}\n```\n\n여기서는 분류부호가 수시로 변하므로 하위클래스로 만들 수 없다. 우선 분류 부호를 자체 캡슐화해야 한다.\n\n```javascript\nclass Employee {\n  static ENGINEER = 0\n  static SALESMAN = 1\n  static MANAGER = 2\n\n  constructor(type) {\n    // this._type = type\n    this.setType(type)\n  }\n\n  getType() {\n    return this._type\n  }\n\n  setType(type) {\n    this._type = type\n  }\n\n  // 앞의 코드를 사용해 조건별로 기능을 실행하는 코드이다.\n  payAmount() {\n    switch (this.getType()) {\n      case ENGINEER:\n        return this._monthlySalary\n        break\n      case SALESMAN:\n        return this._monthlySalary + this._commission\n        break\n      case MANAGER:\n        return this._monthlySalary + this._bonus\n        break\n      default:\n    }\n  }\n}\n```\n\n이제 상태 클래스 `EmployeeType`을 선언하자.\n\n```javascript\n// 상태 클래스 선언\nclass EmployeeType {\n  // abstract\n  getTypeCode() {}\n}\n\nclass Engineer extends EmployeeType {\n  getTypeCode() {\n    return Employee.ENGINEER\n  }\n}\n\nclass Manager extends EmployeeType {\n  getTypeCode() {\n    return Employee.MANAGER\n  }\n}\n\nclass Salesman extends EmployeeType {\n  getTypeCode() {\n    return Employee.SALESMAN\n  }\n}\n\n// 상태 클래스를 사용하자.\nclass Employee {\n  //...\n  getType() {\n    // 이제 _type은 EmployeeType의 인스턴스다.\n    return this._type.getTypeCode()\n  }\n  // EmployeeType 인 상태 클래스를 사용하다 보니 setType 메서드에 스위치 문이 생겼다.\n  // 이 switch 문은 분류가 변할 때만 실행된다.\n  // 생성자를 팩토리 메서드로 전환 기법을 실시해서 각 경우별 팩토리 메서드를 작성하는 방법도 있다.\n  setType(type) {\n    switch (type) {\n      case ENGINEER:\n        this._type = new Engineer()\n        break\n      case SALESMAN:\n        this._type = new Salesman()\n        break\n      case MANAGER:\n        this._type = new Manager()\n        break\n      default:\n    }\n  }\n}\n```\n\n여기서 switch 문을 리팩토링 해보자.\n분류 부호 정의를 EmployeeType 으로 복사하고, EmployeeType 에 대한 팩토리 메서드를 작성한 후, Employee 클래스의 쓰기 메서드를 수정하자.\n\n```javascript\nclass Employee {\n  // 여기에 정의 내렸던 분류 부호 정의를 삭제\n  // EmployeeType 클래스 참조를 넣자.\n  // ...\n  constructor(type) {\n    // this._type = type\n    this.setType(type)\n  }\n\n  getType() {\n    // 이제 _type은 EmployeeType의 인스턴스다.\n    return this._type.getTypeCode()\n  }\n\n  setType(type) {\n    this._type = EmployeeType.newType(type)\n  }\n\n  // 이제 payAmount 메서드에 `조건문을 재정의로 전환 기법`을 적용할 수 있다.\n  payAmount() {\n    switch (this.getType()) {\n      case EmployeeType.ENGINEER:\n        return this._monthlySalary\n        break\n      case EmployeeType.SALESMAN:\n        return this._monthlySalary + this._commission\n        break\n      case EmployeeType.MANAGER:\n        return this._monthlySalary + this._bonus\n        break\n      default:\n    }\n  }\n}\n\nclass EmployeeType {\n  static ENGINEER = 0\n  static SALESMAN = 1\n  static MANAGER = 2\n\n  getTypeCode() {} // 추상 클래스\n\n  static newType(type) {\n    switch (type) {\n      case ENGINEER:\n        return new Engineer()\n        break\n      case SALESMAN:\n        return new Salesman()\n        break\n      case MANAGER:\n        return new Manager()\n        break\n      default:\n    }\n  }\n}\n\n// 사용\nconst employee = new Employee(EmployeeType.ENGINEER)\nemployee.payAmount() // engineer payamount\nemployee.setType(EmployeeType.SALESMAN) // 타입변환\nemployee.payAmount() // salesman payamount\n```\n\n이것으로 payAmout 메서드에 `조건문을 재정의로 전환기법`을 적용할 수 있게 됐다.\n\n## 하위클래스를 필드로 전환(Replace Subclass with Fields)\n\n여러 하위클래스가 상수 데이터를 반환하는 메서드만 다를 땐 각 하위 클래스의 메서드를 상위클래스 필드로 전환하고 하위클래스는 전부 삭제하자.\n\n기능을 추가하거나 기능을 조금씩 달리할 하위클래스를 작성하자. 다형적인 기능의 한 형태는 상수 메서드다. 상수 메서드는 하드코딩된 값을 반환하는 메서드다.\n상수 메서드는 읽기 메서드에 각기 다른 값을 반환하는 하위클래스에 넣으면 유용하다.\n\n상위클래스 안에 읽기 메서드를 정의하고 그 읽기 메서드를 하위클래스에서 다양한 값으로 구현하자.\n하위클래스를 상수메서드로만 구성한다고 해서 그만큼 효용성이 커지는것은 아니다. 상위클래스 안에 필드를 넣고 그런 하위클래스는 완전히 삭제하면 된다.\n\n### 예제\n\n아래 Male 하위클래스와 Female 하위클래스는 하드코딩된 상수 메서드 반환만 다르다.\n이렇게 기능이 충실하지 못한 하위클래스는 삭제하자.\n\n```javascript\n// 상위 클래스\nclass Person {\n  isMale() {}\n  getCode() {}\n}\n\nclass Male extends Person {\n  isMale() {\n    return true\n  }\n  getCode() {\n    return 'M'\n  }\n}\n\nclass Female extends Person {\n  isMale() {\n    return false\n  }\n  getCode() {\n    return 'F'\n  }\n}\n```\n\n우선 생성자를 팩토리 메서드로 전환을 실시한다.\n\n```javascript\nclass Person {\n  constructor(isMale, code) {\n    this._isMale = isMale\n    this._code = code\n  }\n\n  static createMale() {\n    // return new Male()\n    return Person(true, 'M')\n  }\n\n  static createFemale() {\n    // return new Female()\n    return Person(false, 'F')\n  }\n\n  isMale() {\n    return this._isMale\n  }\n\n  getCode() {\n    return this._code\n  }\n}\n\n// 불필요한 하위 클래스들 삭제\n// class Male extends Person {\n//   constructor(){\n//     super(true, 'M')\n//   }\n// }\n\n// class Female extends Person {\n//   constructor(){\n//     super(false, 'F')\n//   }\n// }\n\n// 사용분\nconst kent = Person.createMale()\n```\n","excerpt":"해당 글은  에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다. 클래스의 단방향 연결을 양방향으로 전환 (Change Unidirectional Association to Bidirectional) 두 클래스가 서로의 기능을 사…","fields":{"slug":"/organization-data2/"},"frontmatter":{"date":"Apr 01, 2019","title":"(리팩토링) 데이터 체계화2","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 자바스크립트 콜스택의 이해\n\n번역 : [hocheol](https://github.com/chchoing88)\n\n원문 출처 : https://medium.freecodecamp.org/understanding-the-javascript-call-stack-861e41ae61d4\n\n> 일부 의역이 들어간 경우도 있으므로 해당 원문의 내용과 조금 다를 수 있습니다. 문제가 될 소지가 있다거나 혹은 수정이 필요한 사항이 있다면 있다면 댓글 달아 주세요.\n\n자바스크립트 엔진은 힙과 단일 호출 스택으로 구성된 단일 스레드 인터프리터 이다. 브라우저는 DOM, AJAX 그리고 Timers 과 같은 웹 API 를 제공하고 있다.\n\n이글은 콜 스택이 무엇이고, 왜 필요한지에 대한 설명에 초점을 맞출것이다.\n콜 스택을 이해하는 것은 자바스크립트 엔진이 함수 계층과 실행 순서를 이해하는데 도움이 될것이다.\n\n콜 스택은 주로 함수의 실행을 위해 사용된다. 하지만 콜 스택은 하나이고, 함수 실행은 위에서부터 아래로 한번에 하나씩 실행이 된다. 이것은 콜 스택이 동기식이라는것을 뜻한다.\n\n콜 스택을 이해하는 것은 비동기 프로그래밍을 하는데 있어서 아주 중요합니다.\n\n비동기 적인 자바스크립트는 콜백 함수, 이벤트 루프, 그리고 task 큐가 있습니다. 콜백 함수는 이벤트 루프에 의해 콜백 함수가 스택에 푸시 된 후 실행 중 콜 스택에 의해 작동됩니다.\n\n먼저 이 질문의 답을 생각해보자 - 콜 스택은 무엇인가?\n\n가장 기본적인 레벨에서, 콜 스택은 임시 저장과 함수의 호출을 관리하기 위한 Last In, First Out(LIFO) 의 원리 데이터 구조이다.\n\n이 정의를 다시한번 파해쳐보자.\n\n**LIFO**: 우리가 콜 스택을 이야기할때 Last In, First Out 의 원리로 작동한다고 알고있다. 이것은 스택에 마지막으로 들어간 함수가 리턴될때 처음으로 스택에서 튀어 나옴을 의미한다.\n\n다음 LIFO 를 증명하는 코드 샘플을 보자.\n\n```javascript\nfunction firstFunction() {\n  throw new Error('Stack Trace Error')\n}\n\nfunction secondFunction() {\n  firstFunction()\n}\n\nfunction thirdFunction() {\n  secondFunction()\n}\n\nthirdFunction()\n```\n\n해당 코드가 동작할때, 우리는 error 를 만날 수 있다. 여기서 함수들이 어떻게 위에서부터 쌓였는지 스택이 출력이 된다. 다음 다이어 그램을 보자.\n\n![](https://cdn-images-1.medium.com/max/1600/1*LIuELJ2RTtwWExRWGdu_Hw.png)\n\n우리는 `firstFunction()`부터 시작되어져 있는 스택 정렬을 볼수 있다. ( 이것은 가장 마지막에 스택에 들어갔음을 의미하고, 이 함수에서 에러가 방출되었다는 것을 알 수 있다. ) 다음 `secondFunct()`, 그리고 그다음`thirdFunction()` 이다. ( 이 thirdFunction()은 코드가 처음실행 될때 가장 먼저 스택에 들어간것이다. )\n\n**임시 저장소**: 함수가 실행이 될때(호출할때), 함수와 , 그 함수의 파라미터, 그리고 변수들을 스택 프레임을 형성하기 위해 콜스택 안으로 집어 넣는다.\n이 스택 프레임은 스택안의 메모리 장소이다. 이 메모리는 함수가 스택에서 리턴 되었을때 비워지게 된다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*PPkrowy4n_Pyehb_NdhLrg.png)\n\n**함수 실행 관리**: 콜 스택은 각 스택 프레임의 위치 레코드를 유지 관리 합니다. 그것은 곧 다음에 실행되어질 함수를 안다는 것이다. ( 그리고 실행 후에 지워질 것이다. ) 이것이 JavaScript 에서 코드를 동기식으로 만드는 이유입니다.\n\n식료품점 앞에 서있다고 생각해보자. 오직 다음 사람이 참석한 후에야 당신이 참석할 수 있는 것이다. 이것이 동기식이다.\n\n이것은 \"함수 호출 관리\"가 의미하는 것입니다.\n\n## 호출 스택은 함수 호출을 어떻게 처리합니까?\n\n위 질문에 답을 아래 샘플 코드를 통해 답을 찾을수 있다. 아래 코드를 보자.\n\n```javascript\nfunction firstFunction() {\n  console.log('Hello from firstFunction')\n}\n\nfunction secondFunction() {\n  firstFunction()\n  console.log('The end from secondFunction')\n}\n\nsecondFunction()\n```\n\n![](https://cdn-images-1.medium.com/max/1600/1*9iSkoJoXM0Ok8iQ5mOHl5Q.png)\n\n위 코드가 동작하면서 어떤일이 일어났는가:\n\n1. `secondFunction()`이 실행이되면, 텅빈 스택프레임이 생성된다. 그것은 프로그램의 시작점인 (익명의) 메인이다.\n2. 그런 다음 `secondFunction()`이 `firstFunction()`을 호출하고 그것은 스택에 밀어넣어지게 된다.\n3. `firstFunction()`는 리턴되고 \"Hello from firstFunction\"을 콘솔에 프린트 한다.\n4. `firstFunction()`가 스택에서 튀어 나온다.\n5. 이후 실행 순서가 `secondFunction()` 로 이동한다.\n6. `secondFunction()`는 리턴되고 \"The end from secondFunction\"이 콘솔에 프린트 된다.\n7. `secondFunction()`가 스택에서 튀어나오고 메모리는 깨끗해진다.\n\n## 스택 오버플로우의 원인은 무엇인가?\n\n스택 오버플로우는 빠져나오지 못하는 재귀함수가 실행될때 발생하게 된다.\n브라우저는 스택 에러를 던지기 전에 최대치의 스택을 가지고 있다.\n\n아래 코드 예를 보자.\n\n```javascript\nfunction callMyself() {\n  callMyself()\n}\ncallMyself()\n```\n\n`callMyself()` 는 브라우저가 \"Maximun call size exceeded\" 라는 에러가 날때까지 수행하게 된다. 그리고 스택 오버플로우가 발생하게 된다.\n\n![](https://cdn-images-1.medium.com/max/800/1*JFRlgLp2uvbdVrh7WdmMrQ.png)\n\n## 요약\n\n콜 스택의 주요 특성들은 다음과 같다.\n\n1. 싱글 스레드라는 것은 한번에 한가지 일만 수행할 수가 있다는 말이다.\n2. 코드 실행은 동기적이다.\n3. 함수 실행은 스택 프레임을 생성하고 그것들은 임시 메모리를 차지한다.\n4. 콜 스택은 LIFO -  Last In, First Out 데이터 구조를 지닌다.\n","excerpt":"자바스크립트 콜스택의 이해 번역 : hocheol 원문 출처 : https://medium.freecodecamp.org/understanding-the-javascript-call-stack-861e41ae61d4 일부 의역이 들어간 경우도 있으므…","fields":{"slug":"/call-stack.md/"},"frontmatter":{"date":"Mar 27, 2019","title":"call stack","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n해당 글은 `리팩토링 (코드 품질을 개선하는 객체지향 사고법)` 에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다.\n\n여기서는 데이터 연동을 더 간편하게 해준다.\n객체지향 언어는 구형 언어의 단순 데이터 타입으론 불가능했던 것까지 할 수 있는 새로운 타입을 정의할 수 있어서 좋다.\n\n배열이 데이터 구조 역할을 할 때는 배열을 객체로 전환을 실시하면 그 데이터 구조가 더 선명해진다.\n\n## 필드 자체 캡슐화 (Self Encapsulate Field)\n\n필드에 직접 접근하던 중 그 필드로의 결합에 문제가 생길땐 그 필드용 읽기/쓰기 메서드를 작성해서 두 메서드를 통해서만 필드에 접근하게 만들자.\n필드 자체 캡슐화를 실시해야 할 가장 절실한 시점은 상위클래스 안의 필드에 접근하되 이 변수 접근을 하위클래스에서 계산된 값으로 재정의해야 할 때이다.\n\n### 예제\n\n```javascript\nclass IntRange {\n  constructor(low, high) {\n    this._low = low\n    this._high = high\n  }\n\n  includes(arg) {\n    return arg >= this._low && arg <= this._high\n  }\n\n  grow(factor) {\n    this._high = this._high * factor\n  }\n\n  // 읽기 / 쓰기 메서드를 활용하자.\n  getLow() {\n    return this._low\n  }\n  setLow(arg) {\n    this._log = arg\n  }\n\n  setLow(low) {\n    this._low = low\n  }\n\n  setHigh(high) {\n    this._high = high\n  }\n}\n```\n\n특히 생성자안에서 쓰기 메서드를 사용할 때 주의하자.\n대체로 객체가 생성된 후에 속성을 변경하려고 쓰기 메서드를 사용하게 된다. 이 쓰기 메서드에는 초기화 코드가 아닌 다른 기능이 추가 됐을 수 있다고 전제할 수 있다.\n하여 이럴땐 생성자나 별도의 초기화 메서드를 따로 작성하자.\n\n```javascript\nclass IntRange {\n  constructor(low, high) {\n    initialize(low, high)\n  }\n\n  initialize(low, high) {\n    this._low = low\n    this._high = high\n  }\n\n  includes(arg) {\n    // return arg >= this._low && arg <= this._high\n    return arg >= this.getLow() && arg <= this.getHigh()\n  }\n\n  grow(factor) {\n    // this._high = this._high * factor\n    this.setHigh(this.getHigh() * factor)\n  }\n\n  getLow() {\n    return this._low\n  }\n\n  getHigh() {\n    return this._high\n  }\n\n  setLow(low) {\n    this._low = low\n  }\n\n  setHigh(high) {\n    this._high = high\n  }\n}\n```\n\n이렇게 해두면 다음과 같은 하위 클래스가 생길 때 편리해진다.\n\n```javascript\nclass CappedRange extends IntRange {\n  constructor(low, high, cap) {\n    super(low, high)\n    this._cap = cap\n  }\n\n  getCap() {\n    return this._cap\n  }\n\n  // 재정의\n  // 상위 클래스 안의 필드에 접근하되 이 변수 접근을 하위클래스에서 계산된 값으로 재정의해야 할때!!\n  getHigh() {\n    return Math.min(super.getHigh(), this.getCap())\n  }\n}\n```\n\nIntRange 의 기능을 전부 재정의하면 기능을 하나도 수정하지 않고 cap 을 계산에 넣을 수 있다.\n\n## 데이터 값을 객체로 전환 (Replace Data Value with Object)\n\n데이터 항목에 데이터나 기능을 더 추가해야 할 때는 데이터 항목을 객체로 만들자.\n\n예를 들어 한동안은 전화번호를 문자열로 표현해도 상관없지만 시간이 더 흐르면 형식화, 지역번호 추출 등을 위한 특수한 기능이 필요해진다.\n한두 항목은 객체 안에 메서드를 넣어도 되겠지만, 금세 중복코드나 잘못된 소속이라는 코드 구린내가 난다.\n\n### 예제\n\n```javascript\nclass Order {\n  constructor(customer: String) {\n    this._customer = customer\n  }\n\n  getCustomer() {\n    return this._customer\n  }\n\n  setCustomer(arg) {\n    this._customer = arg\n  }\n}\n```\n\n각 Order 인스턴스에는 Sting customer 가 들어있었다. 하여 우리가 Customer 를 객체로 바꿀 때에는 Customer 는 값 객체로 만들어야 한다. 규칙에 따라 값 객체는 변경불가여야 한다. 매번 새롭게 메모리를 할당받는 객체가 되어야 한다는 말이다. 참고로 원시 객체는 변경 불가한 녀석들이다.\n\n```javascript\n// Order 객체는 주문 고객을 문자열로 저장한다.\n// 이때 문자열이 아닌 객체로 전환하게 되면 주소나 신용등급 같은 데이터를 저장할 장소와 이 정보를 이용하는 유용한 기능이 생긴다.\nclass Order {\n  constructor(customerName){\n    //this._customer = customer\n    this._customer = new Customer(customerName)\n  }\n\n  // 메서드 이름을 더 간단명료하게 수정하자.\n  //getCustomer() => getCustomerName\n  getCustomerName()\n    //return this._customer\n    return this._customer.getName()\n  }\n\n  // 쓰기 메서드 - 값 객체이기 때문에 기존의 this._customer를 수정하는 것이 아닌 새로운 인스턴스를 만든다.\n  // 매개변수도 꼭 수정하자.\n  setCustomer(customerName) {\n    //this._customer = arg\n    this._customer = new Customer(customerName)\n  }\n}\n\n// 위 코드를 사용하는 일부 코드는 다음과 같다.\nnumberOfOrdersFor(orders=[], cusomter='') {\n  let result = 0\n  const iter = orders[Symbol.iterator]()\n    for (let p of iter) {\n      if(p.value.getCustomerName() === customer) {\n        result++\n      }\n    }\n  return result\n}\n\n// customer 를 객체로 만들자.\nclass Customer {\n  constructor(name) {\n    this._name = name\n  }\n\n  getName() {\n    return this._name\n  }\n}\n```\n\n여기서 `Order` 클래스의 쓰기 메서드 `setCustomer`는 새 `Customer` 인스턴스를 생성하는데, 기존의 문자열 속성이 값 객체였으므로 위의 코드로 인해\n`Customer`도 값 객체가 되었다. 즉, 각 `Order` 객체에 대응하는 `Customer` 객체가 존재한다. 규칙에 따라 값 객체는 변경불가(immutable)여야 한다. 그래야만 위험한 왜곡 버그를 피할 수 있다.\n\n처음에 Order 가 customer 를 String(immutable value)타입으로 가지고 있었기 때문에 다른 쪽에서 이런식으로 활용 했을 수 있다.\n\n```javascript\nconst value = order.getCustomer() // merlin\nconst changeValue = value.addPrefix('hoho') // hoho merlin\n\nconsole.log(order.getCustomer()) // merlin\n\n// but getCustomer가 객체로 리턴된다면..그리고 그 객체에서 addPrefix라는 메서드가 존재한다면\n// 예기치 못한 버그가 튀어나올 것이다.\n\nconst value = order.getCustomer() // {name : merlin}\nconst changeValue = value.addPrefix('hoho') // hoho merlin\n\nconsole.log(order.getCustomer()) // hoho merlin\n```\n\n여기서 추가적인 리팩토링을 실시한다면 그건 당연히 기존 `Customer` 객체를 매개변수로 받는 쓰기 메서드와 새 생성자를 추가하는 작업일 것이다.\n\n`Customer`에 신용등급과 주소 같은것을 추가하려면 지금 할 수는 없다. 왜냐하면 `Customer`는 *값 객체*로 취급되기 때문이다.\n이런 속성을 추가하려면 `Customer`에 값을 참조로 전환을 적용해서 한 고객의 모든 주문이 하나의 `Customer` 객체를 사용하게 해야한다.\n\n또한 개념상 동일한 고객을 나타내는 객체긴 하다. 개념상 동일한 고객에 주문이 여러개 있을 경우 하나의 Customer 객체만 사용하게끔 이것을 수정해야 한다.\n\n#### 여기서 값 객체란 (VO: Value Object)\n\nOOP 에서는 다양한 것들을 객체로 만들 수 있다. 객체로 만들 수 있는 것중에 어떤 '값'도 포함할 수 있다. 잔고, 색상, 좌표 등 값 객체로 표현 될 수 있다.\n값 객체는 하나의 공통점이 있다. 값은 어디에 있든 같다. 빨간색이 여기에 있던 저기에 있던 같은 빨간색이라는 것이다.\n일반적인 경우 어떤 대상이 있다면 그 대상이 어떤 이름을 가지고 있든 간에 같다고 생각한다.\n\n예를들어 내가키우는 강아지 이름이 '멀린' 혹은 '몰링' 이라 불린다고 하자. 하지만 다르게 불려도 다 내가 키우는 강아지 이다.\n다르게 생각하면 같은 '멀린' 이라도 다른 강아지를 가리킨다면 다른 강아지가 되는 것이다.\n\n일반적인 객체는 객체가 생성되는 순간 독립된 객체가 된다. 값 객체가 같은 값을 가지고 있다고 하더라도 다른 객체이기 때문에 같지 않다고 하는 것이다. 이런 개념을 참조 객체라고 한다.\n\n여기서 값 객체 같음을 표현하는 방법은 동일과 동등을 이해해야 한다.\n동일은 객체가 참조하는 것 다시말해 대상이 같다는 것을 의미 (=== 연산자)\n동등은 객체가 참조하는 대상의 속성 값 혹은 동등하게 하는 조건이 같음을 의미 (equal 메서드)\n\n따라서 값 객체라는 것은 equal 메서드로 확인했을때 같음을 의미한다.\n\n값 객체는 변하지않고 항상 새로운 값 객체를 리턴하게 만들어야 한다.\n값 객체를 사용하면 객체의 참조 문제가 해결될 수 있다.\n값 객체를 사용하면 참조 변수 A 와 B 가 C 라는 객체를 참조하고 있을 때, B 에 조작 연산을 가하여도 A 에는 아무런 변화가 생기지 않는다.\n\n## 값을 참조로 전환 (Change Value to Reference)\n\n클래스에 같은 인스턴스가 많이 들어 있어서 이것들을 하나의 객체로 바꿔야 할 땐 그 객체를 참조 객체로 전환하자.\n위 예제에서 한 고객에 주문이 여러 개 있을 경우에는 하나의 Customer 객체만 사용하게끔 이것을 수정해야 한다.\n즉, 이 예제에서는 고객 이름 하나당 한 개의 Customer 객체만 있어야 한다.\n\n아래 예제는 Order 의 인스턴스 \\_customer 변수에 Customer 객체의 참조값을 가지고 있는것을 뜻한다.\n\n### 예제\n\n```javascript\nclass Customer {\n  constructor(name) {\n    this._name = name\n  }\n\n  getName() {\n    return this._name\n  }\n}\n\nclass Order {\n  constructor(customName) {\n    this._customer = new Customer(customerName)\n  }\n\n  getCustomerName() {\n    return this._customer.getName()\n  }\n}\n\n\n// 위 코드를 사용하는 일부 코드는 다음과 같다.\nnumberOfOrdersFor(orders=[], cusomter='') {\n  let result = 0\n  const iter = orders[Symbol.iterator]()\n    for (let p of iter) {\n      if(p.value.getCustomerName() === customer) {\n        result++\n      }\n    }\n  return result\n}\n```\n\n이때 `Customer`는 값 객체다. 각 `Order` 인스턴스에는 고유한 `Customer` 객체가 들어있다.\n개념상 동일한 고객에 주문이 여러 개 있을 경우 하나의 `Customer` 객체만 사용하게끔 이것을 수정해야 한다.\n즉, 이 예제에서 고객 이름 하나당 한 개의 `Customer` 객체만 있어야 한다.\n\n우선 `Customer`의 생성자를 팩토리 메서드로 전환을 하자 이렇게 하면 생성 절차를 제어할 수 있다.\n\n```javascript\n// Customer 인스턴스에 접근할 방법을 정해야 한다. 이때 별도의 객체를 사용하자.\nconst _instances = {\n  _store: {},\n  put(name, customer) {\n    this._store[name] = customer\n  },\n  get(name) {\n    return this._store[name]\n  },\n}\n\n// 팩토리 메서드를 정의하자.\nclass Customer {\n  constructor(name) {\n    this._name = name\n  }\n\n  // static으로\n  // 생성자를 팩토리 메서드로 전환\n  // 메서드 네이밍 변경 create -> getNamed\n  static getNamed(name) {\n    // 새로 생성하는 것이 아닌 미리 생성해둔 customer 인스턴스를 반환하게 하자.\n    // return new Customer(name)\n    return _instances.get(name)\n  }\n\n  // 고객들을 미리 설정하자고 하자.\n  static loadCustomers() {\n    new Customer('ho').store()\n    new Customer('merlin').store()\n    new Customer('gogo').store()\n  }\n\n  store() {\n    _instances.put(this.getName(), this)\n  }\n}\n\n// 그 다음, 생성자 호출을 팩토리 메서드 호출로 수정\nclass Order {\n  constructor(customerName) {\n    this._customer = Customer.getNamed(customerName) // static 메서드\n  }\n}\n```\n\n## 참조를 값으로 전환 (Change Reference to Value)\n\n참조 객체가 작고 수정할 수 없고 관리하기 힘들 땐 그 참조 객체를 값 객체로 만들자.\n즉, 합성관계로 만드는 것이다.\n\n여기서 합성관계란 부분 객체가 전체 객체에 속하는 관계인데전체 객체가 없어지면 부분 객체도 없어지는 관계이다.\n\n```\nComputer *-- Mainboard\n```\n\n```javascript\n// 컴퓨터가 사라지면 메인보드랑 cpu 객체도 사라진다.\nclass Computer {\n  constructor() {\n    this.mb = new Mainboard()\n    this.c = new CPU()\n  }\n}\n```\n\n또 다른 관계로는 집약관계라는것이 있는데 이것은 한 객체가 다른 객체를 포함하는 것이다.\n전체 객체가 메모리에서 사라진다 해도 부분객체는 사라지지 않는다.\n\n```javascript\n// 컴퓨터가 사라지면 메인보드랑 cpu 객체도 사라진다.\nclass Computer {\n  constructor(mainboard, cpu) {\n    this.mb = mainboard\n    this.c = cpu\n  }\n}\n```\n\n참조 객체를 사용한 작업이 복잡해지는 순간이 참조를 값으로 바꿔야 할 시점이다. 참조 객체는 어떤 식으로든 제어되어야 한다.\n값 객체는 분산 시스템이나 병렬 시스템에 주로 사용된다.\n*값 객체는 변경할 수 없어야 한다*는 주요 특성이 있다. 하나에 대한 질의를 호출하면 항상 결과가 같아야 한다.\n\n### 예제\n\n```javascript\nclass Currency {\n  // 생성자가 private 라고 가정하자.\n  constructor(code) {\n    this._code = code\n    this._currencies = {\n      USD: new Currency('USD'),\n    }\n  }\n\n  getCode() {\n    return this._code\n  }\n\n  static get(code) {\n    return this._currences[code]\n  }\n}\n\n// 사용분\nconst usd = Currency.get('USD')\n```\n\n위 클래스는 참조 객체이므로 사용할 인스턴스를 가져오려면 사용분 과 같이 주어진 code 에 Currency 의 동일 인스턴스를 반환하는 메서드를 사용해야 한다.\nCurrency 클래스에는 여러 인스턴스가 들어있다. 생성자만 사용하는것은 불가능하다. 그래서 private 이다.\n\n```javascript\nnew Currency('USD').equals(new Currency('USD')) // false 반환\n```\n\n이것을 값 객체로 변환하려면 그 객체가 변경불가(immutable)인지 확인해야 한다.\n변경불가가 아니면 값이 변경 가능할 경우 별칭 문제가 발생하므로 이 방법을 사용하지 말자.\n\n```javascript\nclass Currency {\n  constructor(code) {\n    this._code = code\n  }\n\n  equals(arg) {\n    if( arg instanceOf Currency ) return false\n    const other = arg\n    return (this._code.equals(other._code))\n  }\n\n  hasCode() {\n  return _code.hashCode()\n  }\n\n  getCode() {\n    return this._code\n  }\n}\n```\n\n여기서는 객체를 값으로 가지고 있기 때문에 같은 필드의 값을 가지고 있어도 같다고 볼수가 없다. 이런 문제점을 안고 있기에 변경 불가한 값을 지니고 있어야 한다.\n즉, 아래 결과에 참이 나와야 한다.\n\n```javascript\nnew Currency('USD').equals(new Currency('USD'))\n```\n\n그렇기에 equals 메서드를 정의해야 한다. 이때, hashCode 메서드도 정의해야 한다.\n간단히 하려면 equals 메서드에 사용되는 필드의 해시코드를 가져다가 XOR 비트 연산을 수행해서 코드를 작성한다.\n\n여기서 XOR 연산은 입력값이 같지 않으면 '1'이 출력이 된다. 이는 두 입력 중 하나만이 배타적으로 참일 경우에만 일어난다.\n\n이제 Currency 인스턴스를 원하는 수만큼 생성할 수 있다. 다음과 같이 Currency 클래스와 팩토리 메서드에 있는 모든 컨트롤러 기능을 삭제하고 생성자만 사용해도 된다.\n그 생성자를 이제 public 으로 만들 수 있다.\n\n## 배열을 객체로 전환 (Replace Array with Object)\n\n배열을 구성하는 특정 원소가 별의별 의미를 지닐 땐 그 배열을 각 원소마다 필드가 하나씩 든 객체로 전환하자.\n\n배열은 데이터 정리에 흔히 사용되는 구조다. 그러나 배열은 비슷한 객체들의 컬렉션을 일정 순서로 담는 용도로만 사용해야 한다. 그러나 간혹 배열에 각양각색의 것이 무수히 들어있는 것을 보게 된다.\n객체를 사용하면 필드명과 메서드명을 사용하여 이러한 정보를 전달할 수 있으므로 기억하거나 주석을 갱신할 필요가 없다. 그런 정보를 캡슐화하고 객체에 기능을 추가할 수도 있다.\n\n### 예제\n\n아래 예제는 스포츠 팀의 이름, 승수, 패수를 배열에서 객체로 바꿔보는 실습이다.\n\n```javascript\nconst row = ['리버풀', '15', '3']\n\n// 위 배열을 객체로 바꾸자.\n\nclass Performance {\n  constructor(name, win, lose) {\n    this._name = name\n    this._win = win\n    this._lose = lose\n  }\n\n  getName() {}\n\n  setName() {}\n}\n```\n\n## 관측 데이터 복제 (Duplicate Observed Data)\n\n도메인 데이터는 GUI 컨트롤 안에서만 사용 가능한데, 도메인 메서드가 그 데이터에 접근해야 할 땐그 데이터를 도메인 객체로 복사하고, 양측의 데이터를 동기화하는 관측 인터페이서 observer 를 작성하자.\n\n계층구조가 체계적인 시스템은 비즈니스 로직 처리 코드와 사용자 인터페이스 처리 코드가 분리되어 있다.\n\n* 비슷한 비즈니스 로직을 여러 인터페이스가 처리해야 하는 경우라서\n* 비즈니스 로직까지 처리하려면 사용자 인터페이스가 너무 복잡해지니까\n* GUI 와 분리된 도메인 객체가 더욱 유지보수하기 쉬우니까\n* 두 부분을 서로 다른 개발자가 다루게 할 수 있으니까\n\n## 예제\n\n아래 예제에서 해볼 예제는 세 개의 텍스트 필드중 하나의 값을 변경하면 다른 필드 값도 바뀌는 UI 가 있다고 하자.\n여기서 start 필드나 end 필드 값을 바꾸면 length 필드 값이 계산되어 바뀌고 length 필드 값을 바꾸면 end 필드 값이 계산되어 바뀌는 UI 이다.\n\n우선 첫번째로 여러가지 혼재되어있는 코드를 볼수있다.\n\n```javascript\n// ui 코드와 비즈니스 코드가 산재하고 있는 클래스\nclass IntervalWindow {\n  constructor() {\n    this._startFieldElem\n    this._endFieldElem\n    this._lengthFieldElem\n  }\n\n  // 3가지 필드는 포커스를 잃으면 반응하게 설정되어 있다.\n  focusLost(event) {\n    const target = event.target\n    if (target === this._startFieldElem) {\n      // 스타트 input 필드에서 초첨을 잃었을때 반응하자.\n      this.startFieldFocusLost(event)\n    } else if (target === this._endFieldElem) {\n      this.endFieldFocusLost(event)\n    } else if (target === this._lengthFieldElem) {\n      this.lengthFieldFocusLost(event)\n    }\n  }\n\n  // 3가지의 이벤트 핸들러들..\n  startFieldFocusLost(event) {\n    if (isNotInteger(this._startFieldElem.value)) this._startFieldElem.value = 0\n    calculateLength()\n  }\n\n  endFieldFocusLost(event) {\n    if (isNotInteger(this._endFieldElem.value)) this._endFieldElem.value = 0\n    calculateLength()\n  }\n\n  lengthFieldFocusLost(event) {\n    if (isNotInteger(this._lengthFieldElem.value))\n      this._lengthFieldElem.value = 0\n    calculateEnd()\n  }\n\n  calculateLength() {\n    try {\n      const start = parseInt(this._startFieldElem.value)\n      const end = parseInt(this._endFieldElem.value)\n      const length = end - start\n\n      this._lengthFieldElem.value = partInt(length)\n    } catch (e) {\n      new error('잘못된 숫자 형식이다.')\n    }\n  }\n\n  calculateEnd() {\n    // calculateLength 비슷.\n  }\n}\n```\n\n위 코드에서 할일은 GUI 코드와 로직 코드를 분리 하는 것이다.\n즉, `calculateLength` , `calculateEnd` 메서드를 별도의 도메인 클래스로 옮겨야한다. 그러려면 start, end, length 변수를 IntervalWindow 클래스를 거치지 않고 참조해야 한다.\n유일한 방법은 start, end, length 변수 데이터를 도메인 클래스로 복사하고 그 데이터를 GUI 클래스의 데이터와 동기화 하는 것이다. 이 작업을 관측 데이터 복제라고 한다.\n\n여기서 `Observable (Subject)_신문사`는 `observer_구독자`들을 관리하고 모든 `observer`가 `Observable (Subject)`를 관찰할수 있다.\n또한 `observer` 은 subscribe 와 unsubscribe 의 메서드를 지닌 인터페이스이다. `Observable (Subject)`에서 state 가 변화가 생겼을때 그 관찰자들에게 통지해준다.\n\n`Observer`는 `Observable (Subject)` 가 변화가 생겼을때 실행될 함수 같은 것이다.\n\n아래 예제에서는 `Interval` 클래스에는 비즈니스 로직이 `IntervalWindow`에는 UI 로직이 들어가있다.\n\n```javascript\n// 도메인 클래스 ( )\nclass Interval extends Observable {\n  constructor() {\n    this._end\n  }\n\n  getEnd() {\n    return this._end\n  }\n\n  setEnd(value) {\n    this._end = value\n    this.setChanged()\n    this.notifyObservers() // observer들의 update 메서드 실행\n  }\n}\n\n// IntervalWindow 클래스 안에는 다음과 같이 넣자.\n// this._subject //( Inverval 의 인스턴스를 담고있을 것이다. )\n\n// 위 상황처럼 구현을 하려면 IntervalWindow 클래스에 Observer 클래스를 상속 구현하게 만들어야 한다.\n\nclass IntervalWindow extends Observer {\n  constructor() {\n    this._endFieldElem\n    this._subject = new Interval()\n    this._subject.addObserver(this)\n    update(_subject, null)\n  }\n\n  endFieldFocusLost(event) {\n    this.setEnd(this._endFieldElem.value)\n\n    if (isNotInteger(this._endFieldElem.value)) this._endFieldElem.value = 0\n    calculateLength()\n  }\n\n  // 여기서 update 함수는 Interval 클래스에서 notifyObservers 메서드가 실행되었을때 실행된다.\n  update(observable, arg) {\n    this._endFieldElem.value = this._subject.getEnd()\n  }\n\n  getEnd() {\n    return this._subject.getEnd()\n  }\n\n  setEnd(value) {\n    // this._endField.value = value\n    this._subject.setEnd(value)\n  }\n}\n```\n\n지금껏 end 필드에 수행한 과정을 start 필드와 length 필드에도 그대로 적용하자. `메서드 이동` 기법으로\ncalculateEnd 메서드와 calculateLength 메서드를 Interval 클래스로 옮기자. 그러면 모든 도메인 기능과 데이터는 도메인 클래스에 들어 있게 되어 GUI 코드와 분리된다.\n","excerpt":"해당 글은  에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다. 여기서는 데이터 연동을 더 간편하게 해준다.\n객체지향 언어는 구형 언어의 단순 데이터 타입으론 불가능했던 것까지 할 수 있는 새로운 타입을 정의할 수 있어서 좋다.…","fields":{"slug":"/organization-data1/"},"frontmatter":{"date":"Mar 27, 2019","title":"(리팩토링) 데이터 체계화1","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n\n해당 글은 `리팩토링 (코드 품질을 개선하는 객체지향 사고법)` 에서 발췌 했습니다. 코드 예제는 javascript로 전환하였습니다.\n\n**기능을 어디에 넣을지 판단** 하는것은 중요하다.\n기능을 넣을 적절한 위치를 찾는 문제는 메서드 이동과 필드 이동을 실시해서 기능을 옮기면 해결된다. 이때, 필드 이동 부터 실시한후 메서드 이동을 실시하는것이 좋다.\n\n클래스가 방대해지는 원인은 대개 기능이 너무 많기 때문이다. 이럴때 클래스 추출을 실시해서 이런 많은 기능을 일부 분리해야한다.\n\n이 밖에 다양한 기능들을 알아보자.\n\n## 메서드 이동 (Move Method)\n\n메서드가 자신이 속한 클래스보다 다른 클래스 기능을 더 많이 이용할 땐 그 메서드가 제일 많이 이용하는 클래스 안에서 비슷한 내용의 새 메서드를 작성하자.\n기존 메서드는 간단한 대리 메서드로 전환하든이 아예 삭제하자.\n\n메서드를 옮길지 확신이 서지 않을 때는 다른 메서드를 살펴본다. 다른 메서드를 옮길지를 판단하는 것이 대체로 더 쉽게 마련이다.\n\n## 필드 이동 (Move Field)\n\n어떤 필드가 자신이 속한 클래스보다 다른 클래스에서 더 많이 사용될 때는 대상 클래스 안에 새 필드를 선언하고 그 필드 참조 부분을 전부 새 필드 참조로 수정하자.\n\n어떤 필드가 자신이 속한 클래스보다 다른 클래스에 있는 메서드를 더 많이 참조해서 정보를 이용한다면 그 필드릴 옮기는 것을 생각해보자. \n인터페이스에 따라 메서드를 옮기는 방법을 사용할 수도 있다. 하지만 메서드의 현재 위치가 적절하다고 판단되면 필드를 옮긴다.\n\n### 예제: 필드 캡슐화\n\n```javascript\nclass Account {\n  constructor() {\n    this._type\n    // 아래 필드를 AccountType 으로 옮기려 한다. \n    // this._interestRate \n  }\n\n  interestForAmount_days() {\n    //return this._interestRate * 10\n    return _type.getInterestRate() * 10\n  }\n}\n\n// _interest 필드를 AccountType 클래스로 옮기려 한다.\n\nclass AccountType {\n  constructor() {\n    // private \n    // 캡슐화\n    this._interestRate\n  }\n\n  setInterestRate(arg) {\n    this._interestRate = arg\n  }\n\n  getIntersetRate() {\n    return this._interestRate\n  }\n}\n```\n\n### 예제: 필드 자체 캡슐화\n\n많은 메서드가 interestRate 필드를 사용한다면 다음과 같이 필드 자체 캡슐화를 실시한다.\n\n```javascript\nclass Account {\n  constructor() {\n    this._interestRate\n  }\n\n  interestForAmount_days() {\n    return getInterestRate() * 10\n  }\n\n  getInterestRate() {\n    return this._interestRate\n  }\n\n  setInterestRate(arg) {\n    this._interestRate = arg\n  }\n}\n```\n\n위와 같이 바꾸고 난 뒤에 다시 아래 처럼 코드를 바꾼다.\n\n```javascript\nclass Account {\n  constructor() {\n    this._interestRate\n  }\n\n  interestForAmount_days() {\n    return getInterestRate() * 10\n  }\n\n  getInterestRate() {\n    return this._type.getInterestRate()\n  }\n\n  setInterestRate(arg) {\n    this._type.setInterestRate(arg)\n  }\n}\n```\n\n## 클래스 추출 (Extract Class)\n\n두 클래스가 처리해야 할 기능이 하나의 클래스에 들어 있을 땐 새 클래스를 만들고 기존 클래스의 관련 필드와 메서드를 새 클래스로 옮기자.\n주로 함께 변화하거나 서로 유난히 의존적인 데이터의 일부분도 클래스로 떼어내기 좋다.\n이것을 판단하는 좋은 방법은 데이터나 메서드를 하나 제거하면 어떻게 될지, 다른 필드와 메서드를 추가하는 건 합리적이지 않은지 자문해보는 것이다.\n\n### 예제\n\n아래 `Person` 클래스에서 전화번호 기능을 하나의 클래스로 떼어 낼 수 있다.\n\n```javascript\nclass Person {\n  constructor() {\n    this._name\n    this._officeAreaCode\n    this._officeNumber\n  }\n  \n  getName() {\n    return _name\n  }\n  // 전화번호 기능을 하나의 클래스로 떼어 낼 수 있다.\n  // getTelephoneNumber() {\n  //   return _officeAreaCode + _officeNumber\n  // }\n\n  // getOfficeAreaCode() {\n  //   return _officeAreaCode\n  // }\n\n  //....\n}\n```\n\n위와 같은 `Person` 클래스에서 Telephone 관련한 부분들은 `TelephoneNumber` 객체로 떼어내자. 그 후 관련 메서드 들도 옮기자.\n그 후에 생각해야 할 것은 새로운 클래스를 클라이언트에 어느 정도 공개할지 결정하자.\n\n```javascript\nclass TelephoneNumber {\n  constructor() {\n    this._areaCode\n    this._number\n  }\n\n  getAreaCode() {\n    return this._areaCode\n  }\n\n  setAreaCode(code) {\n    this._areaCode = code\n  }\n\n  getTelephoneNumber() {\n    return `(${this._areaCode}) ${this._number}`\n  }\n\n  getNumber() {\n    return this._number\n  }\n\n  setNumber(number) {\n    this._number = number\n  }\n}\n\n\nclass Person {\n  constructor() {\n    this._officeTelephone = new TelephoneNumber()  \n  }\n\n  getName() {\n    return _name\n  }\n  \n  getTelephoneNumber() {\n    return this._officeTelephone.getTelephoneNumber()\n  }\n\n  getOfficeTelephone() {\n    return this._officeTelephone\n  }\n}\n```\n\n여기서 새로 만든 `TelephoneNumber` 클래스를 공개하는 방식을 사용할땐 왜곡의 위험을 고려해야한다. \n\n- 모든 객체가 `TelephoneNumber` 클래스의 어느 부분이든 변경할 수 있음을 받아들인다. `TelephoneNumber` 클래스를 참조로 전환해서 `Person` 클래스가 \n`TelephoneNumber` 클래스의 접근 지점이 된다. \n- 어느 주체이든 `Person` 클래스를 거치지 않고 `TelephoneNumber` 클래스의 값을 변경하지 못하게 한다. `TelephoneNumber`를 변경불가로 만들어야 한다.\n- `TelephoneNumber` 클래스를 외부로 전달하기 전에 복사한 후 변경불가로 만든다. 하지만 이 방법은 코드를 보는 이들이 값을 변경할 수 있다는 착각을 불러 일으킨다. 게다가 전화번호가 여기저기로 무수히 전달될 경우 클라이언트 간에 왜곡 문제가 발생할 수도 있다. \n\n## 클래스 내용 직접 삽입 (Inline Class)\n\n클래스에 기능이 너무 적을땐 그 클래시의 모든 기능을 다른 클래스로 합쳐 넣고 원래의 클래스는 삭제하자.\n\n주로 클래스의 기능 대부분을 다른 곳으로 옮기는 리팩토리응ㄹ 실시해서 남은 기능이 거의 없어졌을 때 나타난다. 이럴 때는 이 작은 클래스를 가장 많이 사용하는 다른 클래스를 하나 고른후, 이 클래스를 거기에 합쳐야 한다.\n\n위에서 `Person` 객체의 기능이 많이 줄었다면 `TelephoneNumber` 클래스의 클라이언트를 찾아서 `Person` 클래스의 인터페이스를 사용하도록 다음과 같이 수정하자.\n즉, `Person` 클래스에 `TelephoneNumber` 클래스를 합친다.\n```javascript\n// TelephoneNumber 클래스에 모든 외부 공개 메서드를 Person 클래스에 선언하자.\nclass Person {\n  getAreaCode() {\n    return this._officeTelephone.getAreaCode()\n  }\n\n  setAreaCode(code) {\n    this._officeTelephone.setAreaCode(code)\n  }\n\n  getNumber() {\n    return this._officeTelephone.getNumber()\n  }\n\n  setNumber(number) {\n    this._officeTelephone.setNumber(number)\n  }\n}\n\n// TelephoneNumber 클래스의 클라이언트를 찾아서 Person 클래스의 인터페이스를 사용하도록하자.\nconst martin = new Person()\nmartin.getOfficeTelephone.setAreaCode('181')\n\n// Todo\nconst martin = new Person()\nmartin.setAreaCode('181')\n```\n\n그 이후에 TelephoneNumber 클래스의 메서드와 필드를 하나씩 전부 이동하자. 텅빈 TelephoneNumber 클래스는 삭제하자.\n\n## 대리 객체 은폐 (Hide Delegate)\n\n클라이언트가 객체의 대리 클래스를 호출할 땐 대리 클래스를 감추는 메서드를 서버에 작성하자.\n\n캡슐화란 객체가 시스템의 다른 부분에 대한 정보의 일부만 알 수 있게 은폐하는 것을 뜻한다. 객체를 캡슐화하면 무언가를 변경할 때 그 변화를 전달해야 할 객체가 줄어들므로 변경하기 쉬워진다.\n\n클라이언트가 서버 객체의 필드 중 하나에 정의된 메서드를 호출할 때 그 클라이언트는 이 대리 객체에 관해 알아야 한다. 대리 객체가 변경될 때 클라이언트도 변경해야할 가능성이 있기 때문이다. 이런 의존성을 없애려면, 대리 객체를 감추는 간단한 위임 메서드를 서버에 두면 된다.\n\n아래에서 서버에 해당하는 것은 `Person`객체이다. 대리 객체는 `Department` 이다.\n\n### 예제\n\n```javascript\nclass Person {\n  constructor() {\n    this._department // Department\n  }\n\n  getDepartment() {\n    return this._department\n  }\n\n  setDepartment(arg) {\n    this._department = arg\n  }\n}\n\nclass Department {\n  constructor(manager) {\n    this._chargeCode\n    this._manager = manager // Person\n  }\n\n  getManager() {\n    return this._manager\n  }\n}\n```\n\n위와 같은 코드가 있다고 했을때 어떤 사람의 팀장이 누군지 알아내려면 먼저 부서를 알아내고 나서 알아내야 한다.\n`manager = john.getDepartment().getManager()`\n이런 의존성을 줄이려면 Department 클래스를 클라이언트가 알 수 없게 감춰야 한다. 그러려면 Person 클래스에 다음과 같이 간단히 위임 메서드를 작성한다.\n\n```javascript\ngetManager() {\n  return _department.getManager()\n}\n\nconst manager = john.getManager()\n```\n\n위와 같이 했다면 `Person` 클래스에 들어있는 `getDepartment` 읽기 메서드를 삭제하자.\n\n## 과잉 중개 메서드 제거 (Remove Middle Man)\n\n클래스에 자잘한 위임이 너무 많을 땐 대리 객체를 클라이언트가 직접 호출하게 하자.\n\n위의 대리 객체 은폐 기법은 장점을 얻는 대신 단점도 생긴다. 클라이언트가 대리 개체의 새 기능을 사용해야 할 때마다 서버에 즉, Person 객체에 간단한 위임 메서드를 추가해야 한다는 점이다.\n여기서 서버개체 Person 객체는 그저 중개자에 불과하므로, 이때는 클라이언트가 대리 객체를 직접 호출하게 해야한다. \n\n```javascript\nclass Person {\n  // 다시 부활.\n  getDepartment() {\n    return _department\n  }\n}\n\n// 클라이언트가 대리 객체를 먼저 거치게끔 다음과 같이 수정하자.\nmanager = john.getDepartment().getManager()\n```\n\n편의상 일부 위임 메서드는 그대로 둬야 할 때도 있다. 대리 객체를 일부 클라이언트에게만 감추고 나머지 클라이언트에겐 공개해야 할 때도 있다. 그럴 때는 간단한 위임 메서드 중 일부를 그대로 내버려 두면 된다. \n\n## 외래 클래스에 메서드 추가 (Introduce Foreign Method)\n\n사용 중인 서버 클래스에 메서드를 추가해야 하는데 그 클래스를 수정할 수 없을 땐 클라이언트 클래스 안에 서버 클래스의 인스턴스를 첫번째 인자로 받는 메서드를 작성하자.\n\n원본 클래스가 수정 가능하다면 그 기능의 메서드를 추가하면 된다. 하지만 원본 클래스를 수정할 수 없다면 그 메서드를 클라이언트 클래스 안에 작성해야 한다.\n\n### 예제\n\n대금 결제일을 연기하는 원본 코드는 다음과 같다. 여기서 `previousEnd`가 서버 클래스이다.\n\n```javascript\nconst newStart = new Date(previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate() + 1)\n\n// 우변 코드를 뺴내어 메서드로 만들자.\nconst newStart = nextDay(previousEnd)\nnextDay(arg) {\n  return new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1)\n}\n```\n\n## 국소적 상속확장 클래스 사용\n\n사용 중인 서버 클래스에 여러 개의 메서드를 추가해야 하는데 클래스를 수정할 수 없을 땐 새 클래스를 작성하고 그 안에 필요한 여러 개의 메서드를 작성하자.\n이 상속확장 클래스를 원본 클래스의 하위 클래스나 래퍼 클래스로 만들자.\n\n클래스 제작자도 신이 아니므로 개발자에게 필요한 메서드가 전부 든 클래스를 만드는건 불가능에 가깝다. 원본 클래스를 수정하는 것이 불가능할 때가 대부분이다.\n필요한 메서드 수가 3개 이상이면 필요한 메서드들을 적당한 곳에 모아둬야 한다.\n\n### 예제: 하위 클래스 사용\n\n```javascript\nclass Client {\n  nextDay(date) {\n    // Date 객체를 받아서 이용하는 메서드\n    return new Date(date.getYear(), date.getMonth(), date.getDate() + 1)\n  }\n}\n\n// 위의 Client에 메서드를 두지말고 Date를 상속받아서 내가 필요한 메서드를 옮겨두자.\nclass MfDateSub extends Date {\n  constructor(dateString) {\n    super(dateString)\n  }\n\n  nextDay() {\n    // 더이상 date 객체를 받지 않아도 사용가능하다.\n    return new Date(this.getYear(), this.getMonth(), this.getDate() + 1)\n  }\n}\n```\n\n### 예제: 래퍼 클래스 사용\n\n```javascript\nclass MfDateWrap {\n  constructor(dateString) {\n    this._original = new Date(dateString)\n  }\n\n  // 원본 Date 클래스의 모든 메서드를 위임하는 지루한 작업\n  getYear() {\n    return this._original.getYears()\n  }\n  // 원본 Date 클래스에도 있는 equals\n  equals(arg) {\n    if(this === arg) return true\n    if(! (arg instanceof MfDateWrap)) return false\n    const other = arg\n    return (this._original.equals(other._original))\n  }\n\n  nextDay() {\n    // 더이상 date 객체를 받지 않아도 사용가능하다.\n    return new Date(this.getYear(), this.getMonth(), this.getDate() + 1)\n  }\n}\n```\n\n래퍼 클래스화 방식을 사용할 때는 원본 클래스를 인자로 받는 `after(Date arg)` 메서드들을 처리하는 방법이 문제가 된다.\n\n```javascript\naWrapper.after(aDate) // 동작함\naWrapper.after(anotherWrapper) // 동작함\naDate.after(aWrapper) // 돌아가질 않음\n```\n\n이런식으로 같은 이름의 메서드를 정의(재정의)하는 이유는 래퍼 클래스 사용 사실을 원본 클래스 사용 부분이 모르게 하기 위해서다.\n래퍼 클래스 사용 부분은 래퍼 클래스에 전혀 관여해선 안되며 원본과 래퍼를 동등하게 다룰 수 있어야 하므로 이방식이 좋다.\n하지만 래퍼 클래스 사용 사실을 완벽히 감추진 못한다. 문제는 `equals` 같은 특정 시스템 메서드에 있다. \n\n`equals` 메서드는 대칭적으로 돌아가는 반면 이 전제에 어긋나는 코딩을 하면 각종 이상한 버그가 생길 것이다. \n따라서 이런 상황에서는 어쩔 수 없이 래퍼 클래스 사용 사실을 공개할 수 밖에 없다. `equalsDate` 메서드를 새로 만든다.\n\n결론은 기능을 재정의 하지 않는 이상, 하위클래스화 방식을 사용할 땐 이런 문제가 없다. 그러나 기능을 재정의하면 메서드를 검색할때 애를 먹게 된다.\n그냥 상속확장 클래스를 사용할 땐 메서드를 재정의하지 않고 그냥 메서드를 추가하자.","excerpt":"해당 글은  에서 발췌 했습니다. 코드 예제는 javascript로 전환하였습니다. 기능을 어디에 넣을지 판단 하는것은 중요하다.\n기능을 넣을 적절한 위치를 찾는 문제는 메서드 이동과 필드 이동을 실시해서 기능을 옮기면 해결된다. 이때, 필드 이동 …","fields":{"slug":"/moving-between-object/"},"frontmatter":{"date":"Mar 25, 2019","title":"(리팩토링) 객체 간의 기능 이동","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n해당 글은 `리팩토링 (코드 품질을 개선하는 객체지향 사고법)` 에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다.\n\n## 메서드 추출 (Extract Method)\n\n어떤 코드를 그룹으로 묶어도 되겠다고 판단될때 그 코드를 빼내어 목적을 잘 나타내는 직관적 이름의 메서드로 만들자.\n\n### 예제: 지역변수 사용 안하는 경우\n\n```javascript\nconst testObj = {\n  printOwing(){\n    const e = order.elements()\n    const outstanding = 0.0\n\n    // 배너 추출\n    // console.log('----- banner -----')\n    this.printBanner()\n  }\n\n  printBanner(){\n    console.log('----- banner -----')\n  }\n}\n```\n\n### 예제: 지역변수 사용하는 경우\n\n메서드 안에서 지역변수가 읽히기만 하고 변경되지 않을때, 이럴 땐 지역변수를 그냥 매개변수로 전달하면 된다.\n\n```javascript\nconst testObj = {\n  printOwing(){\n    const e = order.elements()\n    const outstanding = 0.0\n\n    // 세부내역 출력\n    // console.log('고객명' + _name)\n    // console.log('외상액' + outstanding)\n    this.printDetails(_name, outstanding)\n\n  }\n\n  printDetails(name, outstanding){\n    console.log('고객명' + _name)\n    console.log('외상액' + outstanding)\n  }\n}\n```\n\n### 예제: 지역변수를 다시 대입하는 경우\n\n복잡한 경우는 지역변수로의 값 대입이다. 이럴 때는 임시변수만 생각하면 되는데 두가지만 생각하자.\n첫번째는 임시변수가 추출한 코드 안에서만 사용되는 경우, 이럴땐 그냥 임시변수를 추출한 코드로 옮기면 된다.\n두번째는 임시변수가 추출한 코드 코드 밖에서 사용되는 경우, 추출한 코드에서 임시변수의 변경된 값을 반환하게 하자.\n\n```javascript\nconst testObj = {\n  printOwing(){\n    // const e = order.elements()\n    const outstanding = 0.0\n    outstanding = this.getOutstanding(outstanding)\n    // 외상액 계산 : e는 추출될 코드 안에서만 사용, each는 코드 안에서만 사용, outstanding은 반환하자.\n    // while(e.hasMore()){\n      // const each = e.next()\n      // outstanding += each.getAmount()\n    // }\n\n    this.printDetails(_name, outstanding)\n\n  }\n  getOutstanding(initialValue){\n    const e = order.elements()\n    const result = initialValue\n\n    while(e.hasMore()){\n      const each = e.next()\n      result += each.getAmount()\n    }\n    return result\n  }\n}\n```\n\n변수를 두개 이상 반환해야 할땐, 최선의 방법은 여러 개의 메서드를 만드는 방법을 사용하고 출력 매개변수 기느잉 있다면 출력 매개변수를 사용하면 된다.\n\n## 메서드 내용 직접 삽입 (Inline Method)\n\n메서드 기능이 너무 단순해서 메서드명만 봐도 너무 뻔할 땐 그 메서드의 기능을 호출하는 메서드에 넣어버리고 그 메서드는 삭제하자.\n만약 그 메서드가 하위 클래스에 재정의 되어있다면 해당 작업을 실시하지 말자. 없어진 메서드를 재정의 하는 일이 생겨선 안된다.\n\n### 예제\n\n```javascript\nconst testObj = {\n  getRating() {\n    // return (this.moreThanFiveLateDeliveries)? 2 : 1\n    reutnr(deliveris > 5) ? 2 : 1\n  },\n\n  // moreThanFiveLateDeliveries() {\n  //   return deliveris > 5\n  // }\n}\n```\n\n## 임시변수 내용 직접 삽입 (Inline Temp)\n\n간단한 수식을 대입받는 임시변수로 인해 다른 리팩토링 기법 적용이 힘들 땐 그 임시변수를 참조하는 부분을 전부 수식으로 치환하자.\n\n```javascript\n//const basePrice = order.basePrice()\n//return (basePrice > 1000)\n\nreturn order.basePrice() > 1000\n```\n\n## 임시변수를 메서드 호출로 전환 (Replace Temp with Query)\n\n수식의 결과를 저장하는 임시변수가 있을 땐, 그 수식을 빼내어 메서드로 만든후, 임시변수 참조 부분을 전부 수식으로 교체하자.\n새로 만든 메서드는 다른 메서드에서도 호출 가능하다.\n단, 값이 여러번 대입되는 임시변수가 있으면 이 방법을 고려해봐야한다.\n\n반복문이 들어있는 메서드를 추출해서 임시변수 대신 그 메서드를 사용한다면 여러번 호출로 인한 성능이 염려될 수도 있다.\n다른 성능 문제처럼 당장은 느려질 수 있어도 대체로 문제없다. 최적화 과정에서 그 문제를 해결하면 된다.\n\n### 예제\n\n```javascript\n// 리펙토링 하기 전\nconst testObj = {\n  getPrice() {\n    const basePrice = quantity * itemPrice\n    let discountFactor\n    if( basePrice > 1000 ) discountFactor = 0.95\n    else discountFactor = 0.98\n    return basePrice * discountFactor\n  }\n}\n\n// 리펙토링 한 후\nconst testObj = {\n  getPrice() {\n    return this.basePrice() * this.discountFactor()\n  }\n  basePrice(){\n    return quantity * itemPrice\n  }\n  discountFactor(){\n    if(basePrice() > 1000) return 0.95\n    return 0.98\n  }\n}\n```\n\n## 직관적 임시변수 사용 (Introduce Explaining Variable)\n\n사용된 수식이 복잡할 땐 수식의 결과나 수식의 일부분을 용도에 부합하는 직관적 이름의 임시변수에 대입하자.\n그 외에도 긴 알고리즘에서 임시변수를 사용해서 계산의 각 단계를 설명할 수 있을 때도 사용한다.\n\n이 방법을 사용하기 보다는 메서드 추출을 사용하려 노력하자.\n\n## 임시변수 분리 (Split Temporary Variable)\n\n루프 변수나 값 누적용 임시변수(i = i+ 수식)가 아닌 임시변수에 여러번 값이 대입될 땐 각 대입마다 다른 임시변수를 사용하자.\n임시변수는 긴 코드의 계산 결과를 나중에 간편히 참조할 수 있게 저장하는 용도로 사용된다.\n이런 변수에 값이 두번 이상 대입된다는 건 그 변수가 메서드 안에서 여러 용도로 사용된다는 반증이다.\n\n```javascript\n// 리펙토링 하기 전\nlet temp = 2 * (height * width)\nconsole.log(temp)\ntemp = height * width\nconsole.log(temp)\n\n// 리펙토링 후\nlet perimeter = 2 * (height * width)\nconsole.log(perimeter)\nlet area = height * width\nconsole.log(area)\n```\n\n## 매개변수로의 값 대입 제거 (Remove Assignments to Parameters)\n\n매개변수로 값을 대입하는 코드가 있을땐 매개변수 대신 임시변수를 사용하게 수정하자.\n**매개변수로의 값 대입** 이란 만약 foo 라는 객체를 매개변수로 전달 했을때 foo 의 값을 다른 객체 참조로 변경한다는 의미이다.\n즉, foo 에 다른 객체를 할당을 하는 것은 하지 절대로 하지 말아야 한다.\n\n## 메서드를 메서드 객체로 전환 (Replace Method with Method Object)\n\n장황한 메서드에서 각 부분을 간결한 메서드로 빼내면 코드가 훨씬 이해하기 쉬워진다.\n지역변수 때문에 메서드 추출을 적용할 수 없는 긴 메서드가 있을땐 그 *메서드 자체를 객체로 전환*해서 모든 지역변수를 객체의 필드로 만들자.\n그런 다음 그 메서드를 객체 안의 여러 메서드로 쪼개면 된다.\n\n```javascript\nclass Account {\n  // 상당히 복잡한 gamma 메서드\n  gamma(inputValue, qunatity, yearToData) {\n    const importantValue1 = inputValue * quantity + this.delta()\n    const importantValue2 = inputValue * yearToData + 100\n    if (yearToData - importantValue1 > 100) {\n      importantValue2 -= 20\n    }\n    const importantValue3 = importantValue2 * 7\n\n    //.. 기타 작업들\n    return importantValue3 - 2 * importantValue1\n  }\n}\n```\n\ngamma 라는 메서드 대신 객체(Gamma)를 새로 생성하자.\n그런 다음 원본 메서드(gamma)가 이 메서드 객체로 위임하게 수정하자.\n\n```javascript\nclass Account {\n  gamma() {\n    // 위임\n    return new Gamma(this, inputValue, quantity, yearToData).compute()\n  }\n}\n\nclass Gamma {\n  constructor(account, inputValue, quantity, yearToData) {\n    this.account = account\n    this.inputValue = inputValue\n    this.quantity = quantity\n    this.yearToData = yearToData\n  }\n\n  computed() {\n    const importantValue1 = inputValue * quantity + this.account.delta()\n    const importantValue2 = inputValue * yearToData + 100\n    if (yearToData - importantValue1 > 100) {\n      importantValue2 -= 20\n    }\n    const importantValue3 = importantValue2 * 7\n\n    //.. 기타 작업들\n    // 여기서 추가로 메서드를 추출할 수 있다.\n    this.importantThing()\n    return importantValue3 - 2 * importantValue1\n  }\n\n  importantThing() {\n    // .. 중요 로직\n  }\n}\n```\n\n## 알고리즘 전환 (Substitute Algorithm)\n\n알고리즘을 더 분명한 것으로 교체해야 할땐 해당 메서드의 내용을 새 알고리즘으로 바꾸자.\n이렇게 하려면 먼저 메서드를 최대한 잘게 쪼개야 한다. 길고 복잡한 알고리즘은 수정하기 어려우므로, 우선 간단한 알고리즘으로 교체해야만 수정 작업이 편해진다.\n\n어떤 작업을 약간 다르게 처리해야 해서 알고리즘을 변경해야 할 때도 있는데, 이럴 때는 좀 더 변경하기 쉬운 알고리즘으로 교체하는 것이 간편하다.\n\n이렇게 하려면 먼저 메서드를 최대한 잘게 쪼개야 한다. 길고 복잡한 알고리즘은 수정하기 어려우므로, 우선 간단한 알고리즘으로 교체해야만 수정 작업이 편해진다.\n\n### 예제\n\n```javascript\nfoundPerson(people=[]) {\n  for(let i =0; i < people.length; i++) {\n    if(people[i].equals('Don')){\n      return 'Don'\n    }\n    if(people[i].equals('John')){\n      return 'John'\n    }\n    if(people[i].equals('Kent')){\n      return 'Kent'\n    }\n  }\n}\n```\n\n아래처럼 바꿔보자.\n\n```javascript\nfoundPerson(people=[]) {\n  const candidates = new Set(['Don', 'John', 'Kent'])\n\n  for(let i =0; i < people.length; i++) {\n    if(candidates.has(people[i])) {\n      return people[i]\n    }\n  }\n\n  return ''\n}\n```\n","excerpt":"해당 글은  에서 발췌 했습니다. 코드 예제는 javascript 로 전환하였습니다. 메서드 추출 (Extract Method) 어떤 코드를 그룹으로 묶어도 되겠다고 판단될때 그 코드를 빼내어 목적을 잘 나타내는 직관적 이름의 메서드로 만들자. 예제…","fields":{"slug":"/method-cleanup/"},"frontmatter":{"date":"Mar 20, 2019","title":"(리팩토링) 메서드 정리","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## cookie\n\n쿠키는 사용자 속성을 기억하는 데 사용되는 작은 텍스트 파일이다.\n\n서버에서 `Set-Cookie` 라고 헤더에 셋팅을 하게 되면 브라우저는 해당 쿠키를 `key=value`로 저장하게 된다. \n\n쿠키 중에는 2가지 쿠키가 존재한다.\n- 웹브라우저를 끄면 사라지는 휘발성 쿠키를 `Session cookie`.\n- 웹브라우저를 꺼도 사라지지 않는 쿠키를 `Permanent` 쿠키\n\n`Permanent` 쿠키를 셋팅할 때는 `key=value; [expire | Max-Age]` 라고 셋팅을 해준다. expire는 만료되다 라는 뜻이고 쿠키가 언제 죽을것인가 즉, 절대적인것 이다. \nMax-Age는 현재 시점을 기준으로 상대적으로 얼마간 살아있을것인가 를 나타낸다. 예 `key=value; Max-Age=${60*60*24*30}` 30일 짜리 쿠키를 만드는 것이다.\n\n또한 쿠키 옵션 중에는 Secure, HttpOnly, path, domain 이 존재한다.\n\n- Secure는 웹브라우저와 웹서버가 `https`로 통신하는 경우만 웹브라우저가 쿠키를 서버로 전송하는 옵션이다. (`key=value; Secure`)\n- `HttpOnly`는 자바스크립트의 document.cookie를 이용해서 쿠키에 접속하는 것을 막는 옵션이다. 웹브라우저와 통신할 때만 전송되는 쿠키 이다. 쿠키를 훔쳐가는 행위([XSS](https://www.kisa.or.kr/uploadfile/201312/201312161355109566.pdf))를 막기 위한 방법입니다. (`key=value; HttpOnly`)\n\npath와 domina 옵션은 쿠키의 유효범위를 정의하는 옵션이다.\n어떤 특정 디렉토리에서만 쿠키가 활성화 되도록 하고 싶을때 path 라는 옵션을 지정한다. `key=value; path=/cookie` path라는 옵션을 주어서 어떤 디렉토리를 지정하면 디렉토리 하위에서만 쿠키가 활성화 되서 웹 브라우저는 거기에만 해당하는 쿠키를 서버에 전송한다.\n\ndomain 옵션은 다음과 같이 사용하고  `key=value; Domain=o2.org` 어떤 서브 도메인에서도 살아있는 쿠키를 만드는 것이다. 즉, `test.o2.org` 에서는 해당 key, value 가 살아있는 것입니다.\n\n특히 domain은 쿠키가 전송되게 될 호스트를 명시하는데 지정하지 않을 경우에는 서브 도메인은 포함되지 않는 현재 문서 위치의 호스트를 셋팅할 것이고, 명시적으로 설정하게 되면 서브도메인들은 항상 포함되게 됩니다.\n\n쿠키는 사용자 정보를 수집할때도 이용 가능한데 만약에 내 블로그 `www.myBlog.com` 이 있다고 생각해보자. \n`myBlog` 에서 생성된 쿠키는 도메인 스코프를 지니기 때문에 `myBlog` 로만 전송이 될 수 있다. \n\n하지만 `myBlog`에 페이스북 공유하기 버튼을 심어놨다고 생각해보자.\n페이스북 공유하기 버튼에 사용되는 이미지 또는 js 파일을 요청 할 것이다. 이때, 페이스북은 응답으로 여러 쿠키를 심을 것이다. 이후에 페이스북을 접속을 하게 되면 페이스북이 심어놨던 쿠키들을 다시 받을 수 있다. 이때 얻을 수 있는 정보는 아마 내가 `myBlog`에 들렀었고 좋아요 버튼을 눌렀다면 좋아요 버튼도 눌렀다는 사실까지 알 수 있을것이다.\n\n## SOP\n\n영어로 하면 same-origin policy 우리말로 하면 동일 출처 원칙 이라고 한다. \n모든 최신 브라우저에 의해 이 정책을 지원하고있다. 웹 자원들은 같은 프로토콜과 같은 도메인 그리고 같은 포트를 사용한다면 다른 컨텐츠의 자원들에 즉, 속성이나 다른 값어치 있는 것들에 도달할수 있다. 만약 그렇지 않다면 document 속성에 도달하거나 변경하는 작업은 **브라우저**에 의해 막히게 된다. \n\n만약 우리가 http://www.example.com/dir/test.html 페이지를 호스팅했다고 상상해보자 이 안에는 다른 웹페이지가 로드된 iframe이 있다고도 생각해보자.\n우리의 호스트는 www.example.com 으로 정의되어있다. 아래 테이블은 접근 가능한지 안가능한지를 나타내는 full URLs를 비교해놓았다.\n\n| URL                                    | Result         | Reason                                                             |\n|----------------------------------------|----------------|--------------------------------------------------------------------|\n| http://www.example.com/dir/page.htm    | Accessible     | Protocol, host and port match                                      |\n| http://www.example.com:81/dir/test.htm | Not Accessible | Same protocol and host, but port is different (81)                 |\n| https://www.example.com/dir/test.htm   | Not Accessible | Same host, but schema/protocol (https) different                   |\n| http://demo.example.com/dir/test.htm   | Not Accessible | Schema and port are same, but host is different (demo.example.com) |\n| http://example.com/dir/test.htm        | Not Accessible | Host is different (example.com)                                    |\n\n\n모든 모던 브라우저에 의해 동일 출처 정책이 지원되기 때문에 웹 리소스는 동일한 프로토콜, 동일한 도메인, 동일한 포트를 사용하는 경우 서로의 콘텐츠, 속성에 도달할 수 있다.\n만약 그렇지가 않다면 브라우저에 의해서 문서 속성에 도달하거나 변경이 막힙니다.\n\n오늘날 Same-origin Policy는 대게 DOM에만 적용 되는지 알았지만 사실 그게 전부가 아니다 웹의 모든 자원에 대해서 Same-origin Policy의 체크 매커니즘이 적용된다.\n쿠키가 그 한 예중에 하나일것이다. 쿠키는 쿠키속성의 도메인(domain), 경로(path) 및 속성이 요청 된 도메인과 일치하는 이벤트에서만 쿠키가 전송되기 때문에 Same-origin Policy 매커니즘이 적용되는 하나의 예가 될 수 있다. 만약 쿠키가 매칭되고 expired 되지 않았다면 쿠키는 보내질 것이다. 이전에 설명했던 Same-origin Policy와 다른점이 있다면 쿠키(secure-only cookies는 제외)는 포트와 스키마를 쿠키가 보내지기 전에 체크해야하는 대상이 아니라는 점이다.\n\n대부분이 알고 있는 잘못된 사실은 Same-origin Policy는 브라우저가 다른 origin의 자원을 *로드*하는걸 금지한다는 것이다. 하지만 우리가 알고있는 CDN 생태계만 봐도 그것은 사실이 아니라는걸 알 수 있다. \n\n다른 잘못된 사실은 origin에서 다른 곳으로 자원을 *보낼수가 없다*는 사실이다. 이것또한 사실이 아니다. \n\n우리가 기억하고 있는 Same-origin Policy 정책의 정의를 보자.\n\n1. 각 사이트는 자산의 리소스를 지니고있다. 쿠키, DOM 그리고 자바스크립트 네임스페이스\n2. 각 페이지는 자신의 URL로 부터 origin을 갖는다. ( 대게 스키마, 도메인 그리고 포트 )\n3. 스크립트는 자신이 load된 origin의 컨텍스트안에서 실행된다. 어디서 불러왔는지는 중요하지 않다. 오직 마지막에 실행된 장소가 중요하다.\n4. 많은 미디어나 이미지 리소스들은 수동 리소스들이다. 그것들은 그들이 존재하는 컨텍스트의 자원이나 object에 접근 할 수가 없다.\n\n이런 룰을 가지고 *Origin A* 라는 사이트가 있다고 가정해보자.\n\n1. origin B 로 부터 온 스크립트를 load 할수있다. 하지만 그것은 A 컨텍스트 안에서 동작한다.\n2. 스크립트의 원시 컨텐츠나 소스코드에 접근 할 수가 없다.\n3. origin B 로 부터 온 css를 load 할수 있다. \n4. origin B 에 속해있는 css의 raw text에 접근 할 수 없다. \n5. iframe을 이용해서 origin B 페이지를 load 할 수 있다. \n6. iframe 안에 있는 origin B 페이지의 DOM에 접근 할 수 없다.\n7. origin B의 이미지를 load 할 수 있다. \n8. origin B로 부터 로드된 이미지의 bits에 접근할 수 없다.\n9. origin B로 부터 온 비디오를 재생할 수 있다.\n10. origin B에서로드 한 비디오의 이미지를 캡처 할 수 없습니다.\n\n이런 정책들이 브라우저마다 다르게 실행된다는 점이 개발자들이 주의를 해야할 부분이다. 다른 브라우져 사이에서 쿠키, 자바스크립트, DOM 접근에 관해서 Same-origin Policy의 정의가 다르게 되어있다. \n\n예를 들면 우리가 *http://www.example.com/test.html* 을 가지고 있다고 생각하고 이때 *http://www.example.com:81/contact.html* 에 접근하자고 생각해보자. IE의 경우 포트가 달라도 스키마와 도메인이 같기 때문에 접근이 가능하다 하지만 다른 모던 브라우저에서는 접근이 불가능 하다.\n\n때때로 이 Same-origin Policy의 엄격한 룰 때문에 베이스 도메인이 같은 사이트 사이에서 쉐어링할때 문제가 발생할 수 있다. 예를 들면  *login.example.com*, *games.example.com*, 그리고 *calendar.example.com* 이런 사이트를 지니고 있다면 어떻게 전체 도메인이 매칭이 안된 상태에서 커뮤니케이션을 할수 있을까.\n이럴때 javascript의 *document.domain* 이란 설정으로 조금 룰을 완화 시킬 수 있다.\n\n```javascript\ndocument.domain = \"example.com\";\n```\n\n이렇게 하면 브라우저에 모든것이 *login.example.com*, *games.example.com*, 그리고 *calendar.example.com* 을 포함하여 *example.com* 으로 같은 origin으로 고려된다고 말하는것과 같다. \n\n그러나 주의해야 할 것은 *login.example.com* 이 바로 *example.com* 의 DOM에 접근할수 있지 않다는 것이다. 이 접근을 허용하려면 *example.com* 안에\n*document.domain* 을 *example.com* 으로 셋팅해주어야 한다. \n\njavascript에서 document.domain 셋팅하는 것은 Same-origin Policy의 호스트이름 정책을 완화시킬수 있다. 하지만 포트나 스키마 제한은 남아있다. \n아래 표로 예시를 나타낸다.\n\n| URL                        | document.domain | iframe URL                  | document.domain | Result                            |\n|----------------------------|-----------------|-----------------------------|-----------------|-----------------------------------|\n| http://www.example.com     | example.com     | http://login.example.com    | example.com     | Accessible                        |\n| http://www.example.com     | example.com     | https://payment.example.com | example.com     | Not Accessible, protocol mismatch |\n| http://payment.example.com | example.com     | http://example.com          | Not Set         | Not accessible                    |\n| http://www.example.com     | example.com     | http://www.example.com      | Not Set         | Not accessible                    |\n\n여기서 중요한것은  *login.example.com* 을 *example2.com* 로 셋팅 할 수 없다는 것이다.\n\n### XmlHTTPRequest\n\nXmlHTTPRequest 도 동일하게 Same-origin Policy의 요구사항이 적용됩니다.\n\n- XmlHTTPRequest 호출은 다른 출처의 사이트로 보낼 수는 있지만 읽을수는 없습니다.\n- 요청 URL이 같은 출처라면 응답을 읽을 수 있습니다.\n- 사용자 정의 헤더는 동일한 출처에 대한 요청에만 추가 할 수 있다.\n\n조심해야하는 부분은 XmlHTTPRequest 의 호출은 다른 출처로 데이터를 보낼 수 있으므로 잠재적인 Cross Site Request Forgery 공격을 허용할 수 있다는 것이다.\n\n분명히 XmlHTTPRequest의 Same-origin 정책은 다른 출처의 리소스를 사용할 때 문제가 된다. \n\n### JSON Padding (JSONP)\n\nXmlHTTPRequest 객체를 사용해서 다른 출처에 있는 요청을 보낼수 있지만, 응답을 읽을수가 없다. 그래서 어떻게 해야할까? 어떻게 하면 비동기적으로 여러 다양한 데이터를 받을 수 있을까? \n\nSame-origin Policy 원리 하에 우리는 스크립트가 로드된 사이트의 컨텍스트 안에서 동작하는 것을 안다. 당연히 유효한 스크립트 파일이어야 한다는 것이다. 이런 기술을 이용해서 JSONP 가 사용됩니다.\n\n이는 Same-origin Policy를 우회할 수 있습니다.\n\n\n여기 다음과 같은 호출이 있다고 생각합시다. http://www.example.com/getAlbums?callback=foobarbaz\n응답으로는 다음과 같은 결과를 볼수 있습니다.\n\n```javascript\nfoobarbaz([{\"artist\": \"Michael Jackson\", \"album\": \"Black or White\"}{\"artist\": \"Beatles, The\", \"album\": \"Revolution\"}]);\n```\n\n잠시 분석해보자면 \n1. 우리는 *http://www.example.com/getAlbums*의 리소스를 요청했고 그리고 callback 이름을 쿼리 스트링으로 *foobarbaz* 라고 지정했습니다.\n2. 해당 리소스에서 JSON 결과가 리턴될때 그 결과를 함수 이름 *foobarbaz* 으로 감싸줘야 한다. 이는 쿼리 스트링으로 정의내린 이름이다.\n\n물론 이런 방법은 보안의 위험이 있고 반환 된 모든것이 신뢰할 수 있다고 가정해야 한다. 요청을 받은 사이트에서 반환되는 모든 코드가 우리의 브라우저가 띄운 우리 웹사이트의 컨텍스트에서 실행된다는 점을 잊지 말아야 한다. 또  전송시 발생할 수있는 조작을 방지하기 위해 보안 HTTPS 채널을 통해 요청하는 것도 중요하다.\n\n### XDomainRequest and JSONP vs. CORS\n\nJSONP의 한계는 JSONP로 작성된 도메인간 요청은 읽기전용의 한방향만 사용할수 있다는 것이다. 여전히 쓰기 요청에 대한 기회는 여전히 JSONP에 적용되었던 Same-origin Policy에 막\u001c혀있다.\n\n이때 MS는 독자적으로 IE8과 IE9에서 XDomainRequest 를 만들어냈고 Chrome, Firefox 등 기타 브라우저에서는 CORS(Cross-Origin Resource Sharing)이라는 인기있는 대체기능을 구현했다. MS도 나중에 IE10에선 CORS를 채택했다. \n\nCORS는 우리가 origin A 의 사이트가 origin B 사이트에 요청을 보내려고 할때 origin A 에는 *Origin* 이라는 사용자 정의 HTTP 헤더를 설정하여 요청에서 origin을 선언해야 한다. origin B의 사이트는 CORS 요청을 허용하는 출처를 정의하는 HTTP 헤더가 포함된 응답을 반환해야 한다. 이 헤더는 *Access-Control-Allow-Origin* 헤더 이다. \n\n이것을 사용하여 서브도메인도 허용할수 있다. 예를 들면 *sub.example.com*\n```\nAccess-Control-Allow-Origin: www.example.com\n```\n인터넷에 있는 모든 도메인에게 허락할수도 있다.\n```\nAccess-Control-Allow-Origin: *\n```\n\n## Cross-Origin Resource Sharing (CORS) in Detail\n\nCORS 요청은 2가지 타입이 있다. Simple Request와 Preflight 이다. 대부분의 일반 CORS 요청은 일반적인 HTTP 헤더 및 작업으로 구성된 단순 요청 범주에 속합니다. 그러나 프리 플라이트 요청은 단순 요청의 일반적인 신뢰할 수있는 범위를 벗어나는 비정형 성으로 인해 서버에 대한 추가 유효성 검사가 필요하다.\n\n### Simple Request\n\n만약 요청 method가 GET, POST, or HEAD 그리고 *Content-Type*에 의해 셋팅된 message type이 *application/x-www-form-urlencoded,* *multipart/form-data*, *text/plain* 이라면, 이 요청은 CORS Simple 요청으로 간주된다. 그리고 다이렉트로 서버에 전송된다. \n서버는 반환 된 *Access-Control-Allow-Origin* HTTP 헤더에 의해 CORS 요청을 수락하는지 여부를 나타낸다. \n만약 서버가 승인하면, 응답이 클라이언트에 의해 처리 될것이다. \n또한 Accept (허용 할 내용 유형), Accept-Language (브라우저에서 허용하는 언어) 및 Content-Language (요청 언어)와 같이 CORS 요청에 직접 적용되는 요청에서 보낼 수있는 몇 가지 추가 HTTP 헤더가 있다.\n\n우리 페이지 http://www.acceptmeplease.com 에서 core.example.com 으로 요청을 보내는 시도이다.\n요청 헤더에 있는 Host는 요청의 대상이 되는 서버의 호스트 명과 포트를 준다.\n\n요청\n```\nGET / HTTP/1.1\nHost: cors.example.com\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en,en-US;q=0.5\nOrigin: http://www.acceptmeplease.com\nConnection: keep-alive\n```\n\n서버응답\n```\nHTTP/1.1 200 OK\nDate: Sun, 24 Apr 2016 12:43:39 GMT\nServer: Apache\nAccess-Control-Allow-Origin: http://www.acceptmeplease.com\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: application/xml\nContent-Length: 423\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n...\n```\n\n요청시에 우리는 http://www.acceptmeplease.com 사이트에서 cors.example.com에 대한 우리의 CORS 단순 요청을 수행하며, 또한 이를(우리의 사이트 url을) 우리의 origin 지정한다. 서버는 우리의 origin을 승인하는 것에 응답한다. 따라서 브라우저는 Same-origin Policy의 도메인 제한을 완화한 채 요청을 계속할 수 있게 된다.\n\n### Preflight Request\n\nSimple Request에 해당되지 않는 것들에 대해서 Preflight Request를 진행한다. 이것이 의미하는 것은 *GET, POST, or HEAD* 메서드 요청이 아니고 또는 요청이 *POST* 이지만 *Content-type* 이 *application/x-www-form-urlencoded,* *multipart/form-data*, *text/plain* 이 중 하나가 아니고, 또는 만약 커스텀 HTTP 헤더에 추가가 되어있다면 이 요청은 서버에 처음으로 유효성을 받아봐야 한다. \n실제 CORS 전에 서버에게 보내지게 되며 브라우저는 *pre-flight check*을 *OPTIONS* 메서드로 요청을 보내게 된다. 이것은 Simple Request 보다 2번의 HTTP 호출을 하기 때문에 비용이 드는 행위이다. 하지만 필요한 작업이다.\n\n이해를 돕기 위한 CORS Preflight Request and server response 예제이다. POST 메서드를 사용하지만 추가적인 *X-Token-ID* 와 *Content-Type*을 *application/xml* 로 지정했다. 그래서 CORS Preflight Request을 진행할 것이다.\n\n< 요청 헤더 >\n```\nOPTIONS /resources/post-here/ HTTP/1.1\nHost: cors.example.com\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nConnection: keep-alive\n* Origin: http://www.acceptmeplase.com *\n* Access-Control-Request-Method: POST *\n* Access-Control-Request-Headers: X-TOKEN-ID *\n```\n\n여기서 먼저 OPTIONS 메서드로 요청을 보내게 된다. 이것은 먼저 서버에게 보내진 HTTP Header가 수용가능한지 요청을 보내는 것이다. \n다음으로는 우리의 Origin 을 설정한다. \n그리고 2가지의 헤더를 더 정의내리는데 *Access-Control-Request-Method*, *Access-Control-Request-Headers* 이다. 이것들은 브라우저의 의도를 전달하는데 중요하다. POST 메서드와 추가적인 HTTP header 가 있음을 알린다.\n\n\n< OPTIONS 메서드에 대한 서버 응답 >\n```\nHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache\n* Access-Control-Allow-Origin: http://www.acceptmeplease.com *\n* Access-Control-Allow-Methods: POST, GET, OPTIONS *\n* Access-Control-Allow-Headers: X-TOKEN-ID *\n* Access-Control-Max-Age: 86400 *\nVary: Accept-Encoding, Origin\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n```\n\n- Access-Control-Allow-Methods – 이것들은 브라우저가 보낼 수있는 허용 된 요청 방법입니다.\n- Access-Control-Allow-Headers – 이것은 브라우저가 전송할 수있는 승인 된 추가 HTTP 헤더입니다.\n- Access-Control-Max-Age – 이 HTTP 헤더가 응답에 설정되면 서버는 브라우저가 동일한 종류의 요청에 대해 이 OPTIONS 결과를 캐시하기를 원합니다. 이를 통해 브라우저는 각각의 요청 전에 OPTIONS 요청을하지 않고도이 최대 연령 설정 내의 리소스에 비슷한 요청을 할 수 있습니다.\n\n주의 해야 할점은 *Access-Control-Max-Age* 이 값이 86400초 또는 24시간으로 설정되어있습니다. 하지만 각 브라우저는 이 필드의 최대 값을 정의하고 있기에\n브라우저의 최대 보존 기간을 초과하면 이 값을 무시하고 최대 허용 값을 사용하게 됩니다. 예를 들어 크롬은 최대 10분 입니다.\n\n\n### Cookies\n\n우리는 지금까지 다양한 HTTP header와 함께 CORS를 보여주었다. 하지만 *Cookie* HTTP header는 공유할 수가 없다. 디폴트로 브라우저에서 사용되는 인증서 (including cookies, authentications, and certificates)들은 CORS 요청과 함께 전송되지 않는다. Simple 또는 Preflight 둘다. \nIE8 과 IE9 에서 사용하는 XDomainRequest도 마찬가지 이다. 어떤 상황에서도 이러한 자격 증명 데이터를 보낼 수 없습니다.\n\n만약 우리가 접근 가능한 origin 한에서 쿠키 데이터를 전송하고 싶다면, 우리는 간단하게 *Cookie* HTTP header를 CORS 요청에 사용함으로써 쿠키 컨텐츠를 전송할수 있다. (도메인, 만료등의 추가정보 없이) 이것을 Preflight 요청인 OPTIONS 요청에 추가할수 있다. 하지만 필수는 아니다. 응답이 왔을때 서버는 반드시 이 인증의 요청에 대한 받아드리는것과 동의하는것을 *Access-Control-Allow-Credentials* HTTP header로 알려아 한다. 'true' 값으로. \n만약 HTTP header에 이 값을 못받았다면 브라우저는 전체 요청을 실패로 간주하게 된다.\n\n### Implementations\n\n클라이언트 사이드에서의 CORS 요청 실행 예제 이다.\n\n```javascript\n// Declare the XMLHttpRequest object\nvar invocation = new XMLHttpRequest();\n\n// We wish to open a POST method request\ninvocation.open('POST', 'http://cors.example.com/sendData', true);\n\n// If we set this option, then in-browser credentials (cookies,\n// authentication, certificates) will be sent along with the\n// request\ninvocation.withCredentials = true;\n\n// If we set the following two headers, as described previously,\n// this will automatically become a CORS Preflight Request, and\n// an OPTIONS method pre-flight check request will be done in\n// the background, unless a matching one has already been done\n// and was within the site's (and browser's) maximum age setting\ninvocation.setRequestHeader('X-TOKEN-ID', 'aabbccddeeff00112233');\ninvocation.setRequestHeader('Content-Type', 'application/xml');\n\n// When the response is returned from the server, we must\n// process it via a callback function\ninvocation.onreadystatechange = function(){ … };\n\n// Send the POST content and initiate the request\ninvocation.send('…');\n\n```\n\n## Final\n\n동일 출신 정책은 월드 와이드 웹의 끊임없이 진화하는 구성입니다. 쿠키의 진화와 함께이를 볼 수 있습니다. 쿠키는 DOM과 JavaScript보다 먼저 만들어 졌으므로 나중에 동일한 동일 출처 정책이 적용되었습니다. 쿠키와 함께 스키마와 포트를 고려하지 않는 일반적인 Same-Origin Policy와는 대조적으로 볼 수 있습니다. JavaScript가 개발 된 후에는 쿠키가 HTTP 헤더를 통해서만 사용할 수 있고 JavaScript 네임 스페이스에서는 사용할 수 없다고 간주되는 httpOnly 플래그가 추가되었습니다. 나중에 TLS 전용 범위 내의 쿠키 문제를 해결하기 위해 추가 된 secureOnly 플래그가 있었습니다.\n\n동일 출처 정책은 클라이언트 측 웹 보안의 중심에 있지만 광범위하고 매우 다양하며 브라우저에서 브라우저로, 기술 구현간에 중요한 세부 사항이 다릅니다. 이해하는 것이 중요한 개념이지만 더 중요한 것은 차이점과 함정을 똑같이 고려해야한다는 것입니다. 개발자 (실제로 보안 엔지니어)가 자신의 요구에 맞는 Same-Origin Policy를 이해하고 적절하게 구현할 때 실제로는 더 풍부한 웹을 만듭니다.\n\n## DNS Rebinding\n\nSame-origin Policy의 기법을 우회할수 있는 방법중 하나로 XMLHttpRequest를 통해서 localhost 또는 다른 도메인 주소의 요청을 전송할수 없으나 이 방법으로 우회할수 있다. 보통 공격해서 정보를 탈취하는데 쓰일수 있다.\n\n간단한 설명은 다음과 같다.\n\n- 공격자는 attack.com (ip: 1.1.1.1) 이라는 도메인을 등록해둔다. 그리고 그 사이트요청에 공격자가 컨트롤 가능한 DNS 서버가 응답하게 만든다.\n- 공격자는 DNS 서버의 TTL(TIME TO LIVE) 설정을 짧게 설정한다. 이것은 응답 캐싱을 막기 위해서이다.\n- 마지막으로 attack.com 서버를 시작한다.\n- 이때 일반 사용자는 본인만 접속할수 있는 custom.com (ip 2.2.2.2) 사이트가 있다고 하자.\n- 일반 사용자는 공격자가 만든 웹페이지 (attack.com)에 접속하게 된다. 해당 웹페이지에는 사용자 웹 브라우저에서 돌아가는 자바스크립트를 포함하고 있다.\n- 이 스크립트 코드는 같은 도메인인 attack.com 의 attack.com/secret.html 자원을 추가로 다운로드 하도록 만든다.\n- 이때, 브라우저는 다시 DNS에게 attack.com 도메인에 대한 요청을 보내게 된다. ( 이유는 TTL을 짧게 설정했기 때문에. )\n- 하지만 공격자의 DNS 응답은 새로운 IP를 응답해준다. 여기서 IP는 내가 탈취하고 싶은 IP가 되겠다. ( custom.com 의 IP ,localhost..등등 )\n- 그 결과로 사용자는 원하지도 않게 attack.com/secret.html 대신에 custom.com/secret.html 의 자원을 로드하게 된다.\n- 로드 된 후에 응답된 데이터를 image.src 같은 곳에 쿼리 스트링으로 넣어서 필요한 데이터를 공격자 서버로 전송시켜 버린다.\n- 이게 바로 Same-origin Policy가 bypass 당한것이다.\n\n이러한 문제를 막는 방법으로는 'Host' 헤더가 다른 허용하는 호스트 네임을 지니고 있는지 확인하는 것이다.\n서버는 'Host' 헤더에 예기치 않은 호스트 이름이 포함되어 있다면 서버는 요청을 거부해야한다. 다른말로 말하면 'Host'헤더에 대해 적절한 white-listing ('안전'이 증명된 것만을 허용)가 구현되어야합니다.\n\n\n## 출처 \n\n- [https://savni.tistory.com/entry/DNS-Rebinding%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transmission-%EC%B7%A8%EC%95%BD%EC%A0%90-%EB%B6%84%EC%84%9D](https://savni.tistory.com/entry/DNS-Rebinding%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transmission-%EC%B7%A8%EC%95%BD%EC%A0%90-%EB%B6%84%EC%84%9D)\n- [https://www.netsparker.com/whitepaper-same-origin-policy/#SameOriginPolicyinDetail](https://www.netsparker.com/whitepaper-same-origin-policy/#SameOriginPolicyinDetail)\n- [https://blog.gypsyengineer.com/en/security/examples-of-dns-rebinding-attacks.html](https://blog.gypsyengineer.com/en/security/examples-of-dns-rebinding-attacks.html)\n- [https://github.com/mpgn/ByP-SOP](https://github.com/mpgn/ByP-SOP)\n- [https://twitter.com/SpiderSec/status/1219865409895026689/photo/1](https://twitter.com/SpiderSec/status/1219865409895026689/photo/1)\n- [https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/)\n- [https://opentutorials.org/course/3387/21744](https://opentutorials.org/course/3387/21744)\n- [https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies)\n\n","excerpt":"cookie 쿠키는 사용자 속성을 기억하는 데 사용되는 작은 텍스트 파일이다. 서버에서  라고 헤더에 셋팅을 하게 되면 브라우저는 해당 쿠키를 로 저장하게 된다.  쿠키 중에는 2가지 쿠키가 존재한다. 웹브라우저를 끄면 사라지는 휘발성 쿠키를 . 웹…","fields":{"slug":"/sop-and-cors-dnsRebinding.md/"},"frontmatter":{"date":"Feb 27, 2019","title":"sop와 cors 그리고 DNS Rebinding","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n* RxJS 의 특징을 알아보고 공부하자.\n* RxJS 의 공홈을 독파해보자.\n\n## definition\n\n* RxJS 는 Observables 을 이용한 반응형 프로그래밍을 할수 있게 도와주는 라이브러리 입니다. 비동기와 콜백 베이스 코드를 observable sequence 들을 이용해서 좀 더 쉽게 구성할수 있게 만들어준다.\n* RxJS 는 Observable 이라는 코어 타입과 몇몇 서브 타입( Observer, Schedulers, Subjects ) 그리고 Array 의 함수에서 영감을 받은 operator 들이 있다. 이 operator 들은 비동기 이벤트를 collection 들 처럼 처리할 수 있습니다.\n* RxJS 이벤트의 시퀀스를 관리하기 위한 방법으로는 Observer pattern 과 Iterator pattern 과 collection 과 함께하는 functional programming 를 합쳐 놓은 것입니다.\n\n## Essential Concepts\n\n* Observable : 미래 값 또는 이벤트들의 호출 가능한 컬렉션의 아이디어를 나타낸다. Observable 은 모든 operators 를 가지고, 이들을 구독할수 있다.\n* Observer : Observer 는 컬렉션의 콜백이다. 이 콜백은 Observable 이 전달한 값을 듣는 방법을 알고 있습니다. Observer 는 next, error, complete 메서드를 지닌다.\n* Subscription : Observerable 의 실행을 뜻하며 대게 실행을 취소하는데 유용하다.\n* Operators : Operation 은 순수함수이다. 컬렉션 들을 functional programming 스타일로 다루는것을 가능하게 한다. 마치 map, filter, concat, reduce 등등\n* Subject : Subject 는 EventEmitter 와 같다. 값 또는 이벤트를 여러 관찰자에게 멀티 캐스팅 하는 유일한 방법이다. 기본적인 Subject 는 subscribe 한 뒤( observer 생성 ) next 메서드로 실행한 값(emit)만 받아올수 있다. 즉, subscribe 이전에 next 호출에 대해서는 구독을 할 수 없다.\n  Subject 는 observable 이고 observer 다. 그래서 subject 는 observable 과 많은 observer 들 사이에서 bridge/proxy 형태로 행동할수 있다. 이 행동은 다수의 observer 들에게 같은 observable 실행을 공유 할수가 있다.\n  * BehaviorSubject : 기본 Subject 와 다르게 subscribe 가 만들어지기(observer) 바로 직전 next 호출까지 (emit) 받아올수 있다.\n  * ReplaySubject(number, \\[time\\]) : subscribe 가 만들어지기 (observer) n 번째 전 next 호출까지 받아올수 있다. 두번째 인자는 옵셔널 하게 시간을 줄 수 있는데 subscribe 가 만들어지기 (observer) time 시간전에 발생된 next 호출 (emit) 까지 받아 올 수 있다.\n  * AsyncSubject : 가장 마지막 emit 한 value 의 값을 complete 한 메서드가 호출 되었을때만 가져오게 된다. 만약 complete() 메서드가 호출 되지 않는다면 아무것도 observer 는 받아오지 않는다.\n* Schedulers : Schedulers 들은 중앙의 dispatcher 들이다. 이 디스패처들은 concurrency 를 컨트롤 하는 녀석들인데 여기서 concurrency 를 컨트롤 한다는 것은 시분할을 조절한다는 뜻이다. 이것은 계산이 언제 일어나는지를 조정할수 있게 합니다. 예를 들면 setTimeout 또는 requestAnimationFrame 그 외의 것들입니다.\n\n**Observables = PodCasts**\n\n- observers subscribe to observables\n- listeners subscribe to podcasts\n\n참고로 PodCasts는 Hot observables 이다. Hot observable 이란 observable 생성과 동시에 이벤트를 방출하기 시작한다. 이후에 subscribe 되는 시점과는 상관없이 중간에 등록된 옵저버들에게는 이벤트가 중간부터 전송을 해주는 방식입니다. \n반대 방식은 Cold observable 이 있습니다.\n쉽게는 유투브의 실시간 방송과, 일반 VOD 방송 개념으로 이해하면 좋겠습니다.\n\n아주 간단한 Observable 을 만든다면 아래와 같을 것입니다.\n\n```javascript\nclass Observable {\n  constructor(functionThatThrowsValues) {\n    this._functionThatThrowsValues = functionThatThrowsValues\n  }\n  subscribe(observer) {\n    return this._functionThatThrowsValues(observer)\n  }\n}\n\n// 실행문\nlet fakeAsyncData$ = new Observable(observer => {\n  setTimeout(() => {\n    observer.next('New data is coming')\n    observer.complete()\n  }, 2000)\n})\n\nfakeAsyncData$.subscribe({\n  next(val) {\n    console.log(val)\n  },\n  error(e) {\n    console.log(e)\n  },\n  complete() {\n    console.log('complete')\n  },\n})\n```\n\n여기서 중요한 것은 Observable 에 넘기는 함수`(functionThatThrowsValues)`는 반드시 `구독(subscribe)` 하는 녀석이 있어서 실행된다는 것입니다.\n\n또한 Observable 에서 observer 들을 모두 배열이나 다른 데이터 구조로 지니고 있는 것이 아니라 구독할때 observer 자신을 넘긴다는 것입니다. `(subscribe(observer))` 그리고 나서 값이 새로 생성되는 함수에 observer 를 넘겨서 실행하면 `(this._functionThatThrowsValues(observer))` 해당 함수에서 동기 또는 비동기 적으로라도 observer 에 next 메서드를 호출해서 새로운 값을 push 해줄 수 있습니다.\n\n`subscribe` 메서드로 여러 observer 들을 등록해도 모두 push 해줄 수 있습니다.\n\n요약하면 데이터를 발생시키는 함수를 등록시키고 데이터가 발생되면 약속된 `observer`의 `next` 메서드 인자로 넘겨줍니다. 그 이후에 `subscribe` 메서드로 `observer` (관찰하고 싶은 녀석들) 을 등록 시키면 데이터를 발생 시키는 함수를 실행 시킵니다.\n\n아래 코드는 조금 더 진화된 코드\n\n```javascript\nclass Observable {\n\n  constructor(functionThatThrowsValues) {\n    this._functionThatThrowsValues = functionThatThrowsValues;\n  }\n\n  subscribe(next, error, complete) {\n    if (typeof next === \"function\") {\n      return this._functionThatThrowsValues({\n        next,\n        error: error || () => {},\n        complete: complete || () => {}\n      });\n    }\n    else {\n      return this._functionThatThrowsValues(next);\n    }\n\n  }\n\n\n  map(projectionFunction) {\n      return new Observable(observer => {\n        return this.subscribe({\n           next(val) { observer.next(projectionFunction(val)) },\n           error(e) { observer.error(e) } ,\n           complete() { observer.complete() }\n        });\n      });\n  }\n\n  mergeMap(anotherFunctionThatThrowsValues) {\n    return new Observable(observer => {\n      return this.subscribe({\n        next(val) {\n          anotherFunctionThatThrowsValues(val).subscribe({\n            next(val) {observer.next(val)},\n            error(e) { observer.error(e) } ,\n            complete() { observer.complete() }\n          });\n        },\n        error(e) { observer.error(e) } ,\n        complete() { observer.complete() }\n      });\n    });\n  }\n\n  static fromArray(array) {\n    return new Observable(observer => {\n      array.forEach(val => observer.next(val));\n      observer.complete();\n    });\n  }\n\n  static fromEvent(element, event) {\n    return new Observable(observer => {\n      const handler = (e) => observer.next(e);\n      element.addEventListener(event, handler);\n      return () => {\n        element.removeEventListener(event, handler);\n      };\n    });\n  }\n\n  static fromPromise(promise) {\n    return new Observable(observer => {\n      promise.then(val => {\n        observer.next(val); observer.complete();\n      })\n      .catch(e => {\n        observer.error(val); observer.complete();\n      });\n    })\n  }\n}\n```\n\n## Examples\n\n### Purity\n\nRxJS 를 파워풀하게 만드는것은 pure function 을 사용해서 value 를 만드는게 가능하다는 것입니다. 이것은 실수를 줄여주는 코드를 만들게 해줍니다.\n\n보통 impure function 을 사용하게 되면 다른 코드 조각들이 당신의 state 를 더럽히게 됩니다.\n\n```javascript\nvar count = 0\nvar button = document.querySelector('button')\nbutton.addEventListener('click', () => console.log(`Clicked ${++count} times`))\n```\n\nRxJS 를 사용하면 state 를 독립시킬수 있다.\n\n```javascript\nconst { fromEvent } = rxjs\nconst { scan } = rxjs.operators\n\nconst button = document.querySelector('button')\nfromEvent(button, 'click')\n  .pipe(scan(count => count + 1, 0))\n  .subscribe(count => console.log(`Clicked ${count} times`))\n```\n\n여기서 scan operator 는 array 의 reduce 처럼 움직입니다.\n\n### Flow\n\nRxJS 는 모든 범위의 operator 를 가지고 있습니다. 이것은 observable 을 통해 이벤트 흐름을 제어하는 방법을 도와줍니다.\n\n플래인 자바스크립트\n\n```javascript\nvar count = 0\nvar rate = 1000\nvar lastClick = Date.now() - rate\nvar button = document.querySelector('button')\nbutton.addEventListener('click', () => {\n  if (Date.now() - lastClick >= rate) {\n    console.log(`Clicked ${++count} times`)\n    lastClick = Date.now()\n  }\n})\n```\n\nRxJS 를 이용\n\n```javascript\nconst { fromEvent } = rxjs\nconst { throttleTime, scan } = rxjs.operators\n\nconst button = document.querySelector('button')\nfromEvent(button, 'click')\n  .pipe(throttleTime(1000), scan(count => count + 1, 0))\n  .subscribe(count => console.log(`Clicked ${count} times`))\n```\n\n다른 flow 를 컨트롤 하는 operator 에는 filter, delay, debounceTime, take, takeUntil, distinct, distinctUntilChanged 등이 있습니다.\n\n### Values\n\nvalue 를 observable 로 전달하면서 변화를 시킬수 있습니다.\n\n```javascript\nlet count = 0\nconst rate = 1000\nlet lastClick = Date.now() - rate\nconst button = document.querySelector('button')\nbutton.addEventListener('click', event => {\n  if (Date.now() - lastClick >= rate) {\n    count += event.clientX\n    console.log(count)\n    lastClick = Date.now()\n  }\n})\n```\n\n```javascript\nconst { fromEvent } = rxjs\nconst { throttleTime, map, scan } = rxjs.operators\n\nconst button = document.querySelector('button')\nfromEvent(button, 'click')\n  .pipe(\n    throttleTime(1000),\n    map(event => event.clientX).scan((count, clientX) => count + clientX, 0)\n  )\n  .subscribe(count => console.log(count))\n```\n\nvalue 를 만드는 operator 에는 pluck, pairwise, sample 들이 있습니다.\n\n## Observable\n\nObservable 은 다양한 값을 지닌 lazy Push collections 입니다.\n\n|      | SINGLE   | MULTIPLE   |\n| ---- | -------- | ---------- |\n| Pull | Function | Iterator   |\n| Push | Promise  | Observable |\n\n보통 우리는 data 를 생성하는 쪽(data source)과 data 를 받는 쪽(data receiver)으로 생각할 수 있습니다. 여기서 push 라 함은 data 생성하는 쪽(data source)이 생성한 data 를 data 받는 쪽(data receiver)에게 전달할 때를 결정합니다. 반대로 pull 이라 함은 data 받는 쪽(data receiver)에서 data 생성하는 곳(data source)으로 부터 받을 때를 결정합니다.\n\n가장 유명한 push 행동 방식은 eventListener 를 DOM element 에 적용하는 방식입니다. 여기서 handler 는 data 를 받는 쪽(data receiver) 유저가 DOM 에 인터렉션을 하는건 data 생성자(data source)에 해당한다. 따라서 여기서는 data 생성자가 data 전달을 결정합니다.\n\n반대로 pull 방식은 대부분 사용하는 javascript 의 function 입니다.\n모든 function 은 pull system 이다. 어떤 코드가 function 을 호출 했다는 것은 function 으로 부터 data 를 요청 했다는 것입니다. 그래서 data 받는 쪽이(data receiver) data 생성자로부터(data source) data 를 당겼다는 의미에서 pull 행동입니다.\n\n또한 function 은 한가지 값만을 위한 pull system 이 아닙니다. ES6 의 generator function 은 return multiple values 를 할수 있습니다. 각각 시간마다 data receiver 는 next 메서드를 호출하면 data source 는 매번 다른 값을 yield 시키고 receiver 에게 전달해줍니다.\n\n\n## Higher-Order RxJs Mapping Operator (switchMap, mergeMap, concatMap, exhaustMap)\n\n제일먼저 mapping operation 을 이해하기 전에 기본 로직인 concat, merge, switch and exhaust 전략부터 살펴볼것입니다.\n\n끝으로는 어떻게 mapping operation 이 동작하고 언제 사용하고 왜 사용하는 이유까지 알게 될것입니다.\n\n### RxJs Map Operator\n\n이름에서 알수 있듯이 그것은 무엇인가를 mapping 하고 있는 것입니다. 하지만 정확히 무엇을 mapping 하고 있는 것일까요?\n\n![https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/01-rxjs-map.png](https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/01-rxjs-map.png)\n\nmap 연산자를 사용하면 입력 스트림 (값 1, 2, 3)을 가져 와서 파생 매핑 된 출력 스트림 (값 10, 20, 30)을 만들 수 있습니다.\n\n맨 아래의 출력 스트림 값은 입력 스트림의 값을 가져 와서 함수를 적용하여 얻습니다. 이 함수는 단순히 값에 10을 곱합니다.\n따라서 map 연산자는 입력 관측 값의 값을 매핑하는 것입니다. \n\n그래서 map operator 는 input observable 의 값들 모두를 매핑해주는 것입니다.\n\n```javascript\nconst http$: Observable<Course[]> = this.http.get('/api/courses')\n\nhttp$\n  .pipe(\n    tap(() => console.log('HTTP request executed')),\n    map(res => Object.values(res['payload']))\n  )\n  .subscribe(courses => console.log('courses', courses))\n```\n\n위 예제를 봅시다. 우리는 하나의 HTTP observable 을 만들었습니다. 이것은 backend 에 요청을 보내고 그 답을 구독하게 됩니다. \n이 observable 은 backend 의 응답이 오면 값을 방출하게 됩니다.\n\n이 경우, 응답은 data 의 payload 프로퍼티에 감싸여져서 내려옵니다. 이 값을 얻기 위해서 우린 RxJs map operator 를 사용합니다. mapping function 은 JSON response payload 에 매핑하고 그 값을 추출합니다.\n\n아래는 간단한 map 함수의 매커니즘입니다.\n\n```javascript\nfakeAsyncData$.map(val => `New value ${val}`).subscribe({\n   next(val) { console.log(val) } ,\n   error(e) { console.log(e) } ,\n   complete() { console.log(‘complete’) }\n});\n\nmap(projectionFunction) {\n     return new Observable(observer => {\n       return this.subscribe({ // this는 fakeAsyncData$ 의 객체이다. \n          next(val) { observer.next( projectionFunction(val)) },\n          error(e) { observer.error(e) } ,\n          complete() { observer.complete() }\n        });\n     });\n  }\n```\n\n우리가 `map` 메서드를 호출하게 되면 `new Observable`이 리턴됩니다. 이 Observable 에는 현재 source 코드에 대한 subscribes 가 들어있는데 이때 source 에 해당하는 것이 `fakeAsyncData$`가 되겠습니다. \n\nsource 코드에서 새로운 값이 던져지게 되면 map 메서드가 받게 되고, 그 값을 `projectionFunction` 에 실어서 실행하게 됩니다. \n그리곤 map 메서드에서 리턴했던 Observable 을 구독하고 있는 우리에게 그 `projectionFunction` 실행하고 리턴된 값이 전해지게 된다. (우리는 map Observable 을 구독하고 있어야 한다는 점을 명심하자.)\n\n### What is Higher-Order Observable Mappping?\n\nhigher-order mapping 은 일반 plain value 1 을 10 으로 맵핑하는 대신에 값을 Observable 로 mapping 합니다. \n그 observable 을 higher-order Observable 이라고 합니다. 이 higher-order Observable 은 다른 Observable 과 같은 마찬가지 이지만 그것이 방출하는 값들은 일반 plain 값이 아닌 우리가 별도로 구독할 수 있는 Observable 들이라는 점이 다른점입니다.\n\n쉽게 말해 아래와 같은 코드가 있습니다.\n\n```javascript\nconst click$ = Observable.fromEvent(button, 'click')\nconst interval$ = Observable.interval(1000)\n\nconst clicksToInterval$ = click$.map(event => {\n  return interval$ // observable을 mapping\n})\n\nclicksToInterval$.subscribe(intervalObservable =>\n  console.log(intervalObservable)\n)\n```\n\n여기서 `clicksToInterval$`은 higher-order Observable 입니다. 우리가 이 Observable 을 구독하는 순간 `click$` Observable 은 `interval$` observable 과 함께 Observer의 next()를 호출 할것입니다. 그렇게 되면 클릭시 일반적인 map 에서 보였던 plain 한 값이 보이지 않고 실행되지 않은 `interval observable` 객체가 보일것입니다.\n\n그 이유는 `interval$` observable 을 구독하지 않았기 때문입니다. observable 들은 lazy 입니다. 만약 observable 이 지닌 값들을 가져오고 싶다면 반듯이 `subscribe()` 해야합니다.\n\n```javascript\nclicksToInterval$.subscribe(intervalObservable$ => {\n  intervalObservable$.subscribe(num => {\n    console.log(num)\n  })\n})\n```\n\n위 처럼 하면 다시 값이 보일것입니다. 이게 가장 자연스럽게 이해할수있는 higer order observable 입니다.\n\n특히 `mergeAll()` 메서드는 higher order observable 의 이해를 돕기 위한 좋은 예제입니다.\n\n```javascript\nconst click$ = Observable.fromEvent(button, ‘click’);\nconst interval$ = Observable.interval(1000);\n\nconst observable$ = click$.map(event => {\n   return interval$;\n});\n\n\n// mergeAll() 메서드 사용\nobservable$.mergeAll().subscribe(num => console.log(num));\n```\n\n`mergeAll()`의 경우에는 inner observable(여기서 `interval$`에 해당함)을 받아다가 그것을 구독하고 해당 값을 `subscribe`로 등록한 `observer` 에게 전달시켜 줍니다. 즉, inner observable 이 emits 될때 그 값을 outer observable와 merging 해서 나에게 알려줍니다. \n\n위의 경우에서는 source observable(또는 outer observable) 은 `click$` observable 이고 inner observable 은 `interval$` 입니다.\n그래서 `mergeMap()`은 단지 `map() + mergeAll()` 입니다.\n\n또한 위 코드에서 `observable$` 을 그냥 subscribe를 했다면 `num`에는 `observable`(`interval$`) 객체가 콘솔에 찍힐것입니다. \n`map()` 코드는 어떠한 이벤트 스트림에서 값을 받아서 즉, 신호로 받아들여서 새로운 값 또는 `observable` 객체로 맵핑할 때 사용되고 매 값이 나올때마다 output으로 `observable` 이 나올 것입니다. \n\n![https://rxjs-dev.firebaseapp.com/assets/images/marble-diagrams/mergeAll.png](https://rxjs-dev.firebaseapp.com/assets/images/marble-diagrams/mergeAll.png)\n\noutput으로 `observable` 들을 하나의 새로운 `observable`로 만드는 작업을 `mergeAll()`이 진행합니다.\n`mergeAll()`의 경우에는 모든 이벤트 스트림을 머지해서 마지막으로 `subscribe`로 등록한 `observer`에게 알려준다고 생각하면 될 것입니다.\n\n위 코드를 `mergeMap()`으로 짠다면 아래와 같습니다.\n\n```javascript\nconst click$ = Observable.fromEvent(button, ‘click’);\nconst interval$ = Observable.interval(1000);\n\nconst observable$ = click$.mergeMap(event => { \n   return interval$;\n});\n\nobservable$.subscribe(num => console.log(num));\n```\n\n### why Higher-Order Observables?\n\n만약 폼 데이터를 중간에 조금씩 저장해서 만일에 잘못된 새로고침에 전체 양식의 손실을 방지하기 위한 작업이 필요하다고 생각해봅시다.\n폼의 value 들이 변화가 생기고 일정시간 가장 마지막 변화를 감지하면 그 값들을 가지고 백엔드에다가 저장시킨다고 해봅시다.\n\n폼 값들을 저장하는 수행을 함수형으로 짜기 위해선 값을 받고 그 이후에 HTTP observable 을 생성해야한다. 그리고 그 결과 값을 구독해야 합니다.\n\n이 수행을 매뉴얼하게 짠다고 하면 아래와 같은 그림이 될 것입니다.\n\n```javascript\nthis.form.valueChanges\n    .subscribe(\n       formValue => {\n\n           const httpPost$ =\n                 this.http.put(`/api/course/${courseId}`, formValue);\n\n           httpPost$.subscribe(\n               res => ... handle successful save ...\n               err => ... handle save error ...\n           );\n\n       }\n    );\n```\n\n하지만 위 그럼인 중첩된 subscribe 인 안티패턴에 속하게 됩니다.\n\n단점으로는 첫번째로는 callback hell 에 빠질수 있고, 두번째로는 각각의 observable 의 subsciption 처리를 스스로가 해야한다는 점이 있습니다.\n\n### Avoiding nested subscriptions\n\n만약 위 상황에서 여러 폼 값을 빠르게 연속적으로 내보내고 저장 작업을 완료하는데 시간이 걸리는 경우 어떻게 되는지 생각해봅시다.\n\n* 우리는 다른 save request 하기 전에 하나의 save request 가 완료되기를 기다리고 싶은가요? (concat)\n* 우리는 병렬로 save 들을 하고 싶은가요? (merge)\n* 우리는 새로운 save request 가 나타나면 진행했던것을 취소하고 싶은가요? (switch)\n* 우리는 이미 진행중인 save request 동안 새로운 save request 에 대해서 무시하고 싶은가요? (exhaust)\n\n위 처럼 중첩된 상황이라면 우리는 실제로 병렬로 save operation 을 발생시킵니다. 이것은 사실 우리가 원하는 방식은 아닙니다. 왜냐하면 백엔드에서 순차적으로 저장한다는 보장이 없기 때문이고, 마지막 유효한 값이 실제로 백엔드에 저장되었다고 볼수 없기 때문입니다. 이 방법을 higher-order observable 로 피해봅시다.\n\n### Understanding Observable Concatenation\n\n위 예제에서 순차적으로 저장을 하기 위해선 우린 새로운 Observable concatenation 개념을 소개합니다.\n\n```javascript\nconst series1$ = of('a', 'b')\n\nconst series2$ = of('x', 'y')\n\nconst result$ = concat(series1$, series2$)\n\nresult$.subscribe(console.log)\n\n// 결과\n// a\n// b\n// x\n// y\n```\n\n여기서 `of()` 함수는 `of()`로 전달된 값을 방출하고 그 이후에 값을 모두 방출하면 complete 되는 Observable 을 생성합니다.\n\n![https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/01-rxjs-concat.png](https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/01-rxjs-concat.png)\n\n`concat()` 은 처음인자로 들어온 `series1$` 을 처음으로 구독하고 두번째 인자인 `series2$`는 구독하지 않습니다. ( 이것이 중요한 이해 입니다. )\n`series1$`이 값을 방출하면 바로 `result$` Observable output 에 반영된다고 이때 `series2$`는 값을 방출하지 않습니다. 왜냐하면 아직 구독하지 않기 때문입니다. 이후에 `series1$` 이 complete 가 되면 `series2$`를 구독하기 시작합니다. 그럼 `series2$` 값이 output 으로 반영되고 `series2$`가 complete 되면 `result$` Observable 도 끝나게 됩니다.\n\n여기서 중요한것은 첫번째 Observable 이 끝나야 다음 Observable 을 구독해서 실행한다는 것이다. 이 작업은 모든 Observable 이 끝날때 까지 실행됩니다.\n\n### Using Observable Concatenation to implement sequential saves\n\n위 폼 예제에서 값을 순차적으로 받아서 저장하기 위해서는 각각의 폼 값들을 받아서 그 값들을 `httpPost$` Observable 에 mapping 할 필요가 있습니다.\n그래서 우리는 여러 `httpPost$` Observable 들을 함께 concatenate 를 할 필요가 있습니다.\n\n우리가 필요한 것은 아래 두가지 입니다.\n\n* a higher-order mapping operation( 폼 값을 받고 그 값을 `httpPost$` Observable 로 변환하기 위해서 )\n* `concat()` operation 은 여럿 `httpPost$` Observable 을 이전 save complete 가 되기 전에 HTTP save 가 만들어지지 않는 것을 보장하기 위해 concatenating 을 합니다.\n\n이 두가지를 믹스 시킨것을 RxJs concatMap Operator 라고 이름을 붙일것입니다.\n\n### The RxJs concatMap Operator\n\n위에서 말했던 concatMap 을 사용하면 아래 코드와 같을 것입니다.\n\n```javascript\nthis.form.valueChanges\n    .pipe(\n        concatMap(formValue => this.http.put(`/api/course/${courseId}`,\n                                             formValue))\n    )\n    .subscribe(\n       saveResult =>  ... handle successful save ...,\n        err => ... handle save error ...\n    );\n```\n\n이 concatMap 같은 higher-order mapping operator 를 사용하면 더이상 subscribe 를 중첩시키지 않아도 된다. 또한 모든 폼 값들이 backend 에 순차적으로 전달될것이며 이는 크롬 DevTools 의 네트워크 탭에서 확인할 수 있습니다.\n\n`concatMap` 은 각 폼 값을 save HTTP Observable 을로 변환을 시킵니다. 이를 우리는 inner Observable 이라 부를 것입니다. 그 후에 inner Observable 을 구독하고 그 결과를 output 시킵니다.\n두번째 폼 값이 이전 값 저장하는 것보다 더 빠르게 방출될것입니다. 만약 이런일이 발생한다면 새로운 폼 값은 그 즉시 HTTP request 로 mapping 되지 않습니다. 대신에 `concatMap`은 이전 HTTP Observable 이 complete 될때 까지 기다립니다.\n\n### Observable Merging\n\n만약 다른 상황을 우리가 원한다면, 이전 Observable 이 끝나기를 기다리지 않고 병렬로 처리를 원한다면 이때 우리는 `Merge` 전략을 사용할수 있습니다. `Merge` 는 `Concat` 과 다르게 `Observable` 이 끝나기를 기다려주지 않습니다.\n\n대신에 merge 구독은 매 Observable 과 같은 타임에 `merged` 됩니다. 그 후에 각 source Observable 의 값들이 시간이 자나서 혼합되어서 여러 값으로 result Observable 에 나타나게 됩니다.\n\n```javascript\nconst series1$ = interval(1000).pipe(map(val => val * 10))\n\nconst series2$ = interval(1000).pipe(map(val => val * 100))\n\nconst result$ = merge(series1$, series2$)\n\nresult$.subscribe(console.log)\n\n// 결과\n// 0\n// 0\n// 10\n// 100\n// 20\n// 200\n// 30\n// 300\n```\n\n![https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/04-rxjs-merge.png](https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/04-rxjs-merge.png)\n\n여기서 보면 혼합된 source Observable 의 값이 result Observable 에 즉시 나타난것을 볼수 있습니다. 만약 머지당한 source Observable 중 하나가 complete 된다면, merge operator 는 계속 다른 Observable 의 값을 방출할 것입니다.\n\n### The RxJs mergeMap Operator\n\n만약 우리가 merge 전략과 higher-order Observable mapping 을 혼합한다면 우린 RxJs mergeMap Operation 을 얻을 수 있습니다.\n\nmergeMap operator 작동방법은 다음과 같습니다.\n\n![https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/04-rxjs-mergeMap-2.png](https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/04-rxjs-mergeMap-2.png)\n\n각 source Observable 의 값은 `concatMap` 과 같이 inner Observable 로 `mapping` 됩니다. 이 inner Observable 은 `mergeMap` 에 의해서 구독됩니다.\ninner Observable 이 새로운 값을 방출할때, 그것들은 즉시 output Observable 에 반영됩니다.\n다만 concatMap 과 다르게 `mergeMap` 의 경우에는 다음 inner Observable 이 일으키기(triggering) 전에 이전 inner Observable 이 complete 되는것을 기다려주지 않습니다. 이 의미는 `mergeMap` 은 여러개의 inner Observable 이 시간이 지나서 겹칠수도 있다는것을 뜻합니다. result Observable 에 반영되는 값들이 서로 겹쳐서 진행될 수 있다는 것입니다.\n\n위 예제의 경우 우린 concatMap 이 더 깔끔합니다. 우린 병렬로 저장되길 원하지 않기 때문에 mergeMap 은 적합지 않습니다.\n\n```javascript\nthis.form.valueChanges\n    .pipe(\n        mergeMap(formValue =>\n                 this.http.put(`/api/course/${courseId}`,\n                               formValue))\n    )\n    .subscribe(\n       saveResult =>  ... handle successful save ...,\n        err => ... handle save error ...\n    );\n```\n\n위와 같이 `mergeMap` 을 사용했을 경우 우린 여러번 save request 가 병렬로 동작하는 모습을 크롬의 네트워크 탭에서 볼 수 있습니다. 그래서 이 경우는 error 입니다. 이런 로드가 많은 경우 이러한 요청이 순서없이 처리 될 수 있기 때문입니다.\n\n아래는 가장 기본적인 `mergeMap()`의 실행문 입니다.\n\n```javascript\nfunction myMergeMap(innerObservable) {\n  /** the click observable, in our case */\n  const source = this\n\n  return new Observable(observer => {\n    source.subscribe(outerValue => { // value from outer observable \n      /** innerObservable — the interval observable, in our case */\n      innerObservable(outerValue).subscribe(innerValue => {\n        observer.next(innerValue) // 밖 subscribe 실행시 넘어오는 observer에 값 넘겨줌.\n      })\n    })\n  })\n}\n\nObservable.prototype.myMergeMap = myMergeMap\n```\n\n새로운 `Observable`을 리턴 시키면서 `source`에서 발생되는 데이터를 받아 오기 위해 `subscribe`로 `observer`를 등록시킵니다.\nsource 에서 발생되는 데이터를 받아와서 `myMergeMap`의 인자로 받아왔던 `innerObservable`을 실행시키면서 바로 해당 결과 값을 받아오기 위해 `subscribe`를 실행 시킵니다.\n이때 `innerValue` 값을 새로운 `Observable`에 등록될 `observer`의 `next()` 메서드로 밖에 전달해 줍니다.\n\n```javascript\nconst click$ = Observable.fromEvent(button, ‘click’);\nconst interval$ = Observable.interval(1000);\n\nconst observable$ = click$.mergeMap(event => { \n   return interval$;\n});\n\nobservable$.subscribe(num => console.log(num));\n```\n\n위 코드를 보면 우리가 각 button 을 클릭할 때마다 inner `interval()` 의 `subscribe()` 메서드를 호출하는것을 배울 수 있습니다. \n이는 페이지에서 각 독립적인 인터벌로 수행합니다. 만약에 이전 구독을 취소하고 단 하나만 유지하고 싶다면 `switch()` 오퍼레이션을 이용해야 합니다.\n\n### Observable Switching\n\n![https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/05-switch.png](https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/05-switch.png)\n\nswitching 은 merging 과 비슷하다. 그말인 즉슨, 어떤 Observable 이라도 끝날때 까지 기다려 주지 않는다는 말입니다.\n\n하지만 merging 과 다르게 만약 새로운 Observable 의 값이 방출이 된다면 이전 Observable 의 구독을 취소해 버립니다.\n\nObservable switching 은 사용하지않는 Observable 의 구독취소 트리거를 발생시켜서 자원을 released 합니다.\n\nswitching Marble Diagram 을 보면 맨 위의 higher-order Observable 에서 대각선으로 forks 되는 순간이 value Observable 이 방출되고 switch 에 구독되는 순간입니다.\n\n여기서 중요한건 이런 그림들이 higher-order Observable 로 부터 fork 된 diagonal lint 의 그 시점 일때 각 inner Observable 이 구독이 되던지 또는 구독이 취소되던지 하는 그림이 필요하기 때문에 갈라지는 선을 표현하게 됩니다.\n\n### The RxJs switchMap Operator\n\n![https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/06-switchMap-2.png](https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/06-switchMap-2.png)\n\n이제 switch 전략과 그것을 higer order mapping 을 적용시켜보자. 여기서 input stream 이 1,3 그리고 5 를 방출할 계획을 가지고 있다고 해봅시다.\n\n우리는 각 값을 Observable 로 mapping 합니다. 다른 concatMap 그리고 mergeMap 케이스들과 같이 higer-order Observable 을 얻습니다.\n만약 방출된 inner Observable 사이에서 switch 가 일어났다고 했을때, 그것들을 concatenating 또는 mergeing 하는 대신에 switchMap Operator 로 종료시칩니다.\n\n```javascript\nfunction mySwitchMap(innerObservable) {\n  /** the click observable, in our case */\n  const source = this\n  let innerSubscription\n\n  return new Observable(observer => {\n    source.subscribe(outerValue => {\n      innerSubscription && innerSubscription.unsubscribe()\n\n      /** innerObservable — the interval observable, in our case */\n      innerSubscription = innerObservable(outerValue).subscribe(innerValue => {\n        observer.next(innerValue)\n      })\n    })\n  })\n}\n\nObservable.prototype.mySwitchMap = mySwitchMap\n```\n\n### The Exhaust Strategy\n\n![https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/07-exhaust.png](https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/07-exhaust.png)\n\n만약 source observable 에서 나오는 새로운 값을 이전 값 처리가 완료 될때까지 무시하고 싶다면 어떻게 해야할까?? 예를들어, save 버튼을 눌러 backend 에 save request 요청을 보낸다고 해보자. 우리는 concatMap operator 를 사용해서 실행할것입니다. 왜냐하면 save operation 이 순차적으로 저장되길 원하기 때문입니다.\n\n```javascript\nfromEvent(this.saveButton.nativeElement, 'click')\n  .pipe(concatMap(() => this.saveCourse(this.form.value)))\n  .subscribe()\n```\n\n![https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/08-exhaustMap.png](https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/08-exhaustMap.png)\n\n하지만 만약 사용자가 버튼을 여러번 눌렀다고 했을땐 어떤일이 일어날까? 20 번을 눌렀다고 한다면 20 번이 저장이 될것입니다.\n우리는 이미 save 가 진행중인게 있다면 나머지 클릭들이 무시되길 원한다. 이때 exhaust Observable 전략을 사용할 수있습니다.\n\n다른것과 마찬가지로 marble diagram 에 가장 상위 라인이 higher-order Observable 을 가지고 있습니다.\nexhaust 는 첫번째로 나오는 inner Observable 을 구독합니다.\n이때 처음 나오는 inner Observable 은 (a-b-c) 값을 방출하고 그건 그 즉시 output 에 반영됩니다.\n두번째 inner Observable 이 방출될때 (d-e-f) 아직 처음 Observable 이 진행되고 있습니다. (a-b-c)\n\n이떄 두번째 inner Observable 은 exhaust 전략에 따라 버려짐을 당합니다. 그리고 그 두번째 Observable 은 구독하지 않습니다.\n\n오직 첫번째 Observable 이 끝났을때, 새로운 Observable 이 구독됩니다.\n세번째 Observable(g-h-i)이 방출됬을때 첫번째는 이미 끝난 상태라 세번째는 버려지지 않고 구독을 시작하게 됩니다.\n여기서 (d-e-f)가 방출되지 않는 두번째와는 다르게 세번째 (g-h-i)는 result Observalbe 의 output 에 보여지게 됩니다.\n\n\n\n## Error handling\n\n* stream 이 completes 가 되면, 이후에 error 는 방출되지 않는다.\n* stream 이 error 를 발생하면, 이후에 complete 하지 않는다.\n\n따라서 에러 발생 시점에 어떻게 이 recover 를 할수 있을지 생각해야 한다.\n\nsubscribe 는 항상 3 가지의 부가적인 arguments 를 받는다.\n\n* success handler 함수는 stream 에서 value 가 발생할때마다 불러진다.\n* error handler 함수는 오직 error 발생시에만 호출된다.\n* completion handler 함수는 stream 이 끝났을때만 호출된다.\n\nsubscribe 에서 error handling 접근은 제한적이다. 왜냐하면 error 와 백엔드에서 대체할수 있는 값을 내려주었을때 복귀할수가 없다.\n\n그래서 몇몇 에러를 핸들링할 operatior 을 배워보자.\n\n### catchError Operator\n\n해당 Operator 는 input Observable 을 받아서 output Observable 을 내보내는 간단한 함수이다.\n\ncatchError 를 호출하려면, error handling 이라는 함수를 전달해줘야 한다.\n\ncatchError 는 error 를 방출하는 Observable 을 받아서 output Observable 에서 그 에러 값을 방출하기 시작한다.\n만약 에러가 발생하지 않는다면 catchError 로 생성된 output Observable 은 똑같이 input Observable 처럼 작동한다.\n\n반대로 에러가 발생되면 catchError operator 는 error 를 받아서 error handling 함수로 전달된다. 이 함수는 에러를 방출한 stream 을 다른 stream 으로 대체하는 replacement Observable 을 생성하는 역활을 한다.\n\n아래 예제를 보자.\n\n아래 예제는 에러를 감지하고 replace 하는 전략을 보여준다.\ncatchError 에 error handling 함수를 전달한다. 이 핸들러 함수는 평범한 상황일때는 호출되지 않다가 입력받는 observable 에서 error 가 발생되면 그때 호출이 된다.\n\n만약 input stream 에서 에러가 발생되면 이 함수는 `of([])` 를 사용해서 Observable 을 생성해 리턴한다.\n여기서 `of()`는 오직 한번 []의값을 방출하고 complete 되는 Observable 을 생성하는 함수이다.\nerror handling 함수는 recovery Observable 인 `of([])`를 리턴한다.\nrecovery Observable 의 값들은 catchError 에 의해 리턴된 output Observable 안에서 방출되는 replacement value 들 이다.\n\n결과적으론 http$ Observable 은 error 를 더이상 발생시키지 않는다. 따라서 subscribe 에서 error handling 은 호출되지 않는다. 대신 빈 배열인 [] (빈배열 : fallback value) 값을 방출하고 http$ observable 은 completed 된다.\n\n```javascript\nconst http$ = this.http.get<Course[]>('/api/courses');\n\nhttp$\n    .pipe(\n        catchError(err => of([]))\n    )\n    .subscribe(\n        res => console.log('HTTP response', res),\n        err => console.log('HTTP Error', err),\n        () => console.log('HTTP request completed.')\n    );\n\n// 결과 콘솔\n// HTTP response []\n// HTTP request completed.  \n```\n\n위와 같은 상황에서 Rethrow 도 할수 있다. 위 상황처럼 대처하기 보다는 local 에서 error 를 핸들링하고 싶을때 즉, 에러 메세지를 유저에게 보여주고 싶을때 사용된다.\n\n아래와 같이 `throwError`를 사용해주면 된다.\n이 `throwError`는 value 를 방출하지 않고 catchError 와 동일한 error 를 사용해서 error 를 내주는 Observable 을 생성한다.\n\n```javascript\nconst http$ = this.http.get<Course[]>('/api/courses');\n\nhttp$\n    .pipe(\n        catchError(err => {\n            console.log('Handling error locally and rethrowing it...', err);\n            return throwError(err);\n        })\n    )\n    .subscribe(\n        res => console.log('HTTP response', res),\n        err => console.log('HTTP Error', err),\n        () => console.log('HTTP request completed.')\n    );\n```\n\n또한 아래처럼 Observable 체인에서 여러번 사용할 수 있다.\n\n```javascript\nconst http$ = this.http.get<Course[]>('/api/courses');\n\nhttp$\n    .pipe(\n        map(res => res['payload']),\n        catchError(err => {\n            console.log('caught mapping error and rethrowing', err);\n            return throwError(err);\n        }),\n        catchError(err => {\n            console.log('caught rethrown error, providing fallback value');\n            return of([]);\n        })\n    )\n    .subscribe(\n        res => console.log('HTTP response', res),\n        err => console.log('HTTP Error', err),\n        () => console.log('HTTP request completed.')\n    );\n```\n\ntry..catch..finally 문 처럼 RxJs 에서도 Finalize Operator 가 있다. 예제는 아래와 같다.\n\n```javascript\nconst http$ = this.http.get<Course[]>('/api/courses');\n\nhttp$\n    .pipe(\n        map(res => res['payload']),\n        catchError(err => {\n            console.log('caught mapping error and rethrowing', err);\n            return throwError(err);\n        }),\n        finalize(() => console.log(\"first finalize() block executed\")),\n        catchError(err => {\n            console.log('caught rethrown error, providing fallback value');\n            return of([]);\n        }),\n        finalize(() => console.log(\"second finalize() block executed\"))\n    )\n    .subscribe(\n        res => console.log('HTTP response', res),\n        err => console.log('HTTP Error', err),\n        () => console.log('HTTP request completed.')\n    );\n\n// 결과\n// 에러발생\n// caught mapping error and rethrowing {에러객체}\n// caught rethrown error, providing fallback value\n// first finalize() block executed\n// HTTP response []\n// HTTP request completed.  \n// second finalize() block executed\n```\n\n재 시도에 대한 전략도 세울수가 있다.\n만약 스트림이 에러가 발생했을 경우 우리는 input Observable 을 다시 subscribe 할수 있는 새로운 stream 을 만들어야 한다.\n\n언제 재시도를 해야할까?\n\n즉시 실행이 가능할까? 또는 몇초 뒤에 실행해야할까, 문제가 해결되고 다시 시도하길 바랄수도 있다, 또는 몇몇 시도를 제안 둘수도 있을까?\n\n우리는 위와 같은 답을 얻기 위해서 보조적인 Observable 이 필요하다. 이름하야 Notifier Observable. 이 Observable 은 언제 재시도를 해야할지 알려준다.\n\n즉시 실행하는 방법은 `retryWhen` 를 사용한다. 이것은 간단하게 input Observable 을 Notification Observable 이 값을 방출할때마다 재 시도 하는 것이다.\n\n그럼 여기서 어떻게 Notification Observable 을 만들 것인가.\n`retryWhen` operator 에 전달된 함수가 Notification Observable 을 만들고 이 함수는 Error Observable 을 인자로 받는다.\n\n에러가 발생 즉시 재시도를 하기 위해서 여기서 해야할 일은 Error Observable 을 변화시키지 않고 리턴하는 것이다. 그래야 이 Error Observable 을 구독함으로써 언제 정확히 에러가 발생하는지 알 수 있는 Notification Observable 을 만들어 낼 수 있다. 아래 코드에서는 tap operation 을 사용했는데 이는 단지 로깅을 위한 목적으로 쓰이고 Error Observable 은 변화시키지 않았다.\n\n여기서 기억해야하는것은 `retryWhen` 함수 호출에서 반환되는 Observable 은 Notification Observable 이라는 것이다. 이곳에서 어떤 값이 방출되는건 중요치 않다. 단지 재시도를 하기 위한 트리거이기 때문에 중요한건 언제 방출된 값을 받았는지가 중요하다.\n\n```javascript\nconst http$ = this.http.get<Course[]>('/api/courses');\n\nhttp$.pipe(\n        tap(() => console.log(\"HTTP request executed\")),\n        map(res => Object.values(res[\"payload\"]) ),\n        shareReplay(),\n        retryWhen(errors => {\n            return errors\n                    .pipe(\n                        tap(() => console.log('retrying...'))\n                    );\n        } )\n    )\n    .subscribe(\n        res => console.log('HTTP response', res),\n        err => console.log('HTTP Error', err),\n        () => console.log('HTTP request completed.')\n    );\n\n// 결과\n// 에러\n// retrying...\n// HTTP request executed\n// HTTP response\n// HTTP request completed.\n```\n\n또는 딜레이를 주는 방법이 있다. 특히 트레픽이 높아서 네트워크 실패인 경우 유용하게 사용할 수 있다.\nex) `timer(3000,1000)` 3 초 뒤에 1 초마다 발생, 2 번쨰 인자는 옵셔널한 인자인데 주지 않는다면 3 초 뒤에 값이 한번 발생하고 complete 되는 것이다.\n\n한가지 중요한 점은 `retryWhen` Operator 의 Notification Observable 를 정의하는 함수(인자로 전해지는 함수)는 오직 한번만 호출된다는 점이다. 그래서 재 시도를 해야할 신호가 왔을때 Notification Observable 을 정의할 기회는 한번 뿐이라는 것이다.\n\n우리는 Error Observable 을 받을때 Notification Observable 을 정의하고 `delayWhen` 를 적용할 것이다.\n\n```javascript\nconst http$ = this.http.get<Course[]>('/api/courses');\n\nhttp$.pipe(\n        tap(() => console.log(\"HTTP request executed\")),\n        map(res => Object.values(res[\"payload\"]) ),\n        shareReplay(),\n        retryWhen(errors => {\n            return errors\n                    .pipe(\n                        delayWhen(() => timer(2000)),\n                        tap(() => console.log('retrying...'))\n                    );\n        } )\n    )\n    .subscribe(\n        res => console.log('HTTP response', res),\n        err => console.log('HTTP Error', err),\n        () => console.log('HTTP request completed.')\n    );\n```\n\nError Observable 에서 들어오는 각각의 error 값에 delay 를 적용하기 위해서 `delayWhen` 에 전달된 함수(duration selector function 이라 부른다.)를 호출한다. 이 함수는 input value 가 어느정도 경과했는지를 결정할 Observable 을 방출한다.\n\n각각의 input value 에는 duration selector Observable 을 가지고 있다. 이 Observable 이 결국 값을 emit 하고 나면 input value 가 delayWhen 의 ouput 으로 보여지게 된다.\n\n에러가 발생할때마다 `delayWhen` operator 는 timer 함수를 호출함으로써 duration selector Observable 를 생성하게 된다. 이 duration selector Observable 는 0 값이 2 초후에 발생하게 되고 그 후엔 complete 된다. 그 일이 일어나게 되면 `delayWhen` Observable 은 주어졌던 error input 의 경과시간을 알게 되고 2 초라는 경과시간이 지나게 되면 error 는 notification Observable ouput 에 보여지게 된다. notification 에 value 가 emit 하게 되면, `retryWhen` operator 는 재시도를 하게 된다.\n\n\n## RxJS 개발방법\n\n1. 데이터 소스를 Observable로 생성\n2. Observable의 operator를 사용\n    - 데이터를 변경, 추출, 합침, 분리\n3. 원하는 데이터를 받아 처리하는 Observer를 만든다. \n4. Observable의 subscribe를 통해 Observer를 등록한다.\n5. Observable 구독을 정지하고 자원을 해지한다.\n\n## 출처\n\n* [https://www.youtube.com/watch?v=PhggNGsSQyg](https://www.youtube.com/watch?v=PhggNGsSQyg)\n* [https://www.youtube.com/watch?v=2f09-veX4HA&t=1714s](https://www.youtube.com/watch?v=2f09-veX4HA&t=1714s)\n* [https://oaksong.github.io/2017/12/23/concurrency-and-parallelism/](https://oaksong.github.io/2017/12/23/concurrency-and-parallelism/)\n* [https://netbasal.com/understanding-subjects-in-rxjs-55102a190f3](https://netbasal.com/understanding-subjects-in-rxjs-55102a190f3)\n* [https://blog.angular-university.io/rxjs-error-handling/](https://blog.angular-university.io/rxjs-error-handling/)\n* [https://blog.angular-university.io/rxjs-higher-order-mapping/](https://blog.angular-university.io/rxjs-higher-order-mapping/)\n* [https://netbasal.com/javascript-observables-under-the-hood-2423f760584](https://netbasal.com/javascript-observables-under-the-hood-2423f760584)\n* [https://netbasal.com/understanding-mergemap-and-switchmap-in-rxjs-13cf9c57c885](https://netbasal.com/understanding-mergemap-and-switchmap-in-rxjs-13cf9c57c885)\n* [https://blogs.msmvps.com/deborahk/higher-order-observable/](https://blogs.msmvps.com/deborahk/higher-order-observable/)","excerpt":"RxJS 의 특징을 알아보고 공부하자. RxJS 의 공홈을 독파해보자. definition RxJS 는 Observables 을 이용한 반응형 프로그래밍을 할수 있게 도와주는 라이브러리 입니다. 비동기와 콜백 베이스 코드를 observable seq…","fields":{"slug":"/hello-rxjs.md/"},"frontmatter":{"date":"Jan 28, 2019","title":"hello-RxJS","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Intro\n\n- MobX 의 특징을 알아보고 공부하자.\n- MobX 의 공홈을 독파해보자.\n\n## Concepts\n\n### State\n\n- state 란 어플리케이션을 이끄는 데이터 입니다.\n- 흔히 todo items의 list 같은 _domain specific state_ 라고 하는 것과 현재 선택된 element를 가리키는 _view state_ 입니다.\n- state는 마치 엑셀 스프레드 시트에서 값을 지닌 cells 들과 같다고 생각하십시요.\n\n### Derivations ( 파생 )\n\n- state 로 부터 파생되는 값들이다. 다양한 형태로 존재할 수 있습니다.\n\n  - 유저 인터페이스\n  - todo 리스트 data에서 남아있는 todo item 갯수의 파생된 데이터\n  - 서버에 변경 사항을 보내는 것과 같은 백엔드 통합\n\n- MobX 는 구별되는 두가지의 파생 종류가 있다. 하나는 **Computed values** 또 다른 하나는 **Reactions** 이다.\n  - Computed values 는 순수 함수를 이용해서 observable state로 부터 파생된 새로운 값이다. 따라서 side effect 가 없어야 합니다.\n  - 만약 지금의 state 를 베이스로 새로운 값을 만들길 원한다면 computed 를 사용하면 됩니다.\n  - 모든 Computed value는 state 를 변화 시키면 안됩니다.\n  - Reactions 는 state 변화로 인해 자동적으로 발생될 필요가 있는 sied effect 이다. 여기서 side effect 는 호출된 함수 밖에 있는 다른 값들이나 어플리케이션의 상태를 변경되는 것을 뜻합니다.\n  - Reactions 은 명령형 프로그래밍(Imperative programming)과 reactive 프로그래밍 사이를 연결해주는 것으로 필요하고 명확하게는 I/O를 달성하는데 필요합니다.\n\n> 여기서 명령형 프로그래밍은 상태를 어떠한 다른 상태로 명령을 하면서 프로그램을 만들어가는 패러다임중 하나라고 생각하면 됩니다.\n\n### Action\n\n- action 은 state 를 변화시키는 한 코드이다. 마치 스프레드 시트에 새로운 값을 입력하는 user 와 같은 것입니다.\n- Mobx는 코드 구조를 명확하게 도와주기 위해 strict 모드를 사용해서 액션 밖에서 state 를 강제로 바꾸는 일을 할 수 없게 만들 수 있습니다.\n\n#### imperative programing\n\n- `imperative` 는 명령형 프로그래밍으로 쉽게는 순차적으로 명령을 하듯이 프로그래밍 하는것을 뜻한다. 컴퓨터가 수행할 명령들을 순서대로 적어놓아서 내가 원하는 결과를 얻는것이다. 즉, `how 어떻게 할 것인가`에 포커싱을 맞춥니다. 반대로는 선언적인 프로그래밍이 있다. 선언적 프로그래밍에선 데이터에 집중하기 보단 절차에 집중을 해서 만들어 낸다. 즉, `what 무엇을 할 것인가` 또는 `목표가 무엇인가`에 초점을 맞춥니다.\n\n- `명령형 프로그래밍`에서는 어떠한 알고리즘을 사용할지에 대해 나타낸다고 한다면, `선언형 프로그래밍`에서는 필요한게 무엇인지 목표가 무엇인지에 대해서 나타내는 프로그래밍 입니다.\n\n- 데이터를 정의하고 그것의 변화 과정을 프로그래밍 할것이냐 행위를 정의하고 거기에 데이터를 집어 넣을 것이냐 방법의 차이. 즉, 생각의 주체를 데이터에 두느냐 function 에 두느냐의 차이.\n\n#### reactive programing\n\n- async 상황에서 이 async 데이터를 어떻게 처리할것이냐 , 아이디어는 stream 라는것으로 연결하고 그 stream 에 데이터를 흘려 보내자. 라는 생각이 reactive 프로그래밍이다. 함수의 동작은 async 하게 움직이지만 코드로는 순서대로.. async 한 작업을 functional 하게 처리하는 아이디어.\n\n- 어떤 데이터를 생산해내는 함수가 있을거고 그 데이터를 받아서 처리하는 컨슈머가 있을것이다. 그것을 서로 스트림으로 연결시키고 데이터를 만드는애를 observable 데이터를 소비하는 애를 subscriber 라고 한다.\n  observable 부터 subscriber 까지 데이터가 흘러가는데 흘러가는 사이에 operator 라는 것들을 통해 데이터를 변형하거나 제작할수 있다.\n\n- reactive 프로그래밍이란 데이터의 흐름과 그 변화를 알려주는 통지로 바라보는 패러다임이다. 예를 들면 a = b + c 에서 덧셈의 결과를 a 에 할당하지만 일반적인 패러다임은 b 나 c 가 변하여도 a 값은 변경되지 않는다. 하지만 반응형 프로그래밍에서는 a 가 자동으로 변경된다. ( ex. 엑셀의 셀처럼 ) 즉, 프로그래밍 언어에서 정적 또는 동적 데이터 흐름을 쉽게 표현할 수 있어야 하며 변경 사항을 데이터 흐름을 통해 자동으로 전파한다는 것을 의미\n\n- 공식 문서에서의 imperative 란 반응형으로 이뤄진 코드 생태계의 외부 code 생태계라고 볼수있다. 이 외부 code 생태계는 반응형의 생태계의 side effect 정도 되겠다.\n\n### Principles\n\n```\nAction -> State -> Views\n```\n\n- MobX 는 action 이 상태를 변경하고 그에 따른 views 를 업데이트하는 단방향 데이터 흐름을 지원합니다.\n- 모든 파생들은 state 가 변할때 **자동적(automatically)** 그리고 **따로 분리 되지 않는 행동단위(atomically)** 업데이트 됩니다. 결과적으로는 그 변화하는 값에서 중간값들을 관찰할 수는 없습니다.\n- 모든 파생들은 기본적으로 **동기식(synchronously)** 으로 업데이트 됩니다. 이 의미는 actions 이 state 가 변화시키고 난 후 computed 된 value 를 안전하게 확인할 수 있다는 의미입니다.\n- Computed value 는 update 가 **lazily** 하게 됩니다. 실제로 사용되지 않는 Computed value 는 side effect 위해 필요로 하지 않는 이상 업데이트 되지 않는다. 만약 view 가 더이상 사용하지 않는다면 자동적으로 가비지 컬렉터가 수거해 갑니다.\n- 모든 Computed 된 value 들은 **pure** 해야 합니다. Compute에서는 state 변화를 지원하지 않습니다.\n\n### Illustration\n\n```javascript\nimport { observable, autorun } from 'mobx'\n\nvar todoStore = observable({\n  /* some observable state : 상태 값*/\n  todos: [],\n\n  /* a derived value : 파생된 값 */\n  get completedCount() {\n    return this.todos.filter(todo => todo.completed).length\n  },\n})\n\n/* a function that observes the state : 상태를 관찰한다. */\nautorun(function() {\n  console.log(\n    'Completed %d of %d items',\n    todoStore.completedCount,\n    todoStore.todos.length\n  )\n})\n\n/* ..and some actions that modify the state : 상태를 수정하는 액션을 취한다. */\ntodoStore.todos[0] = {\n  title: 'Take a walk',\n  completed: false,\n}\n// -> synchronously prints 'Completed 0 of 1 items'\n\ntodoStore.todos[0].completed = true\n// -> synchronously prints 'Completed 1 of 1 items'\n```\n\n## observable\n\n```javascript\n// Usage\nobservable(value)\n@observable classProperty = value\n```\n\n- Observable 이라는건 \"MobX! 이 값을 추적해줘, 그러면 당신은 observer 들을 업데이트 시킬수 있습니다.\"\n- RxJs 에서도 Observable 을 사용하고 있는데 여기서 느낌을 말하자면 동기적이든 비동기적이든 값을 던지는 함수라고 생각하고, 만약 이 값에 흥미가 있다면 observer를 등록해서 받아 볼 수 있습니다. [참조글](https://netbasal.com/javascript-observables-under-the-hood-2423f760584)\n- Observable values 의 값으로는 js 의 원시타입, 참조, 일반객체 , 클래스 인스턴스, array 그리고 map 이 될수 있습니다.\n- 리턴 값으로는 observable 한 객체가 리턴됩니다. \n- 리턴된 객체를 observer에서 참조 하고 있다면 리턴된 객체의 변화를 추적할 수가 있습니다. \n\n다음 변환 규칙이 적용되지만 *modifiers*를 이용해서 세부 조정을 할 수 있다. 여기서 _modifiers_ 란 observable 프로퍼티들의 동작방식을 정의 하는데 사용되는 부분이다. ( ex. observable.deep, observable.ref)\n\n1. value 가 ES6 의 Map 이면 : 새로운 Observable Map 이 리턴된다. 이것은 구체적인 엔트리의 변화에 대한 반응을 하고 싶지 않을때 유용하다. 또한 엔트리 항목의 추가 제거에도 반응하고 싶지 않을때 유용하다.\n2. value 가 ES6 의 Set 라면 : 새로운 Observable Set 이 리턴된다.\n3. value 가 array 라면 : 새로운 Observable Array 가 리턴된다.\n4. value 가 prototype 이 없는 객체라면 : 모든 그 객체의 프로퍼티들을 observable 로 만들 수 있다.\n5. value 가 prototype 을 지닌 객체라면 (원시타입 및 함수) `observable`은 에러를 던질 것이다. 그러한 값에 대한 독립형 관찰 가능 참조를 작성하려는 경우 Boxed Observable 를 사용해야 한다. MobX 는 prototype 를 지닌 object(function 같은) 들을 자동으로 observable 한 객체로 만들어 주지 않는다. 이 객체는 생성자 함수에서 생성자에서 수행하도록 고려되어져야 한다. extendObservable 을 사용하거나 클래스 정의에서 @observable / decorate 를 대신 사용해라.\n\n- 여기서 observable reference 란 객체를 observable 로 바꿀 필요가 없을때 사용하는 것이다. 전형적인 케이스들은 immutable object 들 또는 내가 아닌 외부 라이브러리에 의해 관리되는 object 들이다. 예를 들면 JSX elements, DOM elements, History, window 같은 네이티브 object 들이다. 이런 객체들에 대해서는 observable 로 바꾸지 않고 단지 reference 만 저장 및 추적하면 된다.\n\n- observable은 디폴트로 observable한 데이터 구조를 감염적(infective)으로 구성한다. 이 말이 뜻하는 바는 `observable`은 자동적으로 데이터 구조에 포함되어있는 어떤 값이라도 자동적으로 observable 하게 적용한다는 뜻이고 또는 추후에 새롭게 들어 오는 데이터에 대해서도 obserable하게 적용한다는 말이다. 이 행위는 _modifier_ 를 통해서 수정될 수 있습니다.\n\n- [Mobx 4 그리고 그 이 이하 버전] 에서는 다이나믹한 키를 가진 objects를 생성하려면 Observable Map을 사용해야 하고 오직, 초기에 설정했던 object에 존재했던 프로퍼티들에 서만 observable 하게 만들어준다. 물론 프로퍼티를 새롭게 추가하려면 `extendObservable`을 사용하면 된다.\n\n```javascript\nclass Message {\n  @observable message = 'Hello world'\n\n  // fictional example, if author is immutable, we just need to store a reference and shouldn't turn it into a mutable, observable object\n  // author가 불변의 값이라면, 참조 값만 저장하고 변경가능하고 관찰 가능한 객체로 바꾸면 안된다.\n  @observable.ref author = null\n}\n```\n\n- 기본적으로 데이터 구조를 observable 하게 만든다는 것은 infective(감염적)이다. 이 의미는 observable 은 자동적으로 그 데이터 구조안에 포함된 어떤 값이라도 자동으로 적용한다는 의미이다. 또는 나중에 포함될 어느 값 또한 적용된다. 이 행위는 modifiers 에 의해 변화될수 있다.\n\n## @observable\n\n```javascript\nimport { observable, computed } from 'mobx'\n\nclass OrderLine {\n  @observable price = 0\n  @observable amount = 1\n\n  @computed\n  get total() {\n    return this.price * this.amount\n  }\n}\n```\n\n- ES7 에서 사용되는 Decorator 는 클래스 프로퍼티들을 observable 하게 만들어준다.\n- @observable 은 인스턴스 필드나 getter 프로퍼티에 사용될 수 있다.\n- 이렇게하면 개체의 어떤 부분을 관찰 할 수 있는지에 대한 세부적인 제어가 가능합니다.\n\n## objects\n\n- 만약 plain 한 객체가 observable 에 전달된다면 안에있는 모든 프로퍼티들은 복제본에 복사되어 관측할수 있게 된다. ( 여기서 plain 한 객체라 하면 생성자 함수를 사용하여 만들지는 않았고 해당객체의 프로토타입(**proto**)이 `Object`을 가지거나 프로토타입 프로퍼티가 전혀 없는경우이다. )\n- observable 은 디폴트로 재귀적으로 적용이 됩니다. 그래서 만약 값들중 하나가 object 또는 array 라면 그 값들 또한 observable 하게 적용된다.\n- 오직 plain object 만 observable 하게 만들 수 있다. non-plain object 의 경우에는 생성자에서 observable 프로퍼티를 초기화 해줘야 한다. @observable 또는 extendObservable 함수를 이용할 수 있다.\n- getter 프로퍼티는 자동적으로 @computed 처럼 파생 프로퍼티로 전환된다.\n- observable 은 재귀적으로 전체 object 그래프에 적용됩니다. 인스턴스화된 것과 나중에 새롭게 observable 프로퍼티들에 할당될 새로운 값(object 객체)들에 대해서도 적용이 된다.\n- Observable 은 non-plain objects 를 재귀하지 않는다. 즉, 클래스로 인스턴스를 만들어서 observable 한것은 재귀 하지 않는다.\n- 속성 값의 자동 변환을 사용하지 않으려면 {deep : false}를 3 번째 인수로 전달하십시오.\n- 이 객체에 친숙한 디버그 이름을 할당하려면 {name : \"my object\"}를 전달하십시오.\n\n### example\n\n```javascript\nobservable.object(props, decorators?, options?)\n\nimport {observable, autorun, action} from \"mobx\";\n\nvar person = observable({\n    // observable properties:\n    name: \"John\",\n    age: 42,\n    showAge: false,\n\n    // computed property:\n    get labelText() {\n        return this.showAge ? `${this.name} (age: ${this.age})` : this.name;\n    },\n\n    setAge(age) {\n        this.age = age;\n    }\n}, {\n  // decorators\n    setAge: action\n});\n\n// object properties don't expose an 'observe' method,\n// but don't worry, 'mobx.autorun' is even more powerful\nautorun(() => console.log(person.labelText));\n\nperson.name = \"Dave\";\n// prints: 'Dave'\n\nperson.setAge(21);\n// etc\n```\n\n```javascript\n// plain object\nfunction isPlainObject(value) {\n  if (value === null || typeof value !== 'object') return false\n  // 지정된 __proto__  타입을 반환한다.\n  // __proto__ : 나를 누가 만들었는가.\n  // prototype : 나를 이용해서 만들면 해당 prototype을 기반으로 만든다.\n  const proto = Object.getPrototypeOf(value)\n  return proto === Object.prototype || proto === null\n}\n```\n\n## arrays\n\n- observable 에 array 를 넣어도 똑같다.\n- 이 구문도 재귀적으로 잘 움직이고, 모든 값 ( 미래에 들어올 값 ) 또한 observable 할 수 있다.\n- array 의 빌트인 함수들 뿐만 아니라 observable array 는 다음과 같은 유용한 기능을 사용할 수 있다.\n  - intercept(interceptor), observe(listener, fireImmediately? = false), clear(), replace(newItems), find(predicate: (item, index, array) => boolean, thisArg?), findIndex(predicate: (item, index, array) => boolean, thisArg?) , remove(value)\n\n### example\n\n```javascript\nobservable.array(values?)\n\nvar todos = observable([\n    { title: \"Spoil tea\", completed: true },\n    { title: \"Make coffee\", completed: false }\n]);\n\nautorun(() => {\n    console.log(\"Remaining:\", todos\n        .filter(todo => !todo.completed)\n        .map(todo => todo.title)\n        .join(\", \")\n    );\n});\n```\n\n## maps\n\n`observable.map(values?)` 은 dynamic 키를 가진 observable map을 만듭니다. 단지 구체적인 entry 의 변화에만 반응하는걸 원치 않다면 Observable maps는 유용할 것입니다. 또한 entry를 추가하거나 제거의 경우에도 마찬가지 입니다. Optionally 하게 배열의 entry들 또는 초기 값을 가진 ES6 map의 문자열키를 받을 수 있습니다.\n\n`observable(new Map())` 처럼 ES6 Map의 생성자를 통해서 observable map을 초기화 할 수 있고, decorator를 이용해서 `@observable map = new Map().` 클래스 프로퍼티를 위한 observable map을 만들수도 있습니다.\n\n[ES6 Map Spec](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) 에 따르는 method들을 사용할 수 있습니다.\n\n## boxed values\n\nJavaScript 의 모든 원시객체 값은 변경 가능하지(immutable) 않으므로 정의에 따라 관찰(observable) 할 수 없다. 일반적으로 MobX 는 관찰 가능한 값을 포함하는 속성(property)을 만들 수 있습니다.\n드문 경우지만 object에 소유하지 않는 \"원시객체를\"를 observable 로 만드는 것이 편리 할 수 있을때가 있습니다. 이러한 경우에는 이러한 프리미티브를 관리하는 observable obx를 생성 할 수 있습니다.\n\n### example\n\n```javascript\nimport { observable } from 'mobx'\n\nconst cityName = observable.box('Vienna')\n\nconsole.log(cityName.get())\n// prints 'Vienna'\n\ncityName.observe(function(change) {\n  console.log(change.oldValue, '->', change.newValue)\n})\n\ncityName.set('Amsterdam')\n// prints 'Vienna -> Amsterdam'\n```\n\n## decorators\n\nMobX에는 관찰 가능한 속성(observable properties)의 동작 방식을 정의하는 데코레이터 세트가 있습니다.\n\n- `observable`: An alias for observable.deep.\n- `observable.deep`: This is the default modifier, used by any observable. It clones and converts any (not yet observable) array, Map or plain object into it's observable counterpart upon assignment to the given property\n- `observable.ref`: Disables automatic observable conversion, just creates an observable reference instead.\n- `observable.shallow`: Can only used in combination with collections. Turns any assigned collection into an observable, but the values of that collection will be treated as-is.\n- `observable.struct`: Like ref, but will ignore new values that are structurally equal to the current value\n- `computed`: Creates a derived property, see computed\n- `computed(options)`: Idem, sets additional options.\n- `computed.struct`: Same as computed, but will only notify any of it's observers when the value produced by the view is structurally different from the previous value\n- `action`: Creates an action, see action\n- `action(name)`: Creates an action, overrides the name\n- `action.bound`: Creates an action, and binds this to the instance\n\n데코레이터들은 구체적인 객체 멤머의 작동방식을 위해 다음 `decorate`, `observable.object`, `extendObservable` and `observable` (객체를 생성할 때) api들과 함께 사용이 가능합니다.\n만약 아무런 데코레이터를 지정하지 않는다면 디폴트로 `observable.deep`을 사용하게 됩니다.\n\n### example\n\n```javascript\nimport { observable, autorun, action } from 'mobx'\n\nvar person = observable(\n  {\n    name: 'John',\n    age: 42,\n    showAge: false,\n\n    get labelText() {\n      return this.showAge ? `${this.name} (age: ${this.age})` : this.name\n    },\n\n    // action:\n    setAge(age) {\n      this.age = age\n    },\n  },\n  {\n    setAge: action,\n    // the other properties will default to observables  / computed\n  }\n)\n```\n\n```javascript\nclass Person {\n  name = 'John'\n  age = 42\n  showAge = false\n\n  get labelText() {\n    return this.showAge ? `${this.name} (age: ${this.age})` : this.name\n  }\n\n  setAge(age) {\n    this.age = age\n  }\n}\n// when using decorate, all fields should be specified (a class might have many more non-observable internal fields after all)\ndecorate(Person, {\n  name: observable,\n  age: observable,\n  showAge: observable,\n  labelText: computed,\n  setAge: action,\n})\n```\n\n### Reference observability\n\n때때론 object들이 observable하게 변화하지 않아도 될때가 있다. 대게 이런 케이스들은 immutable object들 이거나 object가 외부 라이브러리에 의해서 관리가 될때 입니다. 예를 들어 JSX 엘리먼트나 DOM element, History나 window 또는 그 외에 native object 들을 말합니다. 이러한 object들을 위해 해당 객체를 observable하게 변화시키지 않고 객체의 참조값만을 저장하길 원할 것입니다.\n\n이럴때 `ref` modifier를 사용합니다. `ref`는 참조 만 추적하고 그것의 값을 변환하지는 않는 관찰 가능한 속성이 생성되도록 합니다.\n\n예를 들어 아래 `author`를 `observable.ref`로 해두면 `author`의 참조값만을 추적하게 됩니다.\nimmutable 값이 들어온다면 추적하지만 반대로 mutable 하고 observable 한 객체가 들어온다면 추적을 하지 못합니다. 즉, 새로운 객체 또는 primitive 한 값들이 들어와야 한다는 것입니다.\n\n#### example\n\n```javascript\nclass Message {\n  @observable message = 'Hello world'\n\n  // fictional example, if author is immutable, we just need to store a reference and shouldn't turn it into a mutable, observable object\n  @observable.ref author = null\n}\n\n// ES5 syntax:\n\nfunction Message() {\n  extendObservable(\n    this,\n    {\n      message: 'Hello world',\n      author: null,\n    },\n    {\n      author: observable.ref,\n    }\n  )\n}\n\n// 예\nvar person = observable(\n  {\n    name: 'John',\n    age: 42,\n    showAge: false,\n    author: null,\n    get labelText() {\n      return this.showAge ? `${this.name} (age: ${this.age})` : this.name\n    },\n\n    // action:\n    setAge(age) {\n      this.age = age\n    },\n  },\n  {\n    author: observable.ref, // ref 설정\n    setAge: action,\n  }\n)\n\nreaction(\n  () => person.author && person.author.name, // observe\n  (value, reaction) => {\n    console.log(`author 값이 ${value} 로 바뀌었네요!`)\n  }\n)\n\nperson.author = { name: 'merlin' }\nperson.author.name = 'ho' // 변화를 감지 못한다.\n\n// author 값이 merlin 로 바뀌었네요!\n```\n\n### Shallow observability\n\n`observable.shallow` modifier는 관측가능성을 'one-level-deep' 하게 적용하는 것입니다.\n\n#### example\n\n```javascript\nvar person = observable(\n  {\n    authors: [{ name: 'merlin' }, { name: 'ho' }],\n  },\n  {\n    authors: observable.shallow,\n  }\n)\n\nautorun(() => console.log(`변화 ${person.authors[0].name}`)) // 2 뎁스에 있는 변화를 감지 하고 싶다.\nperson.authors[0].name = 'hhhhh'\n// 변화를 감지 못한다.\n// 대신 아래처럼 authors 배열에 push를 넣으면서 변화를 주면\nperson.authors.push({ name: 'ererer' })\n\n// test에 변화가 생겼기 때문에 위 autorun이 실행이 되게 된다.\n```\n\n위 예제에서 authors 의 배열에 변화가 생기면 추적을 하도록 observable array로 변화를 하지만 array 가 포함하고 있는 객체들은 observable이 아닌 일반 오리지널 객체입니다. 따라서 `person.authors[0]` 에 어떠한 변화를 주어도 감지해 내지 못합니다.\n\n## (@)Computed\n\n```javascript\nclass OrderLine {\n  @observable price = 0\n  @observable amount = 1\n\n  constructor(price) {\n    this.price = price\n  }\n\n  @computed\n  get total() {\n    return this.price * this.amount\n  }\n}\n\n// or\n\nvar upperCaseName = computed(() => name.get().toUpperCase())\nvar disposer = upperCaseName.observe(change => console.log(change.newValue))\n```\n\n- Computed values 는 다른 computed value 또는 지금 존재하는 state 로 부터 파생된 값입니다.\n- Computed 는 reaction 들이 일어나고 나서 계산이 수행 됩니다.\n- Coumputed는 실제로 수정가능한 state 를 최소화 시킬수 있는 방법중 하나입니다.\n- computed 와 autorun 는 반응적(reactively)으로 실행되는 표현식(expressions)이지만, `computed` 는 다른 observer 에 의해 사용되는 값을 생성할때 사용되고 `autorun` 은 새로운 값을 만들어 내지 않습니다. 그 대신에 어떠한 효과를 이루기 위해 사용될수 있다. 예를들면 로깅이나 네트워크 요청 같은 것들이 될 수 있습니다.\n- Compute values 이전 계산에서 사용 된 데이터가 변경되지 않으면 계산 된 속성이 다시 실행되지 않습니다. 뿐만 아니라 다른 computed property 또는 reaction 에서 사용되지 않으면 재 계산되지 않습니다.\n- Computed values가 더이상 관찰되지 않으면 Mobx가 자동으로 가비지를 수거해 갈 수 있습니다. 이는 autorun 과의 차이점 중에 하나입니다. ( autorun 의 경우에는 그들 스스로가 dispose 해주어야 한다. )\n- 만약 항상 computed value 가 계산되길 원한다면 observe 또는 `keepAlive` 또는 `observe` 를 이용해서 변화를 계속 탐지할 수 있습니다.\n- computed 프로퍼티들은 `enumerable` 하지 않는다. 여기서 `enumerable` 하다는 뜻은 `for..in` 루프로 프로퍼티들을 순회 할 수 있다는 뜻이다. 또한 이 computed 프로퍼티들은 상속 된 값으로 덮어 씌여지지 않는다.\n- computed value 를 위한 setter 도 정의할 수 있다. 이 setter 는 computed value 를 직접 변경하진 않지만 역 파생으로 사용될 수 있다. 예를 들면, 아래에서 `orderLine.total = 10` 이라고 셋팅하면 total 값이 직접적으로 바뀌는 것이 아닌 price 값이 변경되면서 다시 get 의 total 값이 반응하게 된다.\n\n### example\n\n```javascript\nconst orderLine = observable.object({\n  price: 0,\n  amount: 1,\n  get total() {\n    return this.price * this.amount\n  },\n  set total(total) {\n    this.price = total / this.amount // infer price from total\n  },\n})\n```\n\n> 주의 : @computed get 메서드 내용에 일반 함수를 호출하면 되지만 @action 을 넣으면 computed 가 반응을 하지 않는다.\n\n```javascript\n// 동작\n@computed\nget total() {\n  return this.something()\n}\n\nsomething() {}\n\n// 동작 안함\n@computed\nget total() {\n  return this.something()\n}\n\n@action\nsomething() {}\n```\n\n### computed(expression) as function\n\n`computed`는 바로 함수로 호출을 할 수도 있습니다. `observable.box(primitive value)` 처럼 독립형 observable을 생성하면 반환된 객체에서 `.get()`을 사용해서 현재 계산된 현재값을 가져올수있고, 또는 `.observe(callback)` 으로 그값의 변화를 감지 할 수도 있습니다. 이러한 형식은 잘 사용되지 않지만, 가끔 계산된 'boxed' 값을 넘겨야 할 때 유용하게 사용할 수 있습니다.\n\n```javascript\nimport { observable, computed } from 'mobx'\nvar name = observable.box('John')\n\nvar upperCaseName = computed(() => name.get().toUpperCase())\n\nvar disposer = upperCaseName.observe(change => console.log(change.newValue))\n\nname.set('Dave')\n// prints: 'DAVE'\n```\n\n위 예제에서 `upperCaseName` 을 `observe`로 관찰하지 않으면 Mobx computed는 계산하지 않는다. 따라서 `observe`를 하지 않으면 `upperCaseName.value` 했을 때 값을 얻어 올 수 없다. 대신에 `upperCaseName.get()` 를 사용하면 계산된 값을 얻어 올 순 있다.\n\n`computed` 함수의 두번째 인자로 modifier 객체를 넘길 수 있습니다. 다음과 같은 옵션 값들이 있습니다. `name`, `context`, `set`, `equals`, `requiresReaction`, `keepAlive` 각 옵션값들은 [공홈 참조](https://mobx.js.org/refguide/computed-decorator.html)\n\n### Computeds with arguments\n\n때때로 하나 또는 그 이상의 매개변수를 받아서 computed 값을 갖고 싶을 때가 있을 것이다. 그럴 땐 mobx-util의 `computedFn`을 사용하면 됩니다.\n\n```javascript\n// Parameterized computed views:\n// Create computed's and store them in a cache\nimport { observable, computed } from \"mobx\"\n\nclass Todos {\n  @observable todos = []\n\n  getAllTodosByUser = computedFn(function getAllTodosByUser(userId) {\n    return this.todos.filter(todo => todo.user === userId))\n  })\n}\n```\n\n## Autorun\n\n- autorun 은 함수 자체에 관찰자(observers) 없는 reactive한 함수를 만들 경우 사용됩니다.\n- autorun 은 대게 반응형 코드에서 명령형 코드로 이어짐이 필요할 경우 사용됩니다. 예를 들면 로깅이나 ui update code 에서 사용됩니다.\n- autorun 을 사용할때 제공하는 함수(감싸이는 함수)는 항상 그 즉시 `한번은 실행`된다. 그리고 이후에 그것의 디펜던시들이 변화가 일어날때마다 한번씩 실행됩니다.\n- 대조적으로 `computed(function)`는 오직 관찰자(observers)들이 그 값을 관찰할때 재 계산되는 함수를 만듭니다. 그렇지 않으면 그 함수의 값은 관련이 없는 것으로 간주해서 다시 계산하지 않습니다.\n- autorun 은 자동적으로 실행되야 할 함수를 지닐때 사용되지만 새로운 값을 결과로 가지지 않을때 사용되고 computed 는 그 외에 사용된다고 보면 된다.\n- autorun 은 다른 효과(작용)를 발생시키지만 새로운 값을 만들어 내지 않습니다.\n- 만약 첫번째 인자로 문자열을 autorun 에 넘긴다면 그것은 디버그 네임으로 사용될 수 있다.\n- autorun 의 리턴 값은 해당 autorun 을 해지하는 disposer function 이다. 이 함수는 더이상 autorun 이 필요 없어질때 사용된다.\n- [@observer decorator/function](https://mobx.js.org/refguide/observer-component.html) 과 같이, autoron 은 오직 제공된 함수의 실행중에 사용되는 데이터를 관찰 할 수 있습니다. 이 말은 autorun 처음 실행에서 사용되는 데이터만 관찰할 수 있다는 말 같습니다.\n\n반응(reaction) 그 자체는 autorun 에 제공하는 함수에 유일한 인수로 전달되며 이 인수를 autorun 함수 안에서 다룰수 있다. 이 의미는 두가지 방법으로 더이상 autorun 이 필요 없을때 dispose 할 수 있다는것을 뜻한다.\n\n```javascript\nconst disposer = autorun(reaction => {\n  /* do some stuff */\n})\ndisposer()\n\n// or\n\nautorun(reaction => {\n  /* do some stuff */\n  reaction.dispose()\n})\n```\n\n\n```javascript\nvar numbers = observable([1,2,3]);\nvar sum = computed(() => numbers.reduce((a, b) => a + b, 0));\n\nvar disposer = autorun(() => console.log(sum.get()));\n// prints '6'\nnumbers.push(4);\n// prints '10'\n\ndisposer();\nnumbers.push(5);\n// won't print anything, nor is `sum` re-evaluated\n```\n\nautorun은 두번째 인자로 option 객체를 받을 수 있습니다. `delay`, `name`, `onError`, `scheduler`\n\n## when\n\n```javascript\nwhen(predicate: () => boolean, effect?: () => void, options?)\n```\n\n- when 은 주어진 `predicate` return 값이 true 일때 까지 관찰하고 실행한다. predicate 가 true 값이 리턴되면 주어진 `effect` 값은 실행되고 자동으로 disposed 가 실행된다. 즉, 한번만 실행하고 자동 해지 된다는 뜻이다.\n- 이 함수는 실행되기 전에 미리 취소를 할 수 있도록 disposer 를 리턴한다.\n\n### when-promise\n\n- 만약 `effect` 함수를 제공하지 않으면 when 은 `Promise`가 리턴된다. 이것은 async / await 랑 함께 쓰기 나이스하다.\n\n```javascript\nasync function() {\n    await when(() => that.isVisible)\n    // etc..\n}\n```\n\n## reaction\n\n```javascript\nreaction(() => data, (data, reaction) => { sideEffect }, options?)\n```\n\n- 관측대상을 추적할수 있는 컨트롤을 보다 정밀제어가 가능한 autorun 의 변형입니다.\n- 2 개의 function 을 인자로 받는다. 하나는 data function 으로 추적당하고 data 를 리턴한다. 이 리턴된 값은 두번째 인자로 넘겨지는 것으로 사용됩니다.\n- autorun 과는 달리 side effect 는 생성과 동시에 실행되지 않고 첫번째 인자인 data 표현식이 처음으로 새로운 값으로 리턴되었을때 실행된다. side effect 가 실행되는 동안 side effect 내에서 접근 가능한 observables 들은 tracked 되지 않습니다.\n- reaction 의 return 값으로는 disposer function 이 리턴됩니다.\n- 두번째 인자로 넘겨지는 함수는 effect function 은 2 개의 인자를 받는다. 첫번째 인자는 data function 에서 리턴되는 값이고, 두번째 인자는 현재 반응하는 reaction 이다. 이것은 실행되는 동안에 이 reaction 을 dispose 하는 용도로 사용될 수 있습니다.\n- side effect 는 data expression 에서 accessed 한 데이터에만 반응한다. 이 data 표현식은 사실 effect 에서 사용되는 data 보다 적을 수 있다. 또한 side effect 는 오직 data expression 에 의해 변경되는 data 가 리턴되었을때 반응한다. 다시말해, reaction 은 side effect 에서 필요한것을 생산하도록 요구하는 것입니다.\n\n### example\n\n```javascript\nconst todos = observable([\n  {\n    title: 'Make coffee',\n    done: true,\n  },\n  {\n    title: 'Find biscuit',\n    done: false,\n  },\n])\n\n// wrong use of reaction: reacts to length changes, but not to title changes!\nconst reaction1 = reaction(\n  () => todos.length,\n  length => console.log('reaction 1:', todos.map(todo => todo.title).join(', '))\n)\n\n// correct use of reaction: reacts to length and title changes\nconst reaction2 = reaction(\n  () => todos.map(todo => todo.title),\n  titles => console.log('reaction 2:', titles.join(', '))\n)\n\n// autorun reacts to just everything that is used in its function\nconst autorun1 = autorun(() =>\n  console.log('autorun 1:', todos.map(todo => todo.title).join(', '))\n)\n\ntodos.push({ title: 'explain reactions', done: false })\n// prints:\n// reaction 1: Make coffee, find biscuit, explain reactions\n// reaction 2: Make coffee, find biscuit, explain reactions\n// autorun 1: Make coffee, find biscuit, explain reactions\n\ntodos[0].title = 'Make tea'\n// prints:\n// reaction 2: Make tea, find biscuit, explain reactions\n// autorun 1: Make tea, find biscuit, explain reactions\n```\n\n## (@)observer\n\n- @observer 라고 데코레이터를 사용하는 것은 MobX 에게 \"이 컴포넌트의 rendering 은 observables 관련으로 부터 파생될수 있다.\" 말하는 것과 같다.\n- observer function / decorator 는 react components 를 반응형 컴포넌트로 변환시킬수 있다.\n- 이것은 컴포넌트의 렌더링에 사용되는 데이터가 변경되면 컴포넌트를 강제로 re-rendering 을 하게 만들기 위해서 render 함수를 `mobx.autorun` 으로 감싼다.\n- 'mobx-react' 패키지의 한 부분으로 이용가능하다.\n\n```javascript\nimport { observer } from 'mobx-react'\n\nvar timerData = observable({\n  secondsPassed: 0,\n})\n\nsetInterval(() => {\n  timerData.secondsPassed++\n}, 1000)\n\n@observer\nclass Timer extends React.Component {\n  render() {\n    return <span>Seconds passed: {this.props.timerData.secondsPassed} </span>\n  }\n}\n\nReactDOM.render(<Timer timerData={timerData} />, document.body)\n```\n\nTip: `observer`가 다른 데코레이터나 higher-order-compoenets 와 함께 이용할 필요가 있을땐, `observer`가 가장 먼저 적용되도록 해야한다. 그렇지 않으면 작동안될수 있다.\n\n`observer` 를 observer(class Timer{...}) 로도 이용이 가능하다.\n\n### dereference values inside your components\n\n> `dereference(역참조)` 라는건 주소를 참조하고 있는 변수(reference)를 보고 해당 주소로 찾아가서 값을 보는 것을 말한다. c 언어로 예를 들자면 & 기호가 reference operator 고 \\* 기호가 dereference operator 라고 보면 되겠다.\n\nMobx 는 많은 것을 할 수있지만, 원시타입을 observable 로 만들 수 없다.(비록 boxed obserbables 로 감싸면 observable 로 만들 수 있다.) 그렇기 때문에 값들을 observable 하고 있는게 아니라 객체의 프로퍼티들을 observable 하고 있다는 것이다. 이것이 의미하는건 `@observer`는 사실 역참조한 값에 반응하는것 이다.\n\n좀 더 쉽게 말하면 `const person = {name : 'merlin'}` person 이라는 객체가 있을 때 name 이 observable 이라면 'merlin'이란 값이 바뀌는거에 대해서 포커스를 두는 것이 아니라 `person.name` 의 변화에 포커스를 두고 있다는 사실이다.\n이 때 아마도 person.name 의 `defineProperty` 으로 `get`과 `set` 메서드를 설정해 두어서 그런게 아닐까 싶다.\n그래서 위 예제에서 Timer components 는 다음과같이 초기화 된 경우 반응하지 않는다.\n\n```javascript\nReact.render(<Timer timerData={timerData.secondsPassed} />, document.body)\n```\n\n그래서 observer 하고 있는 컴포넌트 안에서 역 참조한 값을 접근해야 한다.\n\n## Understanding what MobX reacts to\n\nMobx는 90% 정도 유저가 기대하는대로 움직이지만 가끔은 기대하는 것 처럼 움직이지 않을 때가 있습니다. 여기서는 Mobx가 react 하는 것을 어떻게 이해하는지 짚어 볼 것입니다.\n\n- MobX 는 observable 프로퍼티에 반응한다. 이 프로퍼티를 추적하는 함수 실행 동안 읽혀지는 값 입니다.\n- '_reading_' 이라 함은 object 의 프로퍼티에 접근하는 것이다. 예들 들어 user.name or user['name'] 이러한 경우들이다.\n- '_trackable functions_' 라는건 `computed`의 표현입니다, observer component 의 render 메서드 그리고 `when`, `reaction`, 그리고 `autorun`에 첫번째로 전달되는 함수들입니다.\n- '_during_'의 의미는 함수 실행동안에 읽고 있는 오직 observables 들만 추적한다는것을 뜻한다. 이들의 값들은 추적하는 함수에 의해 직접적으로 또는 간접적으로 사용되는지는 중요하지 않습니다.\n\nMobX 는 이럴때 반응하지 않습니다.\n\n- observables 로 부터 얻은 값이지만 tracked function 밖에 있는 값.\n- Observables 들이 비동기에 호출되는 코드 블럭에서 읽혀질때.\n\n**MobX 는 값이 아닌 프로퍼티의 주소를 추적한다. 즉, 주소가 바뀌면 변화를 감지하는 것입니다.**\n\n### Example\n\n```javascript\nlet message = observable({\n  title: 'Foo',\n  author: {\n    name: 'Michel',\n  },\n  likes: ['John', 'Sara'],\n})\n```\n\n![./observed-refs.png](./observed-refs.png)\n\n- tracked function 내의 역참조, `.title` 프로퍼티가 autorun 에 의해 역참조 당했다. 그 이후에 변화가 생기면 이 변화는 감지가 된다. tracked function 안에 trace() 함수를 호출함으로서 MobX 는 추적한다는걸 알수 있다.\n\n```javascript\nautorun(() => {\n  console.log(message.title)\n})\nmessage.title = 'Bar'\n// [mobx.trace] (...)\n```\n\n- non-observable 의 참조값은 변해도 반응하지 않는다. 아래 예제에서 message 는 변했다. 그러나 message 는 observable 한게 아니다 단지 observable 한 객체를 가리키는 변수일 뿐이다. 변수 자체는 observable 하지 않는다.\n\n```javascript\nautorun(() => {\n  console.log(message.title)\n})\nmessage = observable({ title: 'Bar' })\n```\n\n- tracked function 밖에서의 역참조(주소가 아닌 값을 지닌 프로퍼티)는 반응하지 않는다. 아래 예제에서 title 은 observable 한게 아니다. 그래서 꼭 tracked function 안쪽에서 역참조를 진행해야 한다.\n\n```javascript\nvar title = message.title\nautorun(() => {\n  console.log(title)\n})\nmessage.title = 'Bar'\n```\n\n- tracked function 안에서의 역참조는 잘 반응 한다. author 와 author.name 은 모두 점으로 참조하고있습니다. 따라서 MobX 가 이 참조를 추적할 수 있습니다.\n\n```javascript\nautorun(() => {\n  console.log(message.author.name)\n})\nmessage.author.name = 'Sara'\nmessage.author = { name: 'John' }\n```\n\n- observable 한 객체를 tracking 없이 로컬 변수에 저장해서 사용하기. 아래 예제에서는 첫번째 변화에 대해선 잘 감지 할것이다. 그 이유는 message.author 가 주소를 넘기고 로컬 변수인 author 는 그 주소를 받아서 사용하기 때문에 같은 객체를 가리킨다. 그래서 위와 다르게 autorun 에서 반응을 할테지만 두번째 변화에 대해서는 감지를 하지 않는다. 그 이유는 autorun 에 의해 추적되는 author 는 message.author 가 가리키는 또다른 변수이지 message.author 를 추적하진 않는다. autorun 에 있는 author 는 아직 예전 객체를 가리키고 있기 때문이다.\n\n```javascript\nconst author = message.author\nautorun(() => {\n  console.log(author.name)\n})\nmessage.author.name = 'Sara' // 1\nmessage.author = { name: 'John' } // 2\n```\n\n- 아래 예제의 경우에는 업데이트 된 title 을 프린트 하지 않는다. 왜냐하면 autorun 안에서 title 이 사용되지 않았기 때문이다. autorun 은 오직 message 에만 의존하게 된다. 또한 message 는 observable 이 아니다. 그저 상수일 뿐이다. autorun 에서 title 은 사용되지 않았기 때문에 autorun 이랑 관련이 없는 것이다.\n\n```javascript\nconst message = observable({ title: 'hello' })\n\nautorun(() => {\n  console.log(message)\n})\n\n// Won't trigger a re-run\nmessage.title = 'Hello world'\n\n// 해결책들\n\nautorun(() => {\n  console.log(message.title) // clearly, the `.title` observable is used\n})\n\nautorun(() => {\n  console.log(mobx.toJS(message)) // toJS creates a deep clone, and thus will read the message\n})\n\nautorun(() => {\n  console.log({ ...message }) // creates a shallow clone, also using `.title` in the process\n})\n\nautorun(() => {\n  console.log(JSON.stringify(message)) // also reads the entire structure\n})\n```\n\n- tracked function 에서 bound 를 넘치는 접근을 했을때는 반응하지 않는다. 예를 들면 배열에서는 index < length 조건이 되야 한다.\n\n- observable 을 사용하지만 그것의 프로퍼티 접근이 전혀 없을때 반응하지 않는다.\n\n```javascript\nautorun(() => {\n  message.likes\n})\nmessage.likes.push('Jennifer')\n```\n\n- MobX 4 에서는 non-observable 한 프로퍼티 및 아직 존재하지 않은 observable object 프로퍼티 접근이 허용되지 않았지만 MobX 5 에선 반응한다.\n\n- MobX only tracks synchronously accessed data 이 말은 아래 상황에서 확인할 수 있다. 비록 author.name 이 autorun 에 전달되지 않지만 MobX 는 upperCaseAuthorName 에서 발생되는 역참조를 추적할 수 있다. 왜냐하면 그 발생은 autorun 이 실행되는 동안('during') 발생되기 때문이다.\n\n```javascript\nfunction upperCaseAuthorName(author) {\n  const baseName = author.name\n  return baseName.toUpperCase()\n}\nautorun(() => {\n  console.log(upperCaseAuthorName(message.author))\n})\nmessage.author.name = 'Chesterton'\n```\n\n- 반면 아래 상황은 반응하지 않는다. autorun 이 실행되는 동안 어디에서도 accessed 되는 observable 을 만날수가 없다.\n\n```javascript\nautorun(() => {\n  setTimeout(() => console.log(message.likes.join(', ')), 10)\n})\nmessage.likes.push('Jennifer')\n```\n\n- MobX 는 오직 observer 컴포넌트의 render 에 직접적으로 접근되는 data 만 추적합니다.\n  아래 상황에서 <div> 는 사실 MyComponent 에 의해 렌더링 되는 것이 아닌 SomeContainer 에 의해 렌더링 됩니다. 따라서 SomeContainer 의 title 이 정확하게 새로운 message.title 에 반응하는지 확인하기 위해서 SomeContainer 는 observer 이어야 한다.\n\n```javascript\nconst MyComponent = observer(({ message }) => (\n  <SomeContainer title={() => <div>{message.title}</div>} />\n))\n\nmessage.title = 'Bar'\n```\n\n- 만약 SomeContainer 가 외부 라이브러리라면 div 를 우리의 상태가 없는 observer 에 기반한 컴포넌트를 하나 더 만들어야 한다. 이게 싫다면 대안책으로 'mobx-react' 에 내장된 <Observer> 컴포넌트를 이용하자.\n\n```javascript\nconst MyComponent = ({ message }) => (\n  <SomeContainer\n    title={() => <Observer>{() => <div>{message.title}</div>}</Observer>}\n  />\n)\n\nmessage.title = 'Bar'\n```\n\n- 클래스의 로컬 필드에 observable 이 캐싱되는 것을 피하자. 아래 상황에서 author 의 name 의 변화에는 잘 반응 하지만 message 의 author 의 변화에는 반응하지 못한다. 이것은 render() 메서드 밖에서 역참조를 진행 했기 때문이다. 오직 observer 컴포넌트는 render() 메서드가 tracked function 이다. 그래서 간단한 해결책은 render() 메서드 안에서 역참조 하는 것이고 또는 컴포넌트 인스턴스 내에 computed 프로퍼티를 이용해서\n  this.author 를 update 시키면 render 에서 참조하는 값은 예전 주소의 값이므로 변경을 감지하여 반응하게 된다.\n\n```javascript\n@observer\nclass MyComponent extends React.component {\n  author\n  constructor(props) {\n    super(props)\n    this.author = props.message.author\n  }\n\n  render() {\n    return <div>{this.author.name}</div>\n  }\n}\n\n// computed 해결책\n@observer\nclass MyComponent extends React.component {\n  @computed\n  get author() {\n    return this.props.message.author\n  }\n}\n```\n\n- 아래와 같은 상황에서 `<Author author={ message.author.name} />` 와 같이 호출한다면, `Message`는 역참조 컴포넌트가 되어서 message.author.name 이 변화가 생기면 Message 는 re-render 를 할것이다. 그럼에도 불구하고 Author 는 새로운 값을 받았기에 re-render 를 진행할것이다. 이러면 퍼포먼스 저하가 나온다. 따라서 가능한한 늦게 역참조를 진행하는 것이 옳다.\n\n- 만약에 likes 데이터가 문자열이 아닌 객체들로 구성되어있다면, (ex. [{}, {}, {},...]) 그리고 그 객체들이 `Like` 컴포넌트에서 렌더링이 된다고 했을때 `Likes` 컴포넌트는 특정 like 객체의 변화에 re-render 를 하지 않는다.\n\n```javascript\nconst Message = observer(({ message }) => (\n  <div>\n    {message.title}\n    <Author author={message.author} />\n    <Likes likes={message.likes} />\n  </div>\n))\n\nconst Author = observer(({ author }) => <span>{author.name}</span>)\n\nconst Likes = observer(({ likes }) => (\n  <ul>\n    {likes.map(like => (\n      <li>{like}</li>\n    ))}\n  </ul>\n))\n```\n\n| 변화                              | re-rendering component                                           |\n| --------------------------------- | ---------------------------------------------------------------- |\n| message.title = \"Bar\"             | Message                                                          |\n| message.author.name = \"Susan\"     | Author (.author is dereferenced in Message, but didn't change)\\* |\n| message.author = { name: \"Susan\"} | Message, Author                                                  |\n| message.likes[0] = \"Michel\"       | Likes                                                            |\n\n## action\n\n```javascript\naction(fn)\naction(name, fn)\n@action classMethod() {}\n@action(name) classMethod () {}\n@action boundClassMethod = (args) => { body }\n@action(name) boundClassMethod = (args) => { body }\n@action.bound classMethod() {}\n```\n\n- Action 은 state 를 변화시키는 모든것들입니다.\n- Action 은 인자로 함수를 받아서 같은 함수이지만 `transaction`, `untracked`, `allowStateChagnes`. 로 감싸진 함수를 반환한다. 사실 transaction 은 자동으로 적용됩니다.\n- action 은 변화들을 한다발로 묶는다. 그리고나서 computed value 와 reaction 들에게 가장 마지막 action 이 끝난 후에 통지한다. 이렇게 하면 action 이 끝날때 까지 action 실행 중에 나머지 application 은 중간값 또는 아직 끝나지 않은 값은 확인할 수가 없습니다.\n- observable 을 변경하는 모든 함수 또는 side effects 를 만드는 함수에는 (@)action 을 사용하는게 좋습니다.\n- @action 데코레이터를 사용하는 setter 는 지원하지 않습니다. 하지만 computed 프로퍼티의 setter 들은 자동으로 action 이 됩니다.\n- MobX config 에서 state 변화를 반드시 action 을 사용하도록 config 한다면 action 은 필수 적으로 사용되어져야 합니다. (enforceActions 옵션)\n- action decoreator / function 들은 javascript 의 기본적인 binding 룰을 따르게 됩니다. 그러나 `action.bound` 는 자동으로 action 에 대상 객체에 대한 this 를 bind 한다. action 과 다르게 (@)action.bound 는 name 파라미터를 받지 않는다. 대신 action.bound 를 적용하는 프로퍼티 이름에 기반으로 한다. action.bound 와 arrow 함수는 함께 사용하지 말아야 합니다.\n- `runInAction(name?, thunk)` 는 간단한 유틸리티 이다. 이것은 code block 을 받고 익명의 action 을 실행한다. 이것은 즉석에서 액션을 생성하고 실행하는데 유용하다. 예를 들면 비동기적인 절차 안에서 사용하는 예가 있겠다. 간단하게 말해서 `runInaction(f)`은 `action(f)()` 과 같다.\n\n### action 의 4가지 컨셉\n\n- 액션은 명시적으로나 은연중에 실행될 수 있다.\n- Mobx는 은연중에 state를 바꾸는 사고를 피하기 위해서 제약을 둘 수 있습니다.\n- state를 변화시키고 결과적으로 reaction을 이끕니다.\n- Mobx는 모든 파생물은 동기적으로 동작합니다. ( 한번에 2번의 action, 즉 2개의 state를 한번에 바꾸면 state 바꿀때마다 파생물을 계산한다. 그래서 2번의 계산이 이뤄진다. )\n- transaction을 사용하면서 변화에 대해서 그룹을 지을 수 있다.\n- 이때, transaction은 잊어도 된다 왜냐하면 action에서 자동적으로 그것을 적용해 주기 때문이다.\n- 액션은 이름을 가질수 있다. Mobx dev tool에서 보여줄 수 있다.\n- strict 모드를 사용하면 state의 변화를 정의된 영역 안에서만 수정할 수 있게 해준다.\n\n## async action & flow\n\n- action wrapper / decorator 는 오직 현재 함수가 실행이 되고있을때 영향을 미친다. 하지만 현재 함수에 의해 스케쥴 된 함수(단지, 실행함수 말고)는 영향을 미치지 않는다. 이것이 의미하는건 setTimeout, promise then, async , state 를 변화시키는 callback 함수같은 함수들에게 action 으로 감싸줘야 한다는 것이다.\n- 비동기 action 을 생성하는 방법은 몇몇 가지가 있다.\n\n### Promise\n\n```javascript\nmobx.configure({ enforceActions: 'observed' }) // don't allow state modifications outside actions\n\nclass Store {\n  @observable githubProjects = []\n  @observable state = 'pending' // \"pending\" / \"done\" / \"error\"\n\n  @action\n  fetchProjects() {\n    this.githubProjects = []\n    this.state = 'pending'\n    fetchGithubProjectsSomehow().then(\n      projects => {\n        const filteredProjects = somePreprocessing(projects)\n        this.githubProjects = filteredProjects\n        this.state = 'done'\n      },\n      error => {\n        this.state = 'error'\n      }\n    )\n  }\n}\n```\n\n- 위 예제에서는 예외를 던집니다. `fetchGithubProjectsSomehow`에 넘긴 콜백들은 `fetchProject` 액션의 한 부분이 아니기도 하고, action 은 오직 현재 스택에만 적용되기 때문이다.\n- 가장 쉽게 고치는 방법은 callback 을 action 으로 추출하는 방법이 있다. ( 이때, action.bound 를 사용하는 것은 정확한 this 를 얻는데 중요하다. )\n\n```javascript\nmobx.configure({ enforceActions: 'observed' })\n\nclass Store {\n  @observable githubProjects = []\n  @observable state = 'pending' // \"pending\" / \"done\" / \"error\"\n\n  @action\n  fetchProjects() {\n    this.githubProjects = []\n    this.state = 'pending'\n    fetchGithubProjectsSomehow().then(\n      this.fetchProjectsSuccess,\n      this.fetchProjectsError\n    )\n  }\n\n  @action.bound\n  fetchProjectsSuccess(projects) {\n    const filteredProjects = somePreprocessing(projects)\n    this.githubProjects = filteredProjects\n    this.state = 'done'\n  }\n\n  @action.bound\n  fetchProjectsError(error) {\n    this.state = 'error'\n  }\n}\n```\n\n- 위 코드는 깨끗하고 명확할수 있는 코드이지만 약간은 복잡한 flow 를 가지고 있습니다. ( 코드를 읽기에 왔다갔다 할 수 있다. ) 대안책으로는 promise callback 을 action 키워드로 감싸는 방법을 취할 수 있습니다. 해당 action 에 이름을 부여하는것은 추천하지만 의무는 아닙니다.\n\n```javascript\nmobx.configure({ enforceActions: 'observed' })\n\nclass Store {\n  @observable githubProjects = []\n  @observable state = 'pending' // \"pending\" / \"done\" / \"error\"\n\n  @action\n  fetchProjects() {\n    this.githubProjects = []\n    this.state = 'pending'\n    fetchGithubProjectsSomehow().then(\n      // inline created action\n      action('fetchSuccess', projects => {\n        const filteredProjects = somePreprocessing(projects)\n        this.githubProjects = filteredProjects\n        this.state = 'done'\n      }),\n      // inline created action\n      action('fetchError', error => {\n        this.state = 'error'\n      })\n    )\n  }\n}\n```\n\n### runInAction utility\n\n- 인라인 action 의 단점은 TypeScript 가 그것들을 추론하기 어렵다는 것이다. 그래서 모든 callback 에 type 을 적용해야한다. 이렇게 callback 전부에 action 을 생성하는 대신, action 함수안에 callback 을 약간 수정해서 state 를 수정할 수 있다.\n\n이 패턴의 장점은 액션 안을 어지럽히지 않고 전체 프로세스가 끝날 때 가능한 한 모든 상태 수정을 적용하는 것입니다.\n\n```javascript\nmobx.configure({ enforceActions: 'observed' })\n\nclass Store {\n  @observable githubProjects = []\n  @observable state = 'pending' // \"pending\" / \"done\" / \"error\"\n\n  @action\n  fetchProjects() {\n    this.githubProjects = []\n    this.state = 'pending'\n    fetchGithubProjectsSomehow().then(\n      projects => {\n        const filteredProjects = somePreprocessing(projects)\n        // put the 'final' modification in an anonymous action\n        runInAction(() => {\n          this.githubProjects = filteredProjects\n          this.state = 'done'\n        })\n      },\n      error => {\n        // the alternative ending of this process:...\n        runInAction(() => {\n          this.state = 'error'\n        })\n      }\n    )\n  }\n}\n```\n\n- `runInAction` 또한 첫번째 인자로 이름을 넘길수 있다. `runInAction(f)`는 `action(f)()`로 볼 수있다.\n\n### async / await\n\n- Async / await 를 기반으로 하는 함수는 처음에는 혼동스러울수 있다. 왜냐하면 문법적으로 그것들은 동기적인 함수처럼 보이기 때문이다. 이 방법은 @action 이 전체 함수에 적용되는 인상을 준다. 결론적으로 `@action`은 코드블럭에서 첫번째 await 까지 적용이 된다. 그 후에 await 가 비동기적으로 실행이 되고 await 이 끝난 후에 state 를 변경하는 코드는 action 으로 감싸줘야한다.\n\n```javascript\nmobx.configure({ enforceActions: 'observed' })\n\nclass Store {\n  @observable githubProjects = []\n  @observable state = 'pending' // \"pending\" / \"done\" / \"error\"\n\n  @action\n  async fetchProjects() {\n    this.githubProjects = []\n    this.state = 'pending'\n    try {\n      const projects = await fetchGithubProjectsSomehow()\n      const filteredProjects = somePreprocessing(projects)\n      // after await, modifying state again, needs an actions:\n      runInAction(() => {\n        this.state = 'done'\n        this.githubProjects = filteredProjects\n      })\n    } catch (error) {\n      runInAction(() => {\n        this.state = 'error'\n      })\n    }\n  }\n}\n```\n\n### flows\n\n- 내장된 `flow` 빌트인 함수를 사용하는건 나이스한 접근이지만, flow 는 generators 를 이용한다. 초보자들에겐 두려움이 될수 있지만 async/await 과 같이 움직인다고 보면 된다. 단지 async 대신에 `function *` 을 await 대신에 `yield`를 사용하는 것이다. 이 `flow`는 문법적으로 async/await 와 매우 닮아있고 비동기 파트에 대한 action 래핑이 따로 필요 없다는 것이다. 그 결과 깔끔한 코드를 작성할 수 있다.\n\n- `flow`는 함수처럼 사용이 되고 docorator 가 아니다. 또한 MobX 개발툴과 밀접하며 비동기 함수의 절차를 추적하기에 용이합니다.\n\n```javascript\nmobx.configure({ enforceActions: 'observed' })\n\nclass Store {\n  @observable githubProjects = []\n  @observable state = 'pending'\n\n  fetchProjects = flow(function*() {\n    // <- note the star, this a generator function!\n    this.githubProjects = []\n    this.state = 'pending'\n    try {\n      const projects = yield fetchGithubProjectsSomehow() // yield instead of await\n      const filteredProjects = somePreprocessing(projects)\n      // the asynchronous blocks will automatically be wrapped in actions and can modify state\n      this.state = 'done'\n      this.githubProjects = filteredProjects\n    } catch (error) {\n      this.state = 'error'\n    }\n  })\n}\n```\n\n- flow 는 취소가능하다. 이 의미는 리턴되는 promise 에 있는 `cancel()` 함수를 호출할 수 있다는 뜻이다. 이 함수는 generator 를 즉시 중지 시킬수 있지만 finally 절은 실행이 됩니다. 반환된 promise 그 자체는 FLOW_CANCELLED 로 reject 로 귀결된다.\n\n\n\n## react-mobx\n\n- react 는 render 를 호출하는 방법은 2 가지가 있다. setState() 메서드와 forceUpdate() 이다. 여기서 forceUpdate() 메서드를 사용하게 되면 자식 컴포넌트들이 다 다시 render 가 된다.\n- react 에서 render 를 막을수 있는 방법은 shouldComponentUpdate 와 pure component 방법이 있겠다. 여기서 pure component 는 얕은 비교를 통해서 render 를 할지 안할지를 결정한다.\n- react-mobx 는 forceUpdate 메서드를 가지고 화면을 갱신하게 된다. 이때 문제는 불필요한 자식들까지 렌더링이 된다는 것이다. 이때 shouldComponentUpdate 를 오버라이딩 해놓고 얕은 비교를 통해서 업뎃을 할지 안할지를 결정한다. 따라서 prop 에 data 를 넘길때 observable 한 값을 넘기기 보다는 observable 을 포함한 변하지 않은 객체를 넘기는 것이 효율적이다.\n\n### Example \n\nex) [https://codesandbox.io/s/zq52xy34z4](https://codesandbox.io/s/zq52xy34z4) ( 코드 샌드박스에서 사용할 시 : mobx 셋팅이 이미 되어있다. mobx-dev-tools 설치, tsconfig 의 experimentalDecorators 셋팅만 해주면 된다.  ) \n\n#### 예제 1 ) computed , action \n\n```javascript\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { observable, action, computed } from \"mobx\";\nimport { observer } from \"mobx-react\"; // MobX 에서 사용하는 Provider\nimport DevTools from \"mobx-react-devtools\";\n \nmobx.configure({ enforceActions: \"observed\" }) // action 밖에서 state를 변경하는걸 막아준다.\n \nconst t = new class Temperature {\n  @observable unit = \"C\"\n  @observable temperatureCelsius = 25\n   \n  @computed get temperatureKelvin() {\n      console.log(\"계산 Kelvin\")\n      return this.temperatureCelsius * (9/5) + 32\n  }\n    \n  @computed get temparatureFahrenheit() {\n      console.log(\"계산 Fahrenheit\")\n      return this.temperatureCelsius + 273.15\n  }\n \n   \n  @computed get temperature() {\n     console.log(\"계산 temperature\")\n     switch(this.unit) {\n       case \"K\": return this.temperatureKelvin + \"K\"\n       case \"F\": return this.temparatureFahrenheit + \"F\"\n       case \"C\": return this.temperatureCelsius + \"C\"\n     }\n  }\n \n  @action setUnit(newUnit) {\n    this.unit = newUnit\n  }\n    \n  @action setCelsius(degrees) {\n    this.temperatureCelsius = degrees\n  }\n    \n  @action('update temperature and unit') // 액션에 문자열을 넣어서 액션이름을 설정 할 수 있다. dev tools에서 확인할 수 있다.\n  setTemperatureAndUnit(degrees, unit) {\n    this.setCelsius(degrees)\n    this.setUnit(unit)\n  }\n}\n \nconst App = observer(({temperature}) => (\n  <div>\n    {temperature.temperature}\n  </div>\n))\n   \nReactDOM.render(\n  <App temperature={t} />,\n  document.getElementById(\"root\")\n)\n```\n\n\n#### 예제 2) pass observable data through props in Mobx\n\n##### 1) 아래 처럼 하면 App 컴포넌트에서 자식 li 들을 렌더링 클릭시 마다 App 컴포넌트를 render 하므로 성능이 떨어진다. \n\n```javascript\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { observable, action, computed } from \"mobx\";\nimport { observer } from \"mobx-react\"; // MobX 에서 사용하는 Provider\nimport DevTools from \"mobx-react-devtools\";\n \nlet index = 0\n \nmobx.configure({ enforceActions: \"observed\" })\n \nclass Temperature {\n  @observable id = index++\n  @observable unit = \"C\"\n  @observable temperatureCelsius = 25\n   \n  constructor(degrees, unit) {\n    console.log('con')\n    this.setTemperatureAndUnit(degrees, unit)\n \n  }\n   \n  @computed get temperatureKelvin() {\n      console.log(\"계산 Kelvin\")\n      return this.temperatureCelsius * (9/5) + 32\n  }\n    \n  @computed get temparatureFahrenheit() {\n      console.log(\"계산 Fahrenheit\")\n      return this.temperatureCelsius + 273.15\n  }\n \n   \n  @computed get temperature() {\n     console.log(\"계산 temperature\")\n     switch(this.unit) {\n       case \"K\": return this.temperatureKelvin + \"K\"\n       case \"F\": return this.temparatureFahrenheit + \"F\"\n       case \"C\": return this.temperatureCelsius + \"C\"\n     }\n  }\n \n  @action setUnit(newUnit) {\n    this.unit = newUnit\n  }\n    \n  @action setCelsius(degrees) {\n    this.temperatureCelsius = degrees\n  }\n    \n  @action('update temperature and unit')\n  setTemperatureAndUnit(degrees, unit) {\n    this.setCelsius(degrees)\n    this.setUnit(unit)\n  }\n \n  @action inc() {\n    this.setCelsius(this.temperatureCelsius + 1)\n  }\n}\n \nconst temps = observable([])\ntemps.push(new Temperature(20, \"K\"))\ntemps.push(new Temperature(25, \"F\"))\ntemps.push(new Temperature(20, \"C\"))\n \n \nconst App = observer(({temperature}) => (\n  <ul>\n    {temperature.map(t =>\n        <li key={t.id}\n            onClick={() => t.inc()}\n        >\n        {t.temperature}    \n        </li>\n     )\n    }\n    <DevTools />\n  </ul>\n))\n \n \n   \n \nReactDOM.render(\n  <App temperature={temps} />,\n  document.getElementById(\"root\")\n)\n```\n\n##### 2) App 컴포넌트에서 TView 컴포넌트를 따로 분리시켜서 클릭시 전체 렌더링 하는 방식을 막는다. \n\n```javascript\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { observable, action, computed } from \"mobx\";\nimport { observer } from \"mobx-react\"; // MobX 에서 사용하는 Provider\nimport DevTools from \"mobx-react-devtools\";\n \nlet index = 0;\n \nclass Temperature {\n  id = index++;\n  @observable unit = \"C\";\n  @observable temperatureCelsius = 25;\n \n  constructor(degrees, unit) {\n    this.setTemperatureAndUnit(degrees, unit);\n  }\n \n  @computed get temperatureKelvin() {\n    console.log(\"계산 Kelvin\");\n    return this.temperatureCelsius * (9 / 5) + 32;\n  }\n \n  @computed get temparatureFahrenheit() {\n    console.log(\"계산 Fahrenheit\");\n    return this.temperatureCelsius + 273.15;\n  }\n \n  @computed get temperature() {\n    console.log(\"계산 temperature\");\n    switch (this.unit) {\n      case \"K\":\n        return this.temperatureKelvin + \"K\";\n      case \"F\":\n        return this.temparatureFahrenheit + \"F\";\n      case \"C\":\n        return this.temperatureCelsius + \"C\";\n      default:\n        return this.temperatureCelsius + \"C\";\n    }\n  }\n \n  @action setUnit(newUnit) {\n    this.unit = newUnit;\n  }\n \n  @action setCelsius(degrees) {\n    this.temperatureCelsius = degrees;\n  }\n \n  @action(\"update temperature and unit\")\n  setTemperatureAndUnit(degrees, unit) {\n    this.setCelsius(degrees);\n    this.setUnit(unit);\n  }\n \n  @action inc() {\n    this.setCelsius(this.temperatureCelsius + 1);\n  }\n}\n \nconst temps = observable([]);\ntemps.push(new Temperature(20, \"K\"));\ntemps.push(new Temperature(25, \"F\"));\ntemps.push(new Temperature(20, \"C\"));\n \nconst App = observer(({ temperatures }) => (\n  <ul>\n    {temperatures.map(t => (\n      <TView key={t.id} temperature={t} />\n    ))}\n    <DevTools />\n  </ul>\n));\n \n@observer\nclass TView extends Component {\n  render() {\n    const t = this.props.temperature;\n    return <li onClick={this.onTemperatureClick}>{t.temperature}</li>;\n  }\n \n  @action onTemperatureClick = () => {\n    this.props.temperature.inc();\n  };\n}\n \nReactDOM.render(<App temperatures={temps} />, document.getElementById(\"root\"));\n```\n\n#### 예제 3) 비동기시 처리 \n\n- configure({ enforceActions: \"observed\" }) 의 설정이 있을시에 action 밖에서 state를 변경하는걸 막아준다.\n- 비동기 처리 하는 함수를 @action 으로 감싼다 해도 then에 등록된 callback 들의 컨텍스트는 action 밖에서 실행하게 된다. 따라서 action으로 한번 더 감싸줘야 한다. \n- 참고 : https://mobx.js.org/best/actions.html ( 비동기시 action을 처리하는 다양한 방법 ) \n\n```javascript\n\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { observable, action, computed, configure } from \"mobx\";\nimport { observer } from \"mobx-react\"; // MobX 에서 사용하는 Provider\nimport DevTools from \"mobx-react-devtools\";\n \n \nconfigure({ enforceActions: \"observed\" }) // action 밖에서 state를 변경하는걸 막아준다.\n \nconst APPID = \"AppKey를 등록해서 쓰세요 ~\";\nconst temps = observable([]);\nlet index = 0;\n \nclass Temperature {\n  id = index++;\n  @observable unit = \"C\";\n  @observable temperatureCelsius = 25;\n  @observable location = \"Amsterdam, NL\";\n  @observable loading = true;\n  @observable fetchError = false;\n  // constructor(degrees, unit) {\n  //   this.setTemperatureAndUnit(degrees, unit);\n  // }\n  constructor(location) {\n    this.location = location;\n    this.fetch();\n  }\n \n  @action fetch() {\n    window\n      .fetch(\n        `https://api.openweathermap.org/data/2.5/weather?appid=${APPID}&q=${\n          this.location\n        }`\n      )\n      .then(res => res.json(), action(err => (this.fetchError = true)))\n      .then(\n        action(json => {\n           console.log(json)\n          this.temperatureCelsius = json.main.temp - 273.15;\n          this.loading = false;\n        })\n      );\n  }\n  @computed get temperatureKelvin() {\n    console.log(\"계산 Kelvin\");\n    return this.temperatureCelsius * (9 / 5) + 32;\n  }\n \n  @computed get temparatureFahrenheit() {\n    console.log(\"계산 Fahrenheit\");\n    return this.temperatureCelsius + 273.15;\n  }\n \n  @computed get temperature() {\n    console.log(\"계산 temperature\");\n    switch (this.unit) {\n      case \"K\":\n        return this.temperatureKelvin + \"K\";\n      case \"F\":\n        return this.temparatureFahrenheit + \"F\";\n      case \"C\":\n        return this.temperatureCelsius + \"C\";\n      default:\n        return this.temperatureCelsius + \"C\";\n    }\n  }\n \n  @action setUnit(newUnit) {\n    this.unit = newUnit;\n  }\n \n  @action setCelsius(degrees) {\n    this.temperatureCelsius = degrees;\n  }\n \n  @action(\"update temperature and unit\")\n  setTemperatureAndUnit(degrees, unit) {\n    this.setCelsius(degrees);\n    this.setUnit(unit);\n  }\n \n  @action inc() {\n    this.setCelsius(this.temperatureCelsius + 1);\n  }\n}\n \n \n \nconst App = observer(({ temperatures }) => (\n  <ul>\n    <TemperatureInput temperatures={temperatures} />\n    {temperatures.map(t => (\n      <TView key={t.id} temperature={t} />\n    ))}\n    <DevTools />\n  </ul>\n));\n \n@observer\nclass TemperatureInput extends Component {\n  @observable input = \"\";\n \n  render() {\n    return (\n      <li>\n        Destination:\n        <input onChange={this.onChange} value={this.input} />\n        <button onClick={this.onSubmit}>Add</button>\n      </li>\n    );\n  }\n \n  @action onChange = e => {\n    this.input = e.target.value;\n  };\n \n  @action onSubmit = e => {\n    this.props.temperatures.push(new Temperature(this.input));\n    this.input = \"\";\n  };\n}\n \n@observer\nclass TView extends Component {\n  render() {\n    const t = this.props.temperature;\n    return t.fetchError ? (\n      \"fetch 에러.. \"\n    ) : (\n      <li onClick={this.onTemperatureClick}>\n        {t.location}: {t.loading ? \"loading..\" : t.temperature}\n      </li>\n    );\n  }\n \n  @action onTemperatureClick = () => {\n    this.props.temperature.inc();\n  };\n}\n \nReactDOM.render(<App temperatures={temps} />, document.getElementById(\"root\"));\n\n```\n\n\n\n#### 예제 4) mobx-react 의 provider와 inject 를 사용해서 depth가 깊은 컴포넌트에 props로 전달하는 번거로움을 제거하자. \n\n\n```javascript \nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { observable, action, computed, configure, when } from \"mobx\";\nimport { observer, Provider, inject } from \"mobx-react\"; // MobX 에서 사용하는 Provider\nimport DevTools from \"mobx-react-devtools\";\n\nconfigure({ enforceActions: \"observed\" }); // action 밖에서 state를 변경하는걸 막아준다.\n\nconst APPID = \"등록해서 쓰세욥\"\nconst temps = observable([]);\nlet index = 0;\n\nclass Temperature {\n  id = index++;\n  @observable unit = \"C\";\n  @observable temperatureCelsius = 25;\n  @observable location = \"Amsterdam, NL\";\n  @observable loading = true;\n  @observable fetchError = false;\n  // constructor(degrees, unit) {\n  //   this.setTemperatureAndUnit(degrees, unit);\n  // }\n  constructor(location) {\n    this.location = location;\n    this.fetch();\n  }\n\n  @action fetch() {\n    window\n      .fetch(\n        `https://api.openweathermap.org/data/2.5/weather?appid=${APPID}&q=${\n          this.location\n        }`\n      )\n      .then(res => res.json(), action(err => (this.fetchError = true)))\n      .then(\n        action(json => {\n          console.log(json);\n          this.temperatureCelsius = json.main.temp - 273.15;\n          this.loading = false;\n        })\n      );\n  }\n  @computed get temperatureKelvin() {\n    console.log(\"계산 Kelvin\");\n    return this.temperatureCelsius * (9 / 5) + 32;\n  }\n\n  @computed get temparatureFahrenheit() {\n    console.log(\"계산 Fahrenheit\");\n    return this.temperatureCelsius + 273.15;\n  }\n\n  @computed get temperature() {\n    console.log(\"계산 temperature\");\n    switch (this.unit) {\n      case \"K\":\n        return this.temperatureKelvin + \"K\";\n      case \"F\":\n        return this.temparatureFahrenheit + \"F\";\n      case \"C\":\n        return this.temperatureCelsius + \"C\";\n      default:\n        return this.temperatureCelsius + \"C\";\n    }\n  }\n\n  @action setUnit(newUnit) {\n    this.unit = newUnit;\n  }\n\n  @action setCelsius(degrees) {\n    this.temperatureCelsius = degrees;\n  }\n\n  @action(\"update temperature and unit\")\n  setTemperatureAndUnit(degrees, unit) {\n    this.setCelsius(degrees);\n    this.setUnit(unit);\n  }\n\n  @action inc() {\n    this.setCelsius(this.temperatureCelsius + 1);\n  }\n}\n\n\nconst App = inject(({temperatures}) => ({\n  temperatures\n}))(observer(({ temperatures }) => (\n  <ul>\n    <TemperatureInput />\n    {temperatures.map(t => (\n      <TView key={t.id} temperature={t} />\n    ))}\n    <DevTools />\n  </ul>\n)))\n\n@inject(({temperatures}) => ({\n  temperatures\n}))\n@observer\nclass TemperatureInput extends Component {\n  @observable input = \"\";\n\n  render() {\n    return (\n      <li>\n        Destination:\n        <input onChange={this.onChange} value={this.input} />\n        <button onClick={this.onSubmit}>Add</button>\n      </li>\n    );\n  }\n\n  @action onChange = e => {\n    this.input = e.target.value;\n  };\n\n  @action onSubmit = e => {\n    this.props.temperatures.push(new Temperature(this.input));\n    this.input = \"\";\n  };\n}\n\n@observer\nclass TView extends Component {\n  render() {\n    const t = this.props.temperature;\n    return t.fetchError ? (\n      \"fetch 에러.. \"\n    ) : (\n      <li onClick={this.onTemperatureClick}>\n        {t.location}: {t.loading ? \"loading..\" : t.temperature}\n      </li>\n    );\n  }\n\n  @action onTemperatureClick = () => {\n    this.props.temperature.inc();\n  };\n}\n\nReactDOM.render(\n  <Provider temperatures={temps}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n\nfunction isNice(t) {\n  return t.temperatureCelsius > 25\n}\n// 한번만 실행\nwhen(\n  () => temps.some(isNice),\n  () => {\n    const t = temps.find(isNice)\n    alert(`Book now!! ${t.location}`)\n  }\n)\n\n```\n\n## Defining data stroes\n\nMobx를 다루며넛 Mendix에서 발견된 최고의 연습들을 이번 섹션에선 포함하고 있습니다. 이 섹션에서는 의견을 제시하는 것일 뿐 강제로 적용하라고 권유 하지 않습니다. Mobx와 React를 다루는 많은 방법 중 하나일 뿐입니다. \n\n이 섹션에서는 기존 코드 기반 또는 기존 MVC 패턴에서 잘 작동하는 MobX를 사용하여 눈에 거슬리지 않게 작업하는 방법에 중점을 둡니다. store를 구조잡는데 다른 의견은 [mobx-state-tree](https://github.com/mobxjs/mobx-state-tree) 를 이용하는 방법입니다. 이는 구조적으로 공유되는 snapshot, action middlewares, JSON path 등의 멋진 기능들을 제공합니다. \n\n\n### Store\n\nStore는 Flux 아키텍쳐에서 찾아볼수 있고 MVC 패턴에서 컨트롤러와 약간 비교될 수 있습니다. 스토어의 주된 역할은 _logic_ 과 _state_ 를 component에서 테스트 가능한 독립된 기능 단위로 이동하여 프론트엔드 및 백엔드 javascript 모두에서 사용하는 것입니다. \n\n#### Store for user interface state\n\n대부분의 어플리케이션이 그렇듯 2개 이상의 store를 갖는게 이득입니다. 하나의 UI state 와 한개 이상의 domain state 입니다. 이 2가지를 분리 시켜놓는 이점은 domain state를 범용적으로 test하고 재사용할 수 있다는 점입니다. 그리고 다른 어플리케이션에서도 재사용할 수 있습니다. 반면 _ui-state-store_ 의 경우에는 대게 어플리케이션 따라 다릅니다. 하지만 대체적으로 심플합니다. 이 ui store에는 복잡한 로직을 가지고 있지 않고, UI에 대해 느슨하게 결합 된 수많은 정보를 저장합니다. 이것은 대부분의 응용 프로그램이 개발 프로세스 중에 UI 상태를 자주 변경하기 때문에 이상적입니다.\n\nUI stores 에서 찾아볼수 있는건 다음과 같습니다. \n\n- 세션 정보\n- 어플리케이션이 얼마나 로딩 중인지에 대한 정보\n- backend에 저장할 필요 없는 정보\n- UI 전반적으로 영향을 미치는 정보\n  - Window 치수\n  - 접근성 정보\n  - 현재 언어\n  - 현재 활성화 된 테마\n- 관계 없는 다른 컴포넌트들에 영향을 즉시 미치는 User interface\n  - 현재 세션\n  - 툴바의 보여짐, 기타등등\n  - wizard의 상태\n  - 글로벌 overlay 의 상태\n\n이런 구성 요소들은 특별한 컴포넌트 내부에서 시작하는게 좋습니다. (예를 들면 툴바의 visibility 의 경우) 하지만, 곧 어플리케이션 이곳저곳에서 필요하다는걸 느끼게 됩니다. 이러한 순수하게 React를 사용했을때 처럼 정보를 컴포넌트 트리 상위로 전달하는 대신에 _ui-state-store_ 의 state 로 옮겨서 사용하는게 좋습니다. \n\nisomorphic한 어플리케이션을 위해 모든 컴포넌트가 기대한 대로 렌더링 되기 위한 적절한 기본값을 지닌 store의 스텁구현(stub implementation)을 제공되길 원할 것입니다. 그러면 _ui-state-store_ 를 어플리케이션의 컴포넌트 트리에 props로 전달하거나 `mobx-react` 패키지에 있는 `Provier` 그리고 `inject`를 사용해서 전달 할 수 있습니다. \n\n\n```javascript\nimport {observable, computed, asStructure} from 'mobx';\nimport jquery from 'jquery';\n\nexport class UiState {\n    @observable language = \"en_US\";\n    @observable pendingRequestCount = 0;\n\n    // .struct makes sure observer won't be signaled unless the\n    // dimensions object changed in a deepEqual manner\n    @observable.struct windowDimensions = {\n        width: jquery(window).width(),\n        height: jquery(window).height()\n    };\n\n    constructor() {\n        jquery.resize(() => {\n            this.windowDimensions = getWindowDimensions();\n        });\n    }\n\n    @computed get appIsInSync() {\n        return this.pendingRequestCount === 0\n    }\n}\n```\n\n\n### Domain Stores\n\n어플리케이션은 하나 이상의 domain stores를 지니고 있을 것입니다. 이런 스토어들은 어플리케이션의 모든 data에 대해 저장합니다. Todo item, users, books, movies, orders, 이름짓는 모든것이 될 수 있습니다. 어플리케이션은 적어도 한개의 domain store를 가집니다.\n\n한개의 domain store는 어플리케이션의 한가지 컨셉을 책임집니다. 하지만 한가지 컨셉은 다양한 서브 타입들의 형태를 소유할 수 있습니다. 그리고 그것은 종종 (순환) 트리구조가 됩니다. 예를 들면: 한가지 제품에 대한 domain store와 여러 주문과 주문라인들에 대한 한가지 domian store가 있을 수 있습니다. 경험적으로 볼때 만약 두가지 항목사이가 포함관계(HAS-A: 합성과 집합)라면, 그것들은 전형적으로 같은 store에 있는게 좋습니다. \n\n다음은 store의 책임에 관한 겁니다. \n\n- 도메인 객체(domain objects)를 인스턴스화 합니다. 또한 해당 도메인 객체가 this(store 자신)을 알고 있는지도 확인하십시요.\n- 각 도메인 객체가 중복되지 않게 하나만 인스턴스화를 하게 만드십시요. 같은 유저나 order 또는 todo가 메모리에 두번 저장되게 두지 마십시요. 이 방법은 안전하게 참조를 사용할수 있는 방법이고 가장 최신의 레퍼런스를 확인 할 수 있는 방법입니다.\n- 백엔드 통합을 제공하십시오. 필요할 때 데이터를 저장하십시오.\n- 만약 백엔드에서 업데이트 데이터를 받는다면 존재하는 인스턴스를 업데이트 하십시요.\n- 독립적이고, 범용적인고, test가능한 어플리케이션의 컴포넌트를 제공하십시요.\n- 테스트가 가능한 store 인지 확인하고 server-side에서도 돌아갈 수 있는지 확인하십시요 아마 websocket/http request 를 분리 하게 될것입니다. 그래서 커뮤니케이션 하는 영역을 추상화 할 수 있습니다. \n- store는 오직 하나만 인스턴스화 해야합니다. \n\n#### Domain objects\n\n각 도메인 object는 자신의 class를 사용해서 표현해야 합니다. 해당 클래스는 비정규화 된 형식으로 데이터를 저장하는 것을 추천합니다. 클라이언트 측 애플리케이션 상태를 일종의 데이터베이스로 취급 할 필요는 없습니다.\n실제 참조, 순환 데이터 구조 그리고 인스턴스의 메서드는 Javascript의 매우 강한 컨셉입니다. Domin objects는 직접적으로 다른 스토어에 도메인 오브젝트를 참조 할 수 있습니다. 기억해야하는점은 우리의 액션과 뷰를 가능한 한 단순하게 유지하고, 참조를 관리하고, 가비지 수집을 집적 수행해야 할 수도 있습니다. 많은 Flux 아키텍처와 달리 MobX를 사용하면 데이터를 표준화 할 필요가 없으므로 비즈니스 규칙, 작업 및 사용자 인터페이스와 같이 응용 프로그램의 본질적으로 복잡한 부분을 훨씬 간단하게 구축 할 수 있습니다.\n\n\n도메인 objects는 모든 그들의 로직을 응용 프로그램에 적합한 로직이 속해있는 스토어에게 위임 할 수 있습니다. (ex. this.store.removeTodo(this)) 도메인 객체를 일반 객체로 표현할 수 있지만 클래스는 일반 객체에 비해 몇 가지 중요한 이점이 있습니다.\n\n- 클래스는 메서드를 지닐 수 있습니다. 이것은 도메인 개념을 독립형으로 사용하기가 더 쉬워지고 응용 프로그램에 필요한 상황 인식의 양이 줄어 들게 됩니다. 그냥 objects만 넘기십시요. store를 전달하거나 또는 액션들이 인스턴스의 메서드로만 사용할 수 있다면 이러한 액션들을 object에 적용될 수 있는지 없는지 파악하지 않아도 됩니다. 특히 큰 어플리케이션 환경에서는 그렇습니다.\n- 속성과 메소드의 가시성을 세밀하게 제어 할 수 있습니다.\n- 생성자 함수를 사용하여 생성된 개체는 관측 가능한 특성과 함수, 관측 불가능한 특성과 방법을 자유롭게 혼합할 수 있습니다.\n- 그것들은 쉽게 알아볼 수 있으며 엄격하게 타입을 확인할 수 있습니다.\n\n \n```javascript\nimport {observable, autorun} from 'mobx';\nimport uuid from 'node-uuid';\n\nexport class TodoStore {\n    authorStore;\n    transportLayer;\n    @observable todos = [];\n    @observable isLoading = true;\n\n    constructor(transportLayer, authorStore) {\n        this.authorStore = authorStore; // Store that can resolve authors for us\n        this.transportLayer = transportLayer; // Thing that can make server requests for us\n        this.transportLayer.onReceiveTodoUpdate(updatedTodo => this.updateTodoFromServer(updatedTodo));\n        this.loadTodos();\n    }\n\n    /**\n     * Fetches all todos from the server\n     */\n    loadTodos() {\n        this.isLoading = true;\n        this.transportLayer.fetchTodos().then(fetchedTodos => {\n            fetchedTodos.forEach(json => this.updateTodoFromServer(json));\n            this.isLoading = false;\n        });\n    }\n\n    /**\n     * Update a todo with information from the server. Guarantees a todo\n     * only exists once. Might either construct a new todo, update an existing one,\n     * or remove a todo if it has been deleted on the server.\n     */\n    updateTodoFromServer(json) {\n        var todo = this.todos.find(todo => todo.id === json.id);\n        if (!todo) {\n            todo = new Todo(this, json.id);\n            this.todos.push(todo);\n        }\n        if (json.isDeleted) {\n            this.removeTodo(todo);\n        } else {\n            todo.updateFromJson(json);\n        }\n    }\n\n    /**\n     * Creates a fresh todo on the client and server\n     */\n    createTodo() {\n        var todo = new Todo(this);\n        this.todos.push(todo);\n        return todo;\n    }\n\n    /**\n     * A todo was somehow deleted, clean it from the client memory\n     */\n    removeTodo(todo) {\n        this.todos.splice(this.todos.indexOf(todo), 1);\n        todo.dispose();\n    }\n}\n\nexport class Todo {\n\n    /**\n     * unique id of this todo, immutable.\n     */\n    id = null;\n\n    @observable completed = false;\n    @observable task = \"\";\n\n    /**\n     * reference to an Author object (from the authorStore)\n     */\n    @observable author = null;\n\n    store = null;\n\n    /**\n     * Indicates whether changes in this object\n     * should be submitted to the server\n     */\n    autoSave = true;\n\n    /**\n     * Disposer for the side effect that automatically\n     * stores this Todo, see @dispose.\n     */\n    saveHandler = null;\n\n    constructor(store, id=uuid.v4()) {\n        this.store = store;\n        this.id = id;\n\n        this.saveHandler = reaction(\n            // observe everything that is used in the JSON:\n            () => this.asJson,\n            // if autoSave is on, send json to server\n            (json) => {\n                if (this.autoSave) {\n                    this.store.transportLayer.saveTodo(json);\n                }\n            }\n        );\n    }\n\n    /**\n     * Remove this todo from the client and server\n     */\n    delete() {\n        this.store.transportLayer.deleteTodo(this.id);\n        this.store.removeTodo(this);\n    }\n\n    @computed get asJson() {\n        return {\n            id: this.id,\n            completed: this.completed,\n            task: this.task,\n            authorId: this.author ? this.author.id : null\n        };\n    }\n\n    /**\n     * Update this todo with information from the server\n     */\n    updateFromJson(json) {\n        // make sure our changes aren't sent back to the server\n        this.autoSave = false;\n        this.completed = json.completed;\n        this.task = json.task;\n        this.author = this.store.authorStore.resolveAuthor(json.authorId);\n        this.autoSave = true;\n    }\n\n    dispose() {\n        // clean up the observer\n        this.saveHandler();\n    }\n}\n\n```\n## 참조\n\n- [https://mobx.js.org/](https://mobx.js.org/)\n- [https://velog.io/@velopert/MobX-1-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-9sjltans3p](https://velog.io/@velopert/MobX-1-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-9sjltans3p)\n- [https://velog.io/@velopert/- MobX-2-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-MobX-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-oejltas52z](https://velog.io/@velopert/- MobX-2-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-MobX-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-oejltas52z)\n- [https://velog.io/@velopert/MobX-3-%EC%8B%AC%ED%99%94%EC%A0%81%EC%9D%B8-%EC%82%AC%EC%9A%A9-%EB%B0%8F-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95-tnjltay61n](https://velog.io/@velopert/MobX-3-%EC%8B%AC%ED%99%94%EC%A0%81%EC%9D%B8-%EC%82%AC%EC%9A%A9-%EB%B0%8F-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95-tnjltay61n)\n- [https://egghead.io/lessons/react-sync-the-ui-with-the-app-state-using-mobx-observable-and-observer-in-react](https://egghead.io/lessons/react-sync-the-ui-with-the-app-state-using-mobx-observable-and-observer-in-react)\n- [https://www.youtube.com/watch?v=cXi_CmZuBgg&feature=youtu.be](https://www.youtube.com/watch?v=cXi_CmZuBgg&feature=youtu.be\n","excerpt":"Intro MobX 의 특징을 알아보고 공부하자. MobX 의 공홈을 독파해보자. Concepts State state 란 어플리케이션을 이끄는 데이터 입니다. 흔히 todo items의 list 같은 domain specific state 라고 하…","fields":{"slug":"/hello-mobx.md/"},"frontmatter":{"date":"Dec 31, 2018","title":"hello-MobX","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n## intro\n\n- Node.js 에서 사용되는 use 함수와 redux에서 사용되는 middleware 들은 어떤 원리로 동작하는지 알아보자.\n\n## 문제인식\n\n- 어떠한 함수 호출 속에서 내가 원하는 작업을 중간에 끼워 넣고 싶다.\n- 원하는 작업이 서버를 거쳐서 오는 경우나 DB를 거쳐서 오는 경우가 있을 수 있으니 비동기 작업도 있을 수 있다.\n- 호출 순서를 보장받고 싶다.\n- 기능별로 분리된 모듈로서 관리하고 싶다.\n\n```javascript\n// App의 execute 하기 전에 logging 와 saveStorage 모듈을 끼워 넣고싶다.\nconst App = function () {\n  let state = {}\n  this.execute = function(){\n    state.exe = true\n    console.log('execute')\n  }\n  this.getState = function(){\n    return state\n  }\n}\n\n// 서드파티로 위에껄 제공한다고 했을때..\n// 아래 코드는 사용자 코드\n\nconst app = new App();\n\napp.execute();\n\n```\n\n- 위와 같은 모듈이 있을때 사용자(App 모듈을 사용하는 사용자)는 execute 하기전에 내가 만든 logging 함수와 execute 하고나서의 saveStorage 함수를 끼워넣고 싶다.\n\n### 의식의 흐름대로\n\n```javascript\nconst app = new App();\n\nconsole.log(app.getState()) // logging \napp.execute();\nsaveStorage(app.getState()) // saveStorage\n```\n- 앞뒤로 붙일순 있지만, 매번 이렇게 추가할수 없고, 비동기시 모듈을 실행할시 문제가 될 수 있다. \n\n### execute 몽키패칭\n\n```javascript\nlet next = app.execute;\n\napp.execute = function customExecute(){\n  console.log(app.getState()) // logging \n  next()\n  saveStorage(app.getState()) // saveStorage\n}\n\n```\n- 위와 같이 작성을 해도 될것이다. 하지만 어떤 api가 덮어쓰기를 원할까???\n\n### 몽키패칭 숨기기\n\n- 기존 execute를 덮어쓰지말고 새로운 함수를 반환하는건 어떨까??\n- 또한 각 모듈을 함수로 분리해서 관심사를 분리하자.\n\n```javascript\n// logger 미들웨어\nfunction loggerExecute(app){\n  let next = app.execute\n\n  return function(){\n    console.log(app.getState()) // logging \n    let result = next()\n    return result\n  }\n}\n// save 미들웨어\nfunction saveExecute(app){\n   let next = app.execute\n\n  return function(){\n    let result = next()\n    saveStorage(app.getState()) // saveStorage\n    return result\n  }\n}\n\nconst app = new App();\napp.execute = loggerExecute(app)\napp.execute = saveExecute(app)\n\napp.execute()\n```\n\n### 몽키패칭 제거하기\n\n- 위와 같이 해도 우린 execute 함수를 덮어쓰고있다.\n- 그 이유는 그래야 우리가 등록한 미들웨어(모듈들)을 다 실행시킬수가 있기 떄문이다. 만약 덮어씌우지 않는다면 loggerExecute 나 saveExecute 이 함수 안에서 app.execute는 원본의 app.execute를 실행할 것이다. \n- 우리가 logging , saveStorage 모듈 말고도 다른 서드파티 모듈들을 실행시키고 싶다면 체이닝을 해야한다.\n- 덮어쓰는 체이닝 말고도 미들웨어에서 next 함수를 매개변수로 받는 방법이 있다.\n\n\n```javascript\nconst App = function () {\n  let state = {}\n  this.execute = function(){\n    state.exe = true\n    console.log('execute')\n  }\n  this.getState = function(){\n    return state\n  }\n  this.applyMiddleware = function(middlewares){\n    middlewares = middlewares.slice();\n    middlewares.reverse();\n\n    let execute = this.execute;\n    middlewares.forEach(middleware =>\n      execute = middleware(execute)\n    );\n    \n    this.execute = execute\n  }\n}\n\n// logger 미들웨어\nfunction loggerExecute(next){\n\n  return function(){\n    console.log(app.getState()) // logging \n    let result = next()\n    return result\n  }\n}\n// save 미들웨어\nfunction saveExecute(next){\n   \n  return function(){\n    let result = next()\n    saveStorage(app.getState()) // saveStorage\n    return result\n  }\n}\n\nconst app = new App();\n\napp.applyMiddleware([loggerExecute, saveExecute]) // 방법 1.\n\napp.use(loggerExecute) // 방법 2.\napp.use(saveExecute) \n\napp.execute()\n```\n- 방법 1. 또는 방법 2. 와 같이 진행된다면 사용자 코드에선 강제로 api를 덮어 써야 하는 코드를 작성하지 않아도 된다.\n\n\n\n**위와 같은 문제인식을 생각해보았는데 이럴때 필요한게 미들웨어 패턴을 이다.**\n\n\n## Middleware Pattern\n\n### example 1 \n\n```javascript\n\nvar Middleware = function() {};\n\nMiddleware.prototype.use = function(fn) {\n  var self = this;\n\n  this.go = (function(stack) {\n    return function(next) {\n      stack.call(self, function() {\n        fn.call(self, next.bind(self));\n      });\n    }.bind(this);\n  })(this.go);\n};\n\nMiddleware.prototype.go = function(next) {\n  next();\n};\n```\n\n\n```javascript\nvar middleware = new Middleware();\n\nmiddleware.use(function(next) {\n  var self = this;\n  setTimeout(function() {\n    self.hook1 = true;\n    next();\n  }, 10);\n});\n\nmiddleware.use(function(next) {\n  var self = this;\n  setTimeout(function() {\n    self.hook2 = true;\n    next();\n  }, 10);\n});\n\nvar start = new Date();\nmiddleware.go(function() {\n  console.log(this.hook1); // true\n  console.log(this.hook2); // true\n  console.log(new Date() - start); // around 20\n});\n```\n\n- 느낌 : 원본 go , 사본 go1, 사본 go2 이렇게 메모리에 적제 시켜놓구 ( use 함수를 써서 ) 최종적으로는 사본 go2를 호출 그럼 사본 go2는 사본 go1 을 호출하고 사본 go1 은 원본 go를 호출,\n각각의 go에는 등록해뒀던 코드를 실행하고 이 다음에 실행해야 할 코드를 인자로 받는다. \n- use 를 사용해서 등록되는 함수는 클로저 함수에 의해 function으로 감싸져서 기억되고 있다가 그 클로저가 next 인자와 실행되는 순간 본래 go 함수의 next 인자로 전달이 된다. \n\n```javascript\n// sudo code\noriginal go = function ( next ){\n  next();\n}\n\n실행 use(regi1Fun)\noveride1 go = function(next){\n  origianl go (function(){\n    regi1Fun(next)\n  })\n}\n\n실행 use(regi2Fun)\noveride2 go = function(next){\n  overide1 go (function(){\n    regi2Fun(next)\n  })\n}\n\n실행 go(regi3Fun)\n\n// 실행순서\n실행 go(regi3Fun) -> overide2 go 실행 ( next : regi3Fun ) -> overide1 go 실행 ( next : function(){regi2Fun(next : regi3Fun)} ) -> original go 실행 ( next: regi1Fun(next : function(){regi2Fun(next : regi3Fun)}) ) \n```\n\n- 결국 `regi1Func(function(){regi2Func(regi3Func)})` 이 모양을 만들기 위해 존재하는 로직들이다.\n\n\n### example 2\n\n```javascript\nconst App = () => {\n  const middlewrares = []\n\n  const use = fn => middlewrares.push(fn)\n\n  const runMiddelwrares = index => {\n    const count = middlewrares.length\n    if( index < count ){\n      middlewrares[index].call(null, () => runMiddelwrares(index+1))\n    }\n  }\n\n  const get = () => {\n    runMiddlewares()\n    console.log('get')\n  }\n}\n```\n\n```javascript\nconst app = App()\napp.use(next) = > {\n  setTimeout(() => {\n    console.log('first one')\n    next()\n  },1000)\n}\n\napp.use(next) = > {\n  setTimeout(() => {\n    console.log('second one')\n    next()\n  },1000)\n}\n\napp.use(next) = > {\n  setTimeout(() => {\n    console.log('third one')\n    next()\n  },1000)\n}\n\napp.get()\n```\n\n### example 3\n\n- redux 미들웨어\n\n```javascript\nconst logger = store => next => action => {\n  console.log('dispatching', action);\n  let result = next(action);\n  console.log('next state', store.getState());\n  return result;\n};\n\nconst crashReporter = store => next => action => {\n  try {\n    return next(action);\n  } catch (err) {\n    console.error('Caught an exception!', err);\n    Raven.captureException(err, {\n      extra: {\n        action,\n        state: store.getState()\n      }\n    });\n    throw err;\n  }\n}\n```\n\n```javascript\n// 주의: 적당히 구현함!\n// Redux API가 **아님**.\n\nfunction applyMiddleware(store, middlewares) {\n  middlewares = middlewares.slice();\n  middlewares.reverse();\n\n  let dispatch = store.dispatch;\n  middlewares.forEach(middleware =>\n    dispatch = middleware(store)(dispatch)\n  );\n\n  return Object.assign({}, store, { dispatch });\n}\n```\n\n\n## 정리\n\n- 필요한 정보를 먼저 받고 함수 리턴후 그다음 나중에 실행해야하는거 받고 먼저 받은거 실행하면서 나중에 실행해야하는걸 인자로 전달\n\n\n## 출처 \n\n- [https://gist.github.com/darrenscerri/5c3b3dcbe4d370435cfa](https://gist.github.com/darrenscerri/5c3b3dcbe4d370435cfa)\n- [https://www.youtube.com/watch?v=E5JaeELl2RE](https://www.youtube.com/watch?v=E5JaeELl2RE)\n- [https://dobbit.github.io/redux/advanced/Middleware.html](https://dobbit.github.io/redux/advanced/Middleware.html)","excerpt":"intro Node.js 에서 사용되는 use 함수와 redux에서 사용되는 middleware 들은 어떤 원리로 동작하는지 알아보자. 문제인식 어떠한 함수 호출 속에서 내가 원하는 작업을 중간에 끼워 넣고 싶다. 원하는 작업이 서버를 거쳐서 오는 …","fields":{"slug":"/hello-middleware.md/"},"frontmatter":{"date":"Nov 15, 2018","title":"hello middleware","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# High Order Function에 대해서 생각을 적는다.\n\n## 서론\n\n- 기본적인 high order function (고차함수) 특성을 이해한다.\n- high order function 을 썼을때의 이점과 어느 상황에서 사용이 될 수 있을지 생각해 본다.\n- Promise 와 react-thunk를 알아보면서 느꼈던 high order function(고차함수)에 대해서 생각해 본다. \n\n## high order function 정의 \n\n- Taking Function as Arguments\n- Returning Functions as Results\n\n\n## 상황\n\n### 함수형 자바스크립트\n\n- 미리 넣어두기 ( 느낌 )\n\n### 동기식 로직에서 중간에 비동기 로직이 들어가야 할 경우.\n\n- 내가 다음에 실행하는거 알고 있으니 나한테 인자로 함수를 넣어줘봐 내가 그 함수 인자로 그 다음에 실행해야하는거 넣어줄게 그러면 너는 그 인자를 비동기 후에 실행 시키면 되. ( 느낌 )\n\n## 리엑트 미들웨어\n\n- 어떤 특정한 기능을 하는 함수(A)를 다른 함수를 인자로 주입 한뒤 더 추가 기능을 수행할 수 있는 함수를 작성하고 주입된 함수(A)를 실행하는 코드 작성, 그 후에 그 특정한 기능을 하는 함수(A)를 대체 한다. 그러고 나면 처음에 주입한 함수(A)를 확장할 수 있다. \n\n## 커링\n\n- 어떤 연산을 수행할 때 필요한 값 중 일부를 저장하고 나중에 나머지 값을 전달 받는 기법, 이를 위해 다른 함수를 반환하는 함수를 사용하며, 이를 커링된 함수라 부른다.\n\n```javascript\nconst userLogs = userName => message => \n  console.log(`${userName} -> ${message}`)\n\nconst log = userLogs('merlin');\n\nlog('hi merlin, i am ready message')\n\nfetch('url').then(\n  data => log(`response ${data}`)\n)\n```\n\n## 결론\n\n- 다른 함수를 반환하는 고차 함수는 자바스크립트에서 비동기적인 실행 맥락을 처리할 때 유용하다.\n- 함수를 반환하는 고차 함수를 이용하면 필요할 때 재활용할 수 있는 함수를 만들 수 있다.\n\n\n\n## 참조\n\n- [https://www.sitepoint.com/higher-order-functions-javascript/](https://www.sitepoint.com/higher-order-functions-javascript/)","excerpt":"High Order Function에 대해서 생각을 적는다. 서론 기본적인 high order function (고차함수) 특성을 이해한다. high order function 을 썼을때의 이점과 어느 상황에서 사용이 될 수 있을지 생각해 본다. P…","fields":{"slug":"/think-highOrderFunction.md/"},"frontmatter":{"date":"Nov 05, 2018","title":"thinking high order function","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Goal\n\n- 다양한 자바스크립트 패턴을 익히고 어느 상황에서 사용되는지 파악한다.\n\n## Contents \n- [callback pattern](#callback)\n- [promise pattern](#promise)\n- [partial pattern](#partial)\n- [memoization pattern](#memoization)\n- [singleton pattern](#singleton)\n- [factory pattern](#factory)\n- [sandbox pattern](#sandbox)\n- [decoration pattern](#decoration)\n- [strategy pattern](#strategy)\n- [proxy pattern](#proxy)\n- [chaning pattern](#chaning)\n\n\n\n\n## Pattern\n\n### <span id=\"callback\">callback pattern</span>\n- 콜백은 나중에 실행할 부차 함수에 인자로 넣는 함수다. \n- 여기서 콜백이 실행될 '나중'시점이 부차 함수의 실행 완료 이전이면 동기, 반대로 실행 완료 이후면 비동기라고 본다.\n\n#### 시나리오 \n\n- 컨퍼런스에 attend(참가자) 등록을 하는 시스템이 있다.\n- 한명 또는 여러명을 한번에 참가 등록을 할수 있다.\n- attend(참가자)는 또는 참가자들은 참가자 등록이 되었는지 안되었는지 확인할 수 있다.\n- attend(참가자)는 또는 참가자들은 이름을 알 수 있다. \n\n#### code\n\n```javascript\nvar C = {};\n// singleton \nvar C.attend = function(name){\n  var fullName = name;\n  return {\n    registry: function(){},\n    isRegistry: function(){},\n    getFullName: function(){}\n  }\n}\n\n// 참가자 한명이 생성되었다. \n// 참가자는 참가자 등록에 실제 현실에선 수동적이지만 oop 에선 능동적으로 생각한다.\nvar attendee1 = C.attend('merlin1'); \nvar attendee2 = C.attend('merlin2'); \n\nvar C.attendeeCollection = function(){\n  var attendees = [];\n\n  return {\n\n    contains: function (attendee) {\n      return attendees.indexOf(attendee) > -1; // 들어있니??\n\n    },\n    add: function (attendee) {\n      if (!this.contains(attendee)) {\n        attendees.push(attendee);\n      }\n\n    },\n    remove: function (attendee) {\n      var index = attendees.indexOf(attendee);\n\n      if (index > -1) {\n        attendees.splice(index, 1);\n      }\n\n    },\n    iterate: function (callback) {   // 반복..\n      // attendees의 각 attendee에 대해 콜백을 실행한다..\n      attendees.forEach(callback);\n\n    }\n\n  }\n}\n\nfunction addAttendeesToCollection(attendeeArray) {\n      attendeeArray.forEach(function(attendee) {\n        collection.add(attendee);\n      });\n}\n\nvar attendees = Conference.attendeeCollection();\naddAttendeesToCollection([attendee1, attendee2])\nattendees.iterate(function doCheckIn(attend) { // 익명의 콜백함수 -> 디버깅 용이함을 위해 이름을 지정한다. \n  attend.checkIn();\n})\n\n```\n\n#### 주의사항\n- 콜백을 사용할때는 디버깅에 용이하기 위해 이름을 붙여주자.\n- 콜백 헬이 발생할때는 편 코딩으로 해결할수 있다.\n- 콜백 함수 안의 this를 주의하자.\n\n#### 정리\n- 한가지 일을 여러번 수행해야 할때 함수하나를 인자로 보내(콜백 패턴) 여러번 호출을 진행할수 있다.\n- A작업이 끝난뒤에 B작업이 수행되어지길 바랄때 콜백 패턴을 이용할 수 있다.\n\n### <span id=\"promise\">promise pattern</span>\n- 비동기 액션을 초기화하고 성공과 실패 케이스를 각각 처리할 콜백을 준다.\n- 이벤트 기반의 비동기 프로그래밍보다 훨씬 더 이해하기 쉽고 우아하며 탄탄한 코드를 작성할 수 있다.\n\n### <span id=\"partial\">partial pattern</span>\n- 커링 요소에 뭔가 더 보태서 기능을 할 수있게 끔 만드는 패턴이다.\n- 인자가 여럿 있고 그중 일부는 값이 불변인 함수를 쓸 경우가 있다. 이때 같은 값을 계속 반복하기보다 원본함수를 새로운 함수로 감싼 다음, 상수 인자는 건네주고 값이 달라지는 나머지 인자만 표출하는 것이 좋다.\n- 값이 불면인 상수 인자를 지난 함수 호출부는 상수성을 캡슐화하여 함수를 새로 만드는 것이 좋다.\n- 커링은 여러 인자를 거느린 함수를 인자 하나만으로 취하는 여러 단계의 함수들로 쪼갠다. \n\n#### 시나리오 \n\n- 행사장 근처에 있는 음식점 위치를 알려주는 서드파티 웹 서비스가 있다고 하자.\n- `getRestaurantsWithinRadius(address, radiusMiles, cuisine)` 요건상 address와 cuisine부분은 변경의 필요성이 없어 보인다. \n- `restaurantApi` 에서 반환하는 api 객체에 새로운 메서드를 집어넣기로 하자.\n- address 와 raius 파라미터를 고정한 채 `getRestaurnatsNearConference(cuisine)` 가 `getRestaurantsWithinRadius` 반환값을 무조건 반환하게 하자.\n\n#### code\n\n```javascript\nfunction addGetRestaurantsNearConference(targetInfo) {\n    'use strict';\n\n    //ThirdParty.retaurantApi() 가 반환한 원본 API\n    var api = Aop.next.call(this, targetInfo); // Aop.next 는 원본 함수에 원본 인자를 넣어 호출해준다...\n\n\n    //API에 추가할 함수\n    function getRestaurantsNearConference(cuisine) {\n      return api.getRestaurantsWithinRadius(\n        '울산 남구 신정로 20번길 988', 2.0, cuisine);\n      // 앞에 2개의 인자는 값이 불변인 상수 인자.\n\n    }\n\n    // 없으면 이 함수를 추가한다\n    api.getRestaurantsNearConference = api.getRestaurantsNearConference || getRestaurantsNearConference;\n\n    //수정한 API를 반환한다\n    return api;\n\n  },\n```\n\n### <span id=\"memoization\">memoization pattern</span>\n- 일명 기억패턴 , 보통 함수 호출시 전달받은 인자를 키로 그 반환 결과를 어떤 구조체에 저장하고, 같은 키를 인자로 다시 함수를 호출하면 저장해둔 값을 꺼내어 바로 바환한다. 물론, 이때 함수 본체는 그냥 건너 뛴다. \n\n#### 시나리오\n- 서드파티 api가 요청 건당 과금을 하는 통해 카드 청구서가 수북하다.\n- 그러니 검색 결과를 어디다가 저장해놓았다가 다른 참가자가 같은걸 요구하게 되면 그 데이터를 그대로 반환하면 좋을꺼 같다.\n- 현재 제공되고 있는 api에 퍼사드(facade)나 래퍼(wrpper)를 끼워넣고 이전 검색 결과를 저장/반환하는 기능을 붙이면 된다.\n- 여기서 퍼스드의 경우에는 프로그래밍을 잘 모르는 사용자에게 최소한의 api만 공개하는, 이렇게 일부만 노출하는 패턴을 퍼사드 패턴이라고 한다. \n\n#### code\n```javascript\nmemoizedRestaurantApi = function (thirdPartyApi) {\n  'use strict';\n\n  var api = thirdPartyApi,\n    cache = {};\n\n  return {\n    getRestaurantsNearConference: function (cuisine) {\n      if (cache.hasOwnProperty(cuisine)) {\n        return cache[cuisine];\n      }\n\n      var returnPromise = api.getRestaurantsNearConference(cuisine);\n\n      cache[cuisine] = returnPromise;\n      return returnPromise;\n    }\n  }\n```\n\n\n\n### <span id=\"singleton\">singleton pattern</span>\n- 다중 객체 인스턴스를 만들 필요가 없거나, 오히려 만들면 안 될 때도 있다. 이렇게 하나의 객체 인스턴스만 존재해야 할 때는 싱글톤 패턴을 사용한다.\n\n#### 시나리오\n- 위에서 생각해봤던 메모이제이션을 적용했던 `restaurantApi` 의 인스턴스(api)가 2개 만들어져서 각각 똑같은 인자로 `getRestaurantsWithinRadius` 함수를 2번 객체를 호출하면 1번 객체의 함수 호출 후 캐시된 결과를 다시 사용할까???\n- 여기서 \"1번 객체 함수 호출로 캐시된 결과를 다시 사용해\" 라고 대답할 수 있어야 한다. \n- 이런 인스턴스들이 전부 따로 캐시를 두지 않고 단일 캐시를 공유할 수 있으면 이상적이다. \n- 의존성 주입으로 인스턴스간에 캐시 객체를 공유할수 있게 해주면 좋을듯 싶다.\n\n#### code \n```javascript\n// 공유할 캐시 객체를 주입받는다.\nconst cache = {} // 데이터 감춤 따위의 기능은 없다. \nmemoizedRestaurantApi = function (cache, thirdPartyApi) {\n  const restaurantCache = cache || {} // 캐시를 주입안하면 내부적으로 생성한다. \n  //(...)\n}\n```\n- 캐시가 일반적인 객체가 아닌 여러가지 기능을 하는 캐쉬의 역활도 할수 있음 좋겠다. 예를들어 최저 사용빈도 기능과 일정 시간까지만 캐시값을 저장해두는게 더 합리적인 상황도 필요할 수있다.\n- 이럴땐 리터럴가지고만은 캐시를 만들수 없다.\n\n```javascript\nsimpleCache = function () {\n\n  'use strict';\n\n  var privateCache = {};\n\n  function getCacheKey(key) {\n    return JSON.stringify(key)\n  }\n\n  return {\n    hasKey: function (key) {\n      return privateCache.hasOwnProperty(getCacheKey(key));\n    },\n    setValue: function (key, value) {\n      privateCache[getCacheKey(key)] = value;\n    },\n    getValue: function (key) {\n      return privateCache[getCacheKey(key)];\n    }\n  }\n\n};\n```\n\n- 위 캐시는 함수라서 이 함수를 실행하게 되면 각자 객체 인스턴스를 생성하기 때문에 다시 같은 문제를 야기하게 된다.\n그래서 다들 단일 인스턴스를 바라보게 하려면 즉시 실행을 응용하여 싱글톤 패턴을 구현하는 것이 좋다.\n```javascript\ngetRestaurantsWithinRadius = (function () {\n  'use strict';\n\n  var instance = null;\n  return {\n    getInstance: function () {\n      if (!instance) {\n        instance = Conference.simpleCache();\n      }\n      return instance;\n    }\n  }\n})();\n\nconst cache = RestaurantsWithinRadiusCache.getInstance()\n```\n\n### <span id=\"factory\">factory pattern</span>\n- 팩토리 패턴은 객체를 단순히 찍어내는 함수이다. \n- Object.create 메서드 역시 언어 자체에 포함된 팩토리이다. \n- 모듈은 데이터 감춤이라는 부가 기능이 있지만, 객체 생성/반환이 주 임무라는 점에서 엄밀히 말하면 팩토리 이다. \n- 일반 new 나 일반 함수를 호출해서 객체를 만들어 쓰면 되는데, 굳이 팩토리를 이용하는 이유는 '제어와 추상화'를 강화하기 위해서이다. \n- 용도에 특화된 유형별 create 메서드가 여럿 있는 팩토리도 있다. \n- 팩토리엔 대부분 create 같은 이름의, 하나 또는 그 이상의 파라미터를 받는 메서드가 하나 있다. 이 메서드는 전달 받은 파라미터를 살펴보고 알맞은 객체를 내어준다. \n\n#### 시나리오\n- 유형이 다른 두가지의 프레젠테이션 모델링을 해보자.\n- 일반은 제목과 발표자 정보가 있고, 벤더 프레젠테이션은 여기에 벤더명, 제품정보가 추가된다.\n- 프로퍼티 뭉치로 되어있는 객체를 하나 받았을때 프레젠테이션 유형은 알아서 판단하고 싶다.\n\n#### code\n\n```javascript\n// 팩토리에서 하는일\n// 1. create의 파라미터는 이전에 객체 리터럴로 넘겼을때 undefined로 자리 끼움했던 보기 흉한 형태에서 완전히 벗어났다\n// 2. 파라미터에 무엇이 들었든 잘 건네주기만 하면 뒷일은 팩토리가 알아서 처리한다.\n// 3. 나중에 유형이 다른 프레젠테이션도 얼마든지 추가할 수 있다.\n// 4. new 키워드로 객체를 생성해야 한다는 사실을 팩토리가 대신 기억해준다. 팩토리 안에서 new...\n\n// 팩토리 단위 테스트에서는 다음을 확인하자\n// 1. create 함수는 잘못된 파라미터를 받지 않는다.\n// 2. 파라미터가 정상적으로 전달되면 그에 따른, 원객체의 생성함수를 정확히 호출한다.\n// 3. 이렇게 하여 반환된 객체가 바로 create가 반환한 객체다.\n\npresentationFactory = function () {\n\n  'use strict';\n\n  return {\n    create: function (obj) { // obj가 샬롯이 주는 데이터이다...\n      var baseProperty = ['title', 'presenter'],\n        vendorProperty = ['vendor', 'product'],\n        allProperty = baseProperty.concat(vendorProperty),\n        p,\n        ix;\n\n      for (p in obj) {\n        if (allProperty.indexOf(p) < 0) { // indexOf 배열에서 지정된 요소를 찾을 수있는 첫 번째 인덱스를 반환 -1 이면 못찾음.\n          throw Error(Conference.presentationFactory.messages.unexpectedProperty + p);\n        }\n      }\n\n      // 나중에 Presentation 에서 유래한 객체를 반환할 예정..\n\n      for (ix = 0; ix < vendorProperty.length; ++ix) {\n        if (obj.hasOwnProperty(vendorProperty[ix])) {\n          return new Conference.VendorPresentation(obj.title, obj.presenter, obj.vendor, obj.product);\n        }\n      }\n      return new Conference.Presentation(obj.title, obj.presenter);\n\n    }\n  }\n\n}\n\n```\n\n\n### <span id=\"sandbox\">sandbox pattern</span>\n- 샌드박스 패턴은 자바스크립트의 이름공간의 단점을 해결하는 방안으로 다른 모듈 및 그 샌드박스에 전혀 영향을 주지 않고 어떤 모듈을 실행할수 있는 독자적 환경을 구축한다는 점이다.\n- 단일 전역 변수에 지나치게 의존하지 않고 점으로 길게 연결된 이름을 가진 타입이 범람하지 않게 한다.\n- 다른 모듈 및 샌드박스에 전혀 영향을 주지 않고 어떤 모듈을 '실행할 수 있는' 독자적 환경을 구축한다는 점\n\n#### 시나리오\n- 대시보드 특성 측면상 대시보드는 보통 담당자 별로 보고 싶어하는 타입으로 커스터마이징을 할수 있어야 한다. 예를 들면 어떤 사람은 a,b 만을  어떤 사람은 a,c 만을 보고 싶어할 수도 있다.\n- 각 위젯마다의 의존성은 없어야 겠다.\n- 우선 이런 위젯들을 서로 떼어놓을수 있다면 테스트와 구성 요소간 결합도가 낮아진다. 이에 해결책은 각각 위젯을 자신의 샌드박스에 가둬두자.\n\n#### code \n\n- 샌드박스 편\n```javascript\nWidgetSandbox = function () {\n  'use strict';\n\n  // new로 실행했는지 보장한다..\n  if (!(this instanceof Conference.WidgetSandbox)) {\n    throw new Error(Conference.WidgetSandbox.messages.mustBeCalledWithNew);\n  }\n\n  var widgetFunction,\n    toolsToLoad = [],\n    argsArray;\n\n  // var widgetFunction = arguments[arguments.length -1],\n  //   toolsToLoad = [];\n\n  //arguments에서 *진짜* 배열을 추출한다.\n  argsArray = Array.prototype.slice.call(arguments);\n\n  //배열 마지막 원소는 widgetFunction일 것이다..\n  widgetFunction = argsArray.pop();\n\n  if (typeof widgetFunction !== 'function') {\n    throw new Error(Conference.WidgetSandbox.messages.fcnMustBeProvided);\n  }\n\n  // if(arguments[0] instanceof Array){\n  //   toolsToLoad = arguments[0];\n  // }\n\n  toolsToLoad = (argsArray[0] instanceof Array) ? argsArray[0] : argsArray;\n\n  toolsToLoad.forEach(function (toolName) {\n    if (!Conference.WidgetTools.hasOwnProperty(toolName)) {\n      throw new Error(Conference.WidgetSandbox.messages.unknownTool + toolName);\n    }\n\n    Conference.WidgetTools[toolName](this);\n  }, this); // 콜백 내에서 this가 sandbox 인스턴스를 가리키도록 보장한다..\n\n\n\n  widgetFunction(this);\n\n};\n```\n\n- 위젯 편 \n```javascript\nattendeeNamesWidget = function (sandbox) {\n  'use strict'\n\n  // 해당 도구를 사용할 수 없으면 즉시 실패처리를 한다.\n  if(!sandbox.dom){\n    throw new Error(Conference.Widgets.messages.missingTool + 'dom');\n  }\n  if(!sandbox.attendeeNames){\n    throw new Error(Conference.Widgets.messages.missingTool + 'attendeeNames');\n  }\n\n  // attendeeNames를 조회하여 대시보드에 추가한다.\n  sandbox.attendeeNames.getAll().then(function resolve(name){\n    // sandbox.dom 으로 이름 목록을 표시한다.\n  }, function rejected(reson){\n    // sandbox.dom 으로 위젯 대신 에러 메시지를 나타낸다.\n  })\n}\n```\n\n- 도구 편\n\n```javascript\nWidgetTools.attendeeNames = function (sandbox, injectedAttendeeWebApi) {\n\n  'use strict';\n\n  // attendeeApi를 선택적으로 주입할 수 있게 코딩한다 단위 테스트 할때 유용하다.\n  var attendeeWebApi = injectedAttendeeWebApi || Conference.attendeeWebApi();\n\n  sandbox.attendeeNames = {\n    getAll: function gatAll() {\n      return attendeeWebApi.getAll()\n        .then(function extractNames(attendees) {\n          //각 참가자의 전체 성명만 추출하여 반환한다\n          var names = [];\n          attendees.forEach(function addName(attendee) {\n            names.push(attendee.getFullName());\n          });\n\n          return names;\n        });\n    }\n  }\n};\n```\n\n#### 정리\n\n- WidgetSandbox는 new로 호출되어야 한다. 여러 샌드박스를 만들기 위해서 위젯 하나당 하나의 widgetSandbox 인스턴스를 가진다고 생각하면 될듯 싶다.\n- 도구들은 모듈로 정의를 하고 도구마다 모듈 함수가 WidgetSandbox 인스턴스를 받고 도구가 스스로를 WidgetSandbox 인스턴스의 프로퍼티에 추가한다.\n- WidgetSandbox 생성자는 다음둘중 하나를 받는다. 첫 번째 인자는 위젯에서 쓸 도구명이 담긴 배열, 두번째 인자는 위젯함수 또는 도구명을 개별 인자로 죽 나열하고 위젯 함수를 제일 마지막 인자에 넣는다.\n- 각 도구들은 싱글톤 객체이다.\n- 위젯샌드박스에서 각 도구를 실행시키면 this ( 여기서 this는 WidgetSandbox 의 인스턴스가 되겠다.) 에 도구 이름으로 된 프로퍼티로 도구 스스로가 등록하게 된다. \n```javascript\nWidgetTools.toolA = function(sandbox) {\n  sandbox.toolA = {\n    function1: function(){\n      // function1 구현부\n    },\n    function2: function(){\n      // function2 구현부\n    }\n  }\n}\n```\n- 여기서 샌드박스의 역활은 샌드박스를 new로 선언하면서 해당 this안에 도구와 위젯을 가둬두는 것이다.\n- 도구1(this), 도구2(this), ... 도구n(this), 위젯(this) 이렇게 순차대로 호출하면 위젯에서는 원하는 도구를 this.도구1 , this.도구2 이런식으로 활용할 수 있겟다.\n\n\n\n### <span id=\"decoration\">decoration pattern</span>\n- 객체를 바꾸지 않고 그 기능을 늘리는 수법 \n- 기존 책임을 하는 api 객체는 그대로 놔두고 그 객체를 감싼 객체에 기능을 새로 넣자. 이 래퍼 객체에는 원 객체와 파라미터 개수 및 의미가 같은 메서드가 있는데 추가 할 기능만 자신이 맡고 물밑에서 실제로 처리하는 일은 자신이 감싼 원 객체에게 떠맡긴다. \n- 실제로 상황에 따라 어떠한 특성 혹은 행동을 덧붙이는 패턴이다.\n- 다양한 형태로 기능을 확장해야 하는 경우, 예를 들면 여러 종류의 단위 기능이 있고 이들을 조합해서 사용할 경우 장식자 패턴을 사용하면 장식자 개체에서 필요한 단위 기능을 하는 형식 개체를 포함을 시키는 것으로 이를 해결할 수있다.\n- 단일 책임 원칙을 준수하면서 믿음성이 강화된 코드를 효과적으로 작성할 수 있다.\n\n#### 시나리오\n- 컨퍼런스에서 참가자가 등록버튼을 눌러 등록하면 post로 참가자가 등록하게 된다. \n- 하지만 이때, 신규 참가자 페이지에서 사용자를 계속 붙잡아 두면 안되겠고, post가 끝난 다음에 참가자 명단 페이지에 가서 확인하라고 하는것 또한 안된다. \n- post가 실패할 확률은 희박하다.\n- 다음과 같이 하자\n  1. 새 레코드를 post 하기전, 대기 레코드(pendingPosts) 배열에 담는다.\n  2. post promise가 귀결되면 해당 레코드를 배열에서 들어낸다 ( 삭제 시킨다. ) 배열 splice\n  3. 그러는 동안 대기 레코드들을 get 결과에 덧붙인다. 이렇게 하면 참가자 명단 페이지에서 post 처리된 \n  레코드를 바로 보여줄 수 있다. 대기 레코드들은 아직 DB에서 참가자 ID를 발급받지 못한 상태라 수정/삭제가 불가피 하지만, 어쨌든 그 사이에 적어도 이름을 명단에 보여주는 건 가능하다. \n  4. post 결과 참가자 id가 넘어오면 조금전 3번에서 get으로 덧붙인 해당 레코드에 집어넣고 수정/삭제할 수 있는 상태로 바뀐다. \n  5. 드물긴 하지만, post가 실패하면 에러 메시지를 띄우고 등록 실패한 참가자를 명단 페이지에서 지운다. \n  오류가 발생한 참가자가 명단에 잠시 머물렀다 해도 문제 될 일은 없다. 화면에서 id가 다시 넘어오기 전까지 수정/삭제를 할 수 없을 뿐이니까.\n\n#### code\n\n- 원 객체 ( baseWebApi )\n```javascript\n// fake 모의체\nfakeAttendeeWebApi = function(){\n\n  'use strict';\n\n  var attendees = []; // 가짜 데이터베이스 테이블\n\n  return {\n    //서버에 attendee를 POST 전송하는 척한다.\n    //attendee 사본(마치 서버에서 새 버전을 조회해오는 것처럼 ) 으로\n    // 귀결되는 프라미스를 반환하고 귀결 시점에 이 레코드에는\n    // 데이터베이스에서 할당된 PK(attendeeId)가 들어있을 것이다..\n\n    //프라미스를 버려야 하는 테스트라면 스파이를 이용하자.\n    post: function post(attendee){\n      return new Promise(function(resolve,reject){\n        // 5밀리초에 불과하지만,\n        // setTimeout은 프라미스 귀결을 다음 차례로 지연한다..\n        setTimeout(function pretendPostingToServer(){\n          var copyOfAttendee = attendee.copy();\n          copyOfAttendee.setId(attendees.length+1);\n          attendees.push(copyOfAttendee);\n          resolve(copyOfAttendee);\n        },5);\n      });\n\n    },\n    // 전체 참가자에 대한 프라미스를 반환한다..\n    // 이 프라미스는 반드시 귀결되지만 , 필요하면 테스트 코드에서 스파이를 심을수도 있다..\n    getAll : function getAll(){\n      return new Promise(function(resolve,reject){\n        // setTimeout은 실제 조건을 흉내 내기 위해\n        // post보다 지연시간이 짧다..\n        setTimeout(function pretendToGetAllFromServer(){\n          var copies = [];\n          attendees.forEach(function(a){\n            copies.push(a.copy());\n          });\n          resolve(copies);\n        },1);\n      });\n    }\n\n  }\n};\n```\n\n- 장식자\n```javascript\nattendeeWebApiDecorator = function (baseWebApi) {\n  'use strict';\n\n  var self = this,\n\n    // post 함수에 전달할 레코드\n    // 호출 결과는 아직 귀결되지 않은 상태다.\n    pendingPosts = [],\n    messages = {\n      postPending: '이 참가자에 대한 처리가 진행 중인 것 같습니다.'\n    };\n\n  //attendee에 해당하는 'posts' 원소를 반환하거나\n  // 그런 원소가 없으면 -1을 반환한다..\n  function indexOfPostForSameAttendee(posts, attendee) {\n    var ix;\n    for (ix = 0; ix < posts.length; ++ix) {\n      if (posts[ix].isSamePersonAs(attendee)) {\n        return ix;\n      }\n    }\n    return -1;\n  }\n\n  return {\n    post: function post(attendee) {\n      if (indexOfPostForSameAttendee(pendingPosts, attendee) >= 0) {\n        return Promise.reject(new Error(messages.postPending));\n      }\n\n      pendingPosts.push(attendee);\n\n      return baseWebApi.post(attendee).then(\n        function onPostSucceeded(attendeeWithId) {\n          var ix = pendingPosts.indexOf(attendee);\n          if (ix >= 0) {\n            pendingPosts[ix].setId(attendeeWithId.getId());\n            pendingPosts.splice(ix, 1);\n          }\n\n          return attendeeWithId\n        },\n        function onPostFailed(reason) {\n          var ix = pendingPosts.indexOf(attendee);\n          if (ix >= 0) {\n            pendingPosts.splice(ix, 1);\n          }\n\n          return Promise.reject(reason);\n        }\n      );\n    },\n    getAll: function getAll() {\n      return baseWebApi.getAll().then(function (records) {\n        pendingPosts.forEach(function (pending) {\n          var ix = indexOfPostForSameAttendee(records, pending);\n          if (ix < 0) {\n            records.push(pending);\n          }\n        });\n        return records;\n      });\n    },\n    getMessages: function getMessages() {\n      return messages;\n    }\n  }\n};\n```\n\n#### 정리\n- 기존의 api 호출을 하는 객체를 사용한다면, post 호출후 어떤식으로든 완료가 되고 getAll로 그 리스트를 가져와야 하는 일련의 시간을 사용자가 기다리게 마련이다.\n- 이런 경험을 높히기 위해서 기존 api 호출 하는 객체에 추가 기능을 래퍼 객체로 만들어 주었다.\n- 여기서 래퍼는 post를 보내고 나서 바로 getAll에 post 보낸 정보를 덧대였고( id가 없는 상황 ) post가 끝나면 그 덧댄 객체에게 id를 setting 해주는 식이다.\n- 기존 객체에서 발생하는 에러 및 성공을 잘 패스-스루(장식된 객체에서 -> 장식자 -> 호출부로의 전달) 해주는지 확인해야하고, 장식자의 고유 기능을 넣는다.\n- 논리적으로 다음 단계는 장식자의 일반화 문제를 다뤄야 한다.\n- 실제로 HTTP 의 PUT과 DELETE는 물론이고 연관된 POST GET 까지 캡슐화한 객체를 여럿 두고 구현한 애플리케이션도 있다. ( 예를 들어, 이미지 등록, 사용자 수정..등등의 여러 REST API) `모든 경우`에 적용할 수 있게 장식자를 일반화 하려면 어떻게 해야하는가??? ( 현재는 baseWebApi가 post와 getAll이 있는 녀석들을 받아야 한다. )\n- 공통의 기능을 상위 클래스 및 인터페이스로 일반화를 해보자.\n\n\n\n### <span id=\"strategy\">strategy pattern</span>\n- 전략 패턴은 특정 작업을 수행하는 다중 알고리즘, 즉 전략을 런타임 시 넣었다 뺐다 할 수 있는 모듈 단위로 나누기 위해 사용한다. \n- 특정 작업을 수행하는 서로 다른 알고리즘(운수회사 교통편 예약)을 분리하고, 런타임 시점에 알고리즘, 즉 전략을 동적으로 지정할 수 있게 해주는 패턴\n- 여기서 팩토리 패턴을 사용함으로써 테스트가 덜 복잡해지고 전략을 추가/삭제할 때도 실행 콘텍스트는(transportScheduler) 전혀 고칠 필요가 없다. \n\n#### 시나리오\n- 웹사이트에서 참가자는 자신이 선택한 택시 회사에 요청을 보내고 그 회사가 발급한 에약 확인번호를 돌려받는 식으로 콘퍼런스 행사장 교통편을 예약할 수 있다.\n- 택시 회사에서는 웹사이트 데시보드를 보면서 예약 상황을 모니터링하고, 주최자 역시 회사별 이용 실적이 얼마나 되는지 확인할 수 있어야 한다.\n- 운수회사 모듈 생성을 통틀어 관장하는 팩토리 함수를 하나 만드는게 좋을거 같다. \n- 여기서 운수회사별 모듈이 바로 전략이다.\n\n#### code\n```javascript\ntransportScheduler = function(auditService /* 집계 서비스 */ , transportCompanyFactory){\n  'use strict';\n\n  if(!auditService){\n    throw new Error(Conference.transportScheduler.messages.noAuditService);\n  }\n\n  if (!transportCompanyFactory) {\n    throw new Error(Conference.transportScheduler.messages.noCompanyFactory);\n  }\n\n  return {\n    scheduleTransportation : function scheduleTransportation(transportDetails) {\n      if (!transportDetails) {\n        throw new Error(Conference.transportScheduler.messages.noDetails);\n      }\n      var company;\n      // 여기서 어떤 운수회사 모듈을 생성한다. \n      company = transportCompanyFactory.create(transportDetails);\n\n      // 여기서 운수회사는 schedulePickup 을 반드시 구현한다. \n      return company.schedulePickup(transportDetails).\n        then(function successful(confirmation){\n          auditService.logReservation(transportDetails,confirmation);\n          return confirmation;\n      });\n    }\n  };\n};\n```\n\n```javascript\n// 운수회사\nredicabTransportCompany = function(httpService) {\n\n  'use strict';\n\n  var schedulePickupUrl = \"http://redicab.com/schedulepickup\";\n\n  return {\n    // RediCab사와 픽업 일정을 잡는다.\n    // 이 회사 API로부터 채번된 확인 코드로 귀결되는 프라미스를 반환한다.\n    schedulePickup: function schedulePicup(transportDetails){\n      var details = {\n        passenger: transportDetails.passengerName,\n        pickUp: \"컨퍼런스 센터\",\n        pickUpTime: transportDetails.departureTime,\n        dropOff: \"공항\",\n        rateCode: \"JavaScriptConference\"\n      };\n\n      return httpService.post(schedulePickupUrl,details)\n        .then(function resolve(confirmation){\n          return confirmation.confirmationCode;\n        });\n\n    },\n\n    //픽업 정보를 전송할 url을 반환한다.\n    getSchedulePickupUrl: function getSchedulePickupUrl(){\n      return schedulePickupUrl;\n    }\n  }\n};\n```\n\n### <span id=\"proxy\">proxy pattern</span>\n- 프록시는 대리인이라는 뜻이다. 즉, 사용자가 원하는 행동을 하기 전에 한번 거쳐가는 단계라고 생각하면 된다. \n- 좋은 프록시는 사용자의 요청을 캐싱하여 성능을 높일 수도 있고, 에러를 잡아낼 수도 있지만 나쁘게 사용한다면 사용자의 요청을 왜곡하여 다른 동작을 하도록 만들 수 있다. \n\n#### 주된용도\n- 클라이언 사용 패턴에 따라 데이터를 미리가져온다.\n- 실체에 클라이언트 요청이 과도하게 몰리지 않게 한다. ( ex. 디바운싱 프록시 : 수 밀리 초에 한번만 이벤트에 반응하도록 제한할 수 있다.)\n- 클라이언트가 접근하면 안 되는 자원을 통제한다.\n- HTTP 요청 n 개를 하나로 묶어 n-1개 요청에 따른 고정 비용을 줄인다.\n\n#### 시나리오\n- 콘퍼런스 참가자 명단에서 클릭하면 프로필 전체를 볼수있게 한다.\n- 프로필 화면에는 사진이 적어도 하나 이상 등록되어 있어서 전체 프로필을 처음부터 죄다 끌어오고 싶지는 않다.\n- 현재 페이지의 참가자 중 가장 접근 횟수가 많은 프로필만이라도 미리가져오는게 좋겠다.\n- 시간이 지나면서 쌓인 프로필 클릭 횟수에 따라 누가 유명 인사인지 시스템이 알아서 학습하도록 놔두고 그 사람들 프로필만 선취하면 될거같다.\n\n#### code\n```javascript\n//attendeeProfileService(profileService) 함수로 참가자 배열(attendees)에서\n//accessCount에 따라 가장 인기 있는 프로필부터 prefetchLimit개 만큼 선취하는 식으로\n//참가자 프로필 접근을 관리한다.\nConference.attendeeProfileProxy = function (\n  attendees, profileService, prefetchLimit) {\n  'use strict';\n\n  var prefetched = {};\n\n  function prefetch(attendeeId) {\n    // 이놈이 진짜... getProfile 가져오는 놈...\n    prefetched[attendeeId] = profileService.getProfile(attendeeId);\n  }\n\n  if (prefetchLimit > attendees.length) {\n    prefetchLimit = attendees.length;\n  }\n  // 즉시 실행 함수로 감싸서 딱 한 번만 실행되도록\n  // 그리고 새 변수 sortedAttendees가 외부 스코프에 의해 더렵혀지지 않게 한다...\n  // 즉시 실행 함수도 prefetchAll 이라는 이름을 붙여 문서화 및 스택 추적 시 이정표로 삼는다..\n  (function prefetchAll() {\n    var ix,\n      sortedAttendees = attendees.slice().sort(function byViews(a, b) {\n        // 서버에서는 네트워크 효율 때문에 프로필 조회수가 업슨ㄴ 사람은 profileViews 프로퍼티를 전송하지 않는다.\n        // 따라서 예외 처리를 해준다.\n        return (b.profileViews || 0) - (a.profileViews || 0);\n      });\n    for (ix = 0; ix < prefetchLimit; ++ix) {\n      prefetch(sortedAttendees[ix].attendeeId);\n    }\n  })();\n\n  // 위에걸 한번 돌리고 나면... prefetched에 뭔가가 쌓인다.. 그게 뭐가 쌓이느냐.\n  // 서버에서 내려주는 profileViews 값이 높은순위별로.. prefetchLimit 갯수만큼 쌓인다..\n  // prefetced는 참가자의 id가 키 값이고 값은 진짜 getProfile ( 프로필 ) ..\n\n  return {\n    getProfile: function (attendeeId) {\n      return prefetched[attendId] || profileService.getProfile(attendeeId);\n    }\n  }\n};\n```\n\n### <span id=\"chaning\">chaning pattern</span>\n\n### <span id=\"iterator\">iterator pattern</span>\n\n### <span id=\"mediator\">mediator pattern</span>\n\n### <span id=\"observer\">observer pattern</span>\n- 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성 하는 패턴\n- 데이터의 변경이 발생했을 경우 상대 클래스나 객체에 의존하지 않으면서 데이터 변경을 통보하고자 할 때 유용\n- 통보 해야할 대상 객체의 관리를 Subject 클래스와 그 대상들이 꼭 구현을 해야할 observer 인터페이스로 일반화 한다.\n- 쉽게 여기서 통보 해야할 대상 객체는 구독자 라고 하고 그 구독자들은 update 함수를 구현해야할 약속을 이행하기 위한 observer 인터페이스를 갖는다. 또한 대상 객체의 관리를 하는 Subject는 신문사라고 생각 할 수 있다.\n\n### <span id=\"pubSub\">pubSub pattern</span>\n\n### <span id=\"builder\">builder pattern</span>","excerpt":"Goal 다양한 자바스크립트 패턴을 익히고 어느 상황에서 사용되는지 파악한다. Contents callback pattern promise pattern partial pattern memoization pattern singleton pattern…","fields":{"slug":"/javascript-pattern.md/"},"frontmatter":{"date":"Aug 05, 2018","title":"javascript pattern","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Intro\n\n- 비지니스 코드가 아닌 ui의 이벤트를 활용한 코드를 자스민으로 testing을 진행해보자.\n\n# jasmine 이란?\n\n- 행위 주도 개발 (Behavior-Driven Development, BDD) 방식으로 자바스크립트 단위 테스트를 작성하기 위한 라이브러리\n- 단위 테스트(unit test)란 코드의 기능 단위(funtionality unit)를 테스트 하는 것을 말한다.\n- BDD는 단위 테스트로 확인할 기능 또는 작동 로직을 일상 언어로 서술할 수 있는데 개발자는 자신이 작성 중인 코드가 '어떻게' 가 아닌 '무엇'을 해야하는지 테스트 코드에 표현할수 있다. \n- [공식홈페이지](http://jasmine.github.io)\n\n## 테스트 꾸러미와 스펙\n\n- 테스트 꾸러미는 describe로 정의할수있다. \n```javascript\n// dscribe({문자열}, {함수})\ndecribe(\"무엇을 테스트할지 서술한다.\",function(){\n    console.log(\"테스트 꾸러미의 구현부\")\n})\n```\n\n- 스펙(즉, 개별테스트 )은 it으로 정의된다.\n```javascript\n// dscribe({문자열}, {함수})\nit(\"무엇을 테스트할지 서술한다.\",function(){\n    // 적어도 한개의 기대식을 가진 함수 \n})\n```\n\n- 예) \n```javascript\ndescribe('어떤 버튼은', ()=> {\n  describe('클릭했을 때', ()=> {\n    it('경고창을 띄운다', ()=> {\n\n    })\n  })\n})\n```\n\n- 테스트 꾸러미 구현부에 전역함수 beforeEach/afterEach 를 쓰면 각 꾸러미 테스트가 실행되기 이전에 beforeEach 함수를, 그 이후에는 afterEach 함수를 호출한다. 전체 테스트가 공유할 설정과 정리를 코드를 두 함수에 담아두면 코드 중복을 피할 수 있어 좋다. \n\n## 기대식과 매처\n\n- expect 함수는 테스트 대상 코드가 낸 실제값을 인자로 받아 기댓값과 견주어본다. \n- 실제값과 기댓값을 비교하는 일은 매처 함수의 몫이다. 매처는 비교 결과 성공하면 true를 실패하면 false를 반환한다. 하나 이상의 기대식이 포함된 스펙(it함수) 에서 매처가 하나라도 실패하면 모조리 실패한 거로 간주한다. \n- 여러 매처 중에 toBe 매처는 같은 객체여야 한다는 의미이다. \n- 용도에 맞는 매처가 없으면 자스민이 지원하는 커스텀 매처를 만들어 쓴다.\n\n```javascript\nexpect({실제값이 리턴된다.}).toBe({기댓값})\n```\n- 커스텀 매처 만드는 법\n\n```javascript\n// 기본 형식이다.\nconst customMacher = {\n    merlin: function(){\n        return {\n            compare: function(actual, expected){\n                let result = {}\n                // 여기서 result는 pass와 message 프로퍼티를 포함해야 한다. \n                // pass에는 boolean 값이 들어가야 하고 true / false\n                // message에는 pass가 true 됬을때 값일때 메시지나 false 됬을때 메시지를 적어준다.\n                return result\n            }\n        }\n    }\n}\n\n\ndescribe(\"테스트\", function(){\n    beforeEach(function(){\n        // 인자로 커스텀 macher 객체를 넣어준다. 이 객체는 매처의 이름을 키 값으로 값는 메서드를 갖는다. \n        jasmine.addMatchers(customMacher); \n    })\n})\n```\n\n## 스파이 \n\n- 자스민 스파이는 테스트 더블 역할을 하는 자바스크립트 함수다.\n- 테스트 더블이란\n    - 더미 : 인자 리스트를 채우기 위해 사용되며 전달은 하지만 실제로 사용되지 않는다.\n    - 틀 : 더미를 조금 더 구현하여 아직 개발되지 않은 클래스나 메서드가 실제 작동하는 것처럼 보이게 만든 객체로 리턴값은 하드코딩한다.\n    - 스파이 : 틀과 비슷하지만 내부적으로 기록을 남긴다. 특정 객체가 사용되었는지, 특정인자로 호출되었는지 등의 상황을 감시한다.\n    - 모이체 : 틀에서 조금 더 발전하여 실제로 간단한 구현된 코드를 갖고는 있지만 운영환경에선 사용할수는 객체다.\n    - 모형 : 더미, 틀 , 스파이를 혼합한 형태와 비슷하나 행위를 검증하는 용도로 쓰인다. \n- jasmine.createSpy 함수의 경우 빈 껍데기 스파이이다. \n\n```javascript\n// 예제.\ncallbackSpy = jasmine.createSpy();\nexpect(callbackSpy.calls.count()).expect(array.length);\n```\n\n- spyOn 함수를 쓰면 특정 함수를 들여다 볼수 있다. 첫번째 인자는 객체 인스턴스, 두번째 인자는 감시할 함수명이다.\n- spyOn 함수는 기존 구현부를 대체하는 함수이다. \n\n```javascript\n// 예제\nspyOn(saver,'saveReservation');\nspyOn(api, 'getRestaurnatsNearConference').and.returnValue(returnedFromService);\nexpect(saver.saveReservation).toHaveBeenCalled();\n```\n\n\n# Ui test\n\n## 좋지 못한 html 코드 \n\n- 클릭하면 span 돔에 카운트가 늘어나는 코드이다. \n- html과 javascript가 혼재해 있어서 지저분할분 아니라 javascript 코드를 복붙으로 밖에 재활용이 안된다. \n\n```html\n<!DOCTYPE html>\n<html>\n\n  <head>\n    <script type=\"text/javascript\">\n      var clickCount = 0,\n          displayCount = function() {\n            var countElement = document.getElementById(\"countDisplay\");\n            countElement.innerText = clickCount.toString();\n          }\n    </script>\n  </head>\n\n  <body>\n    <button type=\"button\" onclick=\"clickCount++; displayCount();\">\n      Increment\n    </button>\n\n    <span id=\"countDisplay\">0</span>\n  </body>\n\n</html>\n```\n\n## 테스트 코드 및 모듈 작성(1)\n\n\n- 기존에 인라인으로 들어간 스크립트를 모듈로 빼두자. 그러면 재사용성이 좋아진다.\n- 이벤트 발생시 카운트가 증가해서 저장하는 부분과 DOM업데이트 함수로 나눈다. 그럼 비지니스 로직만 테스트할 수 있음.\n- 우선 DOM과 엮이지 않은 코드를 작성해서 테스트를 진행한다. \n\n```javascript\nfunction clickCountDisplay(){\n    let count = 0;\n    return {\n        // 현재 count 구하기\n        getClickCount: function(){\n            return count;\n        },\n        // count를 Dom에 render\n        updateCountDisplay: function(){\n\n        },\n        // count 증가 및 update Dom\n        incrementCountAndUpdateDisplay: function(){\n            count++;\n            this.updateCountDisplay();\n        }\n    }\n}\n```\n\n```javascript\n// test코드\n\ndecribe(\"clickCountDisplay\", function(){\n    \"use strict\"\n\n    beforeEach(function(){\n        let display = clickCountDisplay();\n    })\n\n    it(\"0으로 초기화\",function(){\n        expect(display.getClickCount()).toEqual(0)\n    });\n\n     describe(\"incrementCountAndUpdateDisplay()\", function() {\n         it(\"count 증가 시킨다.\",function(){\n            let initCount = display.getClickCount();\n            display.incrementCountAndUpdateDisplay();\n            expect(display.getClickCouny()).toEqual(initCount+1);\n         });\n\n         it(\"updateCountDisplay 함수를 실행시킨다.\",function(){\n            spyOn(display,\"updateCountDisplay\");\n            display.incrementCountAndUpdateDisplay();\n            expect(display.updateCountDisplay).toHaveBeenCalled();\n         })\n     })\n})\n```\n\n\n## 테스트 코드 및 모듈 작성(2)\n\n- DOM이 바뀌는지 테스트를 진행한다. \n- updateCountDisplay 함수를 어떻게 테스트할지 생각해보자.\n- updateCountDisplay 이 함수가 조작할수 있는 DOM 요소를 제공해야한다. \n- DOM 요소를 주입하고 나서 함수를 실행했을때 그 값이 잘 렌더링 되는지 확인한다.\n\n```javascript\nfunction clickCountDisplay(opts){\n    if(!opts) throw new Error(\"opts를 주입해야합니다.\");\n    let count = 0;\n    return {\n        // 현재 count 구하기\n        getClickCount: function(){\n            return count;\n        },\n        // count를 Dom에 render\n        updateCountDisplay: function(){\n            opts.updateElement.innerHTML(count);\n        },\n        // count 증가 및 update Dom\n        incrementCountAndUpdateDisplay: function(){\n            count++;\n            this.updateCountDisplay();\n        }\n    }\n}\n```\n\n\n```javascript\n// test코드\n\ndecribe(\"clickCountDisplay\", function(){\n    \"use strict\"\n    let display,\n        displayElement;\n    beforeEach(function(){\n        displayElement = document.createElement(\"span\");\n        document.body.appendChild(displayElement);\n\n        clickElement = document.createElement(\"button\");\n        document.body.appendChild(clickElement);\n\n        let options = {\n            updateElement: displayElement,\n            triggerElement: clickElement\n        }\n        // Element를 주입.\n        display = clickCountDisplay(options);\n    })\n\n    afterEach(function(){\n        displayElement.remove();\n        clickElement.remove();\n    })\n\n     describe(\"incrementCountAndUpdateDisplay()\", function() {\n         it(\"updateDisplay\",function(){\n             display.incrementCountAndUpdateDisplay();\n             expect(displayElement.innerText).teEqual(display.getClickCount());\n         })\n     });\n\n     describe(\"updateCountDisplay()\", function() {\n        it(\"횟수를 한번도 늘린 적 없으면 0이 표시된다\", function() {\n            expect(displayElement.innerText).teEqual(\"\");\n            display.updateCountDisplay();\n            expect(displayElement.innerText).teEqual(\"0\");\n        });\n    });\n})\n```\n\n## 테스트 코드 및 모듈 작성(3)\n\n- 이벤트 트리거가 잘 해당 함수를 호출하는지 확인한다.\n\n```javascript\n// 테스트 코드\n// .. 나머진 생략\nit(\"클릭이벤트가 발생하면 incrementCountAndUpdateDisplay를 호출한다.\",function(){\n    spyOn(display, \"incrementCountAndUpdateDisplay\")\n    clickElement.dispatchEvent(new Event('click')); // 클릭 발생시\n    expect(display.incrementCountAndUpdateDisplay).toHaveBeenCalled();\n})\n```\n\n```javascript\nfunction clickCountDisplay(opts){\n    if(!opts) throw new Error(\"opts를 주입해야합니다.\");\n    let count = 0;\n    const module = {\n        // 현재 count 구하기\n        getClickCount: function(){\n            return count;\n        },\n        // count를 Dom에 render\n        updateCountDisplay: function(){\n            opts.updateElement.innerHTML(count);\n        },\n        // count 증가 및 update Dom\n        incrementCountAndUpdateDisplay: function(){\n            count++;\n            this.updateCountDisplay();\n        }\n    }\n\n    opts.triggerElement.addEventListener('click', function(){\n        module.incrementCountAndUpdateDisplay();\n    })\n\n    return module\n}\n```\n\n# 결론\n\n- UI 단위테스트는 다음을 확인하는 정도로 확인해야한다.\n    - 요소를 클릭하면 알맞은 처리기가 확실히 실행되는가?\n    - 사용자가 보면 안될 UI 요소가 있는가?\n    - <select>가 원하는 데이터로 채워지는가.","excerpt":"Intro 비지니스 코드가 아닌 ui의 이벤트를 활용한 코드를 자스민으로 testing을 진행해보자. jasmine 이란? 행위 주도 개발 (Behavior-Driven Development, BDD) 방식으로 자바스크립트 단위 테스트를 작성하기 위…","fields":{"slug":"/ui-unit-testing.md/"},"frontmatter":{"date":"Aug 04, 2018","title":"UI unit testing","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 동기\n\njavascript 비동기를 다루는데 쓰이는 Promise 라는 객체가 있다. Promise 를 다루는 방법은 많지만 실제로이 객체가 어떤 방식으로 움직이는지 그 구조를 파악하면서 Promise 를 좀더 자유자재로 다뤄보자.\n\n## 틀 만들기\n\npromise 를 실행해서 리턴을 해보면 [[PromiseStatus]] 와 [[PromiseValue]] 이렇게 값이 나오는걸 확인할 수 있다.\n이걸 바탕으로 실제 promise 는 아니지만 비슷하게 만들어 보자.\n\n```javascript\nconst PENDIGN = 0\nconst FULFILLED = 1\nconst REJECTED = 2\n\nfunction Promise(fn) {\n  let status = PENDING // Promise의 상태값\n  let value = null // 최종 결과값이 저장될 장소.\n\n  return {\n    PromiseStatus: status,\n    PromiseValue: value,\n  }\n}\n```\n\n## Promise 기능함수 만들기\n\npromise 개념을 보다보면 resolve, fulfill, reject 라는 용어를 볼 수가 있다.\nresolve 라는 개념은 어떠한 결과값으로 귀결되었다인데 이는 성공했을수도 있고 실패했을수도 있다는 뜻이다. 즉, 어떤 결과든 결론을 지었다라고 생각하면 된다.\nfulfill 은 귀결된 결과값이 성공했다는 뜻이고 반대로 reject 는 실패했다는 뜻이다.\n\nPromise 인자로는 함수 하나를 받는데 그 함수의 인자로 resolve, reject 를 받겠끔 되어있다.\nfn 이라는 함수를 호출할때 resolve 와 reject 구실을 할 수있는 함수를 만들어 넣어줘야 한다.\n\n여기서 참고로 resolve 함수는 Promise 객체를 받을수도 있어야 한다.\n\n이런 기능들을 하는 함수들을 만들어 보자.\n\n```javascript\nconst PENDIGN = 0\nconst FULFILLED = 1\nconst REJECTED = 2\n\nfunction Promise(fn) {\n  let status = PENDING // Promise의 상태값\n  let value = null // 최종 결과값이 저장될 장소.\n\n  // 이부분부터..\n  function fulfill(result) {\n    status = FULFILLED // 상태값을 바꿔줌.\n    value = result // 결과값을 value 값에 넣어줌.\n  }\n\n  function reject(error) {\n    status = REJECTED // 상태값을 바꿔줌.\n    value = error // 실패한 에러를 value 값으로 넣어줌.\n  }\n\n  // 여기서 result가 올수있는 값은 일반 plain 값이 올수 있고 다른 Promise가 올수있으므로 그 처리를 해두어야 한다.\n  // 프로미스는 오직 fulfilled/rejected 중 오직 딱 한번만 귀결이 될수 있다.\n  function resolve(result) {\n    try {\n      let then = getThen(result) // 여기 then 함수가 있으면 Promise로 왔다고 간주. (getThen 은 헬퍼함수)\n      if (then) {\n        doResolve(then.bind(result), resolve, reject) // ( doResolve는 헬퍼함수 )\n        return\n      }\n      fulfill(result) // 일반 값으로 왔을 경우 이행.\n    } catch (e) {\n      reject(e)\n    }\n  }\n\n  // 실행\n  doResolve(fn, resolve, reject)\n\n  return {\n    PromiseStatus: status,\n    PromiseValue: value,\n  }\n}\n```\n\n## 헬퍼함수 작성하기\n\n위에서 본 헬퍼함수는 두종류가 존재한다. `getThen` , `doResolve` 함수이다.\n`getThen` 의 경우에는 Promise 객체의 특징은 then 함수가 있는지 없는지 파악하여 있으면 then 함수를 리턴 없으면 null 을 리턴한다. 또한 잘못된 Promise 를 막아줌.\n여기서 특히 다시 `doResolve` 를 실행시킬때 `then.bind(result)` 구문을 유의깊게 보자.\nthen 을 호출하는데 이 then 의 경우에는 this 를 result 로 바꿔준다. 이는 곧 result(Promise 객체)에 들어있는 then 을 호출하겠다는 의미이다.\n\n`doResolve` 는 `Promise` 로 들어온 함수 인자(`fn`)를 실행해서 `resolve` 시키도록 하는 함수이다. 이 `fn` 함수 인자의 파라미터로 `resolve`, `reject` 함수를 받게 되는데 이 함수들은 `doResolve` 함수가 가지고 있는 함수를 제공하는 것이다. done 이라는 변수는 `fulfill` 과 `reject` 를 한번만 호출할수 있도록 도와준다. 또한 `fn` 을 한번 호출한 뒤에는 다시 `resolve` 나 `reject` 를 사용자에서 호출을 해줘야 다음 절차를 이행해 간다.\n\n```javascript\nfunction getThen(result) {\n  let t = typeof result\n  if (t && (t === 'object' || t === 'function')) {\n    let then = t.then\n    if (typeof then === 'function') {\n      return then\n    }\n  }\n\n  return null\n}\n\nfunction doResolve(fn, onFulfilled, onRejected) {\n  let done = false // 중복 호출 방지\n  try {\n    // Promise 인자로 넘어왔던 함수 fn 호출\n    fn(\n      // Promise 인자로 넘어왔던 함수 fn 인자로 넘겨줄 resolve\n      function(value) {\n        if (done) return\n        done = true\n        onFulfilled(value)\n      },\n      // Promise 인자로 넘어왔던 함수 fn 인자로 넘겨줄 reject\n      function(reason) {\n        if (done) return\n        done = true\n        onRejected(reason)\n      }\n    )\n  } catch (e) {\n    if (done) return\n    done = true\n    onRejected(e)\n  }\n}\n```\n\nPromise 에 들어온 함수 `fn` 인자에서 모든 수행이 끝나면 `resolve`를 실행시키는데 이것은 아래 함수를 실행시킨다.\n특히 `onFulfilled` 함수는 Promise 내장 `resolve` 함수를 실행시키는데 이 함수는 일반 plain 한 값 또는 Promise 객체를 받기 위한 분기 처리가 되어있다.\n\n```javascript\nfunction(value) {\n  if (done) return\n  done = true\n  // Promise 내장 resolve 함수.\n  onFulfilled(value)\n},\n```\n\n반대로 `reject`를 실행시키면 아래 함수를 실행시킨다.\n\n```javascript\nfunction(reason) {\n  if (done) return\n  done = true\n  // Promise 내장 reject 함수.\n  onRejected(reason)\n}\n```\n\n실제 Promise 에서도 resolve 함수를 여러번 호출했을 경우를 막아준다. ( 맨 처음에 호출한 resolve 로 귀결시킨다. )\n\n```javascript\nnew Promise(function(resolve, reject) {\n  // 비동기 처리 예제\n  setTimeout(function() {\n    resolve(1)\n    resolve(2) // 이아이는 실행되지 않는다.\n  }, 2000)\n}).then(result => {\n  console.log(result) // 1\n  return result + 10\n})\n```\n\n\"여기까지는 내가 함수를 하나 줄터이니 Promise 내부 상태값과 결과값을 반영 시킬 함수를 인자로 넣어서 실행 시켜라\" 같은 느낌이다.\n\n그러면 유저가 Promise에 넘길 함수 내용에 비동기 작업을 하고 Promise가 상태값과 결과값을 반영할 함수를 넣어줄거라 믿고 비동기 결과에 따라 적절한 메서드를 결과값과 함께 호출한다.\n\n## Promise 실행\n\n아랫쪽에 다시 `doResolve`를 사용함으로써 잘못 행동하는 `fn` 을 막아준다. 여기서 `fn` 은 `resolve`, `reject` 심지어 에러도 던질수 있기에 `resolved` 와 `rejected` 를 한번만 호출 될수 있도록 보장하고 또한 내부변수인 `state` 를 바뀌는걸 막아준다.\n\n```javascript\nconst PENDIGN = 0\nconst FULFILLED = 1\nconst REJECTED = 2\n\nfunction Promise(fn) {\n  let status = PENDING // Promise의 상태값\n  let value = null // 최종 결과값이 저장될 장소.\n\n  // 이부분부터..\n  function fulfill(result) {\n    status = FULFILLED // 상태값을 바꿔줌.\n    value = result // 결과값을 value 값에 넣어줌.\n  }\n\n  function reject(error) {\n    status = REJECTED // 상태값을 바꿔줌.\n    value = error // 실패한 에러를 value 값으로 넣어줌.\n  }\n\n  // 이 resolve 는 fulfill 또는 reject로 보낼수 있어야 한다.\n  // 여기서 result가 올수있는 값은 일반 plain 값이 올수 있고 다시 Promise가 올수있으므로 그 처리를 해두어야 한다.\n  function resolve(result) {\n    try {\n      let then = getThen(result) // 여기 then 함수가 있으면 Promise로 왔다고 간주. (getThen 은 헬퍼함수)\n      if (then) {\n        doResolve(then.bind(result), resolve, reject) // ( doResolve는 헬퍼함수 )\n        return\n      }\n      fulfill(result) // 일반 값으로 왔을 경우 이행.\n    } catch (e) {\n      reject(e)\n    }\n  }\n\n  // 실행\n  doResolve(fn, resolve, reject)\n\n  return {\n    PromiseStatus: status,\n    PromiseValue: value,\n  }\n}\n```\n\n## done 메서드 작성\n\n`done` 이라는 함수는 `resolver` 끝나고 실행되어야 할 함수를 등록하는 함수이다.\n`then` 이라는 함수를 작성하기 전에 `done` 이라는 함수를 작성해보자.\n`done` 메서드는 간단하면서도 `then` 메서드가 어떻게 실행이 되는지 생각해볼 수 있게 한다.\n`done` 메서드는 `promise` 가 끝나고 나서 해당의 행동을 정의하는 함수이다.\n\n```javascript\npromise.done(onFulfilled, onRejected) // 이렇게 실행이 되도록 할 것이다.\n```\n\n`done` 함수의 몇가지 목표가 있다.\n\n- `done` 함수의 인자의 `onFulfilled` 와 `onRejected` 는 둘 중 하나만 호출이 된다.\n- 호출될 함수(`onFulfilled`, `onRejected`)는 한번만 호출이 된다.\n- 호출될 함수(`onFulfilled`, `onRejected`)는 `done` 메서드가 return 되기 전까지 호출되지 않는다.\n- `promise` 안에 `resolve` 함수(어떠한 결과에 도달함)는 `done` 호출 전에 되었는지 후에 되었는지 상관없이 호출되어진다.\n\n실제로 javascript `promise` 에는 `done` 이라는게 없고 `jqeury` 의 `Deferred` 에는 존재하긴 하다. 어떻게 움직이는지 보자.\n\n```javascript\nconst PENDIGN = 0\nconst FULFILLED = 1\nconst REJECTED = 2\n\nfunction Promise(fn) {\n  let status = PENDING // Promise의 상태값\n  let value = null // 최종 결과값이 저장될 장소.\n\n  var handlers = [] // 성공과 실패 이후에 실행되어야 할 handler를 저장하는 공간.\n\n  // 이부분부터..\n  function fulfill(result) {\n    status = FULFILLED // 상태값을 바꿔줌.\n    value = result // 결과값을 value 값에 넣어줌.\n\n    handlers.forEach(handle) // 이행이 되고 난 다음에 후속 함수들을 실행한다.\n    handlers = []\n  }\n\n  function reject(error) {\n    status = REJECTED // 상태값을 바꿔줌.\n    value = error // 실패한 에러를 value 값으로 넣어줌.\n\n    handlers.forEach(handle)\n    handlers = []\n  }\n\n  // 이 resolve 는 fulfill 또는 reject로 보낼수 있어야 한다.\n  // 여기서 value가 올수있는 값은 일반 plain 값이 올수 있고 다시 Promise가 올수있으므로 그 처리를 해두어야 한다.\n  // Promise가 올 경우에는 then 함수에서 return 값으로 Promise를 넘길때이다.\n  function resolve(result) {\n    try {\n      let then = getThen(result) // 여기 then 함수가 있으면 Promise로 왔다고 간주. (getThen 은 헬퍼함수)\n      if (then) {\n        doResolve(then.bind(result), resolve, reject) // ( doResolve는 헬퍼함수 )\n        return\n      }\n      fulfill(result) // 일반 값으로 왔을 경우 이행.\n    } catch (e) {\n      reject(e)\n    }\n  }\n\n  function handle(handler) {\n    // handler 객체\n    if (status === PENDING) {\n      handlers.push(handler)\n    } else {\n      if (status === FULFILLED && typeof handler.onFulfilled === 'function') {\n        handler.onFulfilled(value)\n      }\n      if (status === REJECTED && typeof handler.onRejected === 'function') {\n        handler.onRejected(value)\n      }\n    }\n  }\n\n  const done = function(onFulfilled, onRejected) {\n    // done 호출 되기 전에 남아있는 함수들을 다 호출하고 handle 을 호출하기 위해\n    // 즉, 여기 있는 함수가 다 호출한 뒤에 호출을 할 목적을 가진 setTimeout 함수.\n    // setTimeout으로 감싼 함수는 webapis timer에 의해 관리되고\n    // 그이후에 나머지 코드를 스택에 쌓고 먼저 실행된다. 그 사이 타이머가 완료가 되고\n    // task queue에 콜백을 집어넣구 event loop는 스택이 비워져있으면 task queue에서 하나하나 꺼내어\n    // 실행시킨다.\n    setTimeout(function() {\n      handle({\n        onFulfilled: onFulfilled,\n        onRejected: onRejected,\n      })\n    }, 0)\n  }\n\n  // 실행\n  doResolve(fn, resolve, reject)\n\n  return {\n    PromiseStatus: status,\n    PromiseValue: value,\n    done,\n  }\n}\n```\n\n앞서 `Promise` 에 넘겨준 `fn` 이 모든 작업이 끝나면 `Promise`의 상태 값을 변경 하게 되고 변경된 상태 값에 따라서 `done`에 등록해둔 함수 (`onFulfilled`, `onRejected`) 를 호출 하게 된다.\n\n## done 함수의 분석\n\n눈 여겨 볼 부분은 `handlers` 와 `done` 함수 그리고 `fulfill` , `reject` 에 있는 `forEach` 메서드 , `handle` 함수이다.\n\n만약 아래처럼 호출했다고 가정하자.\n\n```javascript\nnew Promise((resolve, reject) => {\n  setTimeout(function() {\n    resolve(10)\n  }, 2000)\n}).done(value => console.log(value))\n```\n\n처음 Promise 인자로 받은 `fn` 은 `doResolve` 함수에 인자로 들어가서 호출당하게 된다. 이때 `fn` 에는 비동기인 `setTimeout` 함수가 호출되게 되고 이 안에 있는 `resolve(10)` 를 감싼 익명함수는 2 초 후에 task queue 에 쌓이게 된다.\n\n> 여기서 task queue 는 스택에 있는 실행문이 다 실행이 되고나서 실행된다. 그래서 정확히 2 초 후에 실행 된다는 보장이 없다.\n\n그리고 나서 `done` 함수를 호출하게 되면 여기서 `done` 호출도 비동기 함수인 setTimeout 함수가 실행이 되고 이는 0 초 후에 task queue 에 쌓이게 되어 타이머 차이로 위 `function(){ resolve(10) }` 보다 먼저 큐에 쌓이게 된다. 따라서 done 이 실행이 먼저 된다. handle 함수에서 status 를 파악하는데 `resolve()`가 실행하지 않은 상태이니 상태 값은 `pending` 이다. 따라서 `handlers=[]` 에 `handler 객체`를 push 하게 된다.\n\n그 이후에 `resolve(10)` 이 실행되면 `handlers`를 순회하면서 `handle 함수`를 실행한다.\n상태값이 `FULLFILLED` 가 되면서 `handler.onFuilfilled`를 결과값을 넣어서 실행 하게 된다.\n\n여기서는 `Promise` 의 `resolve` 함수가 `done` 함수 호출 이후에 호출이 되었다. `resolve` 함수가 아직 호출이 안되었기 때문에 상태는 `PENDING` 상태일 것이고 이때는 작업이 귀결(resolve)이 되고나서 실행되어야 할 `resolve`, `reject` 함수를 품은 객체를 `handlers` 라는 배열에 잠시 넣어두고 나중에 적절한 함수를 호출하도록 한다.\n\n만약 `resolve` 가 먼저 실행이 되었다면 `status` 가 `resolve` 된 귀결 상태(fulfill 이 되든 reject 가 되든)에 따라서 바로 `done` 에 넘겼던 함수를 호출하게 된다.\n\n## 여기까지의 요약\n\n여기까지의 `promise` 는 메인 객체 안에 넘겼던 함수가 최종적으로 결론이 났는지 (resolved 가 되었는지) 확인하는 상태값을 가지고 done 에 등록해둔 함수를 호출할지 말지를 결정한다.\n\n`Promise` 에서 인자로 받는 `fn` 에는 `resolve`, `reject` 2 개의 인자가 넘어가는데 이 `resolve`, `reject` 의 경우에는 Promise 안에 있는 내장된 함수들이고 이 함수들을 인자로 넣어서 `fn` 을 실행하게 된다.\n\n원하는 작업이 완료 되었을때 `resolve` (or `reject`) 에 해당 작업의 결과값을 넣어 호출하는 것의 의미는 `Promise` 안에 있는 내장함수들을 수행 시키고 그 작업 이 완료 되었을 때 done 메서드의 인자로 받은 함수를 실행 시키는 것이다.\n\n## then 메서드 작성\n\n`then` 메서드의 경우에는 `done` 과 비슷하지만 `Promise` 를 반환하면서 체이닝을 구성 할 수 있어야 한다.\n\n```javascript\nnew Promise(function(resolve, reject) {\n  // 비동기 처리 예제\n  setTimeout(function() {\n    resolve(1)\n  }, 2000)\n})\n  .then(result => {\n    // then은 새로운 Promise를 반환합니다.\n    console.log(result) // 1\n    return result + 10 // 여기서 return 값은 then이 반환하는 promise 객체의 resolved 된 값이다.\n  })\n  .then(result => {\n    console.log(result) // 11\n    return result + 10\n  })\n```\n\n위 처럼 실행이 되도록 할것이다.\n\n```javascript\nfunction Promise(fn) {\n  //... 윗부분 생략\n\n  const done = function(onFulfilled, onRejected) {\n    // done 호출 되기 전에 남아있는 함수들을 다 호출하고 호출하기 위해\n    // 즉, 비동기를 보장하기 위한 setTimeout 함수.\n    // setTimeout으로 감싸면 스택에 쌓인것부터 무조건 우선순위를 갖는다. 호출 순서에 상관없이\n    setTimeout(function() {\n      handle({\n        onFulfilled: onFulfilled,\n        onRejected: onRejected,\n      })\n    }, 0)\n  }\n\n  const then = function(onFulfilled, onRejected) {\n    // 이 then은 체이닝 될때 resolve 함수에서 then을 bind해서 넘긴다.\n    let self = this\n\n    // self(기존 Promise) 의 귀결이 끝나고 실행해야 하는걸 보장하기 위해 => self.done() 메서드 호출\n    // self.done() 메서드로 self Promise가 끝나고 실행해야 하는 함수 등록.\n    // 등록된 함수에서는 then 에서 등록해 뒀던 onFulfiled 호출 => resolve(onFulfilled(result))\n    // onFulfiled 함수가 결과 값이 나왔을때 새로운 Promise의 then에 등록해 뒀던 함수 다시 호출 => resolve(onFulfilled(result))\n\n    return new Promise((resolve, reject) => {\n      // 체이닝을 하기 위해서 promise를 리턴하자.\n      return self.done(\n        // 여기서 done 함수는 앞서 등록했던 promise가 resolve(귀결) 되었을시\n        // 그 status에 따라 호출될 함수들을 등록시킨다.\n        // 이 함수는 self promise가 resolve 했을 시 그 결과를 result에 넘겨주고\n        // 그 결과를 다시 then에서 넘어온 onFulfiled 함수의 인자로 넘긴다.\n        function(result) {\n          if (typeof onFulfilled === 'function') {\n            try {\n              // 리턴되는 값(then에서 인자로 줬던 함수가 실행되고 난 return 값: onFulfilled(result))을\n              // 다시 새로운 resolve에 넘겨주어야 그 다음 then에게 전달.\n              // 특히 이 onFulfilled(result) 의 리턴값이 Promise 객체라면\n              // 위 new Promise에서 해야할 resolve와 reject 함수를 onFulfilled(result) 의 리턴값인 Promise 객체가\n              // resolve 또는 reject 됬을시 실행하도록 만든다.\n              resolve(onFulfilled(result))\n            } catch (e) {\n              reject(e)\n            }\n          } else {\n            reject(onReject(result))\n          }\n        },\n        function(error) {\n          if (typeof onRejected === 'function') {\n            try {\n              return resolve(onRejected(error))\n            } catch (ex) {\n              return reject(ex)\n            }\n          } else {\n            return reject(error)\n          }\n        }\n      )\n    })\n  }\n\n  // 실행\n  doResolve(fn, resolve, reject)\n\n  return {\n    PromiseStatus: status,\n    PromiseValue: value,\n    done,\n    then,\n  }\n}\n```\n\n## then 함수 파헤치기\n\n앞서 `done` 함수의 경우 연속된 체이닝을 갖지 못하는 단점을 지니고 있었다.\n\n`then` 함수의 경우에는 연속된 `then` 호출을 할수있도록 체이닝을 지니고 있으면서 `then` 에 등록된 함수에서 `return` 값이 자동으로 그 다음 호출되는 `then` 핸들러의 인자값으로 전달 될수 있도록 모양새를 갖추고있다.\n\n위에서 `then` 은 연속된 `then` 호출을 위해 `promise` 로 감싸서 리턴을 하고있다.\n`then` 함수에서 하는 일은 앞의 `promise` 가 `resolve` 또는 `reject` 시 그 결과를 받아 호출될 함수들을 등록할 `done` 함수를 호출 하는 일이다.\n\n이 작업 또한 `new Promise()`로 감싸서 새로운 `Promise`(약속)으로 만들어 준다.\n\n`done` 함수에 앞서 `Promise` 가 귀결되면 호출될 함수를 등록하고 그 함수로 앞선 `Promise` 의 결과를 받게 되면 `then` 메서드에서 인자로 받았던 함수의 인자로 넘기게 되고 그 결과 값을 새로운 `Promise` 의 `resolve`에 인자로 귀결 값을 넘기게 된다.\n\n결국 맨 앞의 `Promise` 의 결과를 `then` 에 등록한 함수가 받는다. (이때 then 은 새로운 `Promise` 를 생성 및 리턴한다.)\n그 등록한 함수의 리턴 값은 새로운 `Promise` 의 `resolve()` 에 인자로 넘겨서 또 다시 `then` 에 등록한 함수가 받게끔 한다.\n\n기본적으로 `then` 에 등록한 함수에서 리턴된 값은 즉시 다음 `then` 에 등록된 함수로 전달이 된다. 만약 리턴된 값이 `promise` 라면 그 값이 귀결(resolve 또는 reject)될 때까지 기다린 후 귀결이 되면 `then` 에서 만들어뒀던 `Promise` 의 `resolve` 또는 `reject` 함수를 실행시켜 다음 `then` 호출로 이어지게 한다.\n\n```javascript\nnew Promise(function(resolve, reject) {\n  setTimeout(() => resolve(1), 1000)\n  // 여기서 resolve는 내부적인 resolve 함수를 호출,\n  // 그 이후에 fulfilled 과 value 1 셋팅 그 이후에 등록해뒀던 핸들러 함수 실행 ( 아래 then으로 등록해둔 함수 )\n  // 사실 then 함수는 바로 등록하기 보다는 해당 함수를 실행할수 있는 함수를 등록함.\n})\n  .then(function(result) {\n    alert(result) // 1\n\n    return new Promise((resolve, reject) => {\n      // (*)\n      setTimeout(() => resolve(result * 2), 1000)\n    })\n  })\n  .then(function(result) {\n    // (**)\n\n    alert(result) // 2\n\n    return new Promise((resolve, reject) => {\n      setTimeout(() => resolve(result * 2), 1000)\n    })\n  })\n  .then(function(result) {\n    alert(result) // 4\n  })\n```\n\n## then 에서 Promise 를 리턴했을 경우를 알아보자\n\n```javascript\nnew Promise(function(resolve, reject) {\n  setTimeout(() => resolve(1), 1000)\n})\n  .then(function(result) {\n    alert(result) // 1\n\n    return new Promise((resolve, reject) => {\n      // (*)\n      setTimeout(() => resolve(result * 2), 1000)\n    })\n  })\n  .then(function(result) {\n    // (**)\n    alert(result) // 2\n  })\n```\n\n처음 `Promise` 의 인자로 넣은 함수를 호출한뒤 `then` 함수들이(동기) 차례로 호출이 되면서 `Promise` 가 `resolve` 되었을때 호출될 콜백 함수들을 등록시킨다.\n\n1 초 뒤에 `resolve(1)` 이 호출되면 `Promise` 내부적으로 `status` 와 `value` 값을 업데이트 하고 그 다음 `then` 함수의 인자로 넘겼던 함수를 실행한다. 이로써 첫번째 `Promise`는 `then` 으로 등록해 두었던 함수를 호출하면서 끝이 난다.\n\n첫번째 `then` 을 실행시키면 아래 해당 함수가 `handler.onFulfilled` 로 등록이 된다.\n\n```javascript\n// then 함수안에 self.done 함수의 첫번째 인자. fulfilled 될때 실행할 함수를 등록\nfunction (result) {\n      if (typeof onFulfilled === 'function') {\n        try {\n          return resolve(onFulfilled(result)); // 여기 onFulfilled는 then에서 등록했던 함수.\n        } catch (ex) {\n          return reject(ex);\n        }\n      } else {\n        return resolve(result);\n      }\n    }\n```\n\n`resolve(1)` 이 실행 되면 등록되었던 위 함수가 실행이 된다.\n\n위 함수에 `onFulfilled(result)`이 실행되면서 `then`에 인자로 넘겼던 함수가 실행이 된다.\n그러면서 `alert(1)`이 실행이 되고, `return new Promise()` 가 실행이 되는데 다시 여기서는 `Promise` 의 인자 함수를 실행하고 `{PENDING, null}` 이런식으로 리턴이 된다.\n\n여기서 `resolve` 함수는 `Promise` 객체 내부에 있는 `resolve` 함수를 가리킨다.\n\n```javascript\nfunction resolve(result) {\n  try {\n    var then = getThen(result)\n    if (then) {\n      // result가 promise 객체이므로 result에 해당하는 then을 호출하자.\n      // then은 result의 done을 호출하면서 result결과에 따른 resolve, reject 함수를 등록한다.\n      doResolve(then.bind(result), resolve, reject)\n      return // 리턴\n    }\n    fulfill(result)\n  } catch (e) {\n    reject(e)\n  }\n}\n\nfunction doResolve(fn, onFulfilled, onRejected) {\n  let done = false // 중복 호출 방지\n  try {\n    fn(\n      function(value) {\n        if (done) return\n        done = true\n        onFulfilled(value)\n      },\n      function(reason) {\n        if (done) return\n        done = true\n        onRejected(reason)\n      }\n    )\n  } catch (e) {\n    if (done) return\n    done = true\n    onRejected(e)\n  }\n}\n```\n\n위 함수에서 `result` 가 `new Promise`의 리턴 값이므로 `fulfill(result)`를 호출하지 않고 (`then` 의 첫번째 인자로 들어왔던 함수가 다 끝났다고 보지 않고) 다시 `doResolve()` 를 실행하게 된다.\n여기서 첫 인자로는 `result` 로 들어왔던 리턴된 `Promise` 객체의 `then` 함수를 넘긴다.\n\n여기서 `then` 을 넘기는 이유!! 리턴 값이 `Promise` 객체 라는 것은 `then` 함수로 소비를 해줘야 그 값을 알 수 있는데 여기에선 단지 `return new Promise()` (첫번째 `then` 함수에 넘겼던 함수에서 리턴한 값) 로 그치기만 했다.\n\n그래서 리턴된 `Promise`를 귀결시키기 위해서 `doResolve` 함수에 `then` 함수와 함께 `resolve` 함수와 `reject` 함수를 인자로 넘기게 된다.\n\n첫번째 `then` 함수에 넘겼던 함수의 `fulfill` 된 사실을 미뤄두고(then 에서 return 하는 Promise) `result` 들어온 `promise` 의 객체의 `then` 함수를 실행시켜서 첫번째 `then` 함수에서 return 한 Promise의 `resolve` 함수를 다시 등록해둔다. 즉, 내부의 `promise` 부터 처리하고 처리가 완료되면 `then` 함수의 결과를 처리 하는 것이다.\n\n여기서 2 초 뒤에 `resolve(result * 2)` 이게 호출이 된다면 결과값으로 들어왔던 `Promise` 가 `resolve` 되고 아까 `doResolve(then.bind(result), resolve, reject)` 등록해뒀던 `resolve` 가 실행된다.\n\ndoResolve 함수가 실행이 될때에는 다음과 같은 모습이 될 것이다.\n\n```javascript\nthen(\n  // Promise 인자로 넘어왔던 함수 fn 인자로 넘겨줄 resolve\n  // then 함수 내부에서 onFulfilled 함수가 됩니다.\n  function(value) {\n    if (done) return\n    done = true\n    onFulfilled(value)  // resolve 함수\n  },\n  // Promise 인자로 넘어왔던 함수 fn 인자로 넘겨줄 reject\n  function(reason) {\n    if (done) return\n    done = true\n    onRejected(reason) // reject 함수\n  }\n)\n```\n\n아래 함수는 `then` 함수 내부 실행될 함수이고\n\n```javascript\nfunction (result) {\n      if (typeof onFulfilled === 'function') {\n        try {\n          return resolve(onFulfilled(result));\n        } catch (ex) {\n          return reject(ex);\n        }\n      } else {\n        return resolve(result);\n      }\n    }\n```\n\n위 함수에서 `onFulfilled` 는 `doResolve` 에서 등록한 아래 함수이고 아래 함수에서 `onFulfilled` 함수가 `doResolve(then.bind(result), resolve, reject)` 에서 두번째 인자인 기존 `promise` 를 지연해왔던 `resolve` 함수가 될 것입니다.\n\n```javascript\nfunction (value) {\n      if (done) return\n      done = true\n      onFulfilled(value)\n    }\n```\n\n그럼 결국엔 2 로 귀결 된 값이 호출이 되고 처음에 지연시켜놨던 `resolve` 가 다시 실행되고 이번엔 값이기 때문에 `fulfill(result);` 가 실행되서 `fulfill` 함수에 등록되었던 등록된 `handlers` 가 마저 실행된다.\n\n## Promise 함수 전체 이해\n\n- `Promise` 란 어떠한 작업을 수행한 뒤 그 작업에 대해 성공을 했는지 아니면 실패를 했는지 결과를 객체(promise 인스턴스)로서 나에게 알려주는 녀석이다. 그 약속의 객체에 메서드를 실행하면서 기존의 비동기 콜백 헬에서 비동기 선형으로 읽기 좋은 코드를 만들기 위한 노력이다.\n\n- 콜백이란 어떠한 작업이 모두 끝났을때 수행하도록 만든 함수이다. 이런 콜백함수는 일종의 약속인 셈이다. 상상해보자. 직접적으로 비동기 작업을 할때 약속을 주입시키는 방법은 콜백 헬을 만들 가능성이 아주 높다. 하지만 `Promise` 라는것으로 한번 감싸 준다면 비동기 작업을 수행하긴 하지만 그 결과를 소비하는 주체 즉, 약속의 행동이 나타나기 전까지는 그 결과 값을 바로 내뱉지 않는다. (`then` 이라는 함수 호출을 통해 그 결과 값을 받아올수 있다.) 그러므로 바로 사용될수 없다. 이런 해당 결과값은 리턴된 객체 안에 보관 시켜둔다. 그래서 약속을 계속 주입하기 보단 순차적인 약속을 만들어 콜백 헬을 막을 수 있다.\n\n- then 이라는 체이닝을 제외하고 `Promise` 의 대략적인 구현 방식은 인자로 받은 첫번째 함수가 결과값을 내고 그 다음 실행하고 싶은 함수 즉, 약속하고 싶은 코드(함수)를 done 함수를 통해서 등록한다. 비동기가 끝난 뒤 resolve 를 실행 하게 되면 등록 되었던 함수가 동작하게 된다. 이것은 `resolve` 라는 함수는 해당 `Promise` 에서 인자로 받았던 함수가 모든 수행을 다 했다는걸 알리기 위한 함수이고 내부적으로 등록해뒀던 `handlers` 들을 `forEach` 하면서 실행하게 된다.\n\n- 체이닝의 경우 처음 동기화 부분이 다 진행된 뒤에 ( 비동기는 나중에 실행될 부분이므로 ) `then` 함수가 진행이 된다. `then` 함수는 기본적으로 `Promise` 를 리턴하므로 체이닝으로 `then` 함수를 또 불러올수 있고 `Promise` 인자인 함수를 바로 호출하게 된다.\n  여기서 `done` 함수를 이용해서 처음에 `Promise` 로 넘겼던 함수(fn) 비동기 완료 후 (`resolve` 후) 불러올 `handler` 를 등록을 해둔다. 그 이후로도 마지막 `then` 까지 실행이 되며 (사실 이 중간에 각 `Promise` 에 `resolve` 가 호출 되었을수도 아닐수도 있다.) 이 `then` 메서드들은 각기 다른 `Promise` 객체(다른 `context` 를 지님, `then` 호출시 `new Promise`를 하기 때문)의 핸들러(`Promise` 안에 `handler` 배열 )에 `fulfill` 과 `reject` 함수를 등록시킨다. \n  이후 비동기 값이 귀결값이 정해지면 `done` 에서 등록해두었던 `handler` 함수가 실행 될것이고 `hendler` 안에는 `then` 에서 등록해두었던 `onFulfilled` 함수를 실행한다. 여기서 나온 리턴값을 가지고 다시 `resolve` 를 시켜주게 되면 계속적으로 등록해두었던 함수를 호출하게 된다.\n\n  즉, `then` 함수는 새로운 약속만드는 함수이다. `then` 에 인자로 넘긴 함수(`onFulfilled`, `onRejected`)에서의 일련의 작업들이 완료되는 경우(`resolved`: 귀결), 그 다음 체이닝 `then` 으로 등록했던 함수에 인자로 그 결과를 다시 또 알려주겠다는 약속인 셈이다.\n  여기서 특히 인자로 넘기는 함수 안에서 다시 `Promise` 객체를 리턴하는 로직을 만난다면 그 `promise` 가 `resolve` 되었을때 수행하는 작업(여기선 또다른 `then` 일 것이다. `then` 을 호출해야 결과 값을 가져올 수 있기 때문이다.) `then` 을 자동으로 등록 해주어 그 결과 값이 `then` 의 `promise` 로 전달 될 수 있도록 한다.\n\n- `Promise` 의 인자 함수에 비동기 코드가 아닌 일반 코드가 들어갔을 경우 (ex. `resolve(1)`만 들어가있을 경우 ) 여기서 동기적인 `resolve(1)` 호출은 `Promise` 의 `resolve` 함수는 상태값과 귀결값(1) 만 셋팅해주고 나머지 done 이나 then 에서 등록된 함수를 내 상태(`Promise` 에 등록해두었던 함수, 즉 `Promise` 의 인자로 넘겼던 함수)가 귀결되었으므로 그 결과를 등록함수 인자로 넘겨서 실행시킨다.\n\n- then 체이닝에서 첫번째 `then` 에 등록한 함수가 리턴 값이 `Promise` 값이라면 (`return new Promise()`)\n  then 에서 리턴할 `Promise` 의 resolve 함수에서 `Promise` 객체를 인자로 받고 `resolve(Promise객체)` 그 객체(`Promise`)가 다시 `resolve` 될때까지 지연시킨다. (결과에 `then` 함수가 있다면 그 `Promise` 결과 객체(`{status:'', value:''...}`)에 있는 then 을 수행하게 된다. `then` 을 수행할때 바로 앞서 실행하고 있는 `resolve` 를 등록해줌으로써 `Promise` 결과 객체의 `value` 값을 추출해 올수 있다. )\n\n- resolve 함수에서 `getThen` 함수는 `result` 값이 `Promise` 객체일 경우 처리해주는 함수이다.\n\n- `doResolve` 해당 헬퍼 함수는 `Promise` 에 등록되는 `fn` 을 실행시켜줄 뿐 아니라 `resolve` 또는 `reject` 를 한번만 실행시킬수 있도록 `done` 이라는 변수로 보장해주는 함수이다. 여기서 `resolve` 는 `Promise` 안의 내장되어있는 `resolve` 함수로 일반 값 또는 또다른 `Promise` 의 리턴 값을 받을 수 있도록 분기 처리 해주는 함수이다.\n\n## 결론\n\n- 고차함수의 특성(함수를 인자로 받을수 있고 리턴 할 수 있다.)을 이용해서 `Promise` 를 구현하고 있다.\n- `then` 으로 등록하는 함수 안에서 또다른 비동기를 구현한다면 `Promise` 로 감싸 주어야 한다. 그래야 비동기 결과를 가지고 그 다음 `then` 으로 등록된 함수에 인자로 넣어줄 수 있다.\n- `then` 을 수행시 마다 새로운 스코프 환경이 생긴다. `then` 을 수행한다는 것은 자신의 스코프에 등록되어 있는 함수를 수행 완료 즉, 결과값을 받아내고 나서 다음으로 그 결과 값을 가지고 호출되어야 하는 함수를 등록해줄 뿐만 아니라, 그 등록된 함수가 수행이 완료되고 또 다른 결과를 가지고 또 다른 함수 호출을 보장하기 `then` 의 실행 구문(후속 처리를 해야하는 함수를 등록하는 `done` 함수)을 `Promise` 로 감싸주고 리턴해준다. 그렇게 되면 두번째 `then` 함수에 등록되었던 함수가 해당 결과 값을 가지고 실행할 수 있다.\n\n아주 간단하게 말해서는 A 라는 함수는 A 라는 함수 동작 이후에 호출될 B 라는 함수를 호출 할 수 있는 함수 B-1(일종의 호출버튼: resolve 함수)를 매개변수로 받을 거라는 Promise 객체의 약속을 받고 유저는 A 함수를 작성 하고 Promise에 넘기게 된다. `A함수(B-1함수)`\n\n이때, A 라는 함수 동작 이후에 B 라는 함수를 호출하게 만들어 주기 위해서 제 3자인 Promise 객체가 A 라는 함수와 B 라는 함수를 가지면서 A 라는 함수가 약속의 함수를 적절할때 호출(위에서 말했던 B-1 함수)해주면 Promise는 가지고 있던 B 라는 함수를 호출해 준다.\n\n다시 B 라는 함수가 끝났을 때 다시 C 라는 함수를 호출 할 수 있게 하기 위해서는\n\n위에서 언급했던 B 라는 함수를 호출할 수 있는 함수 B-1을 다시 새로운 C 함수를 호출 할 수 있는 함수(C-1)를 가진 Promise 에 등록을 해서 B가 호출이 되서 리턴이 되면 C 라는 함수를 호출 할 수 있는 함수 C-1을 호출하게끔 만든다. `C-1(B())`\n\n즉, A가 호출이 되고 -> B 라는 함수를 호출할 수 있는 함수 B-1 호출 -> B 호출 후 리턴 -> B 리턴 값 받아서(리턴 및 귀결될때까지) -> C 라는 함수를 호출할 수 있는 함수 C-1 호출 -> C 호출 순서가 된다.\n\n이때, B가 비동기 호출을 지닌 함수라면 기다렸다가 B가 귀결되어서 리턴되면 C 라는 함수를 호출할 수 있는 함수가 그때 호출된다.\n\n## 출처\n\n[https://www.promisejs.org/implementing/](https://www.promisejs.org/implementing/)\n","excerpt":"동기 javascript 비동기를 다루는데 쓰이는 Promise 라는 객체가 있다. Promise 를 다루는 방법은 많지만 실제로이 객체가 어떤 방식으로 움직이는지 그 구조를 파악하면서 Promise 를 좀더 자유자재로 다뤄보자. 틀 만들기 prom…","fields":{"slug":"/make-promise.md/"},"frontmatter":{"date":"Jul 27, 2018","title":"make promise","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## intro\n\n* 공통모듈을 한 repo 에서 관리 하는 시도를 해보자.\n* 여러 npm 패키지를 하나의 github repo 에서 관리하자.\n* 즉, monorepo 를 구축해서 공통모듈을 관리하는 환경을 만들자.\n\n## monorepo 의 이점\n\n* lint 나 build, test, release 프로세스를 한가지로 가져갈수 있다.\n* 개발 환경을 따로 구축할 수고를 덜어준다.\n* devDependency 를 한곳에서 관리 할 수 있다.\n* 여러 이슈를 중앙에서 관리할 수 있다.\n\n## monorepo 의 단점\n\n* 한 repo 가 커질 수 있다.\n\n## monorepo 를 사용하고 있는 곳\n\n* babel\n* react\n* etc..\n\n## monorepo 를 사용할 수 있는 수단.\n\n* lerna [https://lernajs.io/](https://lernajs.io/)\n* yarn workspace [https://yarnpkg.com/lang/en/docs/workspaces/](https://yarnpkg.com/lang/en/docs/workspaces/)\n* git sub-modules\n\n## lerna\n\n각각의 독립적인 버젼을 가지고 있는 큰 코드베이스 분리는 코드 공유에 큰 이점을 가진다.\n하지만 많이 얽혀져있는 repositories 는 추적하기도 어렵고 지저분합니다. 그리고 테스팅도 복잡해집니다.\n\n이 문제를 해결하기 위해 몇몇 프로젝트는 multi-package repositories 를 설계하고(monorepos 라고 불리움) Babel, React, Angular, Ember, Meteor, Jest 프로젝트들이 싱글 repository 안에 그들의 모든 패키지들을 관리합니다.\n\nlerna 툴은 git 및 npm 을 사용하여 multi-package repositories 를 관리하는 작업을 최적화 하는 도구이다.\n\nLerna 는 또한 개발 및 빌드 환경에서 패키지의 수많은 복사본에 대한 시간과 공간을 줄여줍니다.\n\n`lerna 3.0 이상을 기준으로 합니다.`\n\n### lerna 명령어 사용법\n\n* lerna 초기화 및 independent 모드로 실행\n\n```sh\n$ lerna init -i\n```\n\n* 각 패키지 안에 들어있는 모듈의 npm install 을 실행\n\n```sh\n$ lerna bootstrap\n# 1. 각 패키지의 모든 외부 dependecies를 npm install 해준다.\n# 2. 서로의 dependencies들을 가지고 있는 package들을 Symlink 해준다.\n# 3. 모든 bootstrap 당한 packaged들을 npm run prepublish를 실행한다. ( --ignore-prepublish가 없을경우)\n# 4. 모든 bootstrap 당한 packaged들을 npm run prepare를 실행한다.\n\n$ lerna bootstrap --hoist [glob]\n# glob에 매칭된 모든 외부 dependencies들을 repo의 root에 설치해준다. \n# 이 dependencies들은 node_moules/.bin/ 디렉토리에 연결되고 npm script가 가능하게 해준다. \n```\n\n여기서 hoist를 사용하게 되면 다음과 같은 수행을 하게 됩니다.\n  - 공통된 dependencies들을 오직 top-level의 node_modules에 설치하고 각각의 package에의 node_modules에서 생략됩니다.\n  - 서로 다른 버젼을 가진 package들은 각 로컬에 정상적으로 설치하게 됩니다.\n  - 공통 패키지들의 바이너리 파일들은 개별 패키지의 node_modules/.bin/ 디렉토리와 심볼릭 링크되어 있으므로 package.json 스크립트를 수정없이 사용할수 있다.\n\nNode module resolution algorithm에 따르면 패키지 A를 찾으려고 할때 가장먼저 node_modules/A 를 찾고 그 후엔 ../node_modules/A, ../../node_modules/A, ../../../node_modules/A 이런식으로 상위 폴더의 node_modules를 찾곤한다. \n\n하지만 특히 dependencies들이 local에 있다고 구체적으로 가정하거나 요구하는 경우에는 위 룰을 따르지 않는다. 그래서 이 문제를 해결하기 위해선 top-level에 있는 패키지를 각 패키지 node_module 디렉토리에 symlink 하는 방법이 있다. 하지만 lerna에선 지원하지 않는다.\n\n* 각 패키지들이 마지막 릴리즈 이후에 변화가 있었는지 체크\n\n```sh\n$ lerna updated\n```\n\n* 각 패키지 안에 있는 npm script 를 한번에 run 시켜줌.\n\n```sh\n$ lerna run [script]\n\n$ lerna run --scope my-component test\n```\n\n* 각 패키지 안에서 쉘 스크립트를 실행할수 있다.\n\n```sh\n$ lerna exec [command]\n## ex) lerna exec rm -rf ./node_modules\n```\n\n\n* 모듈간의 의존성 추가\n\n```sh\n## moduleb 의 package.json에 dependency에 modulea 추가\n$ lerna add modulea --scope=moduleb\n\n## moduleb 의 package.json에 devDependency에 modulea 추가\n$ lerna add modulea --scope=moduleb --dev\n\n## 모든 모듈 package.json에 devDependency에 moduleb 추가\n$ lerna add modulea\n```\n\n* 버젼을 수정합니다.\n\n```sh\n$ lerna version 1.0.1 # explicit\n$ lerna version patch # semver keyword\n$ lerna version       # select from prompt(s)\n```\n해당 버젼을 수행하면 다음과 같은 일이 일어난다.\n\n1. 이전 태그 릴리즈 이전부터의 지금까지의 변경사항을 확인한다.\n2. 새로운 버젼에 대한 프롬프트 안내를 한다.\n3. 새로운 릴리즈 정보를 반영한 패키지를 수정한다.\n4. 변경사항을 커밋하고 그 커밋에 태그를 단다.\n5. git remote에 push한다.\n\n`주의` : version 명령시에 git push를 할 수 있는 상태가 되어야 한다. 이미 push를 다 해버린 상태라면 push를 할 수가 없다고 에러가 뜬다.\n\n그래서 수동으로 package.json의 version 을 내리고 다시 lerna version으로 올리는 방법이 있겠다. \n그전에 git tag -d 로 기존에 있던 tag들은 없앤다.\n\n* 배포 ( git 및 npm )\n\n```sh\n\n$ lerna publish\n## git 뿐만 아니라 npmjs 에도 배포 ( npm publish )\n\n$ lerna publish --skip-npm ## Deprecated\n## npm 생략 ( 대신 git 에도 올라가지 않음 )\n## 이렇게 publish 하면 package.json 의 버전이 업데이트가 되고\n## 그에 관련된 의존성있던 모듈들의 package.json의 devDependency 나 dependency의 해당 모듈의 버젼도 업데이트 시켜준다.\n\n$ lerna publish from-git \n## explicitly publish packages tagged in current commit\n## lerna version을 별도로 수행하지 않고 현재 있는 태그로 publish를 도와준다. \n## 주의할 점은 현재 커밋의 tagged를 배포한다는 것이다. 커밋만 있고 Annotated tag가 없다면 \n## No tagged release found 라는 메세지가 뜨면서 배포가 되질 않는다.\n## 그냥 커밋만 했을시엔 lerna publish 를 실행시켜서 다시 version 을 수정해주어야 한다.\n\n$ lerna publish from-package\n# explicitly publish packages where the latest version is not present in the registry\n# 각 package.json을 확인해서 version이 registry에 있지 않은 가장 마지막 커밋을 배포한다. \n# 이는 이전 lerna publish가 모든 패키지 등록을 실패했을때 유용하게 사용할 수 있다.\n```\n\n* 패키지 모듈 생성 \n\n```sh\n$ lerna create test1\n\n## lerna로 관리될 패키지 모듈 생성\n## test1이라는 폴더 이름으로 packages 폴더 안에 생성된다. \n```\n\n`참고 1` : lerna 의 version 과 changed 의 기준은 최신 Annotated tag를 기준으로 한다. npm version 과 lerna version 의 경우 자동으로 Annotated tag를 생성해준다. ( npm version 의 경우 git 사용시 )\n\n`참고 2` : npm version 과 publish 는 git 이랑 무관하게 사용할 수 있다. \n\n`참고 3` : npm publish 의 경우에는 오로지 npm package.json의 version 만 보고 해당 버져닝으로 배포한다. \n\n* 자세한건 lerna 공식 홈페이지 참조.\n  [https://lernajs.io/](https://lernajs.io/)\n\n### lerna json 셋팅\n\n* version: 현재 repository 버젼\n* packages: packages 경로, 배열과 glob 사용.\n* command.publish.ignoreChanges: `lerna changed/puslish` 할때 포함시키지 않을 파일\n* command.bootstrap.ignore: `lerna bootstrap` 명령어 사용할시 bootstrap 안할 리스트 , 배열과 glob 사용\n* command.bootstrap.scope: `lerna bootstrap` 명령어 사용할시 packages 들의 영역을 지정한다. 배열과 glob 사용.\n* command.bootstrap.npmClientArgs: `lerna bootstrap` 명령 사용할시 `npm install`에 직접 넘겨야할 인자들을 배열로 받는다.\n\n\n### lerna 장점\n\n* 공통의 devDependencies 를 가질수 있다.\n  * 대부분의 devDependencies 를 root repo 에서 당겨 받을수 있다.\n  * 모든 패키지들은 같은 버젼의 dependency 로 사용할 수 있다.\n  * 스토리지를 적게 들수있다.\n\n## yarn Workspaces\n\nYarn Workspaces 는 단일 루트 package.json 파일의 하위 폴더에있는 여러 package.json 파일의 종속성을 모두 한 번에 설치할 수있는 기능입니다.\n\n또한 워크스페이스들 간의 중복된 package 를 막아주므로써 가볍고, Yarn 은 서로 의존하는 Workspace 간에 심볼릭 링크를 만들 수 있으며 모든 디렉토리의 일관성과 정확성을 보장합니다.\n\nYarn Workspaces 는 lerna 툴 처럼 사용할 수 있는 low-level 의 primitives 이다.\nlerna 가 제공하는 high-level 의 특징들을 제공하진 않지만, 코어로직의 실행과 linking steps 로 더 향상된 퍼포먼스를 제공할 수 있다.\n\n```javascript\n// package.json 에 아래와 같이 설정\n\"workspaces\": [\n    \"packages/*\"\n  ],\n```\n\n```javascript\n// jest-matcher-utils package.json\n{\n  \"name\": \"jest-matcher-utils\",\n  \"description\": \"...\",\n  \"version\": \"20.0.3\",\n  \"license\": \"...\",\n  \"main\": \"...\",\n  \"browser\": \"...\",\n  \"dependencies\": {\n    \"chalk\": \"^1.1.3\",\n    \"pretty-format\": \"^20.0.3\"\n  }\n}\n```\n\n```javascript\n// jest-diff package.json\n{\n  \"name\": \"jest-diff\",\n  \"version\": \"20.0.3\",\n  \"license\": \"...\",\n  \"main\": \"...\",\n  \"browser\": \"...\",\n  \"dependencies\": {\n    \"chalk\": \"^1.1.3\",\n    \"diff\": \"^3.2.0\",\n    \"jest-matcher-utils\": \"^20.0.3\",\n    \"pretty-format\": \"^20.0.3\"\n  }\n}\n```\n\n위와 같이 설정 후 각 패키지 모듈안에서 `yarn install` 명령을 실행하면 아래와 같은 구조를 만들어준다.\n아래 구조에서 symlink를 잘 보자!!\n\n```\n| jest/\n| ---- node_modules/\n| -------- chalk/\n| -------- diff/\n| -------- pretty-format/\n| -------- jest-matcher-utils/  (symlink) -> ../packages/jest-matcher-utils\n| ---- package.json\n| ---- packages/\n| -------- jest-matcher-utils/\n| ------------ node_modules/\n| ---------------- chalk/\n| ------------ package.json\n| -------- jest-diff/\n| ------------ node_modules/\n| ---------------- chalk/\n| ------------ package.json\n```\n\n마지막으로 `yarn install`을 진행하면 아래와 같은 계층을 얻을수 있다.\n\n`yarn install`시 패키지들의 있는 모듈들을 root 디렉토리쪽으로 hoisted 시켜준다.\n대신 버젼이 다른 dependency 에 한해서는 hoisted 시켜주지 않는다.\n\n이것은 lerna 의 bootstrapping 의 `--hoint` flag 효과와 같다.\n\n```\n| jest/\n| ---- node_modules/\n| -------- chalk/\n| -------- diff/\n| -------- pretty-format/\n| -------- jest-matcher-utils/  (symlink) -> ../packages/jest-matcher-utils\n| ---- package.json\n| ---- packages/\n| -------- jest-matcher-utils/\n| ------------ node_modules/\n| ---------------- chalk/\n| ------------ package.json\n| -------- jest-diff/\n| ------------ node_modules/\n| ---------------- chalk/\n| ------------ package.json\n```\n\n패키지 `diff`, `pretty-format` 그리고 symlink인 `jest-matcher-utils` 들은 root의 node_moules 디렉토리로 hoist 된다.\n그러나 `chalk`의 경우네는 root에 이미 다른 버젼이 설치되어있기 때문에 root로 hoist 되지 않는다. \n\n위와 같은 구조에서 jest-diff 워크스페이스 안이라면, 코드 안에서 다음과 같이 resolve 될것이다.\n\n- require(‘chalk’) resolves to ./node_modules/chalk\n- require(‘diff’) resolves to ../../node_modules/diff\n- require(‘pretty-format’) resolves to ../../node_modules/pretty-format\n- require(‘jest-matcher-utils’) resolves to ../../node_modules/jest-matcher-utils that is a - symlink to ../packages/jest-matcher-utils\n\n### yarn Workspaces setting\n\n* root 에 있는 package.json 에 아래와 같이 셋팅한다.\n\n```javascript\n{\n  \"private\": true,\n  \"workspaces\": [\"workspace-a\", \"workspace-b\"]\n}\n```\n\n* 각 워크스페이스의 package.json 은 아래와 같이 셋팅한다.\n\n아래 보면 줄일 수 third-party dependecies 들이 보인다.\nWorkspaces 를 활성화 시키면 yarn 은 dependency 구조를 좀더 최적화 시켜준다.\n\n```javascript\n// workspace-a/package.json:\n\n{\n  \"name\": \"workspace-a\",\n  \"version\": \"1.0.0\",\n\n  \"dependencies\": {\n    \"cross-env\": \"5.0.5\"\n  }\n}\n```\n\n```javascript\n// workspace-b/package.json:\n\n{\n  \"name\": \"workspace-b\",\n  \"version\": \"1.0.0\",\n\n  \"dependencies\": {\n    \"cross-env\": \"5.0.5\",\n    \"workspace-a\": \"1.0.0\"\n  }\n}\n```\n\n\n\n```sh\n/package.json\n/yarn.lock\n\n/node_modules\n/node_modules/cross-env\n/node_modules/workspace-a -> /workspace-a\n\n/workspace-a/package.json\n/workspace-b/package.json\n```\n\n* 위 처럼 적용이 될때 workspace-b 에있는 파일에서 workspace-a 를 요구하면 현재 Github 에 게시 된 코드가 아니라 프로젝트 내부에있는 정확한 코드가 사용되며 cross-env 패키지가 올바르게 중복 제거되어 프로젝트의 루트에 놓입니다.\n\n* lerna 2.0.0 에선 lerna 커맨드 이용시 `--use-workspace` flag 를 사용하면 프로젝트의 bootstrap 을 Yarn 을 사용하게 된다. 이렇게 되면 root-level의 `packages.json/workspaces` 필드의 값이 `lerna.json/packages` 값을 재정의 한다.\n\nlerna.json 파일로 설정하는 방법은 아래와 같다.\n\n```javascript\n{\n  ...\n  \"npmClient\": \"yarn\",\n  \"useWorkspaces\": true\n}\n```\n\n## 결론\n\n* lerna 와 yarn workspace 를 사용하면 중복되는 dependency 에 관해서 관리를 할 수 있다.\n* yarn workspace 와 lerna 는 쉽게 통합될수 있다.\n* lerna를 이용하면 버져닝과 publish의 flow를 강제해서 많은 모듈들을 관리할 수 있다.\n* lerna 를 이용하면 yarn workspace 에서 할수 없는 다양한 기능들을 사용할 수 있다. ( testing, 배포 , 버젼관리 , 패키지별 scripting 명령)\n* 같은 환경속에서 여러가지 dependency 를 가지고 여러 패키지들을 다룬다면 monorepo 를 사용할만 할것 같다.\n","excerpt":"intro 공통모듈을 한 repo 에서 관리 하는 시도를 해보자. 여러 npm 패키지를 하나의 github repo 에서 관리하자. 즉, monorepo 를 구축해서 공통모듈을 관리하는 환경을 만들자. monorepo 의 이점 lint 나 build…","fields":{"slug":"/experience-monorepo.md/"},"frontmatter":{"date":"Jul 13, 2018","title":"experience monorepo","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 객체지향 이란?\n  * 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법\n  * 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체\n  * 객체는 시스템의 행위를 구현하기 위해 다른객체와 협력, 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.\n  * 객체는 다른 객체와 협력하기 위해 메세지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는데 적합한 메서드를 자율적으로 선택한다.\n  * 메시지는 곧 책임이다.\n\n## 역할, 책임, 협력\n  * 객체는 협력을 위해 특정할 역할을 맡고 적합한 책임을 수행한다.\n  * 여기서 역할은 대체 가능성을 의미한다. \n  * 각 객체는 책임을 수행하는 방법을 자율적으로 선택 하고 다른 객체와 협력한다.\n  * 객체는 다른 객체가 '무엇(what)'을 수행하는지는 알수 있지만 '어떻게(how)' 수행하는지에 대해서는 알 수 없다.\n  * 객체지향 세계에서는 오직 '메시지' 라는 의사소통만이 존재한다.\n\n### 협력\n\n  * 협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작된다.\n  * 요청 받은 사람은 응답을 한다.\n  * 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의하게 된다.\n\n### 책임\n\n  * 적절한 행동을 한 의무가 있는 경우에 해당 객체가 책임을 가진다고 할 수 있다.\n  * 책임은 주로 하는것(doing)과 아는것(knowing)으로 분류된다.\n    * 하는 것 \n      * 객체를 생성하거나 계산을 하는 등의 스스로 하는것\n      * 다른 객체의 행동을 시작시키는 것\n      * 다른 객체의 활동을 제어하고 조절하는 것\n    * 아는 것\n      * 개인적인 정보에 관해 아는 것\n      * 관련된 객체에 관해 아는 것\n      * 자신이 유도하거나 계산할 수 있는 것에 관해 아는것\n  * 즉, 책임은 객체의 외부에 제공해 줄 수 있는 정보(아는것의 측면)와 외부에 제공해 줄 수 있는 서비스(하는 것의 측면)의 목록이고 이 책임은 객체의 공용 인터페이스를 구성하게 된다. \n\n### 역할\n\n  * 어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다. \n  * 역할은 재사용이 가능하고 유연한 객체지향 설계를 낳는 매우 중요한 구성요소이다.\n  * 역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다. 즉, \"이 자리는 나 대신 이 역할을 수행할수 있다면 누구라도 대체할 수 있어\" 라고 말하는것과 같다.\n  * 역할은 객체지향 설계의 \"단순성\" , \"유연성\" , \"재사용성\" 을 뒷바침 하는 핵심 개념이다.\n  * 역할을 사용하면 협력을 추상화 시킬 수 있다.\n\n\n## 타입과 추상화\n\n### 추상화\n\n  * 추상화란 실제의 사물에서 자신이 원하는 특성만 취하고 필요 없는 부분을 추려 핵심만 표현하는 행위이다.\n  * 추상화는 어떤양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법.\n  * 구체적인 사물 간의 공통점은 취하고 차이점을 버리자.\n  * 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거해 단순화 하자.\n  * 추상화 매커니즘의 종류로는 '분류와 인스턴스화' , '일반화와 특수화' , '집합과 분해' 가 있다.\n\n ### 분류의 인스턴스화 \n  * '분류와 인스턴스화' 의 예로는 자동차 , 새 , 나무 등이 되겠다.\n  * '분류' 라는것은 세상에 존재하는 객체에 개념을 적용하는 과정이다. 객체의 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다.\n  * 사람들은 이 '분류'를 통해 개별 현상을 하나의 개념으로 다루고 이때 수많은 객별적인 현상들을 '객체' , '하나의 개념' 을 '타입' 이라고 한다. \n\n### 일반화와 특수화  \n  * 일반화와 특수화는 계층 관계를 이루고 있다. 'is-a' 관계.\n\n### 집합과 분해  \n  * 복잡성은 '계층'의 형태를 띤다.\n  * 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 '안정적인 형태'의 수와 분포에 의존한다. \n  * 안정적인 형태의 부분으로부터 전체를 구축하는 행위를 집합이라고 한다.\n  * 반대로 전체를 부분으로 분할하는 행위를 분해라고 한다. \n  * 집합의 가치는 불필요한 세부사항을 배제하고 큰 그림에서 대상을 다룰 수 있게 한다. 즉, 불필요한 부분을 추상화 한다. \n  * 합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다. 즉, 어느 한 객체 안에 아예 포함시키는 것이다. \n  * 연관 관계는 단순한 물리적 통로가 존재한다는 사실만 나타낸다. 연관관계로 연결된 두 객체는 생명주기와 관련된 어떤테약도 부과하지 않는다. 즉, 독립적이다. \n  * 합성관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화 하는 것처럼 패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화 한다.\n  \n\n### 개념\n\n  * 공통점을 기반으로 객체를 묶기 위한 그릇을 개념(concept) 라고 한다.\n  * 개념의 관점 : 심볼(symbol), 내연(intension), 외연(extension)\n  * symbol : 개념을 가리키는 이름이나 명칭\n  * intension : 개념의 완전한 정의 이 의미로 인해 객체가 개념에 속하는지 여부를 확인할 수 있다.\n  * extension : 개념에 속하는 모든 객체의 집합.\n  * 개념을 이용해 객체의 복잡성을 극복하고 분류하자.\n\n### 타입\n\n  * 타입은 개념이다. \n  * 타입은 공통점을 기반으로 객체들을 묶기 위한 틀이다. \n  * 어떤 객체의 타입이 자동차라고 말할 수 있으려면 자동차가 무엇인지에 대한 명확한 정의가 필요하다.\n  * 타입은 개념과 마찬가지로 심볼, 내연, 외연을 이용해 서술할 수 있으며 타입에 속하는 객체 역시 타입의 인스턴스라고 한다. \n  * '타입이 없다' 라는 말은 메모리 안의 데이터를 다룰 수 있는 단 하나의 타입만이 존재한다는 것을 의미. 사실 메모리 세상엔 타입이라는 질서가 없다.\n  * 타입이 없는 체계에서는 메모리 안의 값이 어떤 의미인지 말할수 있는 사람은 없다. '1001001'만 보고 숫자인지 문자열인지 해석할 수 있는가?\n  * 데이터 타입이란 메모리 안의 데이터에 특정한 의미를 부여한 것이다. 사람들은 자신이 다뤄야 하는 데이터의 용도와 행동에 따라 그것들을 분류한것이다.\n  * 타입 시스템의 목적은 메모리 안의 모든 데이터가 비트열로 보임으로 그 혼란을 막기 위함이다. 메미로 안에 저장된 0과 1에 대해서 수행 가능한 작업과 불가능 작업을 구분함으로써 데이터가 잘못 사용되는것을 방지한다. \n\n\n### 객체와 타입\n  \n  * 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 새로운 데이터 타입을 선언하는것과 같다.\n  * 객체가 어떤 타입에 속하는지는 객체가 수행하는 행동이다. 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.\n  * 내부적인 표현은 외부로부터 철저하게 감춰진다. \n  * 객체를 결정하는 것은 행동이다. 데이터는 단지 행동을 따를 뿐이다. \n  * 객체가 외부에 제공해야 하는 행동을 먼저 생각하자.\n  * 객체는 시시각각 변할 수 있기 때문에 타입을 사용하면 시간과 무관한 정적인 모습으로 다룰수 있게 해준다. 즉, 타입은 추상화이다. 객체의 상태 변경이라는 복잡성을 단순화 할수 있는 방법이다.\n\n### 일반화/특수화 ( 슈퍼타입/서브타입 )\n  \n  * 일반화 / 특수화의 적절한 예는 고양이과 동물 / 사자 를 들수 있을 것이다.\n  * 일반화 / 특수화 관계를 결정짓는 것은 객체의 상태가 아닌 행동이다. \n  * 여기서 일반적인 타입은 특수적인 타입의 모든 행동중에서 일부 행동만 가진다.\n  * 특수한 타입이란 일반적인 타입이 가진 모든 타입을 포함하지만 거기에 자신만의 행동을 추가하는 타입을 가리킨다. \n\n### 클래스\n  \n  * 클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나이다.\n  * 자바스크립트의 경우에는 프로토타입 기반의 언어라 클래스가 존재하지 않는다. \n\n\n\n## 상태, 행동, 식별자\n  \n### 상태\n  * 상태를 이용하면 과거의 행동 이력을 설명하지 않아도 행동의 결과를 쉽게 예측 하고 설명할 수 있다. \n  * 즉, 상태는 특정시점에 객체가 가지고 있는 정보의 집합이다.\n  * 객체는 상태를 스스로 관리하는 자율적인 존재다.\n  * 상태를 외부에 노출시키지 않고 캡슐화 하는것은 객체의 자율성을 높인다.\n\n### 행동\n  * 객체의 상태를 변경하는 것은 객체의 자발적인 행동이다.\n  * 객체의 행동은 상태에 영향을 받는다. \n  * 행동이란 외보의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동\n  * 행동의 결과로는 객체의 자신의 상태를 변경하거나 다른 객체에 메시지를 전달할 수 있다. \n  * 행동은 다른객체와의 협력에 참여하므로 외부에 가시적이다.\n  * drinkBeverage() -> 나 객체 -> drunken(quantity) -> 음료객체\n\n### 식별자\n  * 서로를 구별할 수 있는 특정한 프로퍼티가 식별자라고 한다.\n  * 값의 상태는 변하지 않기에 immutable state를 가진다.\n  * 객체의 상태는 행동에 의해 변할수 있기에 mutable state라고 한다.\n  * 동등성 : 상태를 기반으로 비교 , 동일성: 식별자를 기반으로 비교\n  * 객체의 경우 상태가 가변적이기에 상태 변경에 독립적인 별도의 식별자를 이용해서 두 인스턴스를 비교할 수 있다.\n  \n### 은유와 객체 \n  * 현실속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다. 예를 들면 소프트웨어에선 상품이 가격계산을 스스로 수행할수 있다는 것이다.\n  * 객체를 창조할때 현실 객체를 모방하려 하지말고 현실 속의 객체에 대한 은유를 쓰자. 은유란 하나의 의미를 다른 것을 이용해 전달한다는 의미를 가지고 있다.\n  * \"A라는 객체는 전화기 같아요\" 라고 했을때 A라는 객체는 전화를 걸 수 있다는 사실을 알 수 있다. \n  * 은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 차이를 줄여 소프트웨어의 구조를 쉽게 예측할 수 있다. 그래서 유지보수가 용이한 소프트웨어를 만들 수 있다.\n\n### 객체지향 설계 기법\n\n#### 책임-주도 설계\n  * 객체지향 설계란 app의 기능을 구현하기 위한 협력 관계를 고안하고, 협력에 필요한 역할과 책임을 식별한 후 이를 수행할 수 있는 적절한 객체를 식별해 나가는 과정.\n  * 이 설계는 객체의 책임을 중심으로 시스템을 국축하는 설계 방법\n  * 시스템은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 적절한 객체에게 할당된다. 객체가 책임을 수행하는 도중에 필요하다면 적절한 객체를 찾아 필요한 작업을 요청한다. 만약 책임을 여러 종류의 객체가 수행할 수 있다면 협력자는 객체가 아니라 추상적인 역할로 대체된다.\n  * 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.\n  * 시스템 책임을 더 작은 책임으로 나눈다.\n  * 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.\n  * 객체가 책임을 수행하는 중에 다른객체의 도움이 필요한 경우 이를 책임질 적절한 객체를 찾는다.\n  * 해당 객체에게 책임을 할당함으로써 두 객체가 협력하게 된다.\n\n#### 디자인패턴\n  * 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍\n  * 패턴으로 해결하는 문제가 무엇인지를 명확하게 파악하고 패턴을 적용할수 있는 상황과 적용할 수 없는 상황을 인지하자.\n  * COMPOSITE 패턴은 전체와 부분을 하나의 단위로 추상화해야하는 경우에 사용된다.\n  * 위 예로는 사용자 관점에서 대상이 파일인지 폴더인지 상관없이 파일의 경로를 바꿀수도 있지만 폴더의 경로를 바꾸게 되면 그 안에 있는 파일까지도 한번에 변경 할수도 있어야 한다. 사용자는 단지 대상을 선택한 후 경로를 바꾸기만 하면 된다. \n  * 즉, 메시지 수신자가 부분(파일) 인지 전체(폴더) 인지에 상관 없이 동일한 메시지(경로변경)을 이용해 동일한 방식으로 대상과 상호작용하고 싶을때 이용한다.\n\n## 책임과 메시지\n\n### 자율적인 책임\n   * 자율성 그것은 자기 스스로의 원칙에 따라 어떤 일을 하거나 자신을 통제해서 절제하는 성질이나 특성이다.\n   * 객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이다.\n   * 자율적인 책임의 특징은 객체가 '어떻게 (how)' 해야 하는가가 아니라 '무엇 (what)' 을 해야 하는가를 설명한다는 것이다.\n   \n### 메시지와 메서드\n   * 객체의 행동을 유발하는 행위를 가리켜 메시지-전송 이라고 한다.\n   * 모자장수.증언하라(어제,왕국);\n   * 객체는 메시지를 수신하면 먼저 해당 메시지를 처리할 수 있는지 여부를 확인한다. 그 후에 메시지를 처리할 방법인 메서드를 선택하게 된다.\n   * 메시지는 '어떻게' 수행될 것인지는 명시하지 않는다. \n\n### 다형성\n   * 다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다. \n   * 서로 다른 타입에 속하는 객체들이 동일한 메시지를 쉰할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘을 가리킨다.\n   * 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다. \n   * 메시지를 보내는 객체는 수신하는 객체를 할 필요가 없다. 단지 보내는 메시지를 이해하면 해당 역할을 수행할 수 있는 수신자라면 어떤 누구와도 협력이 가능하다.\n\n### what/who 사이클\n   * 먼저 '어떤 행위(what)'을 수행할 것인지를 결정한 후에 '누가(who)' 그 행위를 수행할 것인지를 결정해야 한다는 것.\n   * 수신 가능한 메시지가 모여 객체의 인터페이스를 구성한다.\n   * 참여할 객체를 결정하기 전에 협력에 필요한 메시지를 먼저 결정한다. \n   * 메시지를 결정하기 전까지 객체에 관해 고민하지 말아야 한다. \n   * '묻지 말고 시켜라' 단지 송신자는 수신자가 어떤 객체인지는 모르지만 자신이 전송한 메시지를 잘 처리할 것이라는 것을 믿고 메시지를 전송한다.\n\n### 객체 인터페이스\n   * 인터페이스는 사용법만 익히면 내부 구조를 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.\n   * 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동방식을 바꾸는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.\n   * 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용 할 수 있다.\n   * 객체의 외부에 공개된 인터페이스를 공용 인터페이스라고 한다.\n   * 객체지향 패러다임 안에서 자기 스스로에게 뭔가를 요청하는 경우에도 메시지를 전송해야 한다.\n   * 외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 말자.\n\n### 구현\n   * 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함된다.\n   * 객체는 상태와 행동을 지닌다 이 부분들을 구성하는 코드 자체는 객체 외부에 노출되는 공용 인터페이스의 일부는 아니기 때문에 객체의 구현부분에 포함된다. \n   * 이 부분을 수정하더라도 객체 외부에 영향을 미쳐서는 안된다. 객체 외부에 영향을 미치는 변경은 객체의 공용 인터페이스를 수정할 때뿐이다.\n\n### 캡슐화\n   * 상태와 행위의 캡슐화 , 외부에 반드시 접근해야만 하는 행위만 골라 공용 인터페이스를 통해 노출한다.\n   * 데이터 캡슐화는 인터페이스와 구현을 분리하기 위한 전제조건이다. \n   * 객체가 자율적이기 위해서는 자기 자신의 상태를 스스로 관리할 수 있어야 하기 때문에 데이터 캡슐화는 자율적인 객체를 만들기 위한 전제 조건이기도 하다.\n   * 외부에 제공해야 할 필요가 있는 메시지만을 객체의 공용 인터페이스에 포함시키고 개인적인 비밀은 공용 인터페이스의 뒤에 감춤으로써 외부의 불필요한 공격과 간섭으로 부터 내부 상태를 격리할 수 있다. \n\n### 책임과 메시지의 정리\n   * 자율적인 책임은 협력을 단순하게 만든다.\n   * 자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다.\n   * 책임이 자율적인 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다. \n   * 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.\n   * 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.\n\n## 객체지향의 예를 살펴보자\n\n### 커피 전문점\n\n   * 커피 전문점에서 주문하기 \n      * 메뉴판( 4개의 메뉴 ) : 4개의 메뉴는 4개의 객체를 말하고 메뉴판은 그 객체를 포함하는 객체라고 볼수있다.\n      * 손님은 메뉴판을 보고 바리스타에게 메뉴를 주문한다. \n      * 바리스타는 커피를 제조한다. 아메리카노 , 카푸치노, 카라멜 마키아또, 에스프레소\n      * 바리스타는 자율적으로 커피를 제조하는 객체로 볼 수 있으며 커피 역시 자신만의 경계를 가지므로 객체로 볼 수 있다.\n      * 도메인은 손님객체 , 메뉴항목객체 , 메뉴판객체 , 바리스타 객체 , 커피객체로 구성된 작은 세상\n      * 동적인 객체를 정적인 타입으로 추상화해서 복잡성을 낮추자.\n      * 손님타입 , 메뉴판타입, 메뉴 항목타입, 바리스타 타입 , 커피타입으로 나눈다.\n      * 메뉴 항목이 메뉴판에 포함된다. ( 합성 )\n      * 손님은 메뉴판을 알아야 하니 서로를 알고만 있으면 된다. ( 연관 )\n      * 바리스타는 커피를 제조해야하므로 커피를 알고있어야 한다. ( 연관 )\n      * 손님은 바리스타를 알아야 한다. ( 연관 )\n   \n   * 커피 전문점 설계\n      * 협력을 찾자. 메시지가 객체를 선택하게 해야한다. 메시지를 먼저 선택하고 그 후에 메시지를 수신하기에 적절한 객체를 선택해야 한다는 것이다. 이제 미시지를 수신할 객체는 메시지를 처리할 책임을 맡게 되고 객체가 수신하는 메시지는 객체가 외부에 제공하는 공용 인터페이스에 표현된다.\n      * 어떤 객체가 커피를 주문할 책임을 져야 하는가?? 커피를 주문하라 ( 메뉴이름 ) 이 메시지에 대한 책임은 손님이다.\n      * 손님은 '메뉴 항목을 찾아라' 라는 새로운 메시지를 보낸다. 메뉴이름 이라는 인자도 함께 보낸다.\n      * 현실 메뉴판은 스스로 메뉴를 찾지 않지만 소프트웨어는 능동적이고 자율적인 존재다. 따라서 설계자는 무생물을 생물처럼 '의인화' 해야한다. \n      * 손님은 메뉴항목을 얻었으니 이제 커피를 제조해달라고 요청할 수 있다.\n\n   * 인터페이스 정리하기\n      * 손님 : 제품을 주문하라\n      * 메뉴판 : 메뉴 항목을 찾아라\n      * 바리스타 : 커피를 제조하라\n      * 커피 : 생성하라\n\n      ```javascript\n        class Customer{\n            constructor(){}\n\n            order: function(menuName){}\n        }\n\n        class MenuItem{}\n\n        class Menu{\n            constructor(){}\n\n            choose: function(name){}\n        }\n\n        class barista{\n            constructor(){}\n\n            makeCoffee: function(menuItem){}\n        }\n        \n        class Coffee{\n            constructor(menuItem){\n\n            }\n            \n        }\n      ```\n\n   * 구현하기\n      * 고객은 메뉴와 바리스타 객체에 접근을 해야한다.\n      * 메뉴는 menuName에 해당하는 MenuItem을 찾아야 하는 책임이 있다. 따라서 Menu 가 MenuItem을 관리하고 있어야 한다. \n      * 바리스타는 MenuItem을 이용해서 커피를 제조한다.\n      \n      ```javascript\n      class Customer{\n            constructor(){}\n\n            order: function(menuName, menu, barista){\n                let menuItem = menu.choose(menuName);\n                let coffee = barista.makeCoffee(menuItem);\n\n                //...\n            }\n        }\n\n      class Menu{\n        constructor(items){\n            this._items = items || [];\n            this._itemsLength = items.length();\n        }\n\n        choose: function(name){\n            for(let i = itemLength; i > 0; i--){\n                if(this._items[i].getName() === name){\n                    \n                    return this._items[i];\n                }\n            }\n        }\n      }\n\n      class barista{\n            constructor(){}\n\n            makeCoffee: function(menuItem){\n                let coffee = new Coffee(menuItem);\n                return coffee;\n            }\n        }\n\n      class Coffee{\n          constructor(opts){\n            this._name = opts.name;\n            this._price = opts.price;\n          }\n      }\n\n      class MenuItem{\n          constructor(opts){\n              this._name = opts.name;\n              this._price = opts.price\n          },\n\n          getCost: function(){\n              return this._price;\n          }\n          getName: function(){\n              return this._name;\n          }\n      }\n      ```\n\n## 정리\n   * 코드는 세가지 관점을 모두 제공해야한다.\n      * 개념관점, 명세관점, 구현관점 \n         * 개념관점 : 도메인을 구성하는 중요한 개념과 관계를 반영한다면 변경을 관리하기 쉽고 유지모수성을 향상 시킬수 있다.\n         * 명세관점 : 클래스의 인터페이스를 바라본다. 클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다. \n         * 구현관점 : 클래스의 내부 구현을 바라본다 내구 구현과 속성이 변경되더라도 외부의 객체에게 영향을 미쳐서는 안된다.\n   * 도메인 개념을 참조하자.\n      * 사용자가 프로그램을 사용하는 대상 분야를 도메인이라고 한다. \n      * 도메인 모델이란 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.\n      * 어떤 메시지가 있을때 그 메시지를 수신할 객체는 도메인 개념중에 가장 적절한 것을 선택하는 것이다.\n\n   * 인터페이스와 구현을 분리하라\n      * 클래스를 봤을 때 클래스를 명세 관점과 구현 관점으로 나눠볼수 있어야 한다는 것이다.\n\n\n\n","excerpt":"객체지향 이란? 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체 객체는 시스템의 행위를 구현하기 위해 다른객체와 협력, 각 객…","fields":{"slug":"/hello-oop.md/"},"frontmatter":{"date":"Apr 25, 2018","title":"hello OOP","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 게으른 평가\n\n* call-by-need 라고도 불리는 이 전략 방법은 ( 반대는 call-by-name ) 값이 실제로 필요할때 평가를 하는것이다. 또한 반복적인 평가를 피하기 위해서 한번 평가해둔 자료는 기억해 둔다.(memoization)\n\n\n\n## 왜?\n\n* 아래와 같은 코드를 생각해 보자. \n\n```javascript\nconst someValue = expensiveFunction();\n//.. someValue를 사용하지 않는 다른 연산 코드들 및 유저 인터페이스를 포함하고 있는 수많은 코드들..\n\nconsole.log(someValue)\n```\n\n* someValue는 코드의 맨 마지막 console.log 찍을때 필요하다.\n* 처음에 expensiveFunction을 호출할때 브라우저는 그 시간동안 아무것도 안한다. 그 이후에 있을 사용자 경험을 높이기 위한 코드를 지연시키고 따라서 사용자 경험을 방해했을 것이다. 이것은 문제다.\n* 물론 아래와 같이 바꿀수 있다.\n\n```javascript\n//.. someValue를 사용하지 않는 다른 연산 코드들 및 유저 인터페이스를 포함하고 있는 수많은 코드들..\n\nconsole.log(expensiveFunction());\n```\n\n* 아름답지 않을 뿐더러 큰 프로젝트일수록 언제 쓰일지도 모르고 필요할때마다 매번 호출하게 되니 비용이 많이 든다.\n\n## 이렇게 하고 싶다.\n\n* 만약 평가를 정말 필요할때 하면 어떨까? \n* 자바스크립트에서 lazy 라는 키워드가 있다면..\n* someValue에는 실제 평가를 진행하는 코드가 있을테고 해당 값을 호출하면 그때 실제로 작동하는 코드이다.\n* 아래와 같이 쓸수 있을 것이다.\n\n```javascript\nlazy const someValue = expensiveFunction();\n\n//... 수많은 코드들..\n\nconsole.log(soameValue);\nconsole.log(soameValue);\n```\n\n* 다만, 여기서 2번 반복해서 썼다고 해서 평가를 2번하는건 비효율 적이다.\n\n\n## 만들어 보자.\n\n* 실제 자바스크립트 안에는 lazy 라는 키워드가 없기 때문에 lazy 라는 함수를 만들어 보자.\n\n### memoization 패턴을 이용한 반복호출을 피하자.\n\n```javascript\nconst lazy = getter => {\n  let evaluated = false;\n  let _res = null;\n\n  const res = function(){\n    if(evaluated) return _res;\n    const _res = getter.apply(this, arguments);\n    evaluated = true;\n    return _res;\n  }\n\n  return res;\n}\n```\n* lazy 함수는 getter 라는 함수를 인자로 받아서 getter를 호출시켜주는 새로운 함수를 반환한다.\n* 클로저를 사용, evaluated 와 _res 변수는 반복 호출을 피하기 위한 자유변수들이다.\n\n### 사용해보자.\n\n```javascript\nlet counter = 0;\n\nconst lazyVal = lazy(() => {\n  counter += 1;\n  return 'result';\n})\n\nconsole.log(counter); // 0\nconsole.log(lazyVal()); // result\nconsole.log(counter); // 1\nconsole.log(lazyVal()); // result\nconsole.log(counter);  // 1\nconsole.log(lazyVal()); // result\n```\n* 여러번 호출하더라도 한번만 호출이 된다는걸 알수 있다.\n\n* 이제 실질적으로 사용하면 되는가????\n* 실제 lazyValue들 끼리 연산작업이 필요할 경우엔 어떻게 해야할까???\n\n```javascript\nconst actualVal1 = lazyVal1();\nconst actualVal2 = lazyVal2();\n\nconsole.log(actualVal1 + actualVal1);\n```\n* 음..달라진게 없는거 같다. \n* 우리는 평가를 실제로 필요한 지점에서 사용하고 싶은데 그럼 어떻게 해야할까.\n\n```javascript\nconst newVal = lazy(() => {\n  const actualVal1 = lazyVal1();\n  const actualVal2 = lazyVal2();\n  return actualVal1 + actualVal2;\n})\n```\n* 다시 lazy로 감싸야한다.\n* 음.. 아름답지가 않다.\n\n### 업그레이드 하자\n\n* 우리가 원하는 시점으로 평가를 할수있도록 뒤로 늦추긴 했지만 매번 lazy로 감싸야 하는 번거로움이 있었다.\n* 체이닝으로 엮어서 표현하면 어떨까???\n* 다시 lazy 함수를 업그레이드 해보자.\n\n### 이런 모양이면 좋겠다.\n\n```javascript\nlet counter = 0;\n\nconst lazyVal = lazy(() => {\n  return counter += 1;\n})\n\n/* 첫 평가 실행후 리턴 된 값으로 다시 lazy를 리턴 */\nconst lazyOp = lazyVal.then(v1 => lazy(()=> {\n  return v1 + 1;\n}))\n```\n\n### lazy를 수정하자.\n\n```javascript\nconst lazy = getter => {\nlet evaluated = false;\nlet _res = null;\n\nconst res = function(){\n  if(evaluated) return _res;\n  const _res = getter.apply(this, arguments);\n  evaluated = true;\n  return _res;\n}\n\n/* 체이닝을 위한 then 함수 생성 */      \nres.then = modifier => modifier(res());\n\nreturn res;\n}\n```  \n\n* 리턴된 inner함수 (res) 에게 프로퍼티로 then 함수를 추가.\n* then에서 인자로는 첫번째 평가 이후에 리턴된 값으로 다시 lazy를 수행할수 있는 next 함수를 받는다.\n* 여기서 modifier 인자는 v1 => lazy() 함수가 되겠다. \n* res()는 lazyVal 함수가 될것이고 여기서 res() 호출된 결과는 즉, v1으로 들어갈 것이다.\n* 받은 v1을 다시 lazy로 감싸서 lazyOp로 return 한다. \n\n### map 함수를 만들어 보자.\n\n* then 함수는 임의로 우리가 lazy 함수를 리턴해줬었어야 했다.\n* 이번엔 그것마저 자동으로 해주는 map 함수를 만들어보자.\n\n#### 이런 모양이어야 한다.\n\n```javascript\nlet counter = 0;\n\n/* 첫 평가 실행후 리턴 된 값으로 다시 lazy를 리턴 */\nconst lazyOp = lazy(() => counter += 1)\n  .map(v1 => \n    v1 + 1\n  )\n  .map(v2 => \n    v2 + 1\n  )\n\n```\n\n\n#### 다시 lazy 함수를 수정하자.\n\n```javascript\nconst lazy = getter => {\n  let evaluated = false;\n  let _res = null;\n\n  const res = function(){\n    if(evaluated) return _res;\n    const _res = getter.apply(this, arguments);\n    evaluated = true;\n    return _res;\n  }\n\n  /* 체이닝을 위한 then 함수 생성 */      \n  res.then = modifier => modifier(res());\n  /* map 함수 */\n  res.map = mapper => lazy(() => mapper(res()));\n  return res;\n}\n```  \n\n## 정리\n\n* 자바스크립트에서의 게으른 평가는 결국 호출하고 싶은 코드들을 함수로 한번 더 감싸 실제 필요할때 평가한다.\n* lazy 체이닝의 경우 연속된 함수 참조에 의해서 이뤄진다.\n\n\n\n\n## 참고\n\n[https://www.codementor.io/agustinchiappeberrini/lazy-evaluation-and-javascript-a5m7g8gs3](https://www.codementor.io/agustinchiappeberrini/lazy-evaluation-and-javascript-a5m7g8gs3)","excerpt":"게으른 평가 call-by-need 라고도 불리는 이 전략 방법은 ( 반대는 call-by-name ) 값이 실제로 필요할때 평가를 하는것이다. 또한 반복적인 평가를 피하기 위해서 한번 평가해둔 자료는 기억해 둔다.(memoization) 왜? 아래…","fields":{"slug":"/lazy-evaluation.md/"},"frontmatter":{"date":"Apr 05, 2018","title":"lazy evaluation","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 패턴 연습을 위한 기본 다지기\n\n## 일급 객체인 함수를 잘 다루자\n\n* 함수를 인자로 받거나 함수를 리턴한다. 이것은 즉, 함수가 high order function 임을 인지한다.\n\n```javascript\n// d3.js example\n\nvar svg = {}\nsvg.line = function() {\n  var getX = function() {}\n  var getY = function() {}\n  var interpolate = function() {}\n\n  function line(data) {\n    //...\n    // private 함수.\n    function segment() {}\n    var d = data\n    // getX 와 getY 로 필요한 데이터를 추출해서 사용.\n    // call 로 함수를 호출 하는 까닭은~?\n    getX.call(this, d, i)\n    getY.call(this, d, i)\n\n    // 추출 후 segment() 함수 사용.\n  }\n\n  line.x = function(fn) {\n    if (!argument.length) return getX\n    getX = fn\n    return line\n  }\n  line.y = function(fn) {\n    if (!argument.length) return getY\n    getY = fn\n    return line\n  }\n\n  return line // 함수를 리턴한다.\n}\n\n// usage\nvar lineGenerator = svg.line()\nvar path = lineGenerator(data)\n\n// 데이터가 달라질때 데이터 추출을 위한 함수 변경이 필요하다.\nvar lineGenerator = svg\n  .line()\n  .x(function(d) {})\n  .y(function(d) {})\n\n// 내가 만든 객체에서 값을 얻게끔 라인 생성기를 확장.\nvar merlin = {\n  getValue: function() {},\n  lineGenerator: svg\n    .line()\n    .x(function(d) {\n      return 10 - this.getValue()\n    })\n    .y(function(d) {\n      return 10 + this.getValue()\n    }),\n}\n\nvar path = merlin.lineGenerator()\n```\n\n* 위의 getX 와 getY 를 그냥 getX() / getY() 처럼 호출 했다면 위 코드는 getValue 는 정의되어있지 않은 method 라고 에러가 날것이다.\n  하지만 getX.call(this) / getY.call(this) 여기서 이 this 는 함수를 호출한 객체를 참조한다.\n\n## 덕 타이핑\n\n* 오리처럼 생겨서 오리처럼 걷고 오리처럼 꽥꽥 소리를 낸다면 그건 오리다.\n\n> 그게 오리인지 검사하지 말고, 당신이 오리의 무슨 행동이 필요한지에 따라서 오리처럼 우는지, 오리처럼 걷는지 등등 적절한 행동을 오리처럼 하는지 검사하세요\n\n* 즉, 사람이라도 오리처럼 울고 오리처럼 뒤뚱거리면 그건 사람이 아니라 오리이다.\n\n* 덕 타이핑이란 형태를 판별하는 대신, 원하는 동작을 수행할수 있는지에 대한 여부만 가지고 검사를 한다. 이때문에 오류들이 잠재할 수 있는 소지들을 안고있다.\n\n```javascript\n // 오리라면 먹이를 주자. 이런 주제가 있다고 하면\n // 오리\n function Duck(){\n     return {\n         duckSound: function(){}\n     }\n }\n\n // 어떤새.\n function Bird(){\n     return {\n         duckSound: function(){}\n     }\n }\n\n function Merlin(){\n     return {\n         feed: function(obj){\n             // if( obj instanceof Duck ) // 이것은 Duck로 객체를 생성했을 시.\n             // if('duckSound' in obj)\n             if(obj.hasOwnProperty('duckSound')){ // 이부분 오리인지 아닌지 확인하는 부분\n                 return true;\n             }\n             return false;\n         }\n     }\n }\n var bird1 = new Bird();\n var bird2 = new Duck();\n var merlin = new Merlin();\n\n var result1 = merlin.feed(bird1); // true\n var result2 = merlin.feed(bird2); // true\n\n // 판별 방법\n if( something instanceof Merlin)\n // or\n if( 'x' in something)\n // or\n if( something.hasOwnProperty('x'))\n```\n\n## 함수 오버로딩\n\n* 자바스크립트에서 함수 오버로딩을 사용할 수 있다.\n\n```javascript\n// ex 1) 인자 갯수에 따른 다른 처리 방법\nfunction a() {\n  if (!arguments.length) {\n    // 인자가 하나도 없을 시 처리하는 로직\n    return\n  }\n\n  // 그외..\n}\n\n// ex 2) 콜백함수\n\nfunction a(data, fn) {\n  var i = 0\n  var d = data\n\n  while (i < 10) {\n    fn(data, i)\n    i++\n  }\n}\n// a에 넘기는 콜백함수는 기본 인자를 2개 받기에 사용자가 선택적으로 사용해도 된다.\na({}, function(data, index) {\n  // data 만 써두 되고..\n  // 주는 index를 같이 써두 되고..\n  // 사용자에게 선택의 폭을 넓혀준다.\n})\n```\n\n## 스코프는 중첩 함수로 다스린다.\n\n* 함수를 중첩하여 코드를 계층화할 수 있다.\n* 덕분에 개발자가 원하는 것을 찾는 데 도움이 된다.\n* 프로그램에서 변수/함수의 스코프를 최소화할 수 있다.\n* 스코프를 최소화?\n\n> 즉, 자바스크립트 스코프는 함수 선언시에 결정되기 때문에 함수를 중첩화 해서 실행시키면 그 안에서만의 스코프가 생겨난다. 다른 스코프에 영향이 가지 않기에 범위를 최소화 시킨다고 한다.\n\n* 위 line 함수에서 멤버함수 line.x 는 line 의 멤버임에도 segments 같은 line 의 지역 변수는 볼 수 없지만, 에워싼 함수 안에서 line 과 getX 변수를 바라볼 수 있다. 이런 식으로 클로저를 교묘하게 잘 섞어 쓰면 대규모 자바스크립틑 시스템에 꼭 필요한 강력한 도구가 된다.\n\n## SOLID 원칙\n\n* 단일 책임 원칙\n* 개방/폐쇄 원칙\n* 리스코프 치환 원칙\n* 인터페이스 분리 원칙\n* 의존성 역전 원칙\n\n## 단일 책임 원칙 (SRP)\n\n* 책임은 곧 변경하려는 이유로 정의하고 모든 클래스 및 함수를 변경하려면 반드시 한가지 변경 사유만 있어야 한다. 즉, 보고서를 편집하고 출력하는 모듈(클래스)이 있다고 생각해보자, 이 모듈을 두가지 사유로 변경될수가 있는데 첫번째는 보고서의 내용이 변경되면 모듈이 변경될 수 있고 두번째는 보고서의 형식이 변경되면 같은 모듈이 변경될 수 있다. 단일 책임 원칙에 의하면 이 문제는 실제로 분리된 책임이라고 보고 분리된 클래스나 모듈로 나눠야 한다. 다른 시기에 다른 이유로 변경되어야 하는 두가지를 묶는 것은 나쁜 설게일 수 있다.\n\n* 유일한 관심사만 확인하고, 어떻게 이행할지는 외부에서 제공하게끔 하면 도움이 된다.\n\n## 개방/폐쇄 원칙\n\n* 확장 가능성은 열어 두되 수정 가능성은 닫아야 한다.\n* 실행 코드를 변경하지말고 어떻게든 재사용하고 확장하라는 뜻.\n* 변경되지 않을 것과 변경 가능성이 있는 것을 내다보는 힘을 길러야 한다.\n\n## 리스코프 치환 원칙\n\n* 한 객체를 다른 객체에서 파생하더라도 그 기본 로직이 변경되어서는 안된다.\n* 내가 작성중인 함수가 기반 클래스로 하는 일과 서브 클래스로 하는일이 다르다면 이 원칙을 어긴 셈이다.\n* 자바스크립트에서는 어떤 함수의 인자가 숫자일 때, 문자열일 때, 아예 인자가 없는 undefined 탕입일 때를 각각 분기 처리하는 것이 대개 좋은 습관이다.\n\n## 인터페이스 분리 원칙\n\n* 함수가 기대하는 인자가 무엇인지 명확히 하고 그 기대치를 최소화 해야한다.\n* 특정 타입의 인자를 바라기보다는 이 타입에서 실제로 필요한 프로퍼티가 더러 있을 거라 기대하는 것이다.\n\n## 의존성 연전 원칙\n\n* 인터페이스 기반 언어에서는 대개 의존성 주입이라는 연관된 개념으로 표현한다.\n* 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 되며 이 둘은 추상화에 의존해야 한다.\n* 클래스 A 가 클래스 B 를 필요로 할때 A 에서 B 를 생성하는게 아닌 A 생성자 안에 B 를 서술하는 인터페이스를 만들어 놓고 A 가 생성이 되면 구체화한 B 를 넘겨받는다.\n\n```javascript\n// bad!!\nfunction A() {\n  var b = new B() // b 에 의존.\n  return {\n    //..\n  }\n}\n\nfunction B() {\n  var name = 'merlin'\n  return {\n    id: name,\n  }\n}\n\n// good!!\nfunction A() {\n  var b = { id: 'none' } // 인터페이스\n\n  return {\n    setB: function(obj) {\n      b = obj\n    },\n  }\n}\n\nvar a = new A()\na.setB(new B())\n```\n\n* 위 처럼 해야 B 의 파생형 버전을 제공할수 있는 이점이 있고 B 를 고쳐야 할 경우 하위 버전 호환성을 유지하려면 어떤 로직을 계속 갖고 있어야 하는지 일목요연하게 서술한다.\n\n```javascript\n// 어떠한 데이터로 라인을 그린다.\nfunction baseFn(data) {\n  return data\n}\n\nsvg.line = function() {\n  return svg_line(baseFn)\n}\n\nfunction svg_line(projection) {\n  function line(data) {\n    function segment() {\n      // 이 함수를 호출해서 여러가지 일을 한다...\n      projection(data)\n    }\n  }\n  return line\n}\n\nvar lineGenerator = svg.line()\nvar path = lineGenerator(data) // 이렇게 하면 데이터 그대로 라인을 그린다.\n\n// 허나 난 이 데이터를 기반으로 다른 모양으로 그리겠다.\n// 데이터를 어떻게 조작할지만 생각한다. 즉, baseFn 만 바꿔주면된다.\n\nfunction additionFn(data) {\n  return data * 0.3\n}\nsvg.line.addition = function() {\n  return svg_line(additionFn) // 의존성 주입.\n}\nvar lineGenerator = svg.line.addition()\nvar path = lineGenerator(data)\n```\n\n## DRY 원칙\n\n* 반복하지 마라!!\n* 재사용할 수 있어야 한다.\n\n```javascript\n// bad\nwhile (++i < n) {\n  points.push([+getX.call(this, data[i], i), +getY.call(this, data[i], i)])\n}\n\n// good\nvar d\nwhile (++i < n) {\n  d = data[i]\n  points.push([+getX.call(this, d, i), +getY.call(this, d, i)])\n}\n```\n\n## 의존성 주입\n\n### 의존성 주입이란?\n\n* 의존성을 품은, 하드 코딩한 모듈은 단위테스트를 진행하기 어렵다.\n* 의존성 품은 모듈의 한 메서드에서 의존성 모듈의 함수들을 호출한다 했을때, 해당 의존성을 품은 모듈은 단위테스트 하기가 까다로워 지고, 폭넓은 경우를 파악하기 힘들다.\n* 반면 의존성을 주입하게 되면 fake(모의체)를 주입해서 좀 더 넓은 범위의 가능성에 대해서 테스트를 진행해볼수 있다.\n\n### 의존성 주입하여 믿음직한 코드 만들기\n\n* 의존성 주입 코드는 재사용을 적극적으로 유도한다.\n* 하드 코딩한 모듈은 재사용하기가 어렵다.\n* 의존성 주입 코드로 바꾼 다음에는 주입 당한 코드에서 사용하는 주입된 인스턴스 메서드만 있다면 어떤 인스턴스라도 사용할수 있다는 장점이 있다.\n\n### 의존성 주입의 모든것\n\n* 객체 또는 의존성 중 어느 하나라도 DB, 설정파일, HTTP, 기타 인프라등의 외부 자원에 의존하는가/\n* 객체 내부에서 발생할지 모를 에러를 테스트에서 고려해야 하나?\n* 특정한 방향으로 객체를 작동시켜야 할 테스트가 있는가?\n* 이 서드파티 제공 객체가 아니라 온전히 내가 소유한 객체인가?\n\n## 애스팩트 지향 프로그래밍(AOP)\n\n* 애스팩트 지향 프로그래밍은 (단일한 책임 범위 내에 있지 않은) 하나 이상의 객체에 유용한 코드를 한데 묶어 눈에 띄지 않게 객체에 배포하는 기법이다.\n  AOP 용어로, 배포할 코드 조각을 어드바이스(advice), 어드바이스가 처리할 문제를 애스팩트(aspect) 또는 횡단 관심사라고 한다.\n\n### 동기\n\n콘퍼런스 웹페이지에서 로그인한 참자가자 원하는 지역 공항의 항공권 할인 운임을 조회하는 웹 서비스를 호출 해야 한다.\n바로바로 알림창이 뜨면 좋겠지만, 웹 서비스 호출은 아무래도 시간이 걸리기 마련이다. 따라서 참가자 본인이 공항을 바꾸지 않는 한 해당 항공권 정보를 캐시하기로 한다. 여기서 캐싱은 횡단 관심사 이자 애스팩트 지향 프로그래밍의 유력한 후보자 이다.\n\n```javascript\nTravelService = (function(rawWebService) {\n  var conferenceAirport = 'BOS'\n  var maxArrival = new Date()\n  var minDeparture = new Date()\n\n  // 간단한 캐싱: 인덱스는 공항이고 객체는 티켓이다.\n  var cache = []\n\n  return {\n    getSuggestedTicket: function(homeAirport) {\n      var ticket\n      if (cache[homeAirport]) {\n        return cache[homeAirport]\n      }\n\n      ticket = rawWebService.getCheapesRoundTrip(\n        homeAirport,\n        conferenceAirport,\n        maxArrival,\n        minDeparture\n      )\n\n      cache[homeAirport] = ticket\n\n      return ticket\n    },\n  }\n})()\n```\n\n작동은 잘 되지만 핵심 기능과 전혀 무관한 코드가 많이 보인다.\ngetSuggestedTicket 을 그대로 둔 상태에서 기능만 추가할 수 있으면 좋을거 같다. 만약 10 분 후 캐시한 결과를 만료시키는 식으로 캐싱 전략을 나중에 바꿔달라고 하면? 추가기능( 사용자가 원하는 옵션을 쿠키에 저장)이 방해 받지 않는 방향으로 연결할 수 있으면 좋을 것이다.\n\n바로 이런 일들을 애스팩트 지향 프로그래밍으로 할 수 있다.\n\n```javascript\nAop.around('getSuggestedTicket', cacheAspectFactory())\n```\n\ncacheAspectFactory() 는 모든 호출을 가로챌 수 있는, 완전히 재사용 가능한 캐싱 함수를 반환하며 똑같은 인자가 들어오면 똑같은 결과를 반환한다.\n\n### AOP code\n\n```javascript\nAop = {\n  around: function(fnName, advice, fnObj) {\n    var originalFn = fnObj[fnName]\n    fnObj[fnName] = function() {\n      return advice.call(this, { fn: originalFn, args: arguments })\n    }\n  },\n\n  next: function(targetInfo) {\n    return targetInfo.fn.apply(this, targetInfo.args)\n  },\n}\n\nAop.before = function(fnName, advice, fnObj) {\n  Aop.around(\n    fnName,\n    function(targetInfo) {\n      advice.apply(this, targetInfo.args)\n      return Aop.next(targetInfo)\n    },\n    fnObj\n  )\n}\n\nAop.after = function(fnName, advice, fnObj) {\n  Aop.around(\n    fnName,\n    function(targetInfo) {\n      var ret = Aop.next(targetInfo)\n      advice.apply(this, targetInfo.args)\n      return ret\n    },\n    fnObj\n  )\n}\n```\n\n## 정리\n\n* 관심사를 분리하는 일에 집중하고 단일 책임 원칙이나 의존성 주입같은 소프트웨어 공학 원칙을 잘 써먹는게 중요하다.\n","excerpt":"패턴 연습을 위한 기본 다지기 일급 객체인 함수를 잘 다루자 함수를 인자로 받거나 함수를 리턴한다. 이것은 즉, 함수가 high order function 임을 인지한다. 위의 getX 와 getY 를 그냥 getX() / getY() 처럼 호출 했…","fields":{"slug":"/javascript-basic1.md/"},"frontmatter":{"date":"Apr 05, 2018","title":"Javascript-Basic1","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Intro\n  - flow 는 자바스크립트의 스태틱한 타입들을 체크해주는 도구이다.\n  - flow 는 코드가 변경되는 동안 빠른 피드백을 줍니다.\n  - flow 는 타입을 추론할 수 있습니다. \n\n# install\n\n  1. 바벨을 이용해서 flow 유형을 변환시켜줘야 한다.\n\n      ```sh\n      npm install --save-dev babel-cli babel-preset-flow\n      ```\n      - 만약 리엑트를 사용해서 babel-preset-react를 사용한다면 bable-preset-flow는 별도로 설치할 필요가 없다.\n\n\n  2. .babelrc 의 preset 속성에 flow 작성\n\n      ```javascript\n      {\n          \"preset\": [\"flow\"]\n      }\n      ```\n\n      - 이 역시도 react를 사용하고 있다면 react만 적어주면 된다.\n\n\n  3. flow 설치\n\n      ```sh\n      npm install -g flow-bin\n      npm install --save-dev flow-bin\n      ```\n\n\n  4. flow init\n      - flow init 을 하게 되면 .flowconfig 파일이 생성.\n      - .flowconfig에서 flow의 여러가지 config 설정을 할 수 있음.\n      - 홈페이지 참조! [https://flow.org/en/docs/config/](https://flow.org/en/docs/config/)\n\n\n  5. flow 명령어를 차기 되면 해당 프로젝트의 타입들을 체크\n\n### 요약\n\n  - flow init 으로 프로젝트를 init\n  - flow 명령으로 Flow background 프로세스를 실행\n  - 각 파일상단에 \"// @flow\" 을 기입하므로써 flow가 모니터링을 할수 있게 정의\n  - flow code 작성\n  - flow error type 체크\n\n\n# Type들 \n\n1. primitive types\n\n    - 가장 기본적인 원시타입의 정의 \n    - 리터럴 값의 타입은 소문자로 정의 \n    - object로 wrapper 한것들은 capitalized 로 정의\n\n    ```javascript\n    function method(x: number){}\n\n    function method(x: Number){}\n    ```\n\n    - Boolean , String, Number, null , undefined(flow는 void로 정의 ) , Symblos ( 아직 flow가 지원안함 )\n\n2. Mixed types\n\n    - type을 알수 없을때 사용한다.\n    - 프로그램들은 여러가지 다른 타입의 종류를 지닐수 있다.\n    - mixed 타입은 아무 타입이나 받을 수 있다. \n    - mixed는 아무거나 받을 수 있지만 mixed 유형의 값을 사용하려고 한다면 실제 유형이 무엇인지 알아내야 한다. 그렇지 않으면 에러를 내뿜는다.\n\n    ```javascript\n    function user(value: mixed) {\n        return \"\" + value // error\n    }\n\n    function user(value: mixed) {\n        if( typeof value === \"string\" ){\n            return \"\" + value // works!!!\n        }\n    }\n    ```\n\n\n\n\n3. any types\n    - mixed 와 햇갈려 하지 마세요.\n    - any 자체는 완벽하게 안전하지 않습니다. 어느때나 에러를 내뿜지 않습니다.\n    - 그래서 any로 type을 지정했을 경우에는 가능한 빨리 다른 타입으로 casting을 해야 합니다.\n\n\n4. maybe types\n\n    - typing value가 있을수도 있구 없을수도 있을때 사용한다.\n    - 예를 들어 ?number 라고 타입을 지정하면 받을 수 있는 타입은 number , null , undefined 타입만을 받을 수 있다.\n\n5. variable types\n\n    - 변수를 선언할때 타입을 추가한다.\n    - javascript 변수 선언 방식은 const , let , var 방식이 있다.\n    - flow는 두 그룹으로 나뉜다 재 할당이 가능한지 ( let, var ) 가능하지 않은지 ( const )\n\n    ```javascript\n    var fooVar: number = 2;\n    let barLet: number = 2;\n    const bar: number = 2;\n\n    fooVar = \"3\" // error\n    ```\n\n6. function types\n\n    - 함수는 2가지 장소에 type을 지정할 수 있다. 하나는 매개변수 ( input ) 나머지 한곳은 return value ( output ) 이다.\n\n    ```javascript\n    function concat(a: string , b: string): string {\n        return a+b;\n    }\n\n    let method = (str: string , bool?: boolean, ...args: Array<number>) => {\n\n    }\n\n    // 함수 타입을 아예 지정할 수 있다.\n    type merlin = {\n        ho: (str: string) => void,\n        hoing: (string , boolean | void , Array<number>) => void, // 파라미터 명을 생략할 수도 있다.\n    }\n    // 콜백에 대한것도 지정할 수 있다.\n    function method(cb: (error: Error | null , value: string | null) => void){\n\n    }\n    ```\n\n    - function 의 this의 경우에는 해당 function을 실행한 context를 체크한다. \n    - 술어 함수에 대해서는 리턴값 다음에 **%checks** 라고 적어주지 않으면 에러를 뿜는다.\n\n    ```javascript\n    function truty(a,b):boolean %checks {\n        return !!a && !!b;\n    }\n\n    function merlin(){\n        if(truty(a,b)){\n\n        }\n    }\n    ```\n\n    - 만약 매개변수로 좀더 유연한 function을 받으려면 **() => mixed** 를 사용한다.\n\n    ```javascript\n    function method(func: () => mixed){\n\n    }\n    ```\n\n    - 만약 타입체크를 피할 필요성이 느끼면서 any 방법을 사용 하지 않으려면 Function 을 타입으로 사용하면 된다. 하지만 이 방법은 안전하지 않고 피해야할 방법이다.\n\n    아래와 같은 코드에서 에러를 내뿜지 않는다.\n\n    ```javascript\n    function method(func: Function){\n        func(1,2); //works\n        func(\"1\",\"2\"); //works\n        func({},[]) //works\n    }\n\n    method(function(a: number, b: number){\n        return a+b;\n    })\n    ```\n\n7. Object types\n\n    ```javascript\n    var obj1: {\n        foo: number,\n        bar: boolean,\n        baz: string\n    } = {\n        foo: 1,\n        bar: true,\n        baz: \"abc\"\n    }\n\n    var obj: { foo? : boolean} = {};\n    obj.foo = true // works\n    obj.foo = \"abc\" // error\n    ```\n    - value 의 type을 설정할 때에는 optional properties가 void 와 생략을 사용할수 있게 한다. 다만 null 값은 에러를 낸다.\n\n    ```javascript\n    // foo 에 null 을 셋팅하면 error가 뜬다.\n    function acceptsObject(value: {foo? : string}){\n        // ...\n    }\n\n    ```\n\n    - sealed object의 경우에는 없는 값을 추가 하려면 에러를 뿜는다.\n    - unsealed object의 경우에는 새로운 값을 추가해도 허락한다.\n\n    ```javascript\n    var obj = {\n        foo: 1\n    }\n\n    obj.bar = true; //error\n    obj.baz = \"abc\"; //error\n    ```\n\n    - 조건문에 따라 달라지는 프로퍼티의 값이 있다면 아래처럼 해줘야 한다.\n\n    - sealed object 는 프로퍼티를 추가 할수 없다. \n\n    ```javascript\n    var val3: boolean | string = obj.prop;\n    ```\n\n    - unsealed object 의 알지못하는 프로퍼티를 정해진 타입에 할당하는 것은 안전하지 못하다.\n\n    - exact 한 obect를 만들고 싶다면 **{| |}** 를 사용한다.\n\n    ```javascript\n    var foo: {| foo: string |} = { foo: \"Hello\", bar: \"World!\" }; // Error!\n    \n    ```\n\n    - flow는 기본 object type에서 추가 속성들을 안전하게 생각한다. 이것을 \"width subtyping\" 이라 한다.\n\n    ```javascript\n    function method(obj: { foo: string }) {\n      // ...\n    }\n\n    method({\n      foo: \"test\", // Works!\n      bar: 42      // Works!\n    });\n\n    ```\n\n     \n\n8. array types\n\n    - array 타입은 Array<Type> 으로 사용하고 Type 장소에 배열의 요소 타입을 정의 할 수 있다. \n    \n    ```javascript\n    let arr: Array<number> = [1, 2, 3];\n    let arr2: Array<string> = [\"1\", \"2\", \"3\"]\n    ```\n\n    - 축약형으로 Type[] 으로 축약할 수도 있다.\n\n    ```javascript\n    let arr: number[] = [0, 1, 2, 3];\n    ```\n    - ?Type[] 는 ?Array<T> 와 같고 Array<?T>는 (?Type)[] 과 같다.\n\n    ```javascript\n    // 이부분은 숫자로 된 배열이거나 , null , undefined\n    \n    let arr1: ?number[] = null;   // Works!\n    let arr2: ?number[] = [1, 2]; // Works!\n    let arr3: ?number[] = [null]; // Error!\n\n    // 이부분은 배열이면서 배열 안에 element들이 숫자이거나 , null , undefined 된거\n    let arr1: (?number)[] = null;   // Error!\n    let arr2: (?number)[] = [1, 2]; // Works!\n    let arr3: (?number)[] = [null]; // Works!\n    ```\n\n    - array type을 안전하게 사용하는 방법\n\n    ```javascript\n    let array: Array<number> = [0, 1, 2];\n    let value: number | void = array[1];\n\n    if( value !== undefined ){\n        // number\n    }\n    ```\n\n9. tuple types\n\n    ```javascript\n    let tuple1: [number] = [1];\n    let tuple2: [number, boolean] = [1, true];\n    let tuple3: [number, boolean, string] = [1, true, \"three\"];\n\n    ```\n\n    - mutating 한 Array method를 tuples type에 사용하지 않는다.\n    - tuples는 array type과 match 시키지 않는다.\n    - 같은 tuples 타입이라도 같은 length 여야 한다.\n\n10. class types\n\n    - flow 안에서 javascript classes 는 값과 타입 2가지로 작동한다.\n\n    ```javascript\n    class MyClass {\n      // ...\n      prop: number;\n      method(value: string): number {\n          this.prop = 42; // 이걸 사용하려면 위에 처럼 필드에 대한 타입을 설정해야 한다.\n      }\n    }\n\n    let myInstance: MyClass = new MyClass();\n    ```\n\n    - classes는 자신만의 generics를 가질수 있다.\n\n    ```javascript\n    // @flow\n    class MyClass<A, B, C> {\n      constructor(arg1: A, arg2: B, arg3: C) {\n        // ...\n      }\n    }\n\n    var val: MyClass<number, boolean, string> = new MyClass(1, true, 'three');\n\n    ```\n\n11. Type aliases\n\n    - 복잡한 타입들을 다양한 장소에서 사용하고 싶을때 flow는 type alias를 사용한다.\n\n    ```javascript\n    type MyObject = {\n      foo: number,\n      var: boolean,\n      baz: string\n    }\n    ```\n\n    - generics 를 활용해서 정의할 수도 있다.\n\n    ```javascript\n      type MyObject<A, B, C> = {\n        foo: A,\n        bar: B,\n        baz: C,\n      };\n\n      var val: MyObject<number, boolean, string> = {\n        foo: 1,\n        bar: true,\n        baz: 'three',\n      };\n    ```\n\n12. Opaque Type Aliases\n\n    - Opaque type aliases는 이 타입이 정의된 파일 외부에 있는 다른 파일들에서 접근을 허용하지 않는다. \n    - 이 타입은 선언된 곳 어디서든 사용될수 있는 type aliases와 동일하게 작동한다.\n\n    ```javascript\n    opaque type ID = string;\n\n    function identity(x: ID): ID {\n      return x;\n    }\n    export type {ID};\n    ```\n\n    - 또한 optionally하게 제약조건 subtyping을 추가할 수 있다.\n\n    ```javascript\n    // Opaque type alias syntax\n    opaque type Alias = Type;\n    opaque type Alias: SuperType = Type;\n\n    opaque type ID: string = string;\n\n    ```\n\n    - import 한 opaque type은 외부에서 사용할 수 없다. 마치 nomial type 처럼 행동한다.\n    - c++ , java , swift는 nomial type 시스템을 사용한다.\n    - nominal type system 이란 타입의 구조가 같더라도 이름이 다르면 에러를 뿜는다.\n\n    ```javascript\n    // exports.js\n    export opaque type NumberAlias = number;\n\n    // imports.js\n    import type {NumberAlias} from './exports';\n\n    (0: NumberAlias) // Error: 0 is not a NumberAlias!\n\n    function convert(x: NumberAlias): number {\n      return x; // Error: x is not a number!\n    }\n\n    ```\n    - opaque type alias 에 subtyping constraint를 추가할때 우리는 super type으로 사용된 opaque type을 선언된 파일 밖에서 사용할 수 있다.\n\n    ```javascript\n    //exports.js\n    export opaque type ID: string = string;\n\n    //import.js\n    import type {ID} from './exports.js';\n\n    function formatID(x: ID): string {\n      return \"ID: \" + x; // works\n    }\n\n    function toID(x: string): ID {\n      return x;\n    }\n    ```\n\n    - subtyping constraint를 함께 쓰는 opaque type alias 를 만들때 타입설정은 반드시 super type positiona에 설정된 타입을 지니고 있어야 한다. \n\n    ```javascript\n    opaque type Bad: string = number; // Error: number is not a subtype of string\n    opaque type Good: {x: string} = {x: string, y: number};\n\n    ```\n\n13. Interface Types\n\n    - classes flow type 의 경우에는 nominal typed 이다. 다시말해서 같은 속성과 같은 메서드가 있어도 서로 이름이 다른 classes type은 한곳에서 다른곳으로 사용이 불가하다.\n    - 대신에. interface 로 기대 되는 class structure 를 선언할 수 있다.\n\n    ```javascript\n    interface Serializable {\n      serialize(): string;\n    }\n\n    class Foo {\n      serialize() { return '[Foo]'; }\n    }\n\n    class Bar {\n      serialize() { return '[Bar]'; }\n    }\n\n    const foo: Serializable = new Foo(); // Works!\n    const bar: Serializable = new Bar(); // Works!\n    ```\n\n    - implements 구문을 사용해서 flow 에게 이 인터페이스에 매칭되는 클래스를 원한다는 것을 말해줄수가 있다. 이것은 다른 사람이 클래스를 쉽게 변하게 만들지 못하도록 보호할 수 있다.\n    - 멀티로 2개 이상도 설정가능\n\n    ```javascript\n    // @flow\n    interface Serializable {\n      serialize(): string;\n    }\n\n    class Foo implements Serializable {\n      serialize() { return '[Foo]'; } // Works!\n    }\n\n    class Bar implements Serializable {\n      // $ExpectError\n      serialize() { return 42; } // Error!\n    }\n    ```\n\n    - 인터페이스 syntax는 아래와 같다.\n\n    ```javascript\n    interface MyInterface {\n      method(value: string): number;\n      property: string;\n      property?: string;\n\n      [key: string]: number;\n    }\n    ```\n\n    - 인터페이스도 다른 타입과 같이 generics를 사용할수 있고 프로퍼티에 read-only 와 write-only를 설정할 수있다.\n\n      ```javascript\n      interface MyInterface<A, B, C> {\n        foo: A;\n        bar: B;\n        baz: C;\n      }\n\n      interface MyInterface {\n        +covariant: number // read-only\n        -contravariant: number; // write-only\n      }\n\n      interface Invariant { property: number }\n      interface Contravariant { -writeOnly: number }\n\n      function method1( value: Invariant) {\n        value.property; // works\n        value.property = 3.14 // works\n      }\n      funtion method2 ( value: contravariant) {\n        value.property; // error\n        value.writeOnly = 3.14 // works!!\n      }\n      ```\n\n      - write-only 를 사용하면 덜 구체적인 타입도 pass를 진행한다.\n\n      ```javascript\n      interface Contravariant { -writeOnly: number }\n      var numberOrString = Math.random() > 0.5? 42 : 'forty-two';\n\n      var value2: Contravariant = { writeOnly: numberOrString };\n      ```\n\n  14. Generic Types\n\n      - generic은 추상적으로 타입을 지정할수 있는 방법이다.\n      - generic은 function , function types , classes , type aliases , interface에 사용될 수 있다.\n\n      - function 사용\n\n      ```javascript\n      function identity<T>(value: T): T {\n        return value;\n      }\n\n      <T>(param: T) => T\n      ```\n      - classes 사용\n\n      ```javascript\n      class Item<T> {\n        //...\n      }\n\n      class Item<T> {\n        prop: T;\n\n        constructor(param: T) {\n          this.prop = param;\n        }\n\n        method(): T {\n          return this.prop\n        }\n      }\n      ```\n      - many generics as you need\n\n      ```javascript\n      function identity<One, Two, Three>(one: One, two: Two, three: Three) {\n      \n      }\n      ```\n\n      - generic 타입은 말 그대로 \"unknown\" type이다. 하지만 함수 안에서 구체적인 타입을 사용하게 된다면 에러를 뿜는다.\n\n      ```javascript\n      function logFoo<T>(obj: T): T {\n        console.log(obj.foo); // error\n        return obj\n      }\n      // 정확한 타입을 쓰기 위해 분기를 쳐야 한다.\n      function logFoo<T>(obj: T): T {\n      if (obj && obj.foo) {\n        console.log(obj.foo); // Works.\n      }\n        return obj;\n      }\n\n      // 또는 타입을 지정한다.\n      function logFoo<T: {foo: string}>(obj: T): T {\n        console.log(obj.foo);\n        return obj;\n      }\n      ```\n\n      - flow경우 하나의 타입을 다른곳으로 전달할 때 original type을 잃어버린다. 그래서 구체적인 타입을 덜 구체적인 타입으로 전달할때 flow 는 \"forget\" 된다. 그것은 한때 구체적이였던 것이다.\n    \n      ```javascript\n      function identity<T>(val: T): T{\n        retur val\n      }\n\n      let foo: 'foo' = 'foo'; // works\n      // identity 호출할때 구체적인 string이 전잘 됬지만 호출 이후에 original type을 잃어버림.. 그래서 작동할 수 있다.\n      let bar: 'bar' = identity('bar'); // works\n      ```\n\n      - generic은 함수의 arguments 처럼 타입을 지정할 수 있다. \n\n      ```javascript\n      type Item<T> = {\n        prop: T,\n      }\n\n      let item: Item<string> {\n        prop: \"value\"\n      }\n      ```\n\n      - classes 버젼\n\n      ```javascript\n      class Item<T> {\n        prop: T;\n        constructor(param: T) {\n          this.prop = param;\n        }\n      }\n\n      let item: Item<number> = new Item(42); \n      let item: Item = new Item(42); // error;\n      ```\n\n      - type aliases 버젼\n\n      ```javascript\n      type Item<T> = {\n        prop: T,\n      }\n\n      let item1: Item<number> = {prop: 42}\n      let item2: Item = {prop: 42}  // error\n      ```\n\n      - interface 버젼\n\n      ```javascript\n      interface HasProp<T> {\n        prop: T,\n      }\n\n      class Item {\n        prop: string\n      }\n      (Item.prototype: HasProp<string>); // works\n      (Item.prototype: HasProp) // error\n      ```\n\n      - default 값도 설정할 수있다.\n\n      ```javascript\n      type Item<T: number = 1> = {\n        prop: T,\n      };\n\n      let foo: Item<> = { prop: 1 };\n      let bar: Item<2> = { prop: 2 };\n      ```\n\n\n  15. Union types\n\n      - 여러가지 타입을 받고 싶다면 Union types를 쓸수 있다.\n      - syntax는 아래와 같다.\n\n      ```javascript\n      Type1 | Type2 | ... | TypeN\n      ```\n\n      - 여러 타입을 (union types)을 사용한다면 우리는 그들 타입중 하나만을 다뤄야 한다.\n\n      ```javascript\n      function toStringPrimitives(value: number | boolean | string): string { // Error!\n        if (typeof value === 'number') {\n          return String(value);\n        } else if (typeof value === 'boolean') {\n          return String(value);\n        }\n      }\n      ```\n      - 여러타입중 한가지 타입만 다루고 싶다면 다음과 같이 합니다.\n\n      ```javascript\n      function toStringPrimitives(value: number | boolean | string) {\n        if (typeof value === 'number') {\n          return value.toLocaleString([], { maximumSignificantDigits: 3 }); // Works!\n        }\n        // ...\n      }\n      ```\n\n      - 만약 우리가 두가지의 object types들을 union type으로 생성한다면 flow 는 두 object type 에 들어있는 success property 를 base로 사용하여 알아낼수 있다.\n\n      ```javascript\n      type Success = {success: true, value: boolean}\n      type Fail = {success: false, error: string}\n\n      type Response = Success | Fail;\n\n      function handleResponse(response: Response) {\n        if( response.success ){\n          var value: boolean = response.value // work\n        } else {\n          var error: boolean = response.error // work\n        }\n      }\n      ```\n\n      - union type을 위처럼 분리해서 사용하려면 정확한 타입과 함께 사용해야 한다. disjoint unions type은 각 object에서 한가지 프로퍼티를 구별로 사용한다. 따라서 구별 할 수 있는 프로퍼티가 없다면 에러를 뿜게 된다.\n      이것은 flow가 object type을 더 확장 가능한 값으로 보기 때문이다.\n\n      - 정 사용해야 겠다면 아래처럼\n\n      ```javascript\n      type Success = {| success: true, value: boolean |};\n      type Failed  = {| error: true, message: string |};\n\n      type Response = Success | Failed;\n\n      function handleResponse(response: Response) {\n        if (response.success) {\n          var value: boolean = response.value;\n        } else {\n          var message: string = response.message;\n        }\n      }\n      ```\n\n  16. Intersection Types\n\n      - & 로 연결된 타입들 이것들은 모두를 만족해야 한다.\n\n      ```javascript\n      type A = { a: number };\n      type B = { b: boolean };\n      type C = { c: string };\n\n      function method(value: A & B & C) {}\n\n      // ExpectError\n      method({ a: 1 }); // Error!\n      // ExpectError\n      method({ a: 1, b: true }); // Error!\n      method({ a: 1, b: true, c: 'three' }); // Works!\n\n      ```\n\n  17. Typeof Types\n\n      - 자바스크립트의 typeof 연산자에서 리턴되는 값으로 타입을 정의한다.\n\n      ```javascript\n      let num1 = 42;\n      let num2: typeof num1 = 3.14;     // Works!\n      // $ExpectError\n      let num3: typeof num1 = 'world';  // Error!\n      ```\n\n  18. Type Casting Expressions\n\n      - 함수나 변수를 선언하지 않고 타입을 지정하고 싶을 때가 있을 것입니다. 이때 flow는 inline type cast expression 을 사용할 수 있습니다.\n\n      ```javascript\n      (value: Type)\n\n      let val = (value: Type)\n      let obj = { prop: (value: Type)}\n      let arr = ([(value: Type),(value: Type)]: Array<Type>)\n      ```\n      - 선언 뿐만 아니라 할당도 할 수 있다.\n\n      ```javascript\n      let value = 42;\n\n      (value: 42);     // Works!\n      (value: number); // Works!\n\n      // 42 할당 및 type number\n      let newValue = (value: number); \n\n      // $ExpectError\n      (newValue: 42);     // Error!\n      (newValue: number); // Works!\n      ```\n\n      - 다음 아래와 같이 value 를 any로 캐스팅 하면, 너는 원하는 어떤것이든 타입을 캐스팅할수 있다. 다만 이건 굉장이 안전하지 않다. \n\n      ```javascript\n      let newValue = ((value: any): string);\n      ```\n\n      - 하지만 타입을 지정하기 어렵고 불가능할때에는 result에 따라서 타입이 정해지길 바랄수 있다. 예를 들어보자\n\n      ```javascript\n      // 얕은 복사\n      function cloneObject(obj) {\n        const clone = {};\n\n        Object.kets(obj).forEach(key => {\n          clone[key] = obj[key];\n        })\n\n        // return clone;\n        // 이렇게 사용될 수 있다.\n        return ((clone: any): typeof obj);\n      }\n      ```\n\n      - 만약 우리가 cloneObject 메소드를 실행하기전에 들어오는 인자의 타입을 먼저 정한다면 아래처럼 작성할 것이다.\n\n      ```javascript\n      function cloneObject(obj: { [key: string]: mixed}){}\n      ```\n\n      - 하지만 위 코드는 문제가 있다. 우리의 **typeof obj** annotation 또한 새로운 annotation을 갖기에 전체 목적을 파괴시킨다.\n\n      - 그래서 우리는 function 안에 사용할 타입에 대해서 assertion 해야한다.\n\n      ```javascript\n      function cloneObject(obj) {\n        (obj: { [key: string]: mixed});\n        //...\n\n        return ((clone: any): typeof obj);\n      }\n      ```\n\n      - 실질적인 해결 방법은 아래와 같다.\n\n      ```javascript\n      function cloneObject<T: { [key: string]: mixed }> (obj: T): $Shape<T> {\n        //...\n      }\n      ```\n\n   20. Utility Types\n\n      - flow 는 flow 자체내에 utility types 들을 제공한다.\n\n      홈페이지 참고 : [https://flow.org/en/docs/types/utilities/](https://flow.org/en/docs/types/utilities/)","excerpt":"Intro flow 는 자바스크립트의 스태틱한 타입들을 체크해주는 도구이다. flow 는 코드가 변경되는 동안 빠른 피드백을 줍니다. flow 는 타입을 추론할 수 있습니다.  install 바벨을 이용해서 flow 유형을 변환시켜줘야 한다. 만약 …","fields":{"slug":"/hello-flow.md/"},"frontmatter":{"date":"Mar 29, 2018","title":"hello-flow","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## web Server\n---\n\n- web server 는 요청 과 응답의 연속이다.\n- web browser에 web page주소를 입력(요청) 하면 입력한 주소에 맞는 웹 페이지(응답) 을 제공한다. \n- 요청은 요청하는 url , 요청하는 방식 (ex. get,post..) , 요청하는 agent , 요청자가 받을 수 있는 형식이나 charter-set , encoding , language  등등을 함께 실어서 보낸다.\n- 응답은 응답에 상태 ( ex. 200 , 404 error) , 응답하는 data를 전달한다.\n\n여기서 nodeJs는 이 웹서버와 관련된 모든 기능들을 http 모듈에 담았다.\n\n따라서 우리는 앞으로 http 모듈에 대해서 가볍게 다뤄 보겠다.\n\n\n\n### http 모듈\n\n- http 모듈은 createServer()로 server라는 객체를 생성한다.\n- listen(port[, callback])은 서버를 실행한다.\n- stop([callback])은 서버를 종료한다.\n\n### server 객체\n\n- server 객체는 EventEmitter 객체를 기반으로 만들어졌으므로 이벤트를 연결 시킬수 있다.\n- server.on({eventName},{eventHandler})\n- 예를 들면 내부적으로 connection이 발생하면 server.emit('connection'); 이라고 발생을 시키면 외부에서 우린 on 메서드로 그 이벤트를 감지해서 해당 후속 작업을 이어 나갈 수 있다.\n\n```javascript\nserver.on('connection', (code) => console.log('Connection ON'))\n```\n\n- \"request\" 라는 이벤트도 존재하는데 이 이벤트는 예외적으로 on 메서드를 사용해서 지정할 필요가 없고 createServer시 매개변수로 콜백(request 가 발생 했을시 이벤트 핸들러 ) 함수를 넘겨 놓으면 이벤트 핸들러(이벤트 리스너) 처럼 사용 할 수 있다.\n\n```javascript\nhttp.createServer((request, response) => {\n    // 응답헤더\n    response.writeHead(200, {\n        'Content-Type' : 'text/html',\n        'Set-Cookie':['breakfase = toast';Expire = ' + date.toUTCString(),\n        'dinner = chicken']\n        });\n    // 응답본문\n    response.end('<h1>블라블라~</h1>');\n});\n```\n\n### response 객체\n\n- 클라이언트에 웹 페이지를 제공하려면 응답 메세지가 필요하다.\n- request 이벤트가 발생되면 핸들러(리스너)의 두번째 매개변수로 전달되는 response 객체를 사용해서 사용자에게 응답을 전달한다.\n- 응답 메시지의 'Content-Type' 는 전달할 데이터 속성을 뜻한다.\n- response 객체를 사용하면 클라이언트에 쿠키를 할당할 수 있다. 응답헤더에 'Set-Cookie' 라는 키 값으로 셋팅 해준다.\n- 쿠키를 출력할 때에는 request.headers.cookie 라는 값으로 참조 한다. \n\n### request 객체\n\n- server의 request 이벤트가 발생했을 때 이벤트 리스너의 첫 번째 매개변수에는 request 객체가 들어갑니다.\n- method , url , headers, trailers, httpVersion 등, 속성들이 존재한다.\n- 이런 속성들을 사용하면 요청한 페이지를 적절하게 제공하는 것은 물론 요청 방식에 따라 페이지를 구분할 수 있다.\n\n```javascript\nhttp.createServer((request, response) => {\n    // 그냥 요청자의 pathname을 구한다고 보면 된다.\n    const pathname = url.arse(request.url).pathname; \n\n    if(pathname == '/'){\n        \n    }\n\n    //or\n\n    if(request.method == 'GET'){\n\n    }\n\n    //or ( GET 요청 방식에서의 매개변수 추출 )\n    // http://localhost/?name=hoho&region=suwon\n    const query = url.parse(request.url, ture).query;\n    response.end(JSON.stringify(query))  // {\"name\":\"hoho\",\"region\":\"suwon\"}\n\n    //or ( POST 요청 방식에서의 매개변수 추출 )\n    // request 이벤트가 발생한 후 request 객체의 data의 이벤트로 데이터가 전달 된다.\n    request.on('data',(data) => {\n        console.log('POST Data:', data);\n    })\n\n    //or 쿠키 추출\n    const cookie1 = request.headers.cookie; // return 값은 문자열이다.\n    const cookie2 = request.headers.cookie.split(';').map((cookieItem) => {\n        let arrCookieItem = cookieItem.split('=');\n        return {\n            key: arrCookieItem[0],\n            value: arrCookieItem[1]\n        }\n    }); // return 은 객체\n})\n```","excerpt":"web Server web server 는 요청 과 응답의 연속이다. web browser에 web page주소를 입력(요청) 하면 입력한 주소에 맞는 웹 페이지(응답) 을 제공한다.  요청은 요청하는 url , 요청하는 방식 (ex. get,pos…","fields":{"slug":"/hello-webServer.md/"},"frontmatter":{"date":"Mar 15, 2018","title":"hello-webServer","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Intro\n---\n\n- 기존에 돌아가는 서버를 바라보는 dev proxy server를 띄워 부분적으로 react component를 개발하는 환경을 만들어보자.\n- 그러기 위해서 사용하는 개발서버 webpack dev config 설정을 해보자.\n- 배포를 위한 webpack prod config 설정을 해보자.\n- webpack 개발을 위한 babel , react-hot-loader 등을 설정해보자.\n- webpack 을 node api 로 사용해보자.\n\n## Tech stack\n---\n\n- webpack v4.0\n- react v16.2\n\n\n\n## Structure\n---\n\n```\n├── config\n│   ├── paths                       ## 경로 설정 ( 각자의 경로가 다르다면 여기서 수정)\n│   ├── webpack.prod.config.js      ## 웹팩 prod config\n│   ├── webpack.dev.config.js       ## 웹팩 dev config\n│   ├── wepackDevServer.js          ## 웹팩 dev server용 config\n├── scripts                         ## frontend 개발서버 , build , 배포 쪽 스크립트\n│   ├── build.js                    ## 배포 build \n│   ├── start.js                    ## 개발서버 start \n├── src                             ## react 소스 폴더\n│   ├── components                  ## components 들 모음 폴더\n│   ├── App.js                      ## app 의 시작점\n│   ├── index.js                    ## react render의 시작점\n├── .babelrc\n├── package.json                    \n  \n```\n\n- dev 환경 : script/start.js 에서 webpack.dev.config 와 webpackDevServer 를 import 하여 webpack dev server 를 실행시킨다. \n- prod 환경 : script/build.js 에서 webpack.prod.config 를 이용해서 bundle.js를 만든다.\n- 공통 환경 : paths.js 경로에 관련된 환경\n- 깃 : [https://github.kakaocorp.com/FTDev-RnD/study-docker/tree/master/merlin_app/merlin_frontend](https://github.kakaocorp.com/FTDev-RnD/study-docker/tree/master/merlin_app/merlin_frontend)\n\n## 각 파일 설명\n---\n\n### webpack.dev.config.js\n\n\n```javascript\nconst path = require(\"path\");\nconst paths = require(\"./paths\");\n\nmodule.exports = {\n  entry: [\"./src/index.js\"],\n  output: {\n    path: paths.appPublic,\n    filename: \"bundle.js\"\n  },\n  devtool: \"inline-source-map\",\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \"babel-loader\"\n        }\n      }\n    ]\n  },\n  mode: \"development\",\n  plugins: [],\n  resolve: {\n    modules: [\"node_modules\"]\n  }\n};\n\n```\n\n**webpack 4에는 production 과 development mode 옵션이 생겨났다.**\n\n보통의 경우 development config 파일과 production config 파일 2개를 관리하게 된다.\n\n- webpack dev server 를 설정하고 기타 설정들을 위한 dev config\n- UglifyJsPlugin , 소스맵 , 뿐만아니라 배포를 위한 최적화 된 bundle.js 를 위한 기타 설정들을 위한 prod config\n\nwebpack 4 에선 --mode (production / development) 옵션으로 해당 옵션만으로 \n\nproduction 모드에선 minification과 hoisting , tree-shaking(불필요 한것을 떨군다.) 등등의 최적화 작업이 자동으로 이뤄지고\ndevelopment 모드에선 다른 방식으로 optimized를 하면서 un-minified bundle을 내뱉어 준다.\n\nmode 옵션에 대한 참고 : [https://www.valentinog.com/blog/webpack-4-tutorial/#webpack_4_production_and_development_mode](https://www.valentinog.com/blog/webpack-4-tutorial/#webpack_4_production_and_development_mode)\n\n### webpackDevServer\n\n```javascript\n\nconst noopServiceWorkerMiddleware = require(\"noop-service-worker-middleware\");\n\nmodule.exports = {\n  public: \"nodeapp.local:3001\",\n  inline: true, // live reloading insert bundle..\n  hot: true, // hot module reloading\n  compress: true, // enable gzip compression\n  historyApiFallback: true,\n  before(app) {\n    //app.use(errorOverlayMiddleware());\n    app.use(noopServiceWorkerMiddleware());\n  },\n  overlay: {\n    warnings: true,\n    errors: true\n  }\n};\n\n```\n\nwebpack dev server 에 대한 기본적인 option 부분이다.\n\n**devServer 의 옵션**\n\n- devServer.public : dev server 의 inline 모드와 proxying dev server 이용시, inline client scrtip는 항상 어디에 연결해야 하는지 모른다. client script는 server에 window.location 기준으로 추축하게 된다. 그러나 이게 실패할시 이 public을 이용하게 된다.\n- devServer.inline : dev server 에는 inline 모드와 hot 모드가 있다. default 는 inline 모드를 사용한다. 이것은 번들에 삽입되어서 live reloading을 지원하고 build 메세지를 브라우져 console에 보여준다.\n- devServer.historyApiFallback : HTML5 History API 를 사용할때(즉, SPA사용시), true로 설정하면 어느 404 응답대신 index.html을 제공된다. rewrites(Object or Array)를 이용하면 by passing을 설정할 수 있다.\n- devServer.contentBase : dev server 는 기존 프로젝트 루트에 있는 파일을 서비스 하는데 여기서는 proxy를 사용하기에 별도로 작성하지 않는다. \n- devServer.before() : dev 서버 안에 모든 내부 미들웨전에 실행하는 부분이다. 이부분은 커스텀 핸들러를 정의하는데 사용할 수 있다.\n- devServer.overlay : 컴파일 에러시 브라우져 화면에 overlay 로 보여준다.\n\n**noopServiceWorkerMiddleware**\n- express의 미들웨어를 리턴하는 녀석으로 이전의 서비스 워커 설정들을 reset 시키는 녀석이다. ( 사실 react-create-app 에서 사용하기에 들고왔다. ) \n- 아직 왜 필요한지는 파악하지 못함.\n- 서비스 워커란? [https://b.limminho.com/archives/1384](https://b.limminho.com/archives/1384)\n\n### webpack.prod.config\n\n```javascript\nconst path = require(\"path\");\nconst paths = require(\"./paths\");\n\nmodule.exports = {\n  entry: [\"./src/index.js\"],\n  output: {\n    path: paths.appPublic,\n    filename: \"bundle.js\"\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \"babel-loader\"\n        }\n      }\n    ]\n  },\n  mode: \"production\",\n  plugins: [],\n  resolve: {\n    modules: [\"node_modules\"]\n  }\n};\n\n```\n\n- dev.config 와 동일\n\n### paths.js\n\n```javascript\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst url = require(\"url\");\n\nconst appDirectory = fs.realpathSync(process.cwd());\nconst resolveApp = relativePath => path.resolve(appDirectory, relativePath);\n\nmodule.exports = {\n  appPublic: resolveApp(\"public\"),\n  appBuild: resolveApp(\"build\")\n};\n\n```\n\n- path 를 관리하는 장소 ( 상세 설명은 생략 )\n\n\n\n### start.js ( dev start )\n\n```javascript\n\"use strict\";\n\nprocess.env.BABEL_ENV = \"development\";\nprocess.env.NODE_ENV = \"development\";\n\nconst Webpack = require(\"webpack\");\nconst WebpackDevServer = require(\"webpack-dev-server\");\nconst webpackConfig = require(\"../config/webpack.dev.config\");\nconst webpackDevConfig = require(\"../config/webpackDevServer\");\nconst open = require(\"open\");\n\n// setting\nconst host = process.env.HOST || \"0.0.0.0\";\nconst proxyUrl = \"http://nodeapp.local:8081\";\nconst publicPath = \"/\";\nconst port = process.env.PORT || 3001;\nconst devServerOptions = Object.assign({}, webpackDevConfig, {\n  proxy: {\n    \"/\": {\n      target: proxyUrl,\n      secure: false\n    }\n  },\n  host,\n  port,\n  publicPath,\n  stats: {\n    colors: true\n  }\n});\n\nwebpackConfig.plugins.push(new Webpack.HotModuleReplacementPlugin());\nwebpackConfig.plugins.push(new Webpack.NamedModulesPlugin());\n\nWebpackDevServer.addDevServerEntrypoints(webpackConfig, devServerOptions);\nconst compiler = Webpack(webpackConfig);\nconst server = new WebpackDevServer(compiler, devServerOptions);\n\nserver.listen(port, host, err => {\n  if (err) {\n    return console.log(err);\n  }\n\n  console.log(\"Starting server on http://nodeapp.local:3001\");\n  open(\"http://nodeapp.local:3001\");\n});\n\n```\n\n기본적으로 webpack 에선 express를 이용해서 devServer를 만듭니다.\n\nwebpack dev server 에 필요한 추가적인 부분을 작성합니다. \n\n**devServerOptions**\n\n- proxy 라는 부분을 이용해서 \"/\" 경로로 들어왔을때 target 프록시 url로 요청을 보내서 받아오게 됩니다.\n- publicPath 라는 부분은 개발시에 실제 서버 경로 처럼 사용할 수 있게 만들어 줍니다. 예를 들어 \"/asset\" 으로 설정해놓으면 실제로 dev 개발할 시 bundle의 주소는 /asset/bundle.js 로 참고 하게 됩니다.\n\n**HotModuleReplacementPlugin**\n- hot module replace 모드를 활성화 시켜줍니다.\n- 절대 production 모드에선 사용하지 않습니다.\n\n\n**NamedModulesPlugin**\n- hot module replace 모드 사용시 모듈의 상대 경로를 표시해줍니다. 개발시에 추천되는 플러그인 입니다.\n\n\nwebpack dev 참고 : <br/>\n[https://webpack.js.org/guides/hot-module-replacement/#via-the-node-js-api](https://webpack.js.org/guides/hot-module-replacement/#via-the-node-js-api)\n[https://github.com/webpack/webpack-dev-server/tree/master/examples/api/simple](https://github.com/webpack/webpack-dev-server/tree/master/examples/api/simple)\n\n\n### build.js ( prod bundle )\n\n```javascript\nconst path = require(\"path\");\nconst paths = require(\"../config/paths\");\nconst chalk = require(\"chalk\");\nconst fs = require(\"fs-extra\");\nconst argv = require(\"yargs\").argv;\nconst webpack = require(\"webpack\");\nconst config = require(\"../config/webpack.prod.config\");\n\nfunction execute() {\n  build().then(\n    ({ stats }) => {\n      console.log(\"build Success!!\");\n      copyPublicFolder();\n    },\n    err => {\n      console.log(\"build error\");\n    }\n  );\n}\n\nfunction build() {\n  console.log(\"Creating an optimized production build...\");\n\n  let compiler = webpack(config);\n  return new Promise((resolve, reject) => {\n    compiler.run((err, stats) => {\n      if (err) {\n        return reject(err);\n      }\n\n      return resolve({ stats });\n    });\n  });\n}\n\n// copy folder and file\nfunction copyPublicFolder() {\n  fs.copySync(paths.appPublic, paths.appBuild);\n}\n\nexecute();\n\n```\n\n실제 배포 번들을 만든 뒤 파일 copy 하는 부분\n\n< 추가 되어야 할 부분 >\n\n- 실제 배포되야할 번들 파일 뒤에 번들 리비젼 붙이기 \n- 기타 console.log 부분 제거와 optimized\n\n## Reference\n---\n\n- 해당 폴더 구성과 파일 구성등은 Create React App 을 참고 하였다.","excerpt":"Intro 기존에 돌아가는 서버를 바라보는 dev proxy server를 띄워 부분적으로 react component를 개발하는 환경을 만들어보자. 그러기 위해서 사용하는 개발서버 webpack dev config 설정을 해보자. 배포를 위한 we…","fields":{"slug":"/webpack-config.md/"},"frontmatter":{"date":"Mar 14, 2018","title":"webpack config","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Intro\n---\n\n리엑트 및 함수형 프로그래밍에 많이 나오는 모나드 패턴 알아보자.\n\n찾아보니 너무 어렵다. 특정하게 정의를 내려가기 보단 코드를 조금씩 발전시켜 나가면서 느낌을 익혀보자는 취지로 작성한다.\n\n\n## 이해해보자\n---\n\n### 즉시 실행함수로 값 두개를 더해보자.\n\n아래 코드를 보자.\n별도로 설명할건 없을꺼 같다.\n\n\n```javascript\n// 덧셈\n(function(x){\n\t(function(y){ \n        console.log(x+y)\n        })(2)\n})(1)\n```\n\n이쁘다..(?)\n\n딱봐도 뭔가 뎁스가 점점 깊어질꺼 같기도 하다. 느낌이 뭔가 원시적이기도 하고 그 다음에는 helper 함수를 이용해서 조금 더 깔끔하게 바꿔보자.\n\n\n### bind 라는 helper\n\n여기서 bind 는  Function에 있는 bind가 아닌 임의로 만든 helper 함수라는걸 알아두자.\n\n```javascript\n\n// 이걸 이쁘게..\nfunction bind(x, fn){\n\treturn fn(x);\n}\n\n// 컨텍스트가 있는 연속된 계산...이쁜?? 덧셈\n\nbind(1, function(x){\n bind(2 , function(y){\n \tconsole.log(x+y);\n })\n});\n\n```\n\n음.. 뭔가 더 알아보기 쉬워지지 않았는가????\n요느낌 그대로 모나드는 어떻게 사용하는가를 알아보자.\n\n\n### Identity monad v1\n\n\n조금은 어렵고 난해한 그림으로 설명하는 모나드 사이트를 소개한다.\n\n\n[http://lazyswamp.tistory.com/entry/functorsapplicativesandmonadsinpictures](http://lazyswamp.tistory.com/entry/functorsapplicativesandmonadsinpictures)\n\n이해가 안된다면 위 코드를 객체를 이용해서 짜본다고 생각하면 조금 더 이해하기 쉽겠다.\n왜? 객체를 이용해야 하는가.. 그건 아래에서 조금 더 다뤄보자.\n\n\n```javascript\n// 어떠한 특정 값을 wrapping..\nfunction Identity(value){\n\tthis.value = value;\n}\n\n// 여기선 어떠한 값을 Identity 가 들고있기에 어떠한 함수와 결합할것지만 넘겨주면 된다.\nIdentity.prototype.bind = function(fn){\n\treturn fn(this.value);\n}\n\n// 출력을 위한\nIdentity.prototype.toString = function(){\n\treturn `Identity({this.value})`;\n}\n\n// Identity monad test\n// 5 + 6\n\nlet result = new Identity(5).bind(\n\tfunction(x){\n        return new Identity(6).bind(\n            function(y){\n                return (x + y);\n        }\n    );\n  }\n)\n\nconsole.log(result);\n\n```\n\n\n### Identity monad v2\n\n위에 코드도 그닥 깔끔하지 않으니 es6 를 사용해서 조금 더 깔끔하게 작성해보자.\n\n```javascript\n// 간추려 보자...\n\nlet result2 = new Identity(5).bind(x =>\n\tnew Identity(6).bind(y =>\n  \t    x+y\n  )\n);\n\nconsole.log(result2);\n```\n\n음..뭔가 더 있어보인다. \n계속 발전 시켜 나가면서 이게 왜 쓰이고 왜 좋은지 장점들을 알아보자.\n\n\n### Maybe monad\n\n위의 identity 모나드의 문제점을 한번 보자..\n\n만약 계산중에 중간에 값이 없는 경우가 들어온다면???? 결과는 어떻게 나올까??\n\n위의 코드에서 '6' 을 지워보고 테스트 해보자 결과는?? \n\n**NaN**\n\n이럴경우에는 어떻게 처리할까.. 또 다른 코드를 보자.\n\n우선 단순하게 Identity 라는 명칭이 Just로 바꾸었다.\n\n```javascript \n\n// 어떠한 특정 값을 wrapping..\nfunction Just(value){\n\tthis.value = value;\n}\n\n// 여기선 어떠한 값을 Identity 가 들고있기에 어떠한 함수와 결합할것지만 넘겨주면 된다.\nJust.prototype.bind = function(fn){\n\treturn fn(this.value);\n}\n\n// 출력을 위한\nJust.prototype.toString = function(){\n\treturn `Identity(${this.value})`;\n}\n\n// 테스트를 위한 Nothing\nlet Nothing = {\n    bind : function(){\n        return this;\n    },\n    toString : function(){\n        return `this is Nothing`;\n    }\n}\n\n// 중간에 빈 Nothing이 들어온다.\nlet result = new Just(5).bind(x =>\n    Nothing.bind(y =>\n        x+y\n    )\n)\n\nconsole.log(result); // 에러가 뜨지 않는다. \n\n\n```\n\n위 코드는 에러가 뜨지 않는다. 어디서 잘못되었는지 알 도리가 없다.\n대신 Nothing 이 반환된다.\n\n이 코드는 간단해서 금방 어디가 잘못되었는지 알 수 있지만,\n\n코드가 조금만 복잡해지더라도 어디서 잘못되었는지 파악하기가 힘들수 있다.\n\n그렇담 이제부터 뭔가 null,undefined 이나 Nothing 체크가 필요해보인다. 새로운 예제를 보자.\n\n우리는 보통 값이 있는지 없는지를 확인할때 가장 흔하게 if 문을 자주 쓴다.\n\n```javascript\n\n// 유저의 아바타를 가져오는 함수\n// 별도의 설명은 필요 없을 듯 싶다.\nfunction getUser(){\n    return {\n        getAvatar : function(){\n            return null;\n        }\n    }\n}\n\n// if\nlet user = getUser();\nif(user != null){\n    let avatar = user.getAvatar();\n    if(avatar != null){\n        let skill = avatar.skill // 아바타의 스킬을 가져오기 위한 몸부림....\n    }\n}\n\n```\n\nif의 몸부림이 보인다.\n\n이번엔 Maybe 모나드로 처리해보자. 단순히 모나드에 값이 아닌 객체를 넣는게 다르게 보일 수 있다.\n\n방식은 비어있는 값을 만날때에는 연산이 정지하도록 만들어 보자. \n\n위와 동일한 예제이다. Just 객체도 위와 동일하다. Nothing도 위와 같다.\n\n```javascript\n\nfunction getUser(){\n    return new Just({\n        getAvatar: function(){\n            return Nothing; // 값이 없는 객체이지만 모나드와 동일한 메서드 구성을 지니고 있긴하다. \n        }\n    })    // 이전까지는 값을 넣었었는데 이젠 객체를 넣는다.\n};\n\n// if를 대안한 방법... 우린 스킬을 얻길 원한다!!!\nlet skill = getUser().bind(function(user){   // 여기서 user 는 this.value\n    return user.getAvatar();\n}).bind(function(avatar){  // getAvatar를 호출하고 나서 나온 객체에 대해서 다시 binding..\n    return avatar.skill;\n});\n\nif(skill instanceof Just){\n    console.log(`skill is : ${skill.value}`);\n}else{\n    console.log('skill is empty');\n}\n\n```\n\n이 느낌은 모나드라는 인터페이스를 기준으로 모듈들을 짜야만 할것 같은 느낌이다.\n\n값이든 , 어떠한 객체든 하나의 잘 짜여진 인터페이스로 관리를 하는것이다.\n\n\n\n일상생활에서의 예를들면......뭐가 있을까...??\n\n\n### List monad\n\ning......\n\n연산작업을 일련의 과정으로. \n\n\n\n\n\n\n출처 :\n\n- [http://www.haruair.com/blog/2986](http://www.haruair.com/blog/2986)\n\n\n참고할만 자료 : \n\n- [http://reactivex.io/rxjs/manual/overview.html](http://reactivex.io/rxjs/manual/overview.html)\n- [https://curiosity-driven.org/monads-in-javascript](https://curiosity-driven.org/monads-in-javascript)\n- [https://github.com/fantasyland/fantasy-land](https://github.com/fantasyland/fantasy-land)\n\n```html\n<input type=\"text\" id=\"merlin\" value=\"\"/>\n<div id=\"screen\"></div>\n```\n\n```javascript\nRx.Observable.fromEvent(document.getElementById('merlin'), 'input')\n\t\t.map((e) => e.target.value)\n        .map((text) => '<h3>' + text + '<h3>')\n        .subscribe((result) => {\n            document.getElementById('screen').innerHTML = result\n        });\n```","excerpt":"Intro 리엑트 및 함수형 프로그래밍에 많이 나오는 모나드 패턴 알아보자. 찾아보니 너무 어렵다. 특정하게 정의를 내려가기 보단 코드를 조금씩 발전시켜 나가면서 느낌을 익혀보자는 취지로 작성한다. 이해해보자 즉시 실행함수로 값 두개를 더해보자. 아…","fields":{"slug":"/hello-monad.md/"},"frontmatter":{"date":"Feb 13, 2018","title":"hello monad","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n[이글](https://medium.com/ag-grid/webpack-tutorial-understanding-how-it-works-f73dfa164f01)을 번역(의역)한 것입니다. \n\n# Webpack Tutorial: Understanding How it Works\n\n## Introduction to Webpack Tutorial\n\nWebpack은 모듈 번들러 입니다. 이것은 여러가지 디펜던시들을 받고 그것들의 모듈을 생성하고 전체 네트워크를 관리 가능한 번들 파일로 묶습니다.\n특히 요즘 웹 어플리케이션의 기본이 되는 **Single Page Application**(SPAs) 에서 유용합니다.\n\n이 글의 모든 코드들은 다음 [GitHub](https://github.com/seanlandsman/ag-grid-understanding-webpack)에 있습니다.\n\n\n우리가 2개의 간단한 수학적 작업을 하는 어플리케이션이 있다고 가정해 봅시다.- sum 과 multiply. 우리는 이 2개의 함수를 유지보수를 위해 나눠서 관리 할 것입니다.\n\n```html\n<html>\n<head>\n    <script src=\"src/sum.js\"></script>\n    <script src=\"src/multiply.js\"></script>\n    <script src=\"src/index.js\"></script>\n</head>\n</html>\n```\n\n```javascript\nvar totalMultiply = multiply(5, 3);\nvar totalSum = sum(5, 3);\nconsole.log('Product of 5 and 3 = ' + totalMultiply);\nconsole.log('Sum of 5 and 3 = ' + totalSum);\n```\n\n```javascript\nvar multiply = function (a, b) {\n    var total = 0;\n    for (var i = 0; i < b; i++) {\n        total = sum(a, total);\n    }\n    return total;\n};\n```\n\n```javascript\nvar sum = function (a, b) {\n    return a + b;\n};\n```\n\n해당 결과로는 다음과 같습니다.\n\n```\nProduct of 5 and 3 = 15\nindex.js:17 Sum of 5 and 3 = 8\n\n```\n\n# How can Webpack help us?\n\n## Dependencies — Modules To the Rescue!\n\n위 코드를 살펴보면 multiply.js와 index.js는 sum.js에 의존성을 가지고 있습니다. 다음과 같은 간단한 다이어그램으로 표현할 수 있습니다.\n\n![https://miro.medium.com/max/984/0*T6Cg8t5_4nr0QFRf.png](https://miro.medium.com/max/984/0*T6Cg8t5_4nr0QFRf.png)\n\n만약에 index.html에서 js 파일의 순서를 잘못 넣었다면 어플리케이션은 작동하지 않았을 것입니다. 만약 index.js가 나머지 2개의 js 파일 이전에 실행이 되었거나 또는 sum.js가 multiply.js 이후에 실행이 되었다면 에러를 마주할 것입니다.\n\n우리가 이 웹 어플리케이션을 확장했다고 상상해 봅시다.-수 많은 디펜던시 파일들이 있고 몇몇은 다른 모듈들에 디펜던시를 가지고 있습니다.\n유지보수에 악몽이 시작될 것입니다.\n\n마지막으로 전역변수를 사용했다고 생각해봅시다. 우리는 이 변수를 overwriting 할 위험을 가질 것이고 버그를 찾기가 힘들어 질 것입니다.\n\nWebpack은 이런 디펜던시들을 모듈로 변환시킬 수 있습니다. - 이 모듈들은 매우 타이트한 스코프를 지닐것입니다. 게다가 이런 디펜던시를 모듈로 변환함으로써 Webpack은 우리 대신에 우리의 디펜던시들을 관리할 수 있습니다. - Webpack은 이런 디펜던트 모듈들을 제시간에 정확한 스포크를 가지고 밀어 넣어줄 것입니다. ( 나중에 더 자세하게 살펴 봅시다. )\n\n\n## Death by a Thousand Cuts — Reducing Traffic\n\n우리가 index.html 파일을 살펴볼때 3가지의 분리된 파일을 필요로 하다는것을 확인할 수 있습니다. 이것은 괜찮습니다. 하지만 많은 디펜던시 파일들이 있다고 상상해 보십시오. end 유저는 이 모든 디펜던시 파일들이 다운로드 할때까지 기다려야 할 것입니다.\n\nWebpack의 제공되는 다른 특징으로는 번들링입니다. 즉, Webpack은 모든 디펜던시 파일들을 하나의 파일로 가져올 수 있습니다. 이말은 하나의 파일만 다운로드가 가능해진다는 것입니다.\n\n![https://miro.medium.com/max/1264/0*h1oaGZlHh88jEEtv.png](https://miro.medium.com/max/1264/0*h1oaGZlHh88jEEtv.png)\n\n번들과 모듈화는 Webpack의 메인 특징입니다. plugin들과 loader들로 확장이 가능하지만 이것이 Webpack의 주된 기능입니다.\n\n## Making Dependencies Available, And Linking Them\n\n처음 셋팅할때 우리는 CommonJS 모듈 문법을 사용할 것입니다. 이것에 대한 다른 옵션(AMD, ES2015)이 있습니다. 하지만 지금은 CommonJS 를 사용하고 추후에 ES2015 를 사용할 것입니다.\n\nCommonJS 는 `module.exports`로 함수들과 변수들을 다른 코드에 노출 시키는데 사용합니다. `require`를 사용하면 노출된 값들을 가져올 수 있습니다. \n\n```html\n<html>\n<head>\n    <script src=\"./dist/bundle.js\"\"></script>\n</head>\n</html>\n```\n\n```javascript\nvar multiply = require('./multiply');\nvar sum = require('./sum');\nvar totalMultiply = multiply(5, 3);\nvar totalSum = sum(5, 3);\nconsole.log('Product of 5 and 3 = ' + totalMultiply);\nconsole.log('Sum of 5 and 3 = ' + totalSum);\n```\n\n```javascript\nvar sum = require('./sum');\nvar multiply = function (a, b) {\n    var total = 0;\n    for (var i = 0; i < b; i++) {\n        total = sum(a, total);\n    }\n    return total;\n};\nmodule.exports = multiply;\n```\n\n```javascript\nvar sum = function (a, b) {\n    return a + b;\n};\nmodule.exports = sum;\n```\n\n우리는 `sum`과 `multiply` 이 2개를 다른 코드에서 사용 가능하도록 만들었습닏다. 그리고 이 노출된 함수들을 multiple.js와 index.js에서 가져올 수 있습니다.\n\n그리고 index.html에선 bundle.js 라는 하나의 파일만 가져왔습니다.\n\n아주 훌륭합니다! 더 이상 디펜던시의 순서에 대해서 걱정할 필요가 없습니다. 우리가 원하는 것을 노출시켰고 다른 코드와 효율적으로 private 하게 유지 했습니다. 또한 3개의 파일(sum.js, multiply.js and index.js)을 불러오는 대신 하나의 파일만 불러와서 loading 속도도 개선했습니다.\n\n## Webpack — Initial Configuration\n\n위 코드를 수행하기 위해서 우리는 Webpack을 셋팅할 것입니다.\n\n```javascript\nvar path = require('path');\nmodule.exports = {\n    entry: './src/index.js',\n    output: {\n        path: path.resolve(__dirname, './dist/),\n        filename: 'bundle.js\n    }\n}\n```\n\n우리는 Webpack에게 entry point와 어디에 결과물을 내보낼지에 대한 최소한의 셋팅을 하였습니다.\n\n`entry` : 이것은 어플리케이션의 메인 시작 포인트 입니다. 어디서 초기 로딩과 어플리케이션 로직이 시작되는 지를 가리킵니다. Webpack은 이 시작점부터 디펜던시 파일 트리를 탐색합니다. 그리고 이 디펜던시 그래프를 만들고 필요한 모듈들을 만들게 됩니다.\n\n`output.path` : 번들링 된 절대 경로 입니다. 크로스 플랫폼과 쉬운 사용을 위해 우리는 Node.js 에 내장되어있는 (path) 함수를 사용합니다. 이것은 동적으로 우리가 있는 위치에 따라서 절대 경로를 만들어주도록 도와줍니다. \n\n`output.filename` : 결과물의 파일 이름입니다. 아무거나 지정해도 되지만 보통 컨벤션에 의해서 'bundle.js' 라고 지칭 합니다.\n\nNote: __dirname is a Node.js utility variable - it is the directory name of the current file.\n\n\n## Looking at bundle.js\n\n결과 bundle.js를 보는 것은 매우 지시적 일 수 있습니다.\n\n```javascript\n// the webpack bootstrap\n(function (modules) {\n    // The module cache\n    var installedModules = {};\n    // The require function\n    function __webpack_require__(moduleId) {\n        // Check if module is in cache\n        // Create a new module (and put it into the cache)\n        // Execute the module function\n        // Flag the module as loaded\n        // Return the exports of the module\n    }\n\n\n    // expose the modules object (__webpack_modules__)\n    // expose the module cache\n    // Load entry module and return exports\n    return __webpack_require__(0);\n})\n/************************************************************************/\n([\n    // index.js - our application logic\n    /* 0 */\n    function (module, exports, __webpack_require__) {\n        var multiply = __webpack_require__(1);\n        var sum = __webpack_require__(2);\n        var totalMultiply = multiply(5, 3);\n        var totalSum = sum(5, 3);\n        console.log('Product of 5 and 3 = ' + totalMultiply);\n        console.log('Sum of 5 and 3 = ' + totalSum);\n    },\n    // multiply.js\n    /* 1 */\n    function (module, exports, __webpack_require__) {\n        var sum = __webpack_require__(2);\n        var multiply = function (a, b) {\n            var total = 0;\n            for (var i = 0; i < b; i++) {\n                total = sum(a, total);\n            }\n            return total;\n        };\n        module.exports = multiply;\n    },\n    // sum.js\n    /* 2 */\n    function (module, exports) {\n        var sum = function (a, b) {\n            return a + b;\n        };\n        module.exports = sum;\n    }\n]);\n```\n\nWebpack이 각각의 파일들을 모듈로 감싸고 있고 그것들을 모듈의 배열로써 Webpack bootstrap에 넣습니다. 각각의 모듈들은 Webpack에 추가가 되고 이들을 실행하고 다른 모듈에서 사용할 수있게 합니다.\n\n모듈 배열에서 index.js로 보이는 `__webpack_require__(0)`를 실행합니다. 결과는 우리가 처음에 했던 결과이지만 더 쉽게 디펜던시들을 관리할 수 있게 되었습니다.\n\n## Loaders — Making Webpack Smarter\n\nWebpack은 Javascript를 이해합니다. 그리고 모듈을 만들고 Javascript를 번들해서 내놓습니다. 하지만 Javascript 외에 무엇인가를 하기 원하고 또는 ES2015나 ES6로 무엇인가를 작성하기 원한다면 Webpack에게 이것들을 어떻게 진행해야 하는지 말해주어야 합니다.\n\n좀 더 정확하게, 우리는 다른 언어와 버젼들을 Javascript ES5로 전처리를 해야할 필요가 있습니다.\n\n우리는 Typescript의 광팬이지만, 이 예제에서는 예제 코드를 ES2015로 변환합니다. 그리고 Babel을 컨버팅으로 사용합니다.\n\nBabel은 ES2015를 ES5로 트랜스파일링 하는 훌륭한 도구입니다. 하지만 여기서는 다루지 않겠습니다. \n\n처음으로 ES5 코드를 ES2015로 변환해 봅시다.\n\n```javascript\nimport multiply from './multiply';\nimport sum from './sum';\nconst totalMultiply = multiply(5, 3);\nconst totalSum = sum(5, 3);\nconsole.log(`Product of 5 and 3 = ${totalMultiply}`);\nconsole.log(`Sum of 5 and 3 = ${totalSum}`);\n```\n\n```javascript\nimport sum from './sum';\nconst multiply = (a, b) => {\n    let total = 0;\n    for(let i=0;i<b;i++) {\n        total = sum(a, total);\n    }\n    return total;\n};\nexport default multiply;\n```\n\n```javascript\nconst sum = (a, b) => a + b;\nexport default sum;\n```\n\n화살표 함수와 const 키워드, 그리고 템플릿 리터럴, es2015의 import/export 모듈 포멧을 사용했습니다. 이 모든게 ES2015의 특징입니다.\n\nBabel을 사용하기 위해서는 Babel Loader가 필요합니다. Loader는 Webpack에게 어떻게 Javascript 가 아닌 컨텐츠를 처리해야 하는지를 알려줍니다. Loader를 함께 사용하면 Webpack은 다양한 타입의 파일들을 처리할수 있습니다. - CSS, Image, Typescript, ES2015 코드 등등\n\n다음과 같이 3가지의 Babel 디펜던시들을 웹팩에서 사용해야 합니다.\n\n-   `babel-loader`: Babel과 Webpack 사이의 인터페이스\n-   `babel-core`: 어떻게 코드를 읽고 분석할지를 이해하고 관련된 output을 생성해준다.\n-   `babel-preset-es2015`: ES2015를 Babel이 어떻게 처리 할지에 대한 규칙과 그것을 ES5로 변환해준다. \n\nBabel Loader를 사용한 웹팩 구성은 다음과 같습니다.\n\n```javascript\nconst path = require('path');\nmodule.exports = {\n    entry: './src/index.js',\n    output: {\n        path: path.resolve(__dirname, './dist/'),\n        filename: 'bundle.js'\n    },\n    module: {\n        loaders: [\n            {\n                test: /\\.js$/,\n                loader: 'babel-loader',\n                exclude: /node_modules/,\n                query: {\n                    presets: ['es2015']\n                }\n            }\n        ]\n    }\n};\n```\n\n웹팩에는 많은 Loader들이 있기 때문에 값을 배열로 주입해주어야 합니다. - 우리의 경웅에는 하나의 로더만 주입했습니다.\n\n- `test`: 우리는 Loader에게 JavaScript 파일 만 처리하기를 원한다고 알려야합니다. CSS, HTML, 이미지 등을 찾지 않고 JavaScript (.js) 파일 만 찾습니다. 이를 위해 .js 파일과 일치하는 정규식을 제공합니다.\n- `loader`: 사용할 로더 - 이 경우 바벨 로더\n- `exclude`: 우리는 Babel이 node_modules 아래의 파일을 처리하는 것을 원하지 않습니다\n- `query.presets`: 적용하려는 Babel Preset (또는 규칙)-이 경우 ES2015 코드를 변환 할 Babel을 찾고 있습니다.\n\nbundle.js를 다시 보면 ( 여기서는 sum.js만 보겠습니다. ) 다음과 같이 보입니다.\n\n```javascript\n/* 2 */\nfunction(module, exports) {\n    var sum = function sum(a, b) {\n        return a + b;\n    };\n    module.exports = sum;\n}\n```\n\n바벨 로더가 우리 ES2015 코드를 ES5 코드로 변환시켰습니다.\n\n## Making Webpack Look Good — CSS & Styling\n\n실제로 계산 결과를 출력하도록 예제를 확장 해 보겠습니다. \n페이지에서 본문을 만든 다음 제품 및 합계를 spans에 추가하여 본문에 추가합니다.\n\n```javascript\nimport multiply from './multiply';\nimport sum from './sum';\n\nconst totalMultiply = multiply(5, 3);\nconst totalSum = sum(5, 3);\n\n// create the body\nconst body = document.createElement(\"body\");\ndocument.documentElement.appendChild(body);\n\n// calculate the product and add it to a span\nconst multiplyResultsSpan = document.createElement('span');\nmultiplyResultsSpan.appendChild(document.createTextNode(`Product of 5 and 3 = ${totalMultiply}`));\n\n// calculate the sum and add it to a span\nconst sumResultSpan = document.createElement('span');\nsumResultSpan.appendChild(document.createTextNode(`Sum of 5 and 3 = ${totalSum}`));\n\n// add the results to the page\ndocument.body.appendChild(multiplyResultsSpan);\ndocument.body.appendChild(sumResultSpan);\n```\n\n출력은 이전과 동일하지만 페이지에 표시됩니다.\n\n```\nProduct of 5 and 3 = 15 Sum of 5 and 3 = 8\n```\n\nCSS를 사용하여이를 개선 할 수 있습니다. \n각 결과가 새로운 줄에 있는지 확인하고 각 결과 주위에 테두리를 추가하겠습니다.\n\n우리 CSS 는 다음과 같습니다.\n\n```css\nspan {\n    border: 5px solid brown;\n    display: block;\n}\n```\n이 CSS를 우리 어플리케이션으로 가져와야합니다. 물론 html에 링크 태그를 추가 할 수는 있지만, CSS를 import 하고 Webpack을 사용하여 처리하면 Webpack이 제공 할 수있는 혜택을 얻을 수 있습니다.\n\n코드에서 CSS를 가져 오면 얻을 수있는 또 다른 이점은 개발자 (개발자)가 CSS와 그 사용처 사이의 연관성을 확인할 수 있다는 것입니다. CSS는 가져온 모듈에 국한되지 않지만 (전역 적으로) 개발자의 관점에서 보면 관계가 더 명확합니다.\n\n\n```javascript\nimport multiply from './multiply';\nimport sum from './sum';\n\n// import the CSS we want to use here\nimport './math_output.css';\n\nconst totalMultiply = multiply(5, 3);\nconst totalSum = sum(5, 3);\n\n// create the body\nconst body = document.createElement(\"body\");\ndocument.documentElement.appendChild(body);\n\n// calculate the product and add it to a span\nconst multiplyResultsSpan = document.createElement('span');\nmultiplyResultsSpan.appendChild(document.createTextNode(`Product of 5 and 3 = ${totalMultiply}`));\n\n// calculate the sum and add it to a span\nconst sumResultSpan = document.createElement('span');\nsumResultSpan.appendChild(document.createTextNode(`Sum of 5 and 3 = ${totalSum}`));\n\n// add the results to the page\ndocument.body.appendChild(multiplyResultsSpan);\ndocument.body.appendChild(sumResultSpan);\n```\n\n이전과 달라진 것은 이제 CSS를 가져 오는 것입니다.\n\nCSS를 처리하려면 두 개의 로더가 필요합니다 :\n\n- `css-loader` : CSS 가져 오기 처리 방법을 알고 있습니다. 가져온 CSS를 가져 와서 파일 내용을로드합니다.\n- `style-loader` : (가져 오기에서) CSS 데이터를 가져 와서 HTML 문서에 추가합니다\n\n우리의 Webpack 설정은 다음과 같습니다 :\n\n```javascript\nconst path = require('path');\nmodule.exports = {\n    entry: './src/index.js',\n    output: {\n        path: path.resolve(__dirname, './dist/'),\n        filename: 'bundle.js'\n    },\n    module: {\n        loaders: [\n            {\n                test: /\\.js$/,\n                loader: 'babel-loader',\n                exclude: /node_modules/,\n                query: {\n                    presets: ['es2015']\n                }\n            },\n            {\n                test: /\\.css$/,\n                loaders: ['style-loader', 'css-loader']\n            }\n        ]\n    }\n};\n```\n\n- `test`: 이전과 마찬가지로, 로더에게 CSS 파일 만 처리하길 원한다고 알려야합니다.이 정규식은 .css 파일 만 처리합니다.\n- `loaders`: 사용할 로더. 이번에는 로더 배열을 제공 할 때 복수입니다. 또한 Webpack은 **오른쪽에서 왼쪽** 으로 로더를 처리하므로`css-loader` (파일 내용)의 결과는`style-loader` (스타일을 HTML 문서에 추가)로 전달됩니다.\n\n이제 Webpack을 실행하고 응용 프로그램을 다시로드하면 결과는 다음과 같습니다.\n\n![https://miro.medium.com/max/3394/0*vv_pCY61tsoRlnzX.png](https://miro.medium.com/max/3394/0*vv_pCY61tsoRlnzX.png)\n\n코드를 보면 두 로더는 HTML 문서에 스타일을 동적으로 추가했습니다. \nChrome에서 결과 HTML을 검사하면 다음을 볼 수 있습니다.\n\nCSS를 처리하는 다른 방법이 있습니다. 캐시 무효화 (고유 해시 파일)CSS를 파일로 분할 한 다음 이러한 파일을 결과 번들에 포함 할 수 있습니다.\n\n지금은 CSS를 추출하여 가져올 수 있는 파일로 출력 해 봅시다. 이를 위해 Plugin : `ExtractTextPlugin`을 사용합니다.\n\n로더는 번들로 출력되기 전에 데이터를 사전 처리하는 데 사용됩니다. 그러나 플러그인은 번들에 출력으로 나올 것들을 결과물로 내보낼 수 있습니다.\n\n우리의 Webpack 설정은 다음과 같습니다 :\n\n```javascript\nconst path = require('path');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nmodule.exports = {\n    entry: './src/index.js',\n    output: {\n        path: path.resolve(__dirname, './dist/'),\n        filename: 'bundle.js'\n    },\n    module: {\n        loaders: [\n            {\n                test: /\\.js$/,\n                loader: 'babel-loader',\n                exclude: /node_modules/,\n                query: {\n                    presets: ['es2015']\n                }\n            },\n            {\n                test: /\\.css$/,\n                loader: ExtractTextPlugin.extract('css-loader')\n            }\n        ]\n    },\n    plugins: [\n        new ExtractTextPlugin('style.css')\n    ]\n};\n```\n\n`ExtractTextPlugin` 을 최상단에서 import 했습니다. 그리고 CSS loader를 이 플러그인을 사용하도록 바꾸었습니다.\n\n```javascript\n{\n    test: /\\.css$/,\n    loader: ExtractTextPlugin.extract('css-loader')\n}\n```\n\n이것은 Webpack에 css-loader 결과를 ExtractTextPlugin에 전달하라고 말하는 것과 같습니다. 아래는 플러그인 셋팅입니다. \n\n```javascript\nplugins: [\n    new ExtractTextPlugin('style.css')\n]\n```\n\n이것이 하는 일은 플러그인에 전달 된 모든 데이터를 해당 파일에 전달 하는 것입니다. 여기서는 **style.css** 로 불리는 파일이 저장 됩니다.\n지금은 당장 유용해 보이지 않지만 이전이 Javascript 파일이 많아졌던것 처럼 많은 CSS 파일이 있다고 상상해 보십시요. 위와 같이 하면 우리는 분리되어 있는 많은 CSS 파일들을 하나로 만들 수 있고 웹 호출의 횟수와 시간을 절약할 수 있습니다.\n\n **dist/style.css** 에서 다음과 같이 볼 수 있습니다.\n\n```css\n span {\n    border: 5px solid brown;\n    display:block;\n}\n```\n\n이를 사용하려면 다음 CSS를 가져 오기 위해 index.html을 수정해야합니다.\n\n```html\n<html>\n<head>\n    <link rel=\"stylesheet\" href=\"dist/style.css\"/>\n    <script src=\"./dist/bundle.js\"\"></script>\n</head>\n</html>\n```\n\n결과는 아까와 같을 것입니다.\n\n## A Picture Is Worth A Thousand Words\n\n![https://miro.medium.com/max/1800/1*xVUVUNHykoIlyHpPQn-VTw.jpeg](https://miro.medium.com/max/1800/1*xVUVUNHykoIlyHpPQn-VTw.jpeg)\n\n\n우리 어플리케이션에 이미지를 추가 해 봅시다. 그리고 웹팩이 우리를 대신에 그것들을 처리하도록 해봅시다.\n\n여기서 작은거 하나 큰거 하나 2개의 이미지를 사용해봅시다. \n\n이미지를 처리하기 위해선 다음과 같은 2가지의 Loader를 사용합니다:\n\n- `image-webpack-loader`: 큰 이미지를 압축 해줍니다.\n- `url-loader`: `image-webpack-loader`으로 나온 결과가 작다면 인라인으로 크다면 output 디렉토리에 이미지를 포함시킵니다다.\n\n우리는 대략 32kb의 큰 이미지 multiply.png 와 대략 13kb 정도의 작은 sum.png 파일을 추가할 것입니다.\n\n먼저 이미지를 추가하는 유틸 함수를 만듭시다. \n\n```javascript\n// image_util.js\nconst addImageToPage = (imageSrc) => {\n    const image = document.createElement('img');\n    image.src = imageSrc;\n    image.style.height = '100px';\n    image.style.width = '100px';\n    document.body.appendChild(image);\n};\nexport default addImageToPage;\n```\n\n새로운 이미지 유틸리티와 응용 프로그램에 추가 할 이미지를 모두 가져옵니다.\n\n```javascript\nimport multiply from './multiply';\nimport sum from './sum';\n\n// import our image utility\nimport addImageToPage from './image_util';\n\n// import the images we want to use\nimport multiplyImg from '../images/multiply.png';\nimport sumImg from '../images/sum.png';\n\n// import the CSS we want to use here\nimport './math_output.css';\n\nconst totalMultiply = multiply(5, 3);\nconst totalSum = sum(5, 3);\n\n// create the body\nconst body = document.createElement(\"body\");\ndocument.documentElement.appendChild(body);\n\n// calculate the product and add it to a span\nconst multiplyResultsSpan = document.createElement('span');\nmultiplyResultsSpan.appendChild(document.createTextNode(`Product of 5 and 3 = ${totalMultiply}`));\n\n// calculate the sum and add it to a span\nconst sumResultSpan = document.createElement('span');\nsumResultSpan.appendChild(document.createTextNode(`Sum of 5 and 3 = ${totalSum}`));\n\n// add the results to the page\naddImageToPage(multiplyImg);\ndocument.body.appendChild(multiplyResultsSpan);\naddImageToPage(sumImg);\ndocument.body.appendChild(sumResultSpan);\n```\n\n\n마지막으로 두 개의 새로운 로더로 이러한 이미지를 처리하도록 Webpack을 구성 해 보겠습니다.\n\n```javascript\nconst path = require('path');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nmodule.exports = {\n    entry: './src/index.js',\n    output: {\n        path: path.resolve(__dirname, './dist/'),\n        filename: 'bundle.js',\n        publicPath: 'dist/'\n    },\n    module: {\n        loaders: [\n            {\n                test: /\\.js$/,\n                loader: 'babel-loader',\n                exclude: /node_modules/,\n                query: {\n                    presets: ['es2015']\n                }\n            },\n            {\n                test: /\\.css$/,\n                loader: ExtractTextPlugin.extract('css-loader')\n            },\n            {\n                test: /\\.png$/,\n                loaders: [\n                    'url-loader?limit=5000',\n                    'image-webpack-loader'\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new ExtractTextPlugin('style.css')\n    ]\n```\n\n- `output.publicPath` : URL 로더가 디스크에 저장 될 파일에 추가 할 접두사를 알 수 있도록합니다. 예를 들어 위 결과로 img.src는 img.src='dist/output_file.png' 입니다.\n- `test`: 이전과 같이 이미지 파일 만 처리하도록 로더에 알려 주어야합니다.이 정규식은 .png 파일 만 처리합니다. 우리는 다른 이미지 형식에 대한 지원을 추가함으로써 이것을 더욱 복잡하게 만들 수 있습니다.\n- `loaders`: 사용할 로더 - Webpack은 **오른쪽에서 왼쪽**으로 로더를 처리하므로 `image-webpack-loader`의 결과는`url-loader`로 전달됩니다.\n\n만약 웹팩을 동작하면 다음고 같은 것을 볼 수 있을 것입니다.\n\n```\n38ba485a2e2306d9ad96d479e36d2e7b.png\nbundle.js\nstyle.css\n```\n\n만약 우리가 **38ba485a2e2306d9ad96d479e36d2e7b.png** 이 파일을 열면 multiply.png의 큰 이미지를 확인 할 수 있습니다. 작은 sum.js 이미지의 경우에는 bundle.js에 다음과 같이 인라인으로 들어가 있습니다.\n\n```\nmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAMAAAACDyzWAAAC6FBMVEUAuv8AgL....\"\n```\n\n이것은 다음과 같습니다.\n\n```\nimg.src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAMAAAACDyzWAAAC6FBMVEUAuv8AgL...'\n```\n\n어플리케이션을 동작시켜 보면 다음과 같이 나옵니다.\n\n![https://miro.medium.com/max/3398/0*be1gKO7ulqWto3rP.png](https://miro.medium.com/max/3398/0*be1gKO7ulqWto3rP.png)\n\n\n이 Webpack Tutorial에서 Webpack이 응용 프로그램 개발자로 제공 할 수있는 내용을 확인할 수 있습니다. \n상당히 적은 양의 구성으로 ES2015 코드를 처리하고, 번들로 묶고, CSS를 처리하고, 크고 작은 이미지를 모두 이해하기 쉬운 방법으로 처리 할 수 있었습니다.\n\n우리는 이 모든 것을 달성했으며 Webpack 이 할 수있는 일의 아주 작은 부분만 살펴 보았습니다. 코드를 축소 및 축소하고, 코드를 캐시를 안태우는 파일 이름으로 분할하고, TypeScript 및 Angular를 처리 할 수 ​​있습니다. 옵션이 너무 많습니다!","excerpt":"이글을 번역(의역)한 것입니다.  Webpack Tutorial: Understanding How it Works Introduction to Webpack Tutorial Webpack은 모듈 번들러 입니다. 이것은 여러가지 디펜던시들을 받고 그것…","fields":{"slug":"/webpack-understanding/"},"frontmatter":{"date":"Invalid date","title":"webpack-understanding","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# intro\n\n- 웹팩을 알아보고 웹팩 번들링엔 어떤 특징이 있는지 알아보자.\n\n## webpack config ( webpack version 3)\n\n```javascript\n/**\n * merlin webpack test init\n */\nvar webpack = require('webpack');\nconst path = require('path');\n\nmodule.exports = {\n  // 파일을 읽어들이기 시작하는 부분.\n  entry: {\n    app:['./src/a.js','./src/b.js']\n  },\n  output:{\n    path: path.resolve(__dirname, 'dist'), // output으로 나올 파일이 저장될 경로..\n    filename:'[name].js',\n    publicPath:'/' //파일들이 위치할 서버 상의 경로..\n  },\n  \n  module:{\n    rules:[\n      {\n        test:/\\.jsx?$/, // 정규식조건에 부합하는 파일들을 loader에 지정한 로더가 컴파일 해줍니다...\n        loader: 'babel-loader',\n        options:{\n          presets: ['es2015', 'stage-0'],\n        },\n        exclude:['./node_modules']\n      },\n      {\n        test:/\\.css$/,\n        use:['style-loader','css-loader'] // loader로 써도 된다... css-loader로 처리한뒤 그것을 style-loader로 한번 더 처리.\n      }\n    ]\n  },\n  plugins:[\n    new webpack.optimize.UglifyJsPlugin({ // 웹팩 3버젼 이하에선 uglifyjs-webpack-plugin 을 v0.4.6 사용하고 있지만 최신 v1.0.0을 사용하려면 따로 플러그인을 설치해주어야 한다. https://webpack.js.org/plugins/uglifyjs-webpack-plugin/ 참고\n      sourceMap:true,\n      compress:{\n        warnings:true\n      }\n    }),\n    new webpack.DefinePlugin({ // 전역 상수를 생성하고 컴파일 단계에서 치환되어서 해석된다.\n    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),\n    }),\n    new webpack.EnvironmentPlugin(['NODE_ENV']) // 위와 같은 구문이다. definePlugin 의 process.env 설정의 단축으로 사용한다고 보면 된다. 매개변수에 object 도 지원한다. \n  ],\n  resolve:{\n    modules: ['node_modules'],\n    extensions: ['.js', '.json', '.jsx', '.css']\n  }\n};\n```\n\n\n## webpack config ( webpack version 4)\n\n- 기존과 달라졌다고 하는점은 기존에 config 파일에서 exports 를 객체로 넘겼다면 version 4 부턴 함수로 넘길 수 있다.\n- 첫번째 인자는 커맨드 라인에서 `--env` 옵션들이 객체 형태로 전달된다. 두번째 인자는 커맨드 라인에서 전달되는 모든 옵션이 객체 형태로 전달된다.\n- 웹팩 4 에서는 mode가 존재해서 개발환경인 mode 마다 옵션이 달라지고, 최적화도 자동으로 해준다.\n- CommonsChunkPlugin이 deprecated되고 SplitChunksPlugin으로 내장되었으며 optimization.splitChunks라는 옵션이 생겼다.\n- Production 빌드에선 UglifyWebpackPlugin 가 내장되어있다. \n\n```javascript\n// vue-cli 에서 webpack 4에 맞게 수정 ( webpack version 4.25.1 )\n\nvar path = require('path')\nvar webpack = require('webpack')\nconst VueLoaderPlugin = require('vue-loader/lib/plugin')\nconst CleanWebpackPlugin = require('clean-webpack-plugin')\n\nmodule.exports = (env, options) => {\n  const config = {\n    entry: './src/main.js',\n    output: {\n      path: path.resolve(__dirname, './dist'),\n      publicPath: '/dist/',\n      filename: 'build.js'\n    },\n    module: {\n      rules: [\n        {\n          test: /\\.css$/,\n          use: [\n            'vue-style-loader',\n            'css-loader'\n          ],\n        },      {\n          test: /\\.vue$/,\n          loader: 'vue-loader',\n          options: {\n            loaders: {\n            }\n            // other vue-loader options go here\n          }\n        },\n        {\n          test: /\\.js$/,\n          loader: 'babel-loader',\n          exclude: /node_modules/\n        },\n        {\n          test: /\\.(png|jpg|gif|svg)$/,\n          loader: 'file-loader',\n          options: {\n            name: '[name].[ext]?[hash]'\n          }\n        }\n      ]\n    },\n    resolve: {\n      alias: {\n        'vue$': 'vue/dist/vue.esm.js' \n        // import 구문시 vue 라는 명칭이 정확히( 뒤에 $ 붙였을시 ) 맞아 떨어졌을때 해당 url 이용\n        // import vue from 'vue' => import vue from 'node_modules/vue/dist/vue.esm.js\n      },\n      extensions: ['*', '.js', '.vue', '.json']\n      // 자동으로 확장자를 설정해준다.\n    },\n    performance: {\n      hints: false\n    },\n    plugins: [\n      new VueLoaderPlugin()\n    ]\n  }\n\n  if (options.mode === 'production') {\n    config.devtool = '#source-map'\n    // http://vue-loader.vuejs.org/en/workflow/production.html\n    config.plugins = (config.plugins || []).concat([\n      new webpack.DefinePlugin({\n        'process.env': {\n          NODE_ENV: '\"production\"'\n        }\n      }),\n      new CleanWebpackPlugin(['dist'])\n    ])\n  } else if (options.mode === 'development') {\n    config.devtool = '#eval-source-map'\n    config.devServer = {\n      historyApiFallback: true, // 404 에러시 index.html 페이지로 돌아가준다. boolean 값 말고도 object 형식으로 넘겨도 된다.\n      noInfo: true,\n      overlay: true,\n      host: '0.0.0.0',\n      disableHostCheck: true,\n    }\n  }\n  \n\n  return config\n}\n\n```\n\n```javascript\n// package.json\n{\n  \"scripts\": {\n    \"build-dev\": \"webpack --mode development\",\n    \"build-prod\": \"webpack --mode production --progress --profile --hide-module\", \n    // --hide-modeuls : Hides info about modules\n    // --progress : Print compilation progress in percentage\n    // --progress 와 함께 --profile 을 함께 쓰면 어떤 뎁스에서 컴파일이 얼마나 걸렸는지 알수 있다.\n    \"dev-server\": \"webpack-dev-server --open --mode development\"\n  }\n}\n\n \n```\n\n\n\n\n## webpack concept\n\n### Modules\n\n- [modular programming](https://en.wikipedia.org/wiki/Modular_programming) 에 따르면 개발자들은 프로그램을 모듈이라고 불리우는 기능성들을 분리해서 프로그램을 만든다.\n\n- 각각의 모듈들은 전체 프로그램에서 아주 작은 파트를 담당하며 코드확인, 디버깅 , 테스팅에 용이하다.\n잘짜여진 모듈들은 solid abstraction 과 캡슐화가 잘되어있고 그로인해 모듈은 전체 어플리케이션 안에서 긴밀한 디자인을 가지고 명료한 목적을 띄고 있다.\n\n### resolve\n\n- resolve 옵션은 모듈들이 어떻게 해석될지를 변경하는 옵션이다. 웹팩은 합리적인 디폴트값을 지니고 있지만 그것은 변경이 가능하다.\n웹팩에는 resolver라는 라이브러리가 있는데 이것은 모듈의 위치를 잡아주는데 도움을 준다. 모듈들은 require 문이나 import문으로 다른 모듈들을 불러올수 있다\n\n```javascript\n// 모듈들 내부에서 \nimport foo from 'path/to/module'\n// or\nrequire('path/to/module')\n```\n\n- 이때 resolver가 웹펙에 해당 모듈의 코드 위치를 매번 번들할때마다 찾아주게 된다.\n웹팩은 [enhanced-resolve](https://github.com/webpack/enhanced-resolve) 를 사용해서 모듈을 번들링하는 동안 파일 경로의 문제를 해결해준다.\n\n### Entry\n\n- entry point 지시자는 webpack이 entry point의 내부 의존성을 파악하고 번들링의 시작점이 된다. 이 시작점을 들어간 후에 웹팩은 의존성이 있는 다른 모듈들과 라이브러리들을 인지하게 된다.\n\n- 모든 의존성은 프로세스를 거친후에 번들이라는 불리우는 파일로 내 뱉어지게 된다. \nwebpack config에서 entry라는 속성으로 설정을 할 수 있다.\n\n```javascript\nmodule.exports = {\n    entry : './path/to/my/entry/file.js'\n}\n```\n\n### Output\n\n- output 속성은 웹펙이 번들을 내 뱉어지는 장소를 가리킨다. \n- output 필드 안에 구체적인 옵션들을 설정 할 수 있다.\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n    entry : './path/to/my/entry/file.js',\n    output : {\n        path : path.resolve(__dirname,'dist'),\n        filename : 'my-first-webpack.bundle.js'\n    }\n}\n```\n\n- 여기서 path.resolve 는 해당 참조.\n[https://nodejs.org/docs/latest/api/path.html#path_path_resolve_paths](https://nodejs.org/docs/latest/api/path.html#path_path_resolve_paths)\n\n- 여기서 output.path 와 output.filename 은 웹팩에게 번들의 이름과 번들이 어디에 방출될 것인지를 설정하는 부분이다.\n\n\n### Loaders\n\n- Loader는 웹팩이 자바스크립트 파일 뿐만 아니라 더 많은것들을 진행 할 수 있게 만들어 줍니다. \n- 웹팩 로더는 app에 걸려있는 dependency를 포함해 모든 타입의 파일들을 모듈로 변화시킵니다.\n- 로더는 test 프로퍼티와 use 프로퍼티를 지닙니다.\n- test 프로퍼티는 어떤 파일 또는 파일들을 변화시킬것인지를 use 프로퍼티는 어떤 로더를 이용해서 변화시킬건지를 설정하는 부분입니다.\n\n```javascript\nconst path = require('path');\n\nconst config = {\n  entry: './path/to/my/entry/file.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'my-first-webpack.bundle.js'\n  },\n  module: {\n    rules: [\n      { test: /\\.txt$/, use: 'raw-loader' }\n    ]\n  }\n};\n\nmodule.exports = config;\n\n```\n\n- 위에서 rules 프로퍼티는 2가지 이상의 프로퍼티들을 가질 때 사용합니다. \n- 이것은 웹팩에게 이렇게 말하는것과 같은 원리 입니다.\n\n> \"웹팩 컴파일러야 경로를 돌아다니면서 .txt파일을 만나거든 raw-loader를 사용해서 변화 시켜줘라 번들되기 전에~\"\n\n\n\n### Plugins\n\n- loader는 확실한 타입만 변화시켜주는 반면 플러그인은 더 넓은 일에 효력을 발휘 할 수 있다. 플러그인의 영향력은 번들 최적화 및 축소 부터 환경과 유사한 변수 정의까지 다양합니다. 따라서 다양한 업무를 해결하는데 사용할 수 있습니다.\n\n- 플러그인을 사용하려면 require()를 추가해야합니다. 여러 목적으로 여러번 사용할 수 있기에 new 를 사용해서 인스턴스를 생성해주어야 합니다.\n\n```javascript\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm\nconst webpack = require('webpack'); //to access built-in plugins\nconst path = require('path');\n\nconst config = {\n  entry: './path/to/my/entry/file.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'my-first-webpack.bundle.js'\n  },\n  module: {\n    rules: [\n      { test: /\\.txt$/, use: 'raw-loader' }\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: './src/index.html'})\n  ]\n};\n\nmodule.exports = config;\n```\n\n\n\n\n\n\n## 번들된 녀석을 파해쳐 보자\n\n기본적으로 즉시 실행 함수를 사용하고 있다. (function(){})();\nfunction 안에는 초기화, 모듈 캐시 및 공개멤버 설정, 모듈의 실행을 하는 함수의 정의\n인자로는 각 모듈들을 배열에 담아 전달한다.\n\n간단하게 아래와 같은 파일 구조를 지니고 있다고 가정하자.\n\n```javascript\n// a.js\nimport b from './b';\nimport {c,wtf} from './c';\n\nconsole.log('a');\n\nb();\nc();\n\nconsole.log(wtf);\n\n// b.js\nexport default function(){console.log('b');}\n\n// c.js\nexport function c(){\n    console.log('c');\n}\nconst wtf = 'wtf';\nexport {wtf};\n\n```\n\nwebpack은 어떤 모양으로 번들링을 만들까???\n\n`참고 : 아래 번들링 모양은 웹팩 3 버젼을 기준으로 합니다.`\n\n전체 프레임은 아래와 같다.\n\n```javascript\n(function(){\n  // The module cache\n  // installedModules가 있는 이유는 여러 파일에서 한 파일을 import 할시 계속 등록하는게 아니라 캐쉬처리해서 \n  // 속도에 이점을 두기 위함이다.\n  var installedModules = {};\n\n  //... 생략\n\n  // Load entry module and return exports\n  // 0번째 실행 인자로 넘어오는 배열의 0 번째 인덱스 함수를 실행한다.\n  return __webpack_require__(__webpack_require__.s = 0);\n})(\n  // 배열 ( 각 인덱스에 각 파일의 코드들이 들어가있음.)\n)\n```\n\n\n#### 1. 각각의 모듈을 배열에 담아 인자로 넘긴다.\n\n참고로 아래 문법은 바벨로 돌렸을때 나오는 문법이다.\n웹팩 2 부턴 바벨 없이도 import / export를 지원한다.\n\n아래 코드는 (function(modules){A})(B) 이런 전체 구조에서 B에 들어가는 배열이다.\nmodules에는 B의 배열이 들어간다.\n\n```javascript\n// modules가 되는 배열\n[\n    // 0 번째 ( 시작점 )\n    (function(module, exports, __webpack_require__) {\n        // 해당 모듈을 installedModules에 등록 후\n        // 이 배열의 인덱스 1번째 코드를 실행한다. \n        module.exports = __webpack_require__(1);\n\n    }),\n    \n    // 1 번째 \n    (function(module, exports, __webpack_require__) {\n\n        \"use strict\";\n        \n        // import b from './b';\n        // 위 문장은 babel이 아래와 같이 변형한다.\n        // var _b = require('./b');\n        // var _b2 = _interopRequireDefault(_b);\n        // function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n        // export 하면 babel은 아래와 같은 object에 __esModule 프로퍼티를 생성한다.\n        // Object.defineProperty(exports, \"__esModule\", {\n        //    value: true\n        // });\n\n\n        // 0번째 꺼 등록후 해당 코드를 실행 하면 이 모듈도 cache 용 installModules 객체에 등록이 되고\n        // 그후 인스톨된 모듈안에 exports를 리턴.. 이것은 곧 b.js 안에 있는 export 된 아이를 가져오는 것.\n\n        // import b from './b' 문은 \n        // var _b2 = _interopRequireDefault(_b); 구문을 실행시키지만\n\n        // import {c,wtf} from './c'; 문은\n        // _interopRequireDefault 이 함수를 실행하지 않는다.\n\n        // 여기서 _b는 새로운 객체가 튀어나온다.\n        // { default: function(){console.log('b')} }\n\n        // 왜 _b만 _interopRequireDefault 함수를 태우는가???\n        // import b from './b' 를 사용한다는 것은 export의 default 프로퍼티 값만 b로 받아온다는 의미가 된다.\n        // b 파일이 만약 Common JS 모듈을 사용했다면 module.exports = function a() {}; 이렇게 exports 시켰을것이다.\n        // Common JS 모듈은 최종적으로 리턴하는 것은 module.exports 다. ( 함수든 , 객체든 )\n        // 이때 var _b = require('./b'); 이렇게 만으로 불러온다면 _b는 exports 함수가 될것인데 \n        // 그럴땐 _interopRequireDefault를 태워서 { default: exports(함수) } 로 변환해서 실행시켜준다.\n\n        // 즉, ES6 와 Common JS 모듈의 간극(default 유무)을 맞춰주기 위해 _interopRequireDefault 가 존재한다.\n\n        var _b = __webpack_require__(2); // var _b = require('./b');\n        var _b2 = _interopRequireDefault(_b);\n        var _c = __webpack_require__(3);\n\n         \n        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n        console.log('a');\n\n        (0, _b2.default)();\n\n        (0, _c.c)();\n\n        console.log(_c.wtf);\n        \n    }),\n    // 2번째\n    (function(module, exports, __webpack_require__) {\n        \n        // 아래 문장은 바벨이 기본적으로 export default function(){ console.log('b')} 문장을 만났을때 해석하는 문장..\n        // exports에 default 프로퍼티를 만든다.\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n\n        // 이 부분은 installedModules 의 exports 에 설정되고 exports는 리턴 된다.\n        exports.default = function () {\n        console.log('b');\n        };\n\n      }),\n    // 3번째\n      (function(module, exports, __webpack_require__) {\n\n        \"use strict\";\n\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        exports.c = c;\n        function c() {\n            console.log('c');\n        }\n        var wtf = 'wtf';\n        exports.wtf = wtf;\n\n    })\n]\n\n```\n\n아래 코드는 **_interopRequireDefault** 이 함수에 대한 필요성을 설명한 코드이다.\n\n```javascript\n// Common JS file : a.js\n// 참고로 a.js는 바벨이 변환을 안한다.\nmodule.exports = {};\n\nmodule.exports.aaa = function(){}\nmodule.exports.bbb = function(){}\n\n// 라고 있었을때.. ES6에선\n\nimport {aaa, bbb} from 'a.js' \n\n// 라고 해야한다. 그래야 바벨이 아래처럼 변환.\nvar _a = require('a.js');\n_a.aaa()\n_a.bbb() \n\n// 만약 아래처럼 호출한다면 babel은 \nimport a from 'a.js'; // exports 의 default 값을 a에 넣겠다 라는 의미.\na.aaa()\n\n// 이렇게 변환.\n\nvar _a = require('a.js'); // _a는 exports 다. \nvar _a2 = _interopRequireDefault(_a);\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// a.js 파일에서 default로 export 하지 않았을 경우 혹시 모르는 상황을 대비.\n// 를 실행시켜서 \n// return { default: _a } 로 변환\n\n_a2.default.aaa();\n\n```\n\n참고로 바벨 없이도 웹팩에서 import / export 를 해석 해준다.\n\n공부 겸 봐두자.\n\n아래 코드는 바벨 없이 웹팩만 돌렸을 때 나오는 코드 스타일 이다.\n\n```javascript\n[\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__b__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__c__ = __webpack_require__(3);\n/**\n * Created by merlin.ho on 2017. 5. 31..\n */\n\nconsole.log('a');\n\nObject(__WEBPACK_IMPORTED_MODULE_0__b__[\"a\" /* default */])();\n\nObject(__WEBPACK_IMPORTED_MODULE_1__c__[\"a\" /* c */])();\n\nconsole.log(__WEBPACK_IMPORTED_MODULE_1__c__[\"b\" /* wtf */]);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Created by merlin.ho on 2017. 5. 31..\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = (function(){console.log('b');});\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = c;\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return wtf; });\nfunction c(){\n    console.log('c');\n}\nconst wtf = 'wtf';\n\n/***/ })\n]\n```\n\n\n#### 2. 배열에 담긴 모듈들을 modules로 웹팩이 만든 함수에 넘긴다.\n\n```javascript\n(\n    function(modules){ // 그 배열을 modules로 받는다.\n        var installedModules = {}; // 모듈 캐싱처리를 위한 곳\n        ...\n    }\n)([\n    //위에서 만든 모듈들을 모아논 배열\n])\n```\n\n#### 3. 웹팩이 만든 함수안에는 웹팩용 \\_\\_webpack\\_require\\_\\_ 함수를 만든다. \n\n이 함수는 모듈 아이디를 받는다. 해당 함수는 모듈 아이디를 받아서 등록된 모듈을 실행시킨다.\n\n```javascript\nfunction __webpack_require__(moduleId){\n    ...\n}\n```\n\n#### 4. 기존에 캐싱되어있던 모듈이 있다면 그 모듈의 exports 를 return 시킨다.\n\n```javascript\nif(installedModules[moduleId]) {\n\treturn installedModules[moduleId].exports;\n}\n```\n\n#### 5. 캐싱된 모듈이 없다면 새로운 모듈을 만들고 cache 안에 집어 넣는다.\n\n```javascript\nvar module = installedModules[moduleId] = {\n\ti: moduleId,\n\tl: false,\n\texports: {}\n};\n```\n\n#### 6. 만들어진 모듈을 실행 시킨다. call 사용\n\n```javascript\nmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n```\n\n#### 7. 호출이 다 이뤄졌다면 l 플래그를 true로 설정\n\n```javascript\n// Flag the module as loaded\nmodule.l = true;\n```\n\n#### 8. 마지막으로 해당 모듈의 exports를 리턴시킨다.\n\n```javascript\n// Return the exports of the module\nreturn module.exports;\n```\n\n   \n이 __webpack_require__ 함수도 객체이기에 여러 프로퍼티가 존재한다.\n\n```javascript\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = modules;\n\n// expose the module cache\n__webpack_require__.c = installedModules;\n\n// identity function for calling harmony imports with the correct context\n__webpack_require__.i = function(value) { return value; };\n\n// define getter function for harmony exports\n// exports에 {name} 프로퍼티가 없으면 해당 {name} 으로 프로퍼티를 설정 get 설정은 해당 프로퍼티를 호출 했을때 getter 함수를 호출해서 나온 리턴값으로 얻게된다. \n// 접근자 프로퍼티 셋팅\n__webpack_require__.d = function(exports, name, getter) {\n    if(!__webpack_require__.o(exports, name)) {\n        Object.defineProperty(exports, name, {\n            configurable: false, // 프로퍼티가 delete 통해 삭제를 할수없고 속성을 바꿀수 없다.\n            enumerable: true, // for-in 루프에서 해당 프로퍼티를 반환할수 있다.\n            get: getter // 접근자 프로퍼티는 getter와 setting 함수로 구성된다.\n        });\n    }\n};\n\n// getDefaultExport function for compatibility with non-harmony modules\n// 모듈을 받아서 getter 함수를 설정하고 getter 함수에 a 프로퍼티를 설정한다.\n// 모듈이 installed가 되었다면 getDefault 아니면 getMouduleExports 를 getter로 셋팅 후 'a' 프로퍼티를 생성하고 반환..\n// getDefault.a 은 module['default'] 반환\n// getMouduleExports.a 은 module 반환\n__webpack_require__.n = function(module) {\n    var getter = module && module.__esModule ?\n        function getDefault() { return module['default']; } :\n        function getModuleExports() { return module; };\n    __webpack_require__.d(getter, 'a', getter);\n    return getter;\n};\n\n// Object.prototype.hasOwnProperty.call\n__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n// __webpack_public_path__\n__webpack_require__.p = \"\";\n\n// Load entry module and return exports\n// 실행 , 2 번째 모듈이 가지고 있는 module의 exports를 리턴\nreturn __webpack_require__(__webpack_require__.s = 2);\n```\n\n\n## 전체 코드\n\n```javascript\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__b__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__c__ = __webpack_require__(3);\n/**\n * Created by merlin.ho on 2017. 5. 31..\n */\n\n\n\n\n\nconsole.log('a');\n\nObject(__WEBPACK_IMPORTED_MODULE_0__b__[\"a\" /* default */])();\n\nObject(__WEBPACK_IMPORTED_MODULE_1__c__[\"a\" /* c */])();\n\nconsole.log(__WEBPACK_IMPORTED_MODULE_1__c__[\"b\" /* wtf */]);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Created by merlin.ho on 2017. 5. 31..\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = (function(){console.log('b');});\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = c;\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return wtf; });\nfunction c(){\n    console.log('c');\n}\nconst wtf = 'wtf';\n\n\n\n/***/ })\n/******/ ]); \n```","excerpt":"intro 웹팩을 알아보고 웹팩 번들링엔 어떤 특징이 있는지 알아보자. webpack config ( webpack version 3) webpack config ( webpack version 4) 기존과 달라졌다고 하는점은 기존에 config 파…","fields":{"slug":"/hello-webpack.md/"},"frontmatter":{"date":"Feb 01, 2018","title":"Hello webpack","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## intro React\n\n리엑트를 처음 마주해보자.\n해당 정리 내용의 출처는 \n[https://www.youtube.com/watch?v=GEoNiUcVwjE&list=PL9FpF_z-xR_GMujql3S_XGV2SpdfDBkeC](https://www.youtube.com/watch?v=GEoNiUcVwjE&list=PL9FpF_z-xR_GMujql3S_XGV2SpdfDBkeC)\n\n이곳을 참조 하였다.\n\nBabel : es6 작성된 코드를 이전 버젼인 es5로 변환하기 위한 도구 \n여러가지 브라우저를 호환하기 위해 es5로 변환\n\n15버전 이상에서 \n\nreact.min.js : 컴포넌트 담당\n\nreact-dom.min.js : dom에 랜더링 담당\n\n컴포넌트는 자바스크립트 클래스 이다.\n리엑트 컴포넌트 클래스를 상속한다.\n\n```javascript\nclass Coldelab extends React.Component{\n    render(){\n        let text = \"Hi i am coldelab\";\n        let style = {\n            baackgroundColor:'aqua'       \n        };\n        return(\n            // <div>Codelab</div>\n            <div style={style}>{text}</div>\n        )\n    }\n}\n// 다른 컴포넌트에서 다시 사용할 수 있다.\nclass App extends React.Component{\n    render(){\n        return (\n            <Codelab/>\n        )\n    }\n}\n\n// 페이지에 랜더링\n// 실제 페이지에 jsx코드를 랜더링할때 사용합니다.\nReactDom.render(<App/>,document.getElementById(\"root\"));\n```\n\n### React element\n\n- `react element`는 컴포넌트 인스턴스 또는 돔 노드를 설명해주고 그것이 원하는 프로퍼티를 설명하는 객체이다. \n- 이 객체 안에는 오직 컴포넌트의 타입(<button>), 프로퍼티(color), 그리고 그 안에 들어있는 child node들의 정보이다. \n- element는 실제 인스턴스가 아닙니다. 오히려, React에게 화면에보고 싶은 것을 알려주는 방법입니다.\n- element의 어떤 method도 호출할 수 없습니다. 이것은 단지 immutable 한 2개의 필드(type: (string | Component) and props: Object.)를 가진 object 설명서입니다.\n\n```javascript\nconst Button = {\n  type: 'button',\n  props: {\n    className: 'button button-blue',\n    children: {\n      type: 'b',\n      children: 'OK!'\n    }\n  }\n}\n```\n\n- component를 설명하는 element 또한 element 이다. 단지 element는 DOM node를 설명하는 것이다. 그것들은 다른것들과 중첩될 수 있다. \n\n```javascript\nconst DeleteAccount = () => ({\n  type: 'div',\n  props: {\n    children: [{\n      type: 'p',\n      props: {\n        children: 'Are you sure?'\n      }\n    }, {\n      type: DangerButton,\n      props: {\n        children: 'Yep'\n      }\n    }, {\n      type: Button,\n      props: {\n        color: 'blue',\n        children: 'Cancel'\n      }\n   }]\n});\n```\n\n- React는 element type에 class나 함수가 오면 주어진 props와 함께 어떤 element를 render 그려야 할지 물어본다.\n- element는 plain object이다. 이 object는 DOM 노드들 또는 다른 컴포넌트들의 관점에서 화면에 표시할 내용을 설명하는 일반 객체이다. Element 들은 다른 element들을 props안에 포함할 수 있다.\n\n### React component\n\n- React component는 props를 input 으로 받아서 element tree를 output으로 방출하는 것이다. 이게 component이다! \n- 이렇게 반환 된 요소 트리에는 DOM 노드를 설명하는 요소와 다른 구성 요소를 설명하는 요소가 모두 포함될 수 있습니다. 이렇게하면 내부 DOM 구조에 의존하지 않고도 UI의 독립적 인 부분을 작성할 수 있습니다.\n- component는 class로도 정의 될 수 있다. 함수 컴포넌트보다 조금더 파워풀 하다. \n- 함수나 클래스나 모든 컴포넌트는 React 이라는 것이다. 컴포넌트들은 props를 받고 element 를 반환한다는 것이다.\n\n\n```javascript\n// React: You told me this...\n// 여기서 From 이 component 라고 한다면 아래 props를 input으로 받아서 새로운 element를 output으로 내놓을 것이다.\n{\n  type: Form,\n  props: {\n    isSubmitted: false,\n    buttonText: 'OK!'\n  }\n}\n// React: ...And Form told me this...\n{\n  type: Button,\n  props: {\n    children: 'OK!',\n    color: 'blue'\n  }\n}\n// React: ...and Button told me this! I guess I'm done.\n{\n  type: 'button',\n  props: {\n    className: 'button button-blue',\n    children: {\n      type: 'b',\n      props: {\n        children: 'OK!'\n      }\n    }\n  }\n}\n```\n\n- 위 수행으로 React가 최종 DOM tree를 안다. 그리곤 ReactDOM 이나 React Native 같은 rederer로 update가 필요한 부분에 실제 DOM 노드를 최소한으로 적용시킨다.\n- component는 2가지로 표현할 수 있다. render() 메서드를 지닌 React.Component를 상속받은 class가 하나고, function 이 또다른 하나다. 이 두가지 케이스는 props를 input으로 받고 return으로는 element 트리를 리턴한다.\n- component가 몇몇 props를 input으로 받는다는 것은 부모 component가 그것의 타입과 그들의 prop를 리턴했기 때문이다. \n- instance는 작성한 컴포넌트 클래스에서 this 참조하는 인스턴스입니다. 로컬 상태를 저장하고 수명주기 이벤트에 반응하는 데 유용합니다.\n- Function component들은 intstaces를 전혀 가지지 못합니다. Class 컴포넌트들은 instances 들을 가진다. 이 instance는 사용자가 직접적으로 만들 필요는 없다. \n- element를 만들기 위해서는 React.createElement(), JSX, 또는 element factory helper 함수를 이용할 수 있다.\n\n### jsx\n\nxml같은 문법을 네이티브 자바스크립트로 변환을 해줍니다. 괄호는 가독성을 위해 사용\n바벨이 jsx로더를 사용해서 jsx 형태코드를 변환해준다. \n\n```jsx\n\n// jsx\nvar a = (\n    <div>\n        Welcome to <b>React CodeLab</b>\n    </div>\n)\n```\n\n\n```javascript\n\n// javascript\nvar a = React.createElement(\n    \"div\",\n    null,\n    \"Welcome to\",\n    React.createElement(\n        \"b,\n        null,\n        \"React.js CodeLab\"\n    )\n)\n```\n\n모든 jsx 형태의 코드는 컨테이너 엘리먼트 안에 포함시켜 주어야 한다.\njsx안에서 javascript 를 표현할때는 {} 로 wrapping을 하면 된다.\nif Else 문은 jsx에서 사용 불가 이에 대한 대안은 tenary expression 을 사용한다.\n\n```javascript\n    condition? true : false // {1==1? 'true':'false'}\n```\n\njsx안에 스타일을 선언할때 카멜케이스를 사용한다. ex) backgroundColor\njsx 안에서 class를 설정할때는 'class=' 가 아닌 className을 사용한다.\n\njsx 에서 주석을 작성할 때는 { /* ... */ } 로 표현한다.\n\n\n\n\n### props\n\n컴포넌트 내부의 immutable Data 를 처리할 때 사용한다.\njsx 내부에 {this.props.propsName} 라고 설정하고\n위에서 설정한 컴포넌트를 사용할때 propsName=\"value\" 라고 사용한다.\nthis.props.childrens은 기본적으로 가지고 있는 props로 \n<Cpnt> 여기에 있는 값이 들어갑니다. <Cpnt>\n\n```javascript\nclass Coldelab extends React.Component{\n    render(){\n       return(\n           <div>\n                <h1>Hello {this.props.name}</h1>\n                <div>{this.props.children}</div>\n           </div>\n        )\n    }\n}\n// 다른 컴포넌트에서 다시 사용할 수 있다.\nclass App extends React.Component{\n    render(){\n        return (\n            <Codelab name=\"merlin\">이 사이에 있는거</Codelab> // \"이 사이에 있는거\" 가 위의 children에 나타납니다.\n        )\n    }\n}\n\n```\n\nprops에 기본 값을 설정 할 수 있다.\nprops에 특정 타입이 아니거나 입력을 안했을때 개발자 콘솔에 뜨게 할 수 있다.\n참고 : js 넣을때 minifyed 버젼은 에러가 뜨지 않는다.\n\n```javascript\nclass App extends React.Component{\n    render(){\n        return (\n            <Codelab name=\"merlin\">이 사이에 있는거</Codelab> // \"이 사이에 있는거\" 가 위의 children에 나타납니다.\n        )\n    }\n}\n\nApp.defaultProps = {\n    value:0\n}\n\nApp.propTypes = {\n    value:React.PropTypes.string,\n    secondValue:React.PropTypes.number,\n    thirdValue:React.PropTypes.any.isRequired // 어떤 타입이든 필수로 입력이 되도록\n}\n```\n\n### state\n\n컴포넌트에서 유동적인 데이터를 보여줄 때 사용합니다.\n초기값 설정이 필수다.\n초기값은 constructor에서 this.state={} 로 설정\n값을 수정할때는 this.setState({...}), 렌더링 된 다음엔 this.state= 절대 사용하지 말것.\n\n렌더링이 되기 전에는 setState 메소드를 사용하지 못한다.즉, construct에서 사용 못함.\n\n렌더링이 된 후에는 this.state= 로 수정하면 안된다. \nsetState 메소드를 사용 state를 바로 수정하는게 아니라 리엑트 개발자가 지정한 안정된 프로세스를 거쳐 값이 변경된다.\n값이 변경된 다음에는 자동으로 리 랜더링 합니다.\n\n스테이트를 바로 수정하는게 아니라 리엑트 개발자가 지정한 안정된 프로세스로 통하여 값이 변경된다.\n값이 변경된 다음에는 랜더링이 다시 진행된다.\n\n```javascript\n\nclass Counter extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {\n      value:0\n    };\n    \n    this.handleClick = this.handleClick.bind(this);\n  }\n  \n  handleClick(){\n    this.setState({\n      value:this.state.value + 1\n    });\n  }\n  \n  \n  \n  render(){\n    return (\n      <div>\n        <h2>{this.state.value}</h2>\n        <button onClick={this.handleClick}>Press me</button>\n      </div>\n    )\n  }\n}\n\nclass App extends React.Component {\n  render() {\n    return (\n      <Counter />\n    );\n  }\n};\n\nReactDOM.render(\n  <App></App>,\n  document.getElementById(\"root\")\n);\n\n\n```\n\n### 컴포넌트 맵핑 \n\n데이터 배열을 리엑트에서 렌더링 할때 javascript 내장 함수인 map을 사용한다.\n\n```javascript\nclass ContactInfo extends React.Component{\n  render(){\n    return (\n      <div>{this.props.contact.name} {this.props.contact.phone}</div>\n    )\n  }\n}\n\nclass Contact extends React.Component{\n\n  constructor(props){\n    super(props);\n    this.state = {\n      contactData:[\n        {name:'Abet',phone:\"010-0000-0001\"},\n        {name:'Bbet',phone:\"010-0000-0002\"},\n        {name:'Cbet',phone:\"010-0000-0003\"},\n        {name:'Dbet',phone:\"010-0000-0004\"},\n      ]\n    }\n  }\n  \n  render(){\n    \n    const mapToComponent = (data) => {\n       return data.map((contact,i) => {\n         return (<ContactInfo contact={contact} key={i} />) // 각 데이터에 identity를 주기 위해서.\n       })\n    };\n    \n    return (\n      <div>\n         {mapToComponent(this.state.contactData)} \n      </div>\n    )\n  }\n}\n\nclass App extends React.Component {\n  render() {\n    return (\n        <Contact />\n    );\n  }\n};\n\nReactDOM.render(\n  <App></App>,\n  document.getElementById(\"root\")\n);\n```\n\n### 위 맵핑의 문제점\n\n- 리액트 컴포넌트를 loop를 돌면서 생성을 할때 key 값을 지정할 수 있다. 여기서 key 값에 list의 index를 전달 해주었는데 이는 안티패턴이다. <br />\n이유는 key 값은 각 요소를 구별할수 있는 장치 이다, 새로운 item을 추가/삭제/정렬시에 리액트는 새롭게 변화된 컴포넌트들을 랜더링하게 된는데, 이 때 이전에 가지고 있던 key 값들을 가져와 비교를 하면서 다시 랜더링하는 것을 막아주고 상태를 유지하게 된다. 하지만 여기서 배열의 인덱스 값으로 key를 설정하게 될경우를 생각해보자. <br />\n부모 컴포넌트가 배열의길이가 10개인 아이템들을 가지고 10개의 컴포넌트를 랜더링 한다고 했을 때, 5번째 아이템을 삭제한다고 가정하자. 다시 부모 컴포넌트는 9개의 아이템을 가지고 9개의 컴포넌트를 렌더링 할것이다. 이때, 리엑트는 key 값인 배열의 인덱스를 살펴볼 것이고 5번째의 아이템이 사라졌다는 생각대신 10번째 아이템이 없어졌다고 인식할 수 있다. <br />\n\n따라서 각 child item 들에 유니크한 값으로 id를 셋팅 후에 이 id 값을 key 값으로 설정해주는 것이 좋다.\n\n### 번외_1 eslint를 함께 사용해보자.\n\n- airbnb의 eslint를 사용해 보자.\n\nIDE: vsCode ( eslint plugin )\n\n1. eslint , babel-eslint 를 설치 \n\n```sh\n$ npm i -g eslint // eslint 명령어를 사용하기 위해..\n$ npm i -D eslint babel-eslint babel-preset-airbnb\n```\n\nbabel-preset-airbnb : airbnb 의 javascript 스타일로 transform 해준다.\nbabel-eslint : eslint 의 parser를 babel-eslint로 사용. 이것은 Babel code를 lint에서 유효하게 만들어 준다.\n\n\n2. eslint 의 configuration file 을 만들기 위해 아래 명령어를 활용한다.\n```sh\n$ eslint --init \n```\n\n3. 선택지가 몇개 나오는데 그중 \"Use a popular style guide\" 에서 \"airbnb\" 선택\n4. react 사용하냐 응답에 yes~\n5. javascript 선택\n\n6. .eslintrc.js 파일이 생성됨.\n7. .eslintrc.js 파일 수정\n\n```javascript\nmodule.exports = {\n    \"parser\": \"babel-eslint\",\n    \"env\": {\n        \"browser\": true,\n        \"node\": true\n    },\n    \"extends\": \"airbnb\",\n    \"rules\": {\n        \"strict\": 0,\n        \"react/jsx-filename-extension\": 0,\n        \"react/no-array-index-key\": 0\n\n    }\n};\n```\n**참고로 airbnb eslint는 state 가 없으면 pure function 으로 작성하게 되어있다.**\n\n관련 자료 : [https://groundberry.github.io/development/2017/06/11/create-react-app-linting-all-the-things.html](https://groundberry.github.io/development/2017/06/11/create-react-app-linting-all-the-things.html)\n\n우선 여기까지만 하면 기본적인 설정은 끝.. 나머지는 차차 하면서~\n\n```javascript\n// package.json \n{\n  \"name\": \"reactTest\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"webpack.config.js\",\n  \"dependencies\": {\n    \"react\": \"^16.2.0\",\n    \"react-dom\": \"^16.2.0\"\n  },\n  \"devDependencies\": {\n    \"babel-core\": \"^6.26.0\",\n    \"babel-eslint\": \"^8.2.1\",\n    \"babel-preset-airbnb\": \"^2.4.0\",\n    \"babel-preset-es2015\": \"^6.24.1\",\n    \"babel-preset-react\": \"^6.24.1\",\n    \"bable-loader\": \"0.0.1-security\",\n    \"eslint\": \"^4.18.0\",\n    \"eslint-config-airbnb\": \"^16.1.0\",\n    \"eslint-plugin-import\": \"^2.8.0\",\n    \"eslint-plugin-jsx-a11y\": \"^6.0.3\",\n    \"eslint-plugin-react\": \"^7.6.1\",\n    \"react-hot-loader\": \"^3.1.3\",\n    \"webpack\": \"^3.11.0\",\n    \"webpack-dev-server\": \"^2.11.1\"\n  },\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n\n```\n\n### 번외_2 react 와 flow 사용하기.\n\n\n### 앞으로 공부할 것\n\n- React 더 심화\n- Redux \n- Rxjs , redux-observable\n- flow\n- esLint & airbnb\n\n## 참고 \n\n[https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca](https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca)","excerpt":"intro React 리엑트를 처음 마주해보자.\n해당 정리 내용의 출처는 \nhttps://www.youtube.com/watch?v=GEoNiUcVwjE&list=PL9FpFz-xRGMujql3S_XGV2SpdfDBkeC 이곳을 참조 하였다. Bab…","fields":{"slug":"/hello-react.md/"},"frontmatter":{"date":"Jan 31, 2018","title":"Hello React","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n# Docker Depolyment\n\n---\n## blue-green 배포 개념\n로드발란서를 앞단에 하나를 두고 v1 버젼인 블루(가칭) 라는 앱을 띄운다. 그러다가 나는 v2 버젼인 그린(가칭)을 무중단 방식으로 업데이트를 진행하고 싶다. <br>\n그럴때 그린을 로드발란서에 등록을 시킨다. <br>\n그러면 블루와 그린을 로드발란싱을 할텐데 그린이 완전히 정상작동을 하였을때 v1 버젼인 블루를 죽이는 방식이다.\n\n## why needs?\n\n\n\n![구성](./img_greenBlue.png)\n\n---\n## BackEnd Environment\n- 노트북 : 맥북\n- 도커 호스트 : virtual box ubuntu or mac\n- 도커 컨테이너 : node express server , nginx-proxy , mongodb\n\n---\n## 폴더 구조\n\n```\n├── dockerfile\n│   ├── Dockerfile_express      ## express 용 서버 이미지 소스파일\n├── template                    ## 템플릿 소스\n├── server                      ## 서버소스\n│   ├── server.js\n├── .dockerignore\n├── check.sh                    ## 배포용 sh\n├── docker-compose.yml          ## docker 컨테이너들의 환경설정을 모아둔곳 한번에 서버들을 손쉽게 실행시킬 수 있다.\n├── package.json                ## app server 컨테이너 안에 들어가 관련 패키지 설치\n  \n```\n\n---\n## Summary\n\n1. 맥북 - virtual box 공유 폴더 구성\n2. 폴더 구성 \n3. ubuntu 에서 nginx-proxy 이미지 다운\n4. ubuntu 에서 node 이미지를 기반으로 express Dockerfile_express 작성 및 빌드\n5. docker-compose.yml 작성\n6. /etc/hosts 파일 수정\n7. check.sh 현재 돌아가는 도커 확인하고 새로운 도커 띄우고 현재 돌아가는 도커 죽이는 쉘 스크립트 작성\n8. 테스트\n\n**만약 mac 에서 테스트를 한다면 2번부터 보시면 됩니다.**\n\n---\n## procedure\n\n1. 버츄어 박스에 공유 폴더 설정\n참고 : [http://theniceguy.tistory.com/13](http://theniceguy.tistory.com/13)\n\n```sh\n## 우분투에 공유폴더 마운트 \n$ sudo mount --types vboxsf blog_project blog_project\n```\n- 로컬 blog_project 폴더를 버츄어박스의 blog\\_proect 폴더랑 연결\n- 버츄어 박스 내의 blog_proect 폴더안에는 도커에서 필요한 소스파일 및 설정파일들이 담겨져 있음.\n\n\n2. 로드밸런싱을 위한 nginx-proxy 이미지 다운 받기 \n\n```sh\n## nginx-proxy 이미지 다운 받기 \n$ docker pull jwilder/nginx-proxy \n```\n\n- 사실 여기서 받지 않아도  docker-compose.yml 파일에 설정이 되어있어서 docker-compose up 하면 자동으로 pull을 받게 된다.\n\n- 해당 이미지는 도커 젠을 기반으로 만들어진 nginx-proxy로 로드발란싱의 기능이 있는 nginx applicaion에 도커 젠 기능을 추가 해서 넣은 이미지\n\n- 해당 이미지를 사용하게 되면 도커 젠이 도커 데몬을 바라보고 있다가 컨테이너의 런 , 스탑 등의 이벤트를 감지, 해당 컨테이너 정보를 수집 해서 추가 작업을 할 수 있게 끔 도와준다. 여기서 추가작업은 nginx reverse proxy config 작업을 자동으로 수행할 수 있게 도와준다.\n\n- 여기서 호스트의 docker.sock을 nginx-proxy 내부로 들고가야 하는데 이유는 호스트와 통신을 해야하기 때문이다. 호스트 서버에서 발생되는 도커 데몬의 이벤트를 바라보고 있다가 정보를 잘 받을수 있도록 통신을 해야한다.\n\n- 여기서 nginx-proxy에 등록될 app 들은 VIRTUAL_HOST라는 환경변수를 등록 해야한다.\n\n- nginx 의 가상 호스트 정보는 [https://opentutorials.org/module/384/4529](https://opentutorials.org/module/384/4529) 여길 참조\n\n\n3. express 도커서버를 위한 도커파일 작성\n\n```dockerfile\n## express 를 위한 도커파일\nFROM node:alpine\nMAINTAINER  merlin@merlin.com\n\nRUN mkdir -p /app\nWORKDIR /app\nCOPY package*.json ./\nRUN  npm install\n\nEXPOSE 3000\n\n```\n\n\n\n4. 도커파일을 express 이미지로 빌드.\n\n```sh\n\n$ docker build -t blog_express:v1 -f ./dockerfile/Dockerfile_express .\n\n```\n\n5. 모아둔 이미지들을 실행할 수 있도록 docker compose 작성\n\n```yml\n#docker-compose.yml\n\nversion: '3.2'\n\nservices:\n  app_blue:\n    image: blog_express:v1\n    depends_on:\n      - nginx-proxy\n      - mongo-db\n    working_dir: /app/\n    ports:\n      - 8888:3000\n    networks: \n      - dbconnection\n    environment:\n      - VIRTUAL_HOST=nodeapp.local\n    volumes:\n      - type: bind\n        source: ./template\n        target: /app/template\n      - type: bind\n        source: ./server\n        target: /app/server\n    command: npm start\n  \n  app_green:\n    image: blog_express:v1\n    depends_on:\n      - nginx-proxy\n      - mongo-db\n    working_dir: /app/\n    networks: \n      - dbconnection\n    environment:\n      - VIRTUAL_HOST=nodeapp.local\n    volumes:\n      - type: bind\n        source: ./template\n        target: /app/template\n      - type: bind\n        source: ./server\n        target: /app/server \n    command: npm start\n\n  nginx-proxy:\n    image: jwilder/nginx-proxy\n    ports:\n      - 8080:80\n    networks: \n      - dbconnection\n    volumes:\n      - /var/run/docker.sock:/tmp/docker.sock:ro\n  \n  mongo-db:\n    image: mongo\n    ports:\n      - 9999:27017\n    volumes:\n      - db-data:/data/db\n    networks: \n      - dbconnection\n    command: mongod --dbpath \"/data/db\" \n    \nvolumes:\n  db-data:\n\nnetworks: \n  dbconnection:\n\n\n```\n\n** 브라우저에서 접근할시 VIRTUAL&lowbar;HOST 에 설정했던 이름으로 접근할 것 <br>\nnginx 설정에 server_name이 VIRTUAL&lowbar;HOST 에 설정했던 값이 박혀있기에 nginx는 해당 이름으로 접근할때 반응하게 된다. <br>\n해서 /etc/hosts 설정은 필수\n\n6. /etc/hosts 파일 수정\n\n```bash\n0.0.0.0   nodeapp.local\n```\n\n\n7. 블루-그린 배포를 위한 쉘 스크립트 작성\n\n```sh\n#check.sh\n\n#!/bin/sh\n\nEXIST_BLUE=$(docker ps | grep app_blue)\n\nif [ -z \"$EXIST_BLUE\"]; then\n    docker-compose up -d app_blue\n    docker-compose stop app_green\n    echo \"run app_blue!!\"\nelse\n    docker-compose up -d app_green\n    docker-compose stop app_blue\n    echo \"run app_green!!\"\nfi\n```\n\n- check.sh 를 작성해서 app&lowbar;blue가 실행했을 경우에는 app&lowbar;green이 실행 후 app&lowbar;blue 를 중지.\n- app&lowbar;green 이 실행했을 경우에는 app&lowbar;blue를 실행 후 app&lowbar;green 를 중지.\n\n\n8. test\n\n```sh\n# 처음에는 app_blue를 띄운다.\n$ docker-compose up -d app_blue\n\n# 그 다음부턴 무중단으로 .check.sh 를 실행\n$ sudo sh check.sh\n\n```\n\n\n![테스트 결과 화면](./img_developTest.png)\n","excerpt":"Docker Depolyment blue-green 배포 개념 로드발란서를 앞단에 하나를 두고 v1 버젼인 블루(가칭) 라는 앱을 띄운다. 그러다가 나는 v2 버젼인 그린(가칭)을 무중단 방식으로 업데이트를 진행하고 싶다. \n그럴때 그린을 로드발란서…","fields":{"slug":"/docker-depolyment.md/"},"frontmatter":{"date":"Jan 20, 2018","title":"Docker Depolyment","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Docker term\n\n### What is Docker?\n\n* 소프트웨어를 containerization(컨테이너화) 한 플랫폼. ( 웹서비스 컨테이너 , 디비 컨테이너 따로 담는다고 하면 서로 isolation 화 할수 있고 서로 독립적인 공간을 가질수 있다. 서로에게 영향을 주지 않을수 있다. )\n* containerization 란 컨테이너를 매체로 한 수송체계, 즉. 컨테이너 규격을 맞춰 놓으면 차 , 배 , 비행기등 더 쉽고 빠르게 대량 수송과 시간을 단축 시킬수 있다. 라는 장점을 지니고 있음.\n* 이걸로 유추해볼 때 도커는 다양한 SW 들을 컨테이너에 담아 이동하기가 쉽게하고 포터블하게 만들수있는 플랫폼.\n* 리눅스의 응용프로그램들을 소프트웨어 컨테이너 안에 배치시키는 일을 자동화 하는 오픈소스\n\n### What is Container?\n\n* 개발 , 배포 , 운용 등을 위해 표준화된 단위로 구성된 소프트웨어 패키지화\n* 호스트 pc 의 커널을 공유하면서 SW 가 돌아갈수 있는 모든 구성들이 들어가있다. 대신, 불필요한 것들은 들어있지 않다.\n* 해당 도커 이미지를 run 시키면 해당 SW 가 돌아가는데 그 상태를 컨테이너 라고 한다.\n  일종의 프로세스와 유사한 개념이다.\n* 이 해당 컨테이너 내부 환경을 정의하는 파일은 dockerfile 이다.\n* 나머지 시스템으로 부터 완전히 독립된 공간을 갖는다. 그래서 밖으로 통신하기 위해선 포트를 맵핑해야 한다.\n\n### What is Service?\n\n* 서비스는 app 의 한 부분이다. 예를 들어 비디오를 공유하는 사이트는 데이타 베이스에 app data 를 저장하는 서비스, 비디오 업로드 후 transcoding 하는 서비스 등등..\n* 서비스들은 실제로 production 의 컨테이너들로 구성된다.\n* 하나의 서비스는 하나의 이미지만 실행하지만 그 이미지를 실행하는 방법을 쳬계화 할 수 있습니다. 그 체계화는 docker-compose.yml 파일에서 설정 할 수 있다.\n* docker-compose.yml 파일에서는 어떤 포트를 사용해야하는지, 서비스가 가져가야 할 필요한 용량에 따라 얼마나 많은 복제 컨테이너를 실행시켜야 하는지, 서비스를 위해 얼마나 컴퓨팅 리소스를 할당할지를 설정 할 수 있다.\n* docker-compose.yml 을 이용 하면 이미지를 일일이 다 run 시키지 않아도 된다.\n\n### What is Image?\n\n* 도커 이미지란 서비스의 필요한 프로그램 , 라이브러리, 소스등을 설치한 뒤에 이를 파일로 만든 것이다. 쉽게 실행파일이라고 생각하면 된다.\n* 이미지를 만들기위해 dockerfile 에 필요한 명령들을 설정해 놓는다.\n* 이미지는 base image 와 parent image 로 나뉜다.\n* base image 는 parent image 가 없는 이미지를 말한다.\n* parent image 는 사용하는 이미지의 Dockerfile 내에 FROM 으로 지시되는 이미지이다. 만약 Dockerfile 내에 FROM 이 지시되어있지 않다면 부모 이미지가 없는것이고 이는 곧 base image 가 된다.\n* Dockerfile 로 이미지를 만들때는 전에 만들었던 이미지 캐시를 잘 이용해야 한다. 기존 방식은 한줄 한줄 실행하면서 <br><b>임시 컨테이너 생성 > 명령어 수행 > 이미지 저장 > 임시 컨테이너 삭제 > 새로 만든 이미지 기반 임시 컨테이너 생성 > 명령어 수행 > 이미지로 저장 > 임시 컨테이너 삭제...</b> 이런식으로 수행....\n\n----> {해쉬아이디} : 이미지 저장 <br>\n----> Running in {해쉬아이디} : 명령어를 수행하기 위해 그 전 이미지 기반으로 임시 컨테이너 생성\n\n< 처음 Dockerfile 돌렸을때 >\n\n![처음 Dockerfile 돌렸을때](./img_build_init.png)\n\n< 기존 Dockerfile 을 2 번째 돌렸을때 >\n\n![기존 Dockerfile을 2번째 돌렸을때](./img_build_before.png)\n\n< 기존 Dockerfile 에서 EXPOSE 80 에서 EXPOSE 81 로 변경했을 때 >\n\n![기존 Dockerfile 에서 EXPOSE 80 에서 EXPOSE 81로 변경했을 때](./img_build_after.png)\n\n* 이미지 생성시 FROM 에 적어둔 parent image 기반으로 변경사항만 따로 저장되는게 장점. vm 처럼 용량을 많이 먹지 않음. <br>\n  따라서 parent image 기반으로 새로운 이미지를 만들고 parent image 를 삭제하려고 했을때 에러 뜸.\n\n![error](./img_parent_error.png)\n\n### What is Stack?\n\n---\n\n## Docker Structure\n\n![Docker Structure](./img_structure.png)\n\n_출처 : [http://www.leafcats.com/146](http://www.leafcats.com/146)_\n\n---\n\n## Docker Install\n\n[공식 홈페이지 참조](https://docs.docker.com/engine/installation/)\n\n---\n\n## Docker use\n\n도커 허브에서 원하는 이미지를 다운 받을 수 있다.\n[도커 허브](https://hub.docker.com/)\n\n```sh\n$ docker --help\n```\n\n도커의 명령어를 살펴볼 수 있다.\n\n```sh\n$ docker pull nginx:latest\nor\n$ docker run -d -it \\\n--name merlin-nginx \\\n-p 8080:80 \\\nnginx:latest\n```\n\npull 을 하면 해당 이미지만 받는것이다 <br>\nrun 을 실행하게 되면 local 에 nginx:latest 라는 이미지가 없으면 자동으로 hub 에서 다운받아서 run 을 시킨다.\n\n```sh\n$ docker images\n$ docker ps\n$ docker ps [-a] [-l] [-n number]\n```\n\nimages 는 도커 이미지 리스트를 살펴볼 수 있다. <br>\nps 는 실행중인 컨테이너 리스트를 볼 수 있다. <br>\n-a 옵션을 붙이면 종료된 목록까지 볼 수 있다.<br>\n-l 옵션은 마지막 실행했던 목록 , -n 은 리눅스의 tail 명령어와 동일하다.\n\n```sh\n$ docker commit -a \"merlin <merlin@kakaocrop.com>\" -m olympic-search-pc naughty_torvalds search.daum.pc:olypic\n```\n\n현재 돌아가고 있는 컨테이너를 이미지로 만들 수 있다.<br>\n-a 옵션 : author , -m : 커밋 메세지 , <naughty_torvalds> 들어가는 부분 : 지금 동작하고 있는 컨테이너 이름 , <search.daum.pc:olypic> 새로운 이미지 네임과 태그\n\n```sh\n$ docker rm <컨테이너 이름>\n$ docker rmi <이미지>\n# 한번에 처리.\n$ docker rm $(docker ps -a -q)\n```\n\n도커 이미지와 컨테이너 삭제\n\n```sh\n$ docker start <컨테이너 이름>\n$ docker stop  <컨테이너 이름>\n$ docker restart <컨테이너 이름>\n```\n\n도커 컨테이너 실행 , 중지 , 재부팅\n\n```sh\n$ docker attach <실행중인 컨테이너 이름>\n$ docker exec -it <실행중인 컨테이너 이름> <컨테이너 안에서 실행할 명령>\n$ docker exec -it merlin-nginx /bin/bash\n```\n\nattach 는 실행중인 도커 컨테이너에 접속한다. 단, ps 쳤을때 command 에 /bin/bash 라고 쳐져있어야 자유롭게 입력할 수 있다. 그렇지 않으면 입력은 할 수 없고 출력만 보인다. <br>\nexec 는 컨테이너 안에서 수행할 명령을 날려줍니다. -it 옵션을 주면 실행된 bash 쉘에서 입력 및 출력을 할 수가 있습니다.\n\n```sh\n$ docker inspect <컨테이너 이름 or 이미지:태그>\n```\n\n이미지 또는 컨테이너의 세부정보를 출력합니다.\n\n```sh\n$ docker history <이미지:태그>\n```\n\n이미지의 히스토리를 조회\n\n```sh\n$ docker diff <실행중인 컨테이너 이름>\n```\n\n컨테이너가 실행되면서 변경된 파일 목록을 출력합니다. 비교 기준은 컨테이너를 생성한 이미지 내용입니다.\n\n```sh\n$ docker cp <컨테이너 이름>:<경로> <호스트 경로>\n```\n\n컨테이너에서 파일을 꺼내기.\n\n---\n\n## Docker build\n\n```sh\n$ docker [OPTIONS] PATH | URL | -\n$ docker build -t app .\n```\n\n-t 옵션은 생성할 이미지 이름을 지정합니다. <br>\n-f 옵션은 파일명을 custom 하게 지었을때 사용하거나 Dockerfile 경로가 루트에 없을때 이용. <br>\nPATH 는 도커 이미지 빌드 할때 전송되는 context 를 가리킨다. <br>\n\n### Dockerfile\n\n```Dockerfile\n# 어떤 이미지로부터 새로운 이미지를 생성할지를 작성\n# 베이스를 지정\nFROM node:argon\n\n# Dockerfile 을 관리하는 사람의 이름\nMAINTAINER < merlin.ho > merlin@merlin.com\n# /app directory 생성\nRUN mkdir /app\n\n# /app directory를 WORKDIR로 설정\nWORKDIR /app\n\n# 현재 경로에 있는 package.json을 /app에 복사\n# ADD와 기본적으로 동일하나 차이점은 URL을 지정할수 없고 압축파일을 자동으로 풀어주지 않는다. \nCOPY package.json /app\n\n# 파일과 디렉토리를 호스트에서 docker image로 copy한다.\n# src에 파일 대신 url을 입력할수 있고 압축 파일의 경우 압축을 해제하면서 복사\n# 호스트에 있는 . 경로에 있는걸 /usr/src/app 에 복사.\nADD < src > < dest >\nADD . /usr/src/app\n\n# 내부적으로 /bin/sh -c 실행 뒤 npm install 을 실행\nRUN npm install\n\n# 현재 Dockerfile 이 있는 경로의 모든 파일을 /app 에 복사함\nCOPY . /app\n\n# 가상머신에 오픈할 포트넘버\nEXPOSE 3000\n\n# 도커 컨테이너가 실행 되었을때 실행되는 명령 지정, 빌드할때는 실행되지 않으며 여러개의 CMD가 존재할 경우 가장 마지막 것만 실행 됩니다.\n# 한꺼번에 여러 개의 프로그램을 실행하고 싶은 경우에는 run.sh파일을 작성하여 데몬으로 실행하거나 supervisord나 forego와 같은 여러 개의 프로그램을 실행하는 프로그램을 사용합니다.\nCMD [\"npm\", \"start\"]\n```\n\n### recommendation Dockerfile\n\n1. Containers should be ephemeral\n\n   * Ephemeral environments are also sometimes called “Dynamic environments”, “Temporary environments”, “on-demand environments” or “short-lived environments”.\n   * static environments 와 반대되는 개념이다.\n   * 이것이 의미하는 바는 이 컨테이너를 우리가 stop and destroy 할 수 있고 새롭게 built 할 수 있으며 최소한의 셋팅과 설정으로 원하는 장소에 올려 놓을수 있다 라는것을 뜻함.\n   * 그래서 항상 production 환경과 같은 환경에서 test 를 진행할 수 있다. test 도 하나의 이미지를 공유 함으로써 병렬로 진행 할 수 있다.\n\n2. Use a .dockerignore file\n   * 우리는 docker build 커멘드를 치는 장소를 build context 라고 부른다.\n   * 디폴트로 현재 디렉토리라고 가정하지만 구체적인 다른 디렉토리를 가리키려면 -f flag 를 사용해야한다.\n   * 현재 디렉토리의 파일과 여러 디렉토리들을 docker deamon 에게 build context 로 보내지게 되는데 이 이것은 무심코 이미지 결과로 보내지게 되어 이미지 파일이 커지게 된다.\n   * 따라서 .gitignore 와 비슷하게 .dockerignore 파일을 사용해서 관계없는 파일들을 exclude 시킬수 있다.\n3. Use multi-stage builds\n\n   * Docker 17.05 버전 이상에서는 multi-stage builds 로 최종 이미지 사이즈를 줄일 수 있다.\n   * multi-stage builds 란 Dockerfile 안에서 multiple FROM 구문을 사용하면 각각의 새로운 stage 가 빌드 되고 한 stage 에서 나온 결과 산출물을 또다른 stage 로 카피를 할 수 있다. 따라서 중간 산출물을 위해 Dockerfile 을 여러개 만들어서 중간 이미지를 만들고 하는 복잡한 과정을 거치지 않아도 된다.\n   * dockerfile 을 작성할때 자주 바뀌지 않은 것부터 자주 바뀌는 순으로 작성을 한다.\n\n4. Avoid installing unnecessary packages\n   * 불필요한 패키지는 인스톨을 피해라.\n   * 예를 들면 데이타베이스 이미지에 text editor 를 추가시킬 필요는 없다.\n5. Each container should have only one concern\n   * 하나의 컨테이너는 오직 하나의 일만하게 시켜라.\n   * 응용 프로그램을 여러 컨테이너로 분리하면 가로로 확장하고 컨테이너를 다시 사용하는 것이 훨씬 쉬워집니다.\n   * 컨테이너를 깨끗하고 가능한 모듈화 시킬 수 있는 최고의 판단을 해라.\n   * 만약 컨테이너 각각이 의존성을 띄고 있다면 Docker network 를 사용하면 컨테이너끼리의 커뮤니케이션을 할 수 있다.\n6. Minimize the number of layers\n7. Sort multi-line arguments\n8. Build cache\n\n---\n\n## 10 things to avoid in docker containers\n\n    1. Don’t store data in containers\n    2. Don’t ship your application in two pieces\n    3. Don’t create large images\n    4. Don’t use a single layer image\n    5. Don’t create images from running containers\n    6. Don’t use only the “latest” tag\n    7. Don’t run more than one process in a single container\n    8. Don’t store credentials in the image. Use environment variables\n    9. Don’t run processes as a root user\n    10. Don’t rely on IP addresses\n\n_출처 : [https://developers.redhat.com/blog/2016/02/24/10-things-to-avoid-in-docker-containers/](https://developers.redhat.com/blog/2016/02/24/10-things-to-avoid-in-docker-containers/)_\n\n---\n\n## Docker app data 관리법\n\n### 호스트의 지정된 폴더를 컨테이너에 다이렉트로 마운트\n\n```sh\n$ docker run --name merlin_ubuntu -d -v <호스트 폴더경로>:<마운트될 컨테이너 폴더경로> -it ubuntu:14.04\n```\n\n### volume container 사용\n\n```sh\n# 볼륨 컨테이너를 만든다. busybox 기반 정말 리눅스의 최소 기반만 가지고 있다. 1.14MB\n$ docker run -v /dbdata --name dbdata busybox\n\n# 볼륨 컨테이너를 우분투 컨테이너에 연결\n$ docker run --volumes-from=dbdata -it ubuntu:14.04 /bin/bash\n\n# 빽업도 진행할 수 있다.\n$ docker run —volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata\n```\n\n### volume 으로 사용\n\n* 보통 standalone 컨테이너에는 -v 또는 --volume 옵션을 사용했고, swarm service 에는 --mount 옵션을 사용해 왔지만 17.06 이후 버젼부터는 standalone 컨테이너에서 모두 사용이 가능하다.\n* 만약 볼륨드라이버의 구체적인 옵션을 셋팅해야 한다면 --mount 옵션을 사용해라.\n* -v 또는 --volume 옵션은 도커 호스트에 파일 또는 디렉토리가 없을 경우 자동으로 생성해주지만 --mount 옵션은 자동으로 생성해주지 않는다 대신 에러를 뿜는다.\n* -v 또는 --volume 은 세가지 field 를 가질수 있다 첫번째는 호스트 머신의 볼륨 이름이고 랜덤한 볼륨을 생성하고 싶다면 생략해도 된다. 두번째는 컨테이너 안에 생성될 디렉토리 또는 파일 path 이다. 세번째는 옵션으로 콤마(:)로 옵션을 나열할 수 있다. 예를 들면 ro(readonly) 옵션등이 있다.\n* --mount 는 key=value 로 구성을 하고 key 에는 type, src or source , dst or target , volume-opt 등이 있다.\n* type 의 경우에는 bind , volume , tmpfs 가 있다. 올바른 타입으로 선택하자.\n* Voloumn 타입, volumn 은 도커에 의해 관리되는 host 쪽에 있는 파일시스템으로 저장이 된다. 여기서 volumn 은 \"~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty\" 해당 경로에 있는 리눅스 안에 \"/var/lib/docker/volumes/\" 쪽에 저장이 된다. 도커가 아닌 프로세스가 이 파일은 수정하지 못하고 volumnes 는 도커 안에서 데이터를 유지하기 최고의 방법이다.\n* bind 타입, 이 bind 타입은 host 어디에나 저장이 될 수 있다. 여기서 중요한 시스템 파일이나 디렉토리들에 사용이 될수있고 언제든지 도커가 아닌 프로세스나 도커 컨테이너에서 수정될수 있다.\n* tmpfs 타입, 이 타입은 hosts 의 메모리에 저장이 된다. 그리고 host 파일시스템에 쓸수가 없다. 휘발성이 강하다.\n\n```sh\n$ docker volume create my-vol\n$ docker volume ls\n## Remove a volume:\n$ docker volume rm my-vol\n```\n\n```sh\n## 컨테이너 연결\n## mount 방법\n$ docker run -d \\\n  -it \\\n  --name devtest \\\n  --mount source=myvol2,target=/app \\\n  nginx:latest\n\n  $ docker run -d \\\n  -it \\\n  --name=nginxtest \\\n  --mount source=nginx-vol,destination=/usr/share/nginx/html \\\n  nginx:latest\n\n# -v 방법\n $ docker run -d \\\n  -it \\\n  --name devtest \\\n  -v myvol2:/app \\\n  nginx:latest\n\n\n  $ docker run -d \\\n  -it \\\n  --name=nginxtest \\\n  -v nginx-vol:/usr/share/nginx/html \\\n  nginx:latest\n```\n\n![img_busybox 용량](./img_busybox.png)\n\n마운트 된 경로는 inspect 명령어로 알아 볼 수 있다.\n\n![마운트 경로](./img_mount.png)\n\n결론은 어찌되었건 호스트에 데이타를 연동 시킨다. <br>\nvolume container 를 사용했을 떄 데이터도 컨테이너로 관리를 할 수 있다. 그럼..컨테이너의 장점을 다 이용할 수 있지 않을까...\n\n---\n\n## Docker compose\n\n여러 컨테이너의 Docker application 을 running 하고 defining 하기 위한 툴이 Compose 이다. Compose 를 사용하기 위해서 YAML 파일에 config 를 app service 별로 설정하면 되고 한 커맨드 라인으로 서비스를 만들고 시작할수 있다. 해당 서비스는 YAML 파일에 적혀있는 그대로를 실행시킨다.\n\ndocker compose install\n[docker compose install](https://docs.docker.com/compose/install/#install-compose)\n\n공식문서 [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)\n\n### Docker compose 를 사용하는 방법\n\n1. Define your app’s environment with a `Dockerfile` so it can be reproduced anywhere.\n2. Define the services that make up your app in `docker-compose.yml` so they can be run together in an isolated environment.\n3. Run `docker-compose up` and Compose starts and runs your entire app.\n\n### Docker compose config\n\nversion 3\n\n```yml\n# compose 버젼 3을 이용하겠다. 대소문자 주의\nversion: '3'\n\nservices:\n    webapp:\n        build: ./dir # 구체적인 빌드 컨텍스트의 경로를 지정할 수 있다. 도커 파일을 포함하는 디렉토리나 깃 레파지토리 url,\n        build: # 또는 구체적인 옵션들을 설정할 수 있다.\n            context: ./dir\n            dockerfile: Dockerfile-alternate\n            args: # 빌드 프로세스 진행중에 사용할 환경 변수들을 지정할 수 있다.\n                buildno: 1\n            cache_from: # v3.2지원 엔진이 캐시로 사용할 이미지들\n                - alpine:latest\n                - corp/web_app:3.14\n        command: bundle exec thin -p 3000  # 디폴트 커멘드를 오버라이딩\n        container_name: my-web-container # 컨테이너 이름\n        # 버전 3부터는 depend_on 안에 condition은 지원하지 않는다.\n        depends_on: # 서비스들 간에 의존성을 표현, 이것은 db, redis 이후에 webapp 이 실행하게 된다.(compose up시)\n            - db\n            - redis\n        tmpfs: /run # 컨테이너에 임시 파일 시스템을 마운트 , 리스트로 작성해도 된다.\n        entrypoint: /code/entrypoint.sh # 도커 파일의 엔트리 포인트를 오버라이딩 , 리스트로 작성해도 된다.\n        env_file:  # 환경변수들을 파일로 받는다. 이 환경 변수 파일들은 각각 라인마다 VAR=VAL 포멧으로 작성한다. #은 주석\n            - ./common.env\n            - ./apps/web.env\n            - /opt/secrets.env\n        environment: # 환경변수 추가. 어떤 boolen 값들은 quotes로 감싼다.\n            RACK_ENV: development\n            SHOW: 'true'\n            SESSION_SECRET:\n        expose: # 포트 노출\n            - \"3000\"\n            - \"8000\"\n        external_links: # 링크 컨테이너 docker-compose.yml 외부에 있는 컨테이너 , CONTAINER:ALIAS\n            - redis_1\n            - project_db_1:mysql\n            - project_db_1:postgresql\n        extra_hosts: # /etc/hosts 에 추가\n            - \"somehost:162.242.195.82\"\n            - \"otherhost:50.31.209.229\"\n        image: redis # 특별한 이미지로 부터 런 , 이미지가 없으면 pull 한다.\n        healthcheck: # 이 서비스를 위해 건강한지 체크 , 이미지로 부터 어떤 디폴트 헬스체크를 disable 하려면 disable: true 추가\n            test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"]\n            interval: 1m30s\n            timeout: 10s\n            retries: 3\n        labels: # 라벨 추가.\n            com.example.description: \"Accounting webapp\"\n            com.example.department: \"Finance\"\n            com.example.label-with-empty-value: \"\"\n        links: # 다른 서비스들의 컨테이너 들과 연결고리를 형성, SERVICE:ALIAS , 주의!! --links 플래그는 레거시 이다. --links 사용을 대신해서 사용자가 정의하는 네트워크 설정을 이용하길 권장한다.\n            - db\n            - db:database\n            - redis\n        logging: # 서비스의 로깅 config\n            driver: syslog # json-file , syslog , none\n            options:\n                syslog-address: \"tcp://192.168.0.42:123\",\n                max-size: \"200k\" # json-file 의 경우 로그 저장을 제한할 수 있다. 오래된 파일은 지워진다.\n                max-file: \"10\"\n        network_mode: bridge # 네트워크 모드 설정 , host , none , service:[service name] , container:[container name/id] //// host 모드는 links랑 같이 사용할 수 없다.\n        networks: # top level 에서 지정한 네트워크 설정 , 알리아스를 사용할 수 도 있다. 이 알리아스 네임으로 서비스를 연결 할 수 있다.\n            - some-network\n            - other-network\n            new:\n                aliases:\n                    - database\n        ports: # HOST:CONTAINER\n            - \"8000:8000\"\n        volumes: # 호스트 경로 또는 생성된 볼륨을 마운트 시킨다.\n            - type: volume\n            source: mydata\n            target: /data\n            volume:\n                nocopy: true\n            - type: bind\n            source: ./static\n            target: /opt/app/static\n\n\nvolumes:\n  mydata:\n    external : true # 컴포즈 밖에 volume이 존재했을때, 없으면 'docker volume create --name=' 으로 만들라고 에러뜸.\n    name : actual-name-of-volume # 이름을 지정할 수도 있다.\n  dbdata:\n\nnetworks:\n```\n\n* 직접 했던 예제\n\n```yml\nversion: '3.2'\n\nservices:\n  app_blue:\n    image: blog_express:v1\n    depends_on:\n      - nginx-proxy\n      - mongo-db\n    working_dir: /app/\n    networks:\n      - dbconnection\n    environment:\n      - VIRTUAL_HOST=nodeapp.local\n    volumes:\n      - type: bind\n        source: ./server\n        target: /app/server\n    command: npm start\n\n  app_green:\n    image: blog_express:v1\n    depends_on:\n      - nginx-proxy\n      - mongo-db\n    working_dir: /app/\n    networks:\n      - dbconnection\n    environment:\n      - VIRTUAL_HOST=nodeapp.local\n    volumes:\n      - type: bind\n        source: ./server\n        target: /app/server\n    command: npm start\n\n  nginx-proxy:\n    image: jwilder/nginx-proxy\n    ports:\n      - 8081:80\n    networks:\n      - dbconnection\n    volumes:\n      - /var/run/docker.sock:/tmp/docker.sock:ro\n\n  mongo-db:\n    image: mongo\n    depends_on:\n      - nginx-proxy\n    volumes:\n      - db-data:/data/db\n    networks:\n      - dbconnection\n    command: mongod --dbpath \"/data/db\"\n\nvolumes:\n  db-data:\n\nnetworks:\n  dbconnection:\n```\n\n---\n\n## Docker network\n\n출처 : [http://bluese05.tistory.com/15](http://bluese05.tistory.com/15)\n\n### network 구성\n\n* 도커를 설치 하면 docker host 쪽에 보면 **docker0** 이라는 virtual ethernet bridge 를 확인할 수 있다. ( $ ifconfig 로 확인가능, 난 172.17.0.1 로 셋팅되어 있다.)\n* docker0 는 container 가 통신하기 위한 가상 linux bridge 이다. bridge 는 기본적으로 L2 통신 기반이다.\n* 컨테이너가 하나씩 생성되면 이 bridge 에 하나씩 바인딩 된다. ( $ brctl show docker0 )\n* 이렇게 연결된 컨테이너와 host 는 케이블로 연결한 두대의 pc 라고 보면 된다.\n* 컨테이너 내부의 eth0 인터페이스는 내부로 격리되어있어서 이 내부와 host 를 이어줄 vethxxxx 형태의 인터페이스가 하나 더 존재한다. 이 인터페이스가 host 와 컨테이너 사이를 연결해준다.\n* 컨테이너 내부의 아이피를 확인하려면 ifconfig eth0 라고 치면 되는데 ifconfig 가 잘 안먹는다. 그럴땐 도커 inspect 로 확인하자.\n\n### network 확인\n\n```sh\n$ ip addr show\nor\n$ ifconfig\n```\n\n```sh\n$ docker attach nonenetcontainer\n# 접속후\n$ cat /etc/hosts\n$ ip -4 addr\n```\n\nattach 했던걸 detach 하기 위해선 CTRL-p CTRL-q 를 입력하면 된다.\n\n### network 방식\n\n```sh\n# 네트워크 방식 확인하기 ( 드라이버 ) bridge , host , none ( 네임 기준 )\n$ docker network ls\n```\n\n```sh\n# 기본 네트워크는 bridge 방식이다.\n# 다른방식으로 컨테이너를 생성하고 싶다면\n$ docker run --new={네트워크 타입}\n```\n\n1. birdge\n\n   * 네트워크에서 브릿지란 호스트 서버의 네트워크를 연결하여 가상화된 머신들도 동일한 네트워크를 사용하도록 하는 것이다.\n   * docker network inspect bridge 로 브릿지 모드의 자세한 내용을 확인 할 수 있다.\n\n2. host\n\n   * 이 방식은 컨테이너가 독립적인 네트워크 영역을 갖지 않고 host 와 네트워크를 함께 사용한다.\n   * 따라서 해당 컨테이너는 host 의 네트워크 정보와 동일시 하게 가져가게 된다.\n   * 따라서 docker0 에 바인딩 되지 않는다.\n\n3. container\n\n   * 다른 컨테이너의 네트워크 환경을 가져온다. 즉, ip 와 mac 주소를 동일시 하게 구성한다.\n   * docker run --name web03 --net=container:{컨테이너 id} -d nginx:alpine\n\n4. none\n   * 이 옵션은 격리된 네트워크 환경은 갖지만, 인터페이스가 없는 상태로 컨테이너를 생성하게 된다.\n\n### container 외부 통신\n\n* 각 컨테이너는 격리된 환경에서 각각의 mac 주소와 ip 주소를 부여 받는다.\n* 각 컨테이너들은 host 와 통신하기 위해 bridge 방식으로 바인딩 되어있는데 각 부여받은 ip 로 자유롭게 통신 가능.\n* 예를 들면 web 서비스를 하는 container 는 80 번 포트에서 리스닝을 하고있다. 이 포트는 외부와 통신이 되어야 하는데 이때 포트를 외부로 지정한다. -p 8080:80 으로 옵션을 주게 되면 docker host 의 8080 포트로 요청이 들어오면 컨테이너의 80 포트로 해당 요청을 forwarding 하겠다는 의미이다.\n* docker ps -a or netstat -nlp | grep 8080 로 확인\n\n### link 방식의 한계\n\n* link 방식은 하나의 호스트 사이에서 실행되는 컨테이너 사이에서만 연결이 가능하다.\n* 다수의 host 가 존재했을때, 다른 host 의 컨테이너에는 접근할 수가 없다.\n* 이 경우 docker swarm 같은 orchestration 툴을 사용하거나 dynamic DNS 를 구축해야한다.\n\n> Warning: >The --link flag is a legacy feature of Docker. It may eventually be removed. Unless you absolutely need to continue using it, we recommend that you use user-defined networks to facilitate communication between two containers instead of using --link. One feature that user-defined networks do not support that you can do with --link is sharing environmental variables between containers. However, you can use other mechanisms such as volumes to share environment variables between containers in a more controlled way.\n\n\\*\\* dynamic DNS 란? - 간단하게 ip 가 바뀌면 그걸 알아채서 외부 DNS 서버에 알려준다. 그러면 ip 가 동적으로 바뀌는 환경에서도 사용자는 바뀐 ip 를 알 필요 없이 domain name 만 알면 동일하게 접속 할 수 있다.\n","excerpt":"Docker term What is Docker? 소프트웨어를 containerization(컨테이너화) 한 플랫폼. ( 웹서비스 컨테이너 , 디비 컨테이너 따로 담는다고 하면 서로 isolation 화 할수 있고 서로 독립적인 공간을 가질수 있다.…","fields":{"slug":"/hello-docker.md/"},"frontmatter":{"date":"Jan 09, 2018","title":"Hello Docker","tags":["undefined"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}}}