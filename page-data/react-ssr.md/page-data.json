{"componentChunkName":"component---src-templates-post-tsx","path":"/react-ssr.md/","result":{"data":{"markdownRemark":{"html":"<p>이 글은 벨로퍼트님의 <code class=\"language-text\">리액트를 다루는 기술</code> 책의 SSR 부분을 핵심만 요약한 글입니다.\nSSR의 흐름을 알기 쉽게 보기 위해서 정리합니다.</p>\n<h2 id=\"정의\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%9D%98\" aria-label=\"정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정의</h2>\n<p>SSR은 <code class=\"language-text\">Server Side Rendering</code> 으로 서버에서 HTML 코드를 만들어서 응답으로 보내주는 형식을 말합니다.\n기존의 SPA의 경우에는 <code class=\"language-text\">Client Side Rendering</code> 을 사용하고 있고 SSR과 CSR은 장단점을 지니고 있습니다.</p>\n<h2 id=\"기본-요약\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EC%9A%94%EC%95%BD\" aria-label=\"기본 요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 요약</h2>\n<ol>\n<li><code class=\"language-text\">index.server.js</code> 를 만들어 <code class=\"language-text\">ReactDOMServer.rednerToString</code> 으로 JSX를 마크업으로 만들어 줍니다.</li>\n<li>서버 코드에서 응답으로 만들어진 마크업을 전달합니다.</li>\n<li>빌드 된 JS, CSS 파일은 파일명이 매번 바뀌기 때문에 <code class=\"language-text\">asset-manifest.json</code> 파일을 참고해서 만들 마크업에 link, script 태그를 이어줍니다.</li>\n<li><code class=\"language-text\">Router</code> 는 <code class=\"language-text\">StaticRouter</code>의 <code class=\"language-text\">location props</code>를 가지고 라우팅 처리를 합니다.</li>\n</ol>\n<h2 id=\"데이터-로딩-요약\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%A1%9C%EB%94%A9-%EC%9A%94%EC%95%BD\" aria-label=\"데이터 로딩 요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 로딩 요약</h2>\n<p>SSR에서는 라이프 사이클 메서드가 동작하지 않고, 데이터가 바뀐다고 해도 re-Rendering이 되지 않으므로\n마크업을 만들어서 응답하기 전에 필요한 API 데이터를 미리 다 불러와야 합니다.</p>\n<h3 id=\"redux-thunk\" style=\"position:relative;\"><a href=\"#redux-thunk\" aria-label=\"redux thunk permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>redux-thunk</h3>\n<ul>\n<li>불려져야 하는 API 함수 (<code class=\"language-text\">promise</code>) 들을 Preload 컴포넌트를 이용해 <code class=\"language-text\">React Context</code>에 하나하나 쌓아 둡니다.</li>\n<li>마크업을 만들기 전에 해당 <code class=\"language-text\">Promise.all</code> 을 이용해서 promise 들을 실행시키며 이 <code class=\"language-text\">promise</code> 들은 <code class=\"language-text\">redux reduce</code> 에서 api 호출 및 저장이 됩니다.</li>\n<li>최종 마크업을 만들어 줍니다.</li>\n<li><code class=\"language-text\">redux thunk</code>(액션함수)를 <code class=\"language-text\">dispatch</code> 의 인자로 넘기면 <code class=\"language-text\">promise</code>가 반환됩니다.</li>\n<li><code class=\"language-text\">PreloadContext</code> 를 만들어 줍니다.</li>\n<li><code class=\"language-text\">Preload</code> 컴포넌트는 초기 데이터를 받아야 할 리턴이 <code class=\"language-text\">promise</code>인 함수를 <code class=\"language-text\">props</code>로 받아 해당 <code class=\"language-text\">Context state</code>에 넣어두는 로직을 구성합니다.</li>\n<li>각 컨테이너 컴포넌트에서 <code class=\"language-text\">Preload</code>가 필요한 곳에 넣어줍니다.</li>\n<li>이때, 라이프 사이클에서 마운트 에서 호출하던 (<code class=\"language-text\">useEffect, componentDidMount</code>) API 호출은 데이터가 유효하면 호출하지 않도록 분기를 쳐 둡니다.</li>\n<li>JSX를 만들고 나서 <code class=\"language-text\">ReactDOMServer.renderToStaticMarkup()</code> 메서드를 활용해서 초기 데이터를 불러오게끔 하는 렌더링을 진행합니다.</li>\n<li><code class=\"language-text\">Promise.all()</code>로 <code class=\"language-text\">PreLoadContext</code>의 <code class=\"language-text\">promise list</code> 들을 실행합니다.</li>\n<li>마지막으로 <code class=\"language-text\">ReactDOMServer.renderToString()</code>으로 마지막 최종 렌더링을 진행해서 응답해줍니다.</li>\n</ul>\n<h3 id=\"redux-saga\" style=\"position:relative;\"><a href=\"#redux-saga\" aria-label=\"redux saga permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>redux-saga</h3>\n<ul>\n<li>saga도 똑같이 <code class=\"language-text\">Preload</code> 컴포넌트를 사용합니다.</li>\n<li>유효성 검사 후 에 null 처리 할 곳에 <code class=\"language-text\">Preload</code> 컴포넌트를 사용합니다.</li>\n<li>서버 코드 내에서 <code class=\"language-text\">sagaMiddleware.run(rootSaga).toPromise()</code> 를 이용해서 saga Task들을 promise로 만들어줍니다.</li>\n<li>서버 코드 내에서 <code class=\"language-text\">store.dispatch(END)</code> 코드를 넣어서 saga가 액션을 모니터링 하는것을 방지합니다.</li>\n<li><code class=\"language-text\">thunk</code> 에서 <code class=\"language-text\">Promise.all()</code> 하는 곳 바로 위에 <code class=\"language-text\">await sagaMiddleware.run(rootSaga).toPromise()</code> 넣어주고 진행 중이던 사가들이 모두 끝날때 까지 기다려줍니다.</li>\n</ul>\n<h2 id=\"서버-사이드-렌더링과-코드-스플리팅\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B2%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81%EA%B3%BC-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%94%8C%EB%A6%AC%ED%8C%85\" aria-label=\"서버 사이드 렌더링과 코드 스플리팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버 사이드 렌더링과 코드 스플리팅</h2>\n<p>이 부분이 중요한 이유는 서버 사이드 렌더링해서 전부 렌더링이 진행 된 이후 클라이언트 사이드에서 js가 다 불러져 온 뒤로 다시 비동기로 컴포넌트를 불러올때 깜빡임이 발생 하기 때문입니다.</p>\n<ul>\n<li><code class=\"language-text\">Loadable Components</code>를 사용할 것을 권장하고 있습니다.</li>\n<li>서버 유틸 함수, 웹팩 플러그인, babel 플러그인을 제공합니다.</li>\n<li>페이지 컴포넌트를 <code class=\"language-text\">loadable()</code> 메서드로 감싸서 Route에 적용합니다.</li>\n<li>웹팩과 바벨을 설정하면 <code class=\"language-text\">loadable-stats.json</code> 이라는 파일이 만들어 집니다.</li>\n<li><code class=\"language-text\">loadable-stats.json</code> 이 파일은 각 컴포넌트 코드가 어떤 청크파일에 들어가 있는지에 대한 정보를 가지고 있다고 보면 됩니다.</li>\n<li>서버 사이드 렌더링을 할 때 이 파일을 참고하여 어떤 컴포넌트가 렌더링 되었는지에 따라 어떤 파일들을 사전에 불러와야 할지 설정할 수 있습니다.</li>\n</ul>\n<h2 id=\"loadableready--hydrate\" style=\"position:relative;\"><a href=\"#loadableready--hydrate\" aria-label=\"loadableready  hydrate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>loadableReady &#x26; hydrate</h2>\n<ul>\n<li><code class=\"language-text\">Loadable Component</code>를 사용하면 성능 최적화를 위해 js 파일을 모두 불러오는데 이때 모든 js 파일이 로딩되고 나서 렌더링을 할 수있도록 하는 것이 <code class=\"language-text\">loadableReady</code> 입니다.</li>\n<li>추가로 <code class=\"language-text\">render()</code> 메서드가 아닌 <code class=\"language-text\">hydrate()</code> 메서드가 존재하는데 이것은 기존에 존재하는 UI에 이벤트만 연동하여 성능을 최적화 시켜줍니다. 하지만 기존에 존재하는 UI 와 <code class=\"language-text\">hydrate()</code> 메서드에서 비교하려는 컴포넌트랑 다르면 에러가 뜬다는 사실이 있습니다.</li>\n</ul>","excerpt":"이 글은 벨로퍼트님의  책의 SSR 부분을 핵심만 요약한 글입니다.\nSSR의 흐름을 알기 쉽게 보기 위해서 정리합니다. 정의 SSR은  으로 서버에서 HTML 코드를 만들어서 응답으로 보내주는 형식을 말합니다.\n기존의 SPA…","tableOfContents":"<ul>\n<li><a href=\"/react-ssr.md/#%EC%A0%95%EC%9D%98\">정의</a></li>\n<li><a href=\"/react-ssr.md/#%EA%B8%B0%EB%B3%B8-%EC%9A%94%EC%95%BD\">기본 요약</a></li>\n<li>\n<p><a href=\"/react-ssr.md/#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%A1%9C%EB%94%A9-%EC%9A%94%EC%95%BD\">데이터 로딩 요약</a></p>\n<ul>\n<li><a href=\"/react-ssr.md/#redux-thunk\">redux-thunk</a></li>\n<li><a href=\"/react-ssr.md/#redux-saga\">redux-saga</a></li>\n</ul>\n</li>\n<li><a href=\"/react-ssr.md/#%EC%84%9C%EB%B2%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81%EA%B3%BC-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%94%8C%EB%A6%AC%ED%8C%85\">서버 사이드 렌더링과 코드 스플리팅</a></li>\n<li><a href=\"/react-ssr.md/#loadableready--hydrate\">loadableReady &#x26; hydrate</a></li>\n</ul>","fields":{"slug":"/react-ssr.md/"},"frontmatter":{"title":"react SSR","date":"Apr 23, 2020","tags":["undefined"],"keywords":["Merlin Tech Blog","Merlin.ho"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/react-ssr.md/","series":[],"lastmod":"0001-01-01"}}}