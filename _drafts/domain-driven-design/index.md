---
title: 도메인 주도 설계
date: "2020-12-15T10:00:03.284Z"
tags:
  - javascript
  - DDD
keywords:
  - DDD
---

> 이 글은 "도메인 주도 설계 철저 입문 책"을 읽고 정리한 내용입니다. 문제가 될 시 삭제하겠습니다.

## 도메인 주도 설계란?

- 도메인은 영역이라는 뜻이다. 프로그램에서는 프로그램이 쓰이는 대상 분야 이다.
- 도메인에 중요한 점은 도메인에 포함되는 것이 무엇인가 하는 것이다.
- 도메인에 포함되는 개념은 시스템의 대상 분야가 무엇인지에 따라 달라진다.
- 모델은 현실에 일어나는 사건 혹은 개념을 추상화한 개념이다.
- 사건 혹은 개념을 추상화 하는 작업을 모델링이라고 한다.
- 모델링의 결과를 모델이라고 한다.
- 도메인 개념을 모델링한 모델을 도메인 모델이라고 한다.
- 도메인 모델을 소프트웨어 형태의 동작하는 모듈로 나타낸 것이 도메인 객체다.

### 도메인 주도 설계 정리

- 사건 또는 개념을 추상화 하는 작업 -> 모델링
- 모델링의 결과 -> 모델
- 도메인 모델을 소프트웨어 형태의 동작하는 모듈 -> 도메인 객체

## 값 객체

- 프로그래밍 언어에서 원시 데이터 타입만 이용하는 것이 아니라 특유의 값을 정의 내릴때 사용하는 객체를 값 객체라고 한다.
- 객체 지향에서는 일반적으로 클래스를 사용해서 값 객체를 나타낸다.
- 객체이기도 하면서 동시에 값이기도 하다.
- 시스템 특유의 값을 나타내는 객체다.
- 값 객체는 데이터와 더불어 그 데이터에 대한 행동을 한곳에 모아둠으로써 자신만의 규칙을 갖는 도메인 객체가 된다.

### 값 객체 성질

- 값은 변화하지 않은 성질을 갖는다.
- 변수에 대입은 값을 수정하는 과정이 아닌 대팅을 통해 변수의 내용이 수정될 뿐 값 자체가 수정되는 것은 아니다.
- 교환 가능하다.
- 값은 값 자신이 아니라 값을 구성하는 속성을 통해 비교된다. (등가성을 비교할 수 있다. ex. === )

## 엔티티

- 엔티티 또한 도메인 모델을 구현한 도메인 객체다.
- 값 객체와 차이는 동일성을 통해 식별이 가능한지 아닌지에 있다.
- 엔티티는 속성이 아닌 동일성으로 식별되는 객체다.

### 엔티티 성질

- 값 객체는 불변성이지만 엔티티는 가변성을 갖는 객체다.
- 값 객체는 속성이 같다면 같은것으로 취급되었지만 엔티티는 속성이 같아도 두 엔티티를 서로 다른 것으로 취급힌다.
- 서로 다른 엔티티를 구별하는데는 식별자가 쓰인다.
- 엔티티는 동일성을 지니고 있다. (ex. 사용자 명이 바뀌더라도  같은 사용자로 인식해야 한다.)

### 엔티티 판단 기준

- 생애주기를 가지며 연속성을 갖는 개념은 엔티티로 판단하기에 문제가 없다.
- 같은 대상이라도 어떤 환경에 있느냐에 따라 모델링 방법이 달라진다.

## 도메인 서비스

- 서비스는 클라이언트를 위해 무언가를 해주는 객체를 말한다.
- 서비스는 크게 두가지로 나뉜다. 도메인을 위한 서비스 와 애플리케이션을 위한 서비스
- 도메인 서비스란 값 객체나 엔티티로 구현하기 어색한 행동을 해결해 주는 객체다.
  - User 엔티티에 사용자명의 중복 여부를 확인하는 행위는 어색하다.
- 도메인 서비스는 자신의 행동을 바꿀 수 있는 인스턴스만의 값을 갖지 않는다는 점에서 값 객체나 엔티티와 다르다.
- 엔티티나 값 객체에 정의하기 부자연스러운 처리는 도메인 서비스에 정의하면 된다.
- 우선 엔티티나 값 객체에 정의하는 것이 좋으며, 도메인 서비스에 행위를 구현하는 것은 가능한한 피해야 한다.
- 도메인 서비스에는 데이터 스토어를 직접 다루는 내용이 들어가지 않도록 하자. ( 간적접으로 리포지토리 패턴으로 이러한 문제를 해결하자.)
- 도메인에는 도메인 객체에 구현하기 자연스럽지 못한 행위가 있다.

## 리포지토리

- 데이터와 관계된 처리를 분리하자.
- 리포지토리는 데이터 보관창고를 의미한다.
- 메모리에 로드된 데이터는 프로그램을 종료하면 사라져 버리기 때문에 데이터스토어에 저장을 해야한다.
- 리포지토리는 데이터를 저장하고 복원하는 처리를 추상화 하는 객체다.
- 리포지토리의 책임은 도메인 객체를 저장하고 복원하는 퍼시스턴시다.
- 객체의 퍼시스턴시와 관련된 처리를 리포지토리에 맡기면 비즈니스 로직을 더욱 순수하게 유지할 수 있다.
- 도메인의 지식이 리포지토리로 넘어가선 안된다. 만약 리포지토리로 어쩔 수 없이 넘어가게 된다면 도메인 지식이 도메인 객체에서 보여지도록 해야한다. (ex. 리포지토리에 넘어가는 매개변수를 통해서라도)
- 리포지토리에 정의되는 행위는 객체의 저장 및 복원에 대한 것이다.
- 불필요하게 수정 메서드가 정의된 리포지토리는 옳지 않다. 객체가 저장하고 있는 데이터를 수정하려면 애초부터 객체 자신에게 맡기는 것이 옳다.
- 객체를 생성하는 처리도 리포지토리에 정의해서는 안된다.

## 애플리케이션 서비스

- 애플리케이션은 유스케이스를 구현하는 객체라고 할 수 있다.
- 애플리케이션은 일반적으로 이용자의 목적에 부응하는 프로그램을 의미한다. 목표는 이용자의 필요를 만족시키고 목적을 달성하게 하는 것이다.
- 도메인 객체의 힘을 하나로 엮어 올바른 방향으로 이끌어야 한다.
- 애플리케이션 서비스에서 도메인 객체를 직접 리턴(공개) 하지 않고(비공개) 클라이언트에 데이터 전송을 위한 객체(DTO, data transfer object)를 만들어 여기에 데이터를 옮겨 넣어 반환한다.
- DTO를 사용하면 클라이언트는 도메인 객체의 메서드를 직접 호출할 수 없다.
- 커맨드 객체를 사용하면 애플리케이션 메서드에서 파라미터가 추가되더라도 메서드의 시그니처(메서드의 리턴타입과 매개변수)를 바꿀 필요가 없게 한다.
- 커맨드 객체는 어떤 처리의 퍼사드 역할을 한다. (퍼사드는 복잡한 코드를 간략화해 노출하는 인터페이스를 의미한다.)
- 애플리케이션 서비스는 도메인 객체가 수행하는 태스크를 조율하는 데만 전념해야 한다.
- 도메인 규칙은 도메인 객체에 구현하고 애플리케이션 서비스는 이 도메인 객체를 사용하는 역할만 맡는다.
- 응집도는 모듈의 책임 범위가 얼마나 집중 되어 있는지를 나타내는 척도다.
- 응집도가 높으면 모듈이 하나의 관심사에 집중하고 있다는 의미이므로 모듈의 견고성, 신뢰성, 재사용성, 가독성의 측면에서 바람직하다.
- 응집도를 측정하는 방법에는 모든 인스턴스 변수가 모든 메서드에서 사용돼야 한다는 관점에서 인스턴스 변수의 개수와 메서드의 수를 통해 응집도를 계산한다.
- 응집도를 높히려면 서로 관계 된 것들끼리 분리를 해두면 응집도가 높아진다.

### 서비스란 무엇인가?

- 서비스는 클라이언트를 위해 무언가를 해주는 존재다.
- 예를 들어 사용자명 중복 확인은 도메인의 활동이다. 이를 제공하는 서비스 객체는 도메인 서비스, 도메인 서비스는 도메인 지식을 나타낸 도메인 객체다.
- 애플리케이션은 이용자의 문제를 해결하기 위한 것이다. 이들 처리는 애플리케이션 고유의 행동이며 이들이 정의된 서비스도 애플리케이션의 서비스가 된다.
- 서비스는 자신의 행동을 변화시키는 것을 목적으로 하는 상태를 갖지 않는다.

### 애플리케이션 서비스 정리

- 애플리케이션 서비스는 도메인 객체를 다루는데 전념하며 유스케이스를 구현한다.
- 애플리케이션 서비스를 구현할 때는 도메인 규칙에 대한 기술이 포함되지 않게 주의한다.

## 의존 관계 역전 원칙

- 의존은 어떤 객체가 다른 객체를 참조하면서 발생한다.

```javascript
// ObjectA 가 의존하는 객체
// ObjectB 가 의존하는 대상
class ObjectA {
  constructor() {
    this.objectB = new ObjectB();
  }
}
```

- 의존하는 객체에서 의존의 대상이 되는 객체 쪽으로 향하는 화살표를 통해 나타낸다.
- 인터페이스와 그 구현체가 되는 구상클래스 사이에도 의존 관계가 생긴다. (일반화 관계)
- 구현 클래스를 참조하기 보다는 인터페이스를 참조해서 그 인터페이스를 구현한 어떤 클래스라도 인자로 받을 수 있게 하자.
- 추상 타입을 사용하면 기존에 구상 타입을 향하던 의존 관계 화살표가 추상 타입을 향하게 된다.

### 의존 관계 역전 원칙이란

- 추상화 수준이 높은 모듈이 낮은 모듈에 의존해서는 안되며 두 모듈 모두 추상 타입에 의존해야 한다.
  - 애플리케이션 서비스(추상화 높음) 데이터 스토어를 다루는(추상화 낮음) 모듈에 의존하면 안된다.
  - 일반적으로 추상 타입은 자신을 사용할 클라이언트가 요구하는 정의다. 즉, 추상타입 `IUserRepository`라는 인터페이스는 `UserApplicationService`를 위해 존재하는 것이다.
- 추상 타입이 구현의 세부 사항에 의존해서는 안된다. 구현의 세부 사항이 추상 타입에 의존해야 한다.
  - 주체가 되는 것은 추상화 수준이 높은 모듈, 추상 타입어야아 한다. 추상화 수준이 낮은 모듈이 주체가 되어서는 안 된다.
  - 추상화 수준이 높은 모듈은 낮은 모듈을 잉요하는 클라이언트다. 클라이언트가 할 일은 어떤 처리를 호출하는 선언이다.
  - 인터페이스는 구현할 처리를 클라이언트에 선언하는 것이며 주도권은 인터페이스를 사용할 클라이언트에 있다.

### Service Locator 패턴

- ServiceLocator 객체에 의존 해소 대상이 되는 객체를 미리 등록해 둔 다음, 인스턴스가 필요한 곳에서 ServiceLocator를 통해 인스턴스를 받아 사용하는 패턴이다.
- 단점으로는 의존관계를 외부에서 보기가 어렵다는 점과 테스트 유지가 어렵다는 점이다.

### IoC Container 패턴

- IoC Container(DI Container)
- IoC는 Inversion of Control '제어의 역전' 이라는 뜻이다.
- Denpendency Injection 패턴은 '의존 관계 주입' 이라고 번역할 수 있다.
- 개발 중에 A 라는 의존성을 매개변수로 주입했다면 운영중엔 당연히 운영 버젼인 B의 의존성을 주입해야한다. 이런 번거로움을 줄이고자 IoC Container 패턴을 사용한다.
- IoC Container 에서는 의존 관계 해소를 위해 설정을 먼저 등록하고 IoC Container를 통해 필요한 인스턴스를 받아온다.

## 소프트웨어 시스템 구성하기

- 애플리케이션에 사용자 인터페이스 등을 추가해 독립적인 시스템으로 기능할 수 있게 만든 것을 소프트웨어로 구분한다.
- 컨트롤러는 프런트 엔드에서 받은 데이터를 비즈니스 로직에 필요로 하는 입력 데이터로 변환하는 작업에만 집중한다. 컨트롤러의 책임은 입력을 변환하는 것이다.
- 사용자 인터페이스를 소프트웨어의 핵심과 분리하고 객체의 책임을 명료하게 나누자.
- 단위 테스트가 갖춰져 있다면 리팩토링이 기존 기능을 망가뜨리지 않음을 확인하면서 작업을 진행할 수 있다.
  - 단위테스트는 어떤 입력이 들어와야 하는지, 그리고 그 입력에 대한 결과가 어떠해야 하는지를 기술하는 요령으로 작성한다.

## 팩토리 패턴

- 객체 생성을 책임지는 객체를 마지 도구를 만드는 공장과도 같다고 해서 '팩토리' 라고 부른다. 팩토리는 객체의 생성 과정과 관련된 지식이 정리된 객체다.
- 클래스 자체가 아닌 메서드가 팩토리 역할을 하는 경우도 있다. 이런 방법은 객체 내부의 데이터를 이용해 인스턴스를 생성할 필요가 있을 때 흔히 쓰인다.
- 팩토리를 통해 생성 절차가 복잡한 객체를 생성하면 코드의 의도를 더 분명히 드러낼 수 있다. 그리고 똑같은 객체 생성 코드가 중복되는 것도 막을 수 있다.

## 데이터 무결성

- 데이터 무결성이란 '서로 모순이 없고 일관적' 이라는 뜻이다.
- 데이터의 무결성을 유지 할 수 있는 방법으로는 다음과 같은 방법들이 있다.
  - 유일 키 제약
  - 트랜잭션

### 데이터 무결성을 유지하면서도 특정 기술에 의존하지 않는 패턴

- 트랜잭션 범위를 사용하는 패턴
  - 비즈니스 로직의 입장에서 생각하면 무결성을 지키는 수단이 무엇이냐는 그리 중요하지 않다.
  - 비즈니스 로직에서는 데이터 무결성을 확보하기 위한 구체적인 구현 코드 보다는 '이 부분에서 데이터 무결성을 확보해야 한다'는 것을 명시적으로 보여주는 코드가 담겨야 한다.
- AOP(관점 지향 프로그래밍)을 사용하는 패턴
  - AOP에서는 소스 코드를 수정하지 않고도 새로운 처리를 추가할 수 있다.
- 유닛오브워크를 사용하는 패턴
  - 유닛오브워크는 어떤 객체의 변경 사항을 기록하는 객체다.
  - 객체를 읽어 들일 때 유닛오브워크가 객체의 상태를 기록한다.
  - 커밋을 호출해야 그때까지 있었던 변경 사항이 데이터스토어에 반영된다.
  - 퍼시스턴시 대상이 되는 객체의 생성, 변경, 삭데 등의 동작이 모두 유닛오브워크를 통하게 된다.

## 애그리게이트

- 애그리게이트는 불변 조건을 유지하는 단위로 꾸려지며 객체 조작의 질서를 유지한다.
- 애그리게이트는 경계와 루트를 갖는다.
  - 애그리게이트의 경계는 애그리게이트에 포함되는 대상을 결정하는 경계다.
  - 애그리게이트의 루트는 애그리게이트에 포함되는 특정한 객체다.
- 외부에서는 애그리게이트 내부에 있는 객체를 조작할 수 없다.
- 애그리게이트를 조작하는 직접적인 인터페이스가 되는 객체는 애그리게이트 루트 뿐이다.
- 객체 지향 프로그래밍에서는 외부에서 내부 객체를 직접 다루는 대신 내부 객체를 감싸는 객체에 요청하는 형태를 취한다. (데메테르 법칙)
- 데메테르 법칙은 어떤 컨텍스트에서 다음 객체의 메서드만을 호출할 수 있게 한다.
  - 객체 자신
  - 인자로 전달받은 객체
  - 인스턴스 변수
  - 해당 컨텍스트에서 직접 생성한 객체

### 애그리게이트의 경계를 어떻게 정할 것인가

- 애그리게이트의 경계 중 가장 흔히 쓰이는 것은 '변경의 단위' 이다.
- 식별자를 이용한 컴포지션을 사용하자. (ex. 서클 객체에 유저 인스턴스를 저장하는 것이 아닌 유저의 식별자를 저장하도록 바꾸는 것이다.)
  - 이런 방법을 사용하면 서클의 members 프로퍼티를 공개하더라도 유저 객체의 메서드를 호출하는 일이 없다.
  - 메모리도 절약된다.

### 애그리게이트의 크기와 조작 단위

- 애그리게이트의 크기는 가능한 작게 유지하는 것이 좋다.
- 한 트랜잭션에서 여러 애그리게이트를 다루는 것도 가능한 피해야 한다.

### 언어 표현과의 모순 제거

- 언어 표현과 숫자 표기의 모순을 막기 위해선 모순이 되는 현상에 대해서 메서드를 추가해서 필요한 곳 마다 메서드를 호출하게 하자.

## 명세

- 명세는 어떤 객체가 그 객체의 평가 기준을 만족하는지 판정하기 위한 객체다.
- 복잡한 평가 절차가 필요하다면 평가 절차를 평가 대상 객체의 메서드로 두는 것이 자연스럽지 못한 경우가 있다.
- 명세라는 객체를 이용하면 엔티티나 값 객체가 리포지토리를 다루지 않으면서 도메인 객체에 명세조건 확인을 위해 리포지토리 객체를 받는 이런 문제는 해결할 수 있다.
- 명세는 객체가 조건을 만족하는지 확인하는 역할만을 수행한다.
- 리포지토리와 함께 사용할때는 리포지토리가 명세를 전달 받아 명세에 정의된 조건과 합치하는 객체를 검색하는 방법이다.

### 명세와 리포지토리를 함께 사용했을때 성능 문제는

- CQS 혹은 CQRS 라는 개념을 따서 객체의 메서드를 성격에 따라 커맨드와 쿼리로 크게 나눠 다르게 다루는 것이 요점인데, 프레젠테이션 계층의 성능적인 요구를 만족하면서도 시스템의 통제를 늦추지 않은 효과를 거둘 수 있다.
- 지연실행을 이용한 최적화를 하자.

## 아키텍쳐
