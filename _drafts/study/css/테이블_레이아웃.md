# 테이블 레이아웃

## 14.1 테이블 포멧

테이블이 어떻게 만들어지는지, 테이블 안에 있는 요소들이 테이블과 어떻게 관계하는지 같은 기본적인 개념들을 테이블 포멧이라 부른다.

### 14.1.1 테이블의 시각적 배열

CSS는 테이블 요소와 테이블 내부 요소를 구분한다.
테이블 내부 요소는 사각형 박스를 형성하고, 이 박스에는 콘텐츠, 패딩, 보더가 있지만 마진은 없다. 따라서 테이블 셀에 마진을 적용해서 서로를 구분할 수 없다. 단, 캡션은 예외이다.

테이블 배열에는 여섯가지 기본 규칙이 있다. 이들 규칙 기준은 테이블을 구성하는 선인 그리드 라인 사이의 영역인 `그리드 셀`이다.

> 그리드는 그리드 레이아웃의 그리드가 아니라 바둑판 모양을 말하는 것이다.

그리드 셀은 이론적 구조이며 문서객체모델(DOM)을 통해 접근하거나 스타일을 적용할 수 없다. 그리드 셀은 그저 테이블이 어떻게 만들어지는지를 설명하기 위한 수단이다.

#### 14.1.1.1 테이블 배열 규칙

* 각 **행 박스**는 그리드 셀 행 하나를 포함한다. 방향은 위쪽에서 아래쪽으로 채우고 단, 테이블 헤더나 테이블 푸터 행 박스는 각각 테이블의 맨 위와 맨 아래에 위치한다.
* **행 그룹** 박스는 자신이 포함한 행 박스의 그리드 셀 역시 포함한다.
* **열 박스**는 하나 이상의 그리드 셀 열을 포함한다. 쓰는 언어의 순서에 따라 첫 번째 열 박스가 위치하는 순서가 달라진다.
* **열 그룹** 박스는 자신이 포함한 열 박스의 그리드 셀 역시 포함한다.
* 셀은 여러 행이나 열로 확장할 수 있다. 확장 방법은 문서 언어에서 정의한다. 확장된 셀은 하나 이상의 그리드 셀로 구성된 사각형 박스이다.
* 셀 박스는 테이블이나 행 그룹의 마지막 행 박스를 너어 확장할 수 없다.

> CSS 명세에서는 테이블 셀과 다른 테이블 내부 요소에 포지션을 지정하지 않길 권장한다. 현재 브라우저에서는 테이블 요소에 포지션을 지정할 수 있다. 확장

그리드 셀은 사각형으로 정의되지만 크기가 같을 필요는 없다. 같은 그리드열에 포함된 그리드 셀의 너비는 모두 같고, 그리드 행에 포함된 그리드 셀의 높이는 모두 같지만 그리드 행 높이는 다른 그리드 행의 높이와 다를 수 있다.

### 14.1.2 테이블 디스플레이 값

테이블 관련 값만 살펴 본다.

**table**

이 값은 요소를 블록 레벨 테이블로 정의합니다.

**inline-table**

이 값은 요소를 인라인 레벨 테이블로 정의한다. 즉 인라인 박스를 형성하는 사각형 블록이다.

**table-row**

이 값은 요소를 테이블 셀 행으로 정의한다. 대응하는 HTML 요소는 tr이다.

**table-row-group**

이 값은 요소를 하나 이상의 테이블 행 그룹으로 정의한다. 대응하는 HTML 요소는 tbody이다.

**table-header-group**

이 값은 헤더 행 그룹은 항상 위쪽 캡션의 아래, 다른 행이나 행 그룹보다 위에 표시된다. 출력 매체에서 테이블이 여러 페이지로 나뉜다면 사용자 에이전트는 헤더 행을 각 페이지마다 반복할 수 있다. 대응하는 HTML 요소는 thead이다.

**table-footer-group**

푸터 행 그룹은 항상 다른 행이나 행 그룹의 아래, 아래쪽 캡션의 위에 표시된다. 출력 매체에서 테이블이 여러 페이지로 나뉜다면 사용자 에이전트는 푸터 행을 각 페이지마다 반복할 수 있다. 대응하는 HTML 요소는 tfoot이다.

**table-column**

이 값은 요소를 테이블 셀 열로 정의한다. 이 값을 가진 요소는 마치 display:none 값을 가진 것처럼 시각적으로 렌더링되지 않는 것으로 정의한다. 이 값은 열에 속한 셀의 표현을 돕는 목적이 대부분이다. 대응하는 HTML 요소는 col이다.

**table-column-group**

이 값은 요소를 하나 이상의 열 그룹으로 정의한다. 렌더링되지 않지만 열 그룹에 속한 요소의 표현을 돕는다. 대응하는 HTML 요소는 colgroup이다.

**table-cell**

이 값은 요소를 테이블 셀로 정의한다. 대응하는 HTML 요소는 th와 td이다.

**table-caption**

이 값은 테이블의 캡션을 정의한다. 테이블이나 inline-table 요소에 display:caption 값을 적용한 요소를 하나 이상 넣어서는 안된다.

#### 14.1.2.1 행 우선

CSS는 테이블 모델을 '행 우선'으로 정의한다. 테이블 모델은 저자가 행을 명시적으로 선언하는 마크업 언어를 사용한다고 간주한다. 반면 열은 셀 행의 레이아웃에서 유추한다. 즉 첫 번째 열은 각 행의 첫 번째 셀로 구성되고, 두 번째 열은 두 번째 셀로 구성되는 식이다.

#### 14.1.2.2 열

CSS 테이블 모델은 행 우선이지만 열 역시 레이아웃의 일부이다. 셀은 문서 소스에서 행 요소의 자손이긴 하지만 행과 열 어느방향으로든 확장할 수 있다. 하지만 CSS에서 열과 열 그룹은 테이블 전용이 아닌 border, background, width, visibility 프로퍼티만 받을 수 있다.

**border**

보더는 border-collapse 프로퍼티 값이 collapse일 때만 열과 열 그룹에 적용할 수 있다.

**background**

열이나 열 그룹의 배경은 셀과 행의 배경이 모두 투명한 셀에서만 보인다.

**width**

width 프로퍼티는 열이나 열 그룹의 최소 너비를 정의한다. 해당 열이나 열 그룹의 콘텐츠에 따라 늘어날 수 있다.

**visibility**

열이나 열 그룹의 visibility 값이 collapse이면 해당 열이나 열 그룹은 렌더링 되지 않는다. 병합된 열에서 다른 열로 확장한 셀은 잘리고, 다른 열에서 병합된 열로 확장한 셀도 마찬가지이다. 또한 테이블 전체적인 너비 역시 해당 열의 너비만큼 줄어든다. 열이나 열 그룹은 collapse 이외의 visibility 값 선언은 무시한다.

#### 14.1.3 익명 테이블 객체

```html
<table>
  <td>Name:</td>
  <td><input type="text"></td>
</table>
```

위 마크업은 행 하나에 셀이 두 개 있는 테이블이라고 생각할 수 있지만 tr이 없으므로 행을 정의하는 요소가 없다.

이런 경우 CSS에서는 '누락된' 테이블 구성 요소를 익명 객체로 삽입하는 메커니즘이 있다. CSS의 관점에서 다음과 같이 익명 table-row 객체가 table 요소와 자손 테이블 셀 사이에 삽입된다.

```html
<table>
  <!-- 익명의 table-row 객체가 시작된다. -->
  <td>Name:</td>
  <td><input type="text"></td>
  <!-- 익명의 table-row 객체가 끝난다. -->
</table>
```

CSS 테이블 모델에서는 총 일곱 가지 익명 객체 삽입이 일어날 수 있다. 이 일곱가지 규칙은 상속과 명시도처럼 CSS가 직관적으로 동작하려고 하는 매커니즘의 한 예다.

#### 14.1.3.1 객체 삽입 규칙

1. table-cell 요소의 부모가 table-row 요소가 아니라면 익명의 table-row 객체를 table-cell 요소와 그 부모 사이에 삽입한다.
2. table-row 요소의 부모가 table, inline-table, table-row-group 요소가 아니면 익명의 table 요소가 table-row 요소와 부모 사이에 삽입된다. 삽입된 객체는 table-row 요소의 형제를 모두 포함한다.
3. table-column 요소의 부모가 table, inline-table, table-column-group 요소가 아니면 익명의 table 요소가 table-column 요소와 부모 사이에 삽입된다.
4. table-row-group, table-header-group, table-footer-group, table-column-group, table-caption 요소의 부모가 table 요소가 아니라면 익명의 table 객체가 요소와 부모 사이에 삽입된다.
5. table이나 inline-table 요소의 자식 요소가 table-row-group, table-header-group, table-footer-group, table-row, table-caption 요소가 아니라면 익명의 table-row객체가 table 요소와 자식 요소 사이에 삽입된다.
6. table-row-group, table-header-group, table-footer-group 요소의 자식 요소가 table-row 요소가 아니면 익명의 table-row 객체가 요소와 자식 요소 사이에 삽입된다.
7. table-row 요소의 자식 요소가 table-cell 요소가 아니면 익명의 table-cell 개게가 table-row 요소와 자식 요소 사이에 삽입된다.

#### 14.1.4 테이블 레이어

CSS는 여섯 가지 '레이어'를 통해 테이블을 구성한다.

![테이블 표현에 쓰이는 레이어](https://www.w3.org/TR/CSS22/images/tbl-layers.png)

그림에서 알 수 있는 가장 중요한 사실은 열 스타일이 행 스타일보다 아래 있으므로 행의 배경이 열의 배경 위에 그려질 거라는 것이다.

### 14.1.5 캡션

테이블 캡션은 테이블의 콘텐츠에 대한 간단한 설명이다. caption-side 프로퍼티를 사용해서 캡셔을 마크업 순서와 상관없이 테이블의 위나 아래에 배치할 수 있다.

```css
.caption {caption-side: top | left;}
```

CSS 명세에서는 캡션을 테이블 박스 바로 앞(또는 바로 다음)에 존재하는 블록 박스와 마찬가지로 렌더링한다고 규정했지만 테이블에서 프로퍼티 값을 상속할 수 있다는 점은 예외이다.
캡션은 거의 블록 레벨 요소와 비슷하게 스타일을 지정받을 수 있다. 패딩, 보더, 배경 등을 모두 사용할 수 있다.

## 14.2 테이블 셀

CSS에는 두 가지 보더 모델이 있다. 레이아웃 관점에서 셀들이 서로 떨어져 있을 대는 **분리 보더 모델**이 적용된다. 셀들 사이에 눈으로 보이는 구분이 없고 셀 보더가 병합될 때는 **결합 보더 모델**이 적용된다.
CSS 이전 버전에서는 결합 모델이 기본값이었지만 지금은 분리 모델이 기본값이다.

border-collapse 프로퍼티를 사용해서 두 모델을 선택할 수 있다.

```css
.collapse {border-collapse: collapse | seperate | inherit;}
```

collapse 값을 사용하면 결합 모델이 적용된다. seperate이면 분리 모델이 적용된다.

### 14.2.1 분리된 셀 보더

이 모델은 테이블의 셀들 사이에 약간의 거리가 있으며, 셀 보더는 서로 결합되지 않는다.

#### 14.2.1.1 보더 간격

테이블 셀 보다를 구분하기로 했다면 각 보더 사이에 간격이 좀 있어야 할 때가 있을 것이다. border-spacing 프로퍼티를 사용하면 된다.

```css
.spacing {border-spacing: <length> <length>?}
```

이 프로퍼티 값으로는 1개 또는 2개를 사용할 수 있다. 1개 값으로 사용을 하게 되면 모든 셀 간격을 고르게 정하게 되고 셀 간격을 가로와 세로로 나눠서 쓰려면 2개의 값으로 사용하면 된다.

```css
.spacing {border-spacing: 1px;}
.spacing {border-spacing: 1px 5px;} /* 가로 1px 간격, 세로 5px 간격 */ 
```

거리 값은 테이블 가장자리에 있는 셀과 테이블 요소 자체의 패딩 사이에도 적용된다.

border-spacing 값은 개별 셀이 아니라 테이블 자체에 적용된다. 만약 border-spacing을 td 요소에 적용했다면 무시됐을 것이다.
구분된 보더 모델에서는 행, 행 그룹, 열, 열 그룹에 보더를 사용할 수 없다.

#### 14.2.1.2 빈 셀 처리

셀은 모두 독립된 공간이다. 셀이 콘텐츠 없이 비어있다면 두가지 선택이 있고, empty-cells 프로퍼티 값으로 결정할 수 있다. 디스플레이 값이 table-cell인 요소에 적용된다.

```css
.empty-cell {empty-cells: show | hide;}
```

이 프로퍼티는 border-collapse 값이 seperate가 아니면 무시됩니다.

empty-cells 값이 show이면 빈 셀의 보더와 배경은 콘텐츠가 있는 테이블 셀과 마찬가지로 그려진다. 값이 hide이면 해당 셀은 마치 visibility: hidden을 선언한 것처럼 아무것도 그려지지 않는다.
여기서는 스페이스 CR, LF, 탭, 스페이스를 제외한 공백 문자도 모두 콘텐츠로 간주한다.

### 14.2.2 결합된 셀 보더

* display 값이 table, inline-table인 요소는 border-collapse 값이 collapse일때 마진은 가질 수 있지만 패딩은 가질 수 없다. 따라서 테이블의 보더와 셀 사이에는 아무 구분도 없다.
* 셀, 행, 행 그룹, 열, 열 그룹에 보더를 적용할 수 있다. 테이블 자체는 항상 보더를 가질 수 있다.
* 결합 모델에서는 셀 보더 사이에 아무 구분도 없다. 인접한 보더는 하나로 합쳐진다.
* 결합된 보더는 셀 사이의 가상의 그리드 라인 중앙에 존재한다.

### 14.2.2.1 결합 보더 레이아웃

![결합 모델을 사용한 테이블 행의 레이아웃](https://devopspoints.com/uploads/library/css3/img_5db27b066c167.png)

셀 사이의 보더에서 보더 절반은 셀 사이의 그리드 라인 왼쪽에 있고 나머지 절반은 오른쪽에 그려지게 된다. 어떤 경우든 보더는 하나만 그려진다.

바깥쪽 보더가 테이블 너비 바깥에 존재하는 것이 보인다. 결합 모델에서는 테이블 보더 절반이 너비에 포함되기 때문에 나머지 절반은 마진 안에 들어있게 된다. 하지만 크롬 기준으로 테스트 해보면 나머지 절반도 table width로 잡혀있는것을 확인할 수 있다.

예를 들어 다음과 같은 코드가 있다고 했을 때 테이블의 넓이는 256px이 나오고 행 너비는 254px이 나오는것을 확인 할 수 있다.

```html
<table>
  <colgroup>
    <col width="auto"/>
    <col />
  </colgroup>
  <tbody>
    <tr>
      <td class="a1">1</td>
      <td class="a2">2</td>
    </tr>
     <tr>
      <td>1</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
```

```css
* {padding:0;}

table {
  border-collapse: collapse;
}

td {
  border: 2px solid black;
}

.a1 {
  width: 150px;
}
.a2 {
  width: 100px;
}
```

보더가 홀수 넓이를 지니고 있다면 사용자 에이전트가 보더를 그리드 라인의 중앙에 배치하는 방법을 스스로 결정하게 된다.

#### 14.2.2.2 보더 결합

둘 이상의 보더가 인접하면 우선권을 갖기 위해 경쟁한다. 어떤 보더가 우선권을 갖는지는 엄격한 규칙에 의해 정해진다.

* 충돌하는 보더 중 하나의 border-style이 hidden이면 이 보더의 우선권이 가장 높다. 이 위치의 보더는 모두 숨겨진다.
* 충돌하는 보더 중에 넓을 수록 우선순위가 높다.
* 충돌하는 보더의 너비가 모두 같지만 보더 스타일이 다르다면 double, solid, dashed, dotted, ridge, outset, groove, inset, none 순서로 우선순위가 정해진다.
* 충돌하는 보더의 스타일과 너비가 모두 같지만 색깔이 다르다면 셀, 행, 행 그룹, 열, 열 그룹, 테이블 순서로 우선순위가 정해진다. 만약 셀과 열의 보더가 다 같고 색상이 충돌한다면 셀의 보더 색깔에 맞는 보더가 그려진다. 요소 타입마저 같다면 왼쪽에서 오른쪽으로 쓰는 언어 기준으로 위쪽과 왼쪽에 가까운 색깔을 사용한다.

## 14.3 테이블 크기

테이블 너비를 결정할 때는 **고정폭 레이아웃** 과 **가변폭 레아아웃** 두 가지가 쓰인다. 높이는 너비 알고리즘과 관계 없이 자동으로 계산된다.

### 14.3.1 너비

테이블 너비 계산 방법을 선언할 때는 table-layout 프로퍼티를 사용한다.

```css
.table-layout {table-layout: auto | fixed;}
```

어떤 모델을 택하느냐에 따라 테이블 레이아웃이 달라지긴 하지만 두 모델의 기본적인 차이는 속도이다. 너비가 고정된 테이블 레이아웃을 사용하면 사용자 에이전트는 가변폭 모델에 비해 테이블 레이아웃을 더 빨리 계산할 수 있다.

#### 14.3.1.1 고정폭 레이아웃

고정폭 모델을 사용하는 주된 이유는 이 레이아웃이 테이블 셀 콘텐츠에 의존하지 않기 때문이다. 고정폭 모델은 테이블, 열, 셀의 너비 값을 사용한다.

고정폭 모델은 다음과 같은 단계로 동작한다.

1. width 프로퍼티 값이 auto가 아닌 열 요소는 그 값이 열 전체의 너비이다.
2. 열의 너비가 auto 값일 때 이 열의 첫 번째 행에 있는 셀의 width 갑싱 auto가 아니라면 그 값이 열 전체의 너비이다. 해당 셀(첫 번째 행에 있는 셀)이 여러 열로 확장됐다면(colspan) 그 너비도 각 열로 나뉜다.
3. 이상의 과장을 거친 후에도 auto 너비인 열이 있으면 그 너비를 가능한 같게 맞춘다.

여기서 테이블 너비는 테이블의 width 값 또는 열 너비의 합께 중 큰 쪽이 된다.

이 방법이 빠른 이유는 테이블의 첫 번째 행을 읽어들이는 순간 모든 열의 너비를 다 알 수 있기 때문이다. 첫 번째 행을 지난 다음 행에 속한 셀들의 너비는 첫 번째 행에서 계산된 열 너비를 따른다. 두 번째 이후 행의 셀은 열 너비를 바꿀 수 없으므로 해당 행의 셀에 width 값이 있더라도 모두 무시된다.
셀의 콘텐츠가 셀에 다 들어가지 않는 경우 셀의 overflow 값에 따라 셀 콘텐츠를 자를지, 렌더링할지, 스크롤 바를 표시할지 결정한다.

테이블에 명시적은 width 값이 있으면 좋지만 고정폭 레이아웃 모델에서 반드시 필요한 건 아니다. 예를 들어서 다음과 같은 규칙이 있다고 했을때 부모 요소의 너비보다 50픽셀 작은 값이니 그 값을 고정폭 모델의 레이아웃 알고리즘에 사용한다.

```css
table {table-layout: fixed; margin: 0 25px; width: auto;}
```

#### 14.3.1.2 가변폭 레이아웃
