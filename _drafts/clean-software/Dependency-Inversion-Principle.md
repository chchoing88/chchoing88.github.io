---
title: 의존 역전 원칙
date: "2020-08-13T10:00:03.284Z"
tags:
  - javascript
  - OOP
keywords:
  - OOP
---

- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
- 추상화는 구체적인 사항에 의존해서는 안 된다.
- 실제로 이런 방법의 목표 중 하나는 상위 수준의 모듈이 하위 수준의 모듈을 호출하는 방법을 묘사하는 서브프로그램의 계층 구조를 정의하는 것이었다.

```uml
copy -- ReadKeyboard
copy -- WritePrinter
```

- 하위 수준의 모듈에 의존하는 상위 수준의 모듈이 의미하는 바를 생각해보자. 어떤 애플리케이션의 중요한 정책 의사결정과 업무 모델을 포함하고 있는 것은 상위 수준의 모듈로서, 이 모듈은 애플리케이션의 본질을 담고있다.
- 이런 상위 수준의 모듈이 하위 수준의 모듈에 의존할 때, 하위 수준 모듈의 변경은 상위 수준 모듈에 직접적인 영향을 미칠 수 있고, 이번엔 상위 수준의 모듈이 변경되게 할 수도 있다.
- 업무 규칙을 포함하는 상위 수준의 모듈은 구체적인 구현을 포함한 모듈에 우선하면서 동시에 독립적이어야 한다. 상위 수준의 모듈은 어떤 식으로든 하위 수준의 모듈에 의존해서는 안된다.
- 재사용하기 원하는 것은 전책을 결정하는 상위 수준의 모듈이다.

## 레이어 나누기

```uml
PolicyLayer ..> MechanismLayer
MechanismLayer ..> UtilityLayer
```

- 위 다이어그램은 Policy 레이어가 아래 Utility 레이어의 모든 변화에 민감하다는 특성이 함정으로 숨어 있다.
- 의존성은 이행적(transitive)이다.

> x,y,z 에 대해 x -> y 이고 y -> z 이면 x -> y 가 성립한다. 이를 z 가 x 에 이행적으로 함수 종속되었다고 한다.

```uml
PolicyLayer --> PolicyServiceInterface
PolicyServiceInterface <|-- MechanismLayer
MechanismLayer --> MechanismServiceInterface
MechanismServiceInterface <|-- UtilityLayer
```

- 위 uml에서 각 상위 수준 레이어는 그것이 필요로 하는 서비스에 대한 추상 인터페이스를 선언한다.
- 하위 수준의 레이어는 이 추상 인터페이스로부터 구체화된다.
- 각 상위 수준 클래스는 추상 인터페이스를 통해 다음 하위 수준의 레이어를 사용한다. 따라서 상위 레이어는 하위 레이어에 의존하지 않는다.
- 반대로 하위 레이어는 상위 레이어에 선언된 추상 서비스 인터페이스에 의존한다.

### 소유권 역전

- DIP가 적용된 경우에는 클라이언트가 추상 인터페이스를 소유하는 경향이 있고, 이들은 서버가 그것에서 파생해 나온다는 사실을 알게된다.
- 하위 수준의 모듈은 상위 수준의 모듈 안에 선언되어 호출되는 인터페이스의 구현을 제공한다.
- 더욱이 PolicyLayer 는 PolicyServiceInterface 에 맞는 하위 수준 모듈을 정의하는 어떤 문백에서든 재사용될 수 있다.

### 추상화에 의존하자

- 이 경험적 접근 방식은 구체 클래스에 의존해서는 안 되고 어떤 프로그램의 모든 관계는 어떤 추상 클래스나 인터페이스에서 맺어져야 한다고 충고한다.
  - 어떤 변수도 구체 클래스에 대한 포인터나 참조값을 가져선 안된다.
  - 어떤 클래스도 구체 클래스에서 파생되어서는 안 된다.
  - 어떤 메소드도 그 기반 클래스에서 구현된 메소드를 오버라이드해서는 안된다.
- 비휘발성(nonvolatile) 클래스에는 이 접근 방식을 적용할 이유가 없어 보인다. 하지만 우리가 애플리케이션 프로그램의 일부로 작성하는 대부분의 구체 클래스는 휘발적이다.
- 우리가 직접적으로 의존하지 않기를 원하는 구체 클래스가 바로 이것들이다. 이들의 휘발성은 이들을 추상 클래스 뒤에 숨겨둠으로써 분리될 수 있다. 하지만 이것은 완벽한 해결책이 아니다.
- 클라이언트 클래스가 자신이 필요로 하는 서비스 인터페이스를 선언한다는 장기적 관점을 택한다면, 이 인터페이스가 변경되는 경우는 오직 클라이언트가 변경을 필요로 할 때가 된다. 추상 인터페이스를 구현하는 클래스의 변경은 클라이언트에 영향을 주지 않는다.

## 간단한 예

### 내재하는 추상화를 찾아서

## 용광로 사례

### 동적 다형성과 정적 다형성

## 결론
