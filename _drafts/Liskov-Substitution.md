---
title: 리스코프 치환 원칙
date: "2020-08-11T10:00:03.284Z"
tags:
  - javascript
  - OOP
keywords:
  - OOP
---

리스코프 치환 원칙(`LSP`: Liskov Subsitution Principle) 은 다음과 같이 설명할 수 있다.

> 서브타입(subtype)은 그것의 기반 타입(base type)으로 치환 가능해야 한다.

- 이것을 위반한 결과를 생각해보면 분명해진다.
  - 어떤 함수 f 가 그 인자로 어떤 기반 클래스 B의 참조값을 갖는다고 생각해보자.
  - 그리고 클래스 B의 파생 클래스 D를 B를 가장해 함수 f 에 넘겼다고 생각해보자.
  - 이때, f 가 잘못된 동작을 하게 만든다면 이 경우 D는 LSP를 위반한다.

## LSP 위반의 간단한 예

```c++
void DrawShape(const Shape& s) {
  if(s.itsType == Shape :: square) {
    static_cast<const Square&>(s).Draw();
  } else if (s.itsType == Shape :: circle) {
    static_cast<const Circle&>(s).Draw();
  }
}
```

- DrawShape 함수는 OCP를 위반한다.
- DrawShape 함수는 Shape 클래스의 모든 가능한 파생 클래스를 알아야 하고, 또한 Shape의 새로운 파생 클래스가 생길 때마다 변경 되어야 한다.
- Square 와 Circle이 Shape를 대체할 수 없다는 것은 LSP 위반이며, 이 위반은 DrawShape 의 OCP(개방폐쇄원칙: 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.) 위반을 유발한다.

## 정사각형과 직사각형, 좀 더 미묘한 위반

```c++
class Rectangle {
  public:
    void SetWidth() {}
    void SetHeight() {}
    double GetHeight() const {}
    double getWidth() const {}
  private :
    Point itsTopLeft;
    double itsWidth;
    double itsHeight;
}
```

- Rectangle 클래스를 사용하는 어떤 애플리케이션을 생각해보자.
- 어느날, 사용자가 직사각형은 물론 정사각형(square)도 조작할 수 있게 해달라고 요구해왔다.
- 종종 상속은 IS-A(~이다) 관계라고 한다. 즉, 새로운 종류의 객체가 원래 종류의 객체와 IS-A 관계를 이룬다고 말할 수 있다면, 새 객체의 클래스는 원래 객체의 클래스에서 파생될 수 있어야 한다.
- 일반적인 개념상, 모든 정사각형은 직사각형이다. 따라서 아래와 같은 그림이 합리적이다.

```uml
Rectangle <|-- Square
```

Square는 Rectangle을 상속한다.

- 그러나 이런 식의 생각은 미묘하지만 심각한 문제를 낳을 수 있다. 일반적으로 이런 문제는 코드에서 보게 되기 전까지는 예측할 수 없다.
- 첫번쨰 증거는 Square가 itsHeight 와 itsWidth 멤버 변수를 필요로 하지 않는다는 사실이다.
- 다른 문제는 Square는 SetWidth 와 SetHeight 함수를 상속하는데, 정사각형의 가로와 세로 길이는 같으므로 이 함수들은 Square에서는 부적절하다.
- 함수들을 오버라이드 한다고 해도 다음과 같은 문제가 생겨날 수 있다.

```c++
void f(Rectangle & r) {
  r.SetWIdth(32) // Reactangle::SetWidth 를 호출한다.
}
```

- 만약 어떤 Square 객체에 대한 참조값을 이 함수에 넘겨준다면, 그 Square 객체는 세로 값이 가로 값에 맞춰 바뀌지 않기 때문에 문제가 생긴다. 이것은 명백한 LSP 위반이다.
- 이 문제는 virtual로 쉽게 고칠수 있지만 파생 클래스를 만드는 것이 기반 클래스의 변경으로 이어질때, 설계에 결점이 있음을 의미한다.

## 본질적인 문제

```c++
void g(Rectangle& r) {
  r.SetWidth(5);
  r.SetHeight(4);
  assert(r.Area() == 20);
}
```

- 위 함수를 보자 본직적인 문제는 **g의 작성자는 Rectangle의 가로 길이를 바꾸는 것이 세로 길이를 바꾸지는 않을 것이라고 생각한다는데 있다.**
- 함수 g는 Square/Reactangel 계층 구조에 대해 취약하다.
- Square 와 Rectangle 사이의 관계는 LSP를 위반한다.
- 불변식을 위반한 것은 Square의 제작자이다.
- Square 작성자는 Square 의 불변식을 위반하지 않았다. Rectangle에서 Square를 파생시킴으로써 Rectangle의 불변식을 위반하게 되었다.

## 유효성은 본래 갖추어진 것이 아니다

- LSP는 '모델만 별개로 보고, 그 모델의 유효성을 충분히 검증할 수 없다.' 라는 아주 중요한 결론을 내린다.
- 어떤 모델의 유효성은 오직 그 고객의 관점에서만 표현될 수 있다.
- 예를 들면 Square 와 Rectangle 클래스를 각각 별개로 검사한다면 자체 모순이 없고 유효하다는 결론을 내릴 것이다.
- 그러나 기반 클래스에 대해 합리적인 가정을 택한 이 기반 클래스를 사용하는 고객 프로그래머의 관점에서 이 클래스들을 본다면 이 모델은 깨지고 만다.
- 그 설계를 사용자가 택한 합리적인 가정의 관점에서 봐야한다. (단위 테스트에서 이런 합리적인 가정 문제가 나타난다.)
- 이것을 예상하려고 시도 하지 말고 관련된 취약성의 악취를 맡을 떄까지 명백한 LSP위반을 제외한 나머지 처리는 연기하자.

## 'IS-A'는 행위에 대한 것이다

- 정사각형은 직사각형일 수 있지만, g의 관점에서 볼때 Square 객체는 절대로 Rectangle 객체가 아니다.
- 이유는 Square 객체의 행위가 g가 기대하는 Rectangle 객체의 행위와 일치하지 않기 때문이다. 행위 측면에서 볼 때, Square는 Rectangle이 아니다.
- 행위야말로 소프트웨어의 모든 것이다.
- LSP는 OOD에서 IS-A 관계는 합리적으로 가정할 수 있고 클라이언트가 의존하는 행위와 관련이 있다는 점을 분명히 한다.

## 계약에 의한 설계

- 고객이 정말로 기대하는 것을 어떻게 알 수 있겠는가?
- 합리적인 추정을 명시적으로 만들어 LSP를 강제하는 테크닉이 있는데 이를 계약에 의한 설계(DBC: design by contract) 라고 한다.
- 이 계약은 모든 고객의 작성자가 신뢰할 수 있는 행위에 대해 알려준다.
- 이 계약은 각 메소드의 사전조건과 사후조건을 선언하는 것으로 구체화된다. 메소드를 실행하기 위해서는 사전 조건이 참이 되어야 하고 완료된 후에는 사후조건이 참이 됨을 보장해야한다.
- 마이어가 설명한 파생 클래스의 사전조건과 사후조건에 대한 규칙은 다음과 같다.

> 루틴 재선언(파생 클래스에서)은 오직 원래 사전조건과 같거나 더 약한 수준에서 그것을 대체할 수 있고, 원래 사후조건과 같거나 더 강한 수준에서 그것을 대체할 수 있다.

- 기반 클래스의 인터페이스를 통해 어떤 객체를 사용할 때 사용자는 그 기반 클래스의 사전조건과 사후조건만 알 수 있다. 따라서 파생된 객체는 이런 사용자가 기반 클래스가 요구하는 것보다 더 강한 사전조건을 따를 것이라고 기대할 수 없다.
- 즉, 파생된 객체는 기반 클래스가 받아들일 수 있는 것은 모두 받아들여야 한다. 또한 파생 클래스는 기반 클래스의 모든 사후조건을 따라야 한다.

## 단위 테스트에서 계약사항 구체화하기

- 계약은 또한 단위 테스트를 작성함으로써 구체화될 수 있다.
- 단위 테스트는 어떤 클래스의 행위를 철저하게 테스트함으로써, 그 클래스의 행위를 좀 더 분명하게 만들어준다.
- 고객 코드의 작성자는 단위 테스트를 관찰해서 그들이 사용하는 클래스에 대한 합리적 추정이 무엇인지 알고 싶어 할 것이다.

## 실제 예

### 동기

- '유계(bounded)' 라고 불리는 배열에 기반한 자료구조와 '무계(unbounded)' 라는 연결 리스트에 기반을 둔 자료구조에 기반을 둔 서드파티 클래스 라이브러리가 구매했다.
- 이 서드파티 클래스 인터페이스가 불편해서 추상 인터페이스로 이 서드파티 컨테이너를 포장했다.

```uml
Set <|-- Unbounded Set
Set <|-- Bounded Set

Unbounded Set -> Third Party Unbounded Set
Bouned Set -> Third Party Bounded Set
```

Container 클래스의 어댑터 레이어

- 이 구조는 2개의 서드파티 Set 변형 클래스를 통합하고 공통의 인터페이스를 통해 그것에 접근할 수 있게 만들어주었다.
- 실제로는 클라이언트가 Set 형의 인자를 받을 수 있고, 실제로 그것이 처리하는 Set이 bounded 종류이든 unbouned 종류이든 신경 쓰지 않을 것이다.

### 문제

- PersistentSet을 이 계층 구조에 추가하려고 한다. 영속 집합은 어떤 스트림에 쓰이고, 나중에 다른 애플리케이션에 의해서도 다시 읽힐 수 있는 집합이다.

```uml
Set <|-- PersistentSet

PersistentSet *- Third Party Persistent Set : <<delegates>>
PersistentObject <.. Third Party Persistent Set
```

- 서드파티 영속 집합에 추가되는 원소는 PersistentObject에서 파생되어야 한다.
- PersistentSet은 단순히 서드파티 영속 집합에 위임하는 역할을 하기 때문에, PersistentSet에 추가되는 원소는 PersistentObject에서 파생되어야 하는 것이다.
- 그럼에도 불구하고 Set 인터페이스는 이런 제약을 갖고 있지 않다.
- 어떤 클라이언트가 기반 클래스 Set에 멤버를 추가할 때, 그 클라이언트는 Set이 실제로 PersistentSet인지 아닌지 알 수 없다. 그러므로 클라이언트는 자신이 추가하는 원소가 PersistentObject에서 파생된 것인지 아닌지 알수 있는 방법이 없다.

```c++
template <typename T>
void PersistentSet :: Add(const T& t) {
  PersistentObject& p = dynamic_cast<PersistentObject&>(t);
  itsThirdPartyPersistentSet.Add(p);
}
```

- 위 코드는 PersistentObject 클래스에서 파생되지 않은 객체를 PersistentSet에 추가하려는 클라이언트가 있으면 런타임 에러가 발생한다.
- Set의 파생 클래스를 넘겨줄 때는 전혀 문제가 없었던 함수들이 PersistentSet을 넘겨줄 때는 런타임 에러를 발생시킨다.

### LSP를 따르지 않은 해결책

- 규정에 따라 해결했다.
- 소스코드에서 해결하지 않고 애플리케이션에 알려지지 않게 한다는 규정을 세웠다.
- 특정 모듈에만 알려져서 이 모듈이 영속 저장소에서 모든 컨테이너를 읽고 쓰는 책임을 지게 했다.

### LSP를 따르는 해결책

- PersistentSet이 Set과 IS-A 관계에 있지 않다는 사실과, 이 클래스가 Set의 적절한 파생 클래스가 아님을 일정한다.
- 멤버 여부 테스트, 순환 등을 허용하는 추상 인터페이스 아래 Set과 PersistentSet 모두를 형제 관계로 묶는 계층 구조를 만들 것입니다.
- 이것은 PersistentSet 객체들을 순환 검색할 수 있고, 멤버 여부 테스트할 수 있게 만들어줄 것입니다. 하지만 PersistentObject에서 파생되지 않은 객체를 PersistentSet에 추가할 수 있게 만들 수는 없습니다.

```uml
MemberContainer <| -- Set
MemberContainer <| -- PersistentSet

PersistentSet *- Third Party Persistent Set : <<delegates>>
PersistentObject <.. Third Party Persistent Set
```

## 파생 대신 공통 인자 추출하기

- 난해한 또 한가지 상속의 예는 Line과 LineSegment 예 입니다.
- LineSegment에는 Line에 선언된 모든 멤버 변수와 모든 멤버 함수를 필요로 합니다. 그리고 LineSegment에서는 고유의 멤버 함수인 GetLength가 추가되었고, IsOn 함수를 오버라이드합니다.
- 하지만 이 두 클래스는 미묘한 방식으로 LSP를 위반합니다.
- Line의 사용자는 당연히 직선상에 있는 모든 점이 이 안에 포함되기를 기대하지만 LineSegment의 많은 인스턴스에서는 이것이 실패합니다.
- 다형적인 행위에 있어서 미묘한 결점은 놔두는 것이 좀 더 적절한 대응인 경우도 드물게 있습니다.
- 하지만 LSP를 가볍게 포기해서는 안됩니다.
- 기반 클래스가 사용되는 곳에서 서브클래스가 항상 제대로 동작함을 보장하는 것은 복잡성을 다루는 강력한 방법입니다. 이것을 버린다면 각 서브클래스를 개별적으로 다루어야 합니다.
- Line 과 LineSegment 에는 간단한 해결책이 있습니다. 만약 두 클래스에 접근이 가능하다면, 두 클래스의 공통도니 원소를 추출하여 추상 기반 클래스로 만들 수 있을 것입니다.

> 어떤 클래스 집합이 모두 같은 책임을 진다면, 공통 슈퍼클래스에서 그 책임을 상속받아야 한다.
> 공통 슈퍼 클래스가 아직 존재하지 않는다면, 하나 만들어서 공통 책임을 이 클래스에 넘겨라. 그러면 언젠가 이 클래스는 분명히 쓸모가 있다. 여러분은 시스템의 향후 확장판에서 새로운 방식으로 이와 같은 책임을 지는 새로운 서브 클래스를추가할 것이라고 생각할 수 있지 않은가? 이 새로운 슈퍼클래스는 아마 추상 클래스가 될 것이다.

## 휴리스틱과 규정

- 기반 클래스보다 덜한 동작을 하는 파생클래스는 보통 그 기반 클래스와 치환이 불가능하므로 LSP를 위반합니다.

### 파생 클래스에서 퇴화 함수

```c++
public class Base {
  public void f() {/* 일부코드 */}
}

public class Derived extends Base {
  public void f() {}
}
```

- 위 코드에서는 유감스럽게도 Base의 사용자는 f를 호출하면 안 된다는 사실을 모르기 때문에, 여기서는 치환 외반이 생긴다.
- 파생 클래스에서 퇴화 함수가 존재한다고 해서 무조건 LSP 위반을 나타낸다고 할 수는 없지만, 이것이 일어났을 때 위반 여부를 살펴볼 만한 가치는 있다.

### 파생 클래스에서의 예외 발생

- 또다른 위반 형태는 그 기반 클래스가 발생시키지 않는 예외를 파생 클래스의 메소드에 추가하는 것입니다.
- 기반 클래스의 사용자가 예외를 기대하지 않는다면, 파생 클래스의 메소드에 예외를 추가했을 때 이들은 치환 가능하지 않습니다.

## 결론

- 이 원칙이 효력을 가질 때, 애플리케이션은 좀 더 유지보수 가능해지고, 재사용 가능하고, 견고해집니다.
- 이것은 기반 타입으로 표현된 모듈을 수정 없이도 확장 가능하게 만드는, 서브타입의 치환 가능성을 말합니다.
- 기반 타입의 계약사항은 명시적으로 강제되지 않은 경우, 코드에서 분명하고 뚜렷해야 합니다.
- 서브타입의 진실된 정의는 **치환 가능성** 입니다.
