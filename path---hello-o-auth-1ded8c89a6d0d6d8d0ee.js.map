{"version":3,"sources":["webpack:///path---hello-o-auth-1ded8c89a6d0d6d8d0ee.js","webpack:///./.cache/json/hello-o-auth.json"],"names":["webpackJsonp","494","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,kBAAAC,OAAA,cAAgDC,gBAAmBC,GAAA,6HAAAC,KAAA,oiGAA69FC,aAAiOL,MAAA,YAAAM,KAAA,oBAA8CC,aAAgBC,KAAA","file":"path---hello-o-auth-1ded8c89a6d0d6d8d0ee.js","sourcesContent":["webpackJsonp([217151528944653],{\n\n/***/ 494:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Merlin Tec Blog\",\"author\":\"merlin.ho\"}},\"markdownRemark\":{\"id\":\"/Users/merlin.ho/Documents/workspace/ho_blog/gatsby-blog/src/pages/hello-OAuth/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2>동기</h2>\\n<p>OAuth 2.0의 절차를 글로 정리해 두자.\\n다음 글은 생활코딩 에서 알려주신 OAuth 2.0 을 정리한 것입니다.</p>\\n<h2>역할</h2>\\n<ul>\\n<li>Resource Owner : User 사용자 - 우리의 서비스를 이용하는 사용자 및 구글,페이스북 등의 서비스도 함께 이용하는 사용자.</li>\\n<li>Client : 우리의 서비스</li>\\n<li>Resource Server(Authorization Server) : 우리의 서비스가 제어하고자 하는 자원, 우리의 서비스가 연동하려는 User의 서비스들 (ex. google, facebook)</li>\\n</ul>\\n<h2>Resource Server 등록</h2>\\n<ul>\\n<li>Client는 Resource Server에 우리 Client를 등록하게 됩니다. 이때 service 이름과 redirect<em>url을 입력 후 등록을 하면 Resource Server는 client</em>id, client<em>secret, redirect</em>url을 알려줍니다.</li>\\n</ul>\\n<h2>Access Token의 발급</h2>\\n<ol>\\n<li>\\n<p>Resource Owner 는 Client 인 우리 서비스에 접속합니다. (이때, 우리 서비스는 Resource Server를 연동하는 서비스입니다.)\\n사용자가 나의 서비스에 와서 글을 남겼다. -> 구글 캘린더에 표시를 하던가 페이스북에 “글을 썼다” 또는 “글을 보았다” 등을 공유</p>\\n</li>\\n<li>\\n<p>Client 는 “Login with Facebook, Login with Google” 등의 버튼을 보여줍니다. 이때, Resource Server의 B,C 기능을 이용하겠다고 가정합니다. 이 버튼의 링크는 다음과 같습니다.\\n<code>https://resource.server/?client_id=1&#x26;scope=B,C&#x26;redirect_url=http://slient/callback</code> 여기서 redirect_url은 Client 에서 미리 구축해두고 있어야 합니다.</p>\\n</li>\\n<li>\\n<p>위 버튼을 눌러 Resource Server에 접속이 되면 Resource Server은 Resource Owner에게 로그인 하라는 페이지를 보여주게 됩니다.</p>\\n</li>\\n<li>\\n<p>Resource Owner가 로그인을 하게 됩니다.</p>\\n</li>\\n<li>\\n<p>Resource Server는 이제 아까 url의 쿼리스트링과 Resource Server가 보유한 client<em>id와 redirect</em>url이 같은지 비교합니다.</p>\\n</li>\\n<li>\\n<p>같다면 다시 Resource Server는 Resource Owner 에게 해당 Client 서비스에게 B,C 기능을 열어주겠냐는 페이지를 보여줍니다.</p>\\n</li>\\n<li>\\n<p>Resource Owner가 허용을 하게 되면 Resource Server는 authorization code(3 이라 칩시다)를 만들어 Resource Owner의 브라우저에게 다음과 같은 주소로 redirection 합니다.\\n<code>https://client/callback?code=3</code></p>\\n</li>\\n<li>\\n<p>Client에서 <code>code=3</code> 이라는 정보를 받게 되면 authorization code = 3 을 생성하게 됩니다.</p>\\n</li>\\n<li>\\n<p>Client에서는 다음과 같은 url로 Resource Server에 Access Token 을 요청 하게 됩니다.\\n<code>https://resource.server/token?grant_type=authorization_code&#x26;code=3&#x26;redirect_url=https://client/callback&#x26;client_id=1&#x26;client_secret=2</code></p>\\n</li>\\n<li>\\n<p>Resource Server는 임시 비밀번호인 authorization code 와 client<em>id, client</em>secret, redirect<em>url을 확인해서 accesss</em>token을 만들어서 Client에 발급시켜 줍니다.</p>\\n</li>\\n</ol>\\n<h2>Refresh Token의 발급</h2>\\n<ul>\\n<li>access<em>token 에게는 수명이 있습니다. 이때 손쉽게 access</em>token을 다시 발급 받을 수 있는 방법이 refresh_token 입니다.</li>\\n<li>보통은 access<em>token을 발급할때, refresh</em>token을 발급해 줍니다.</li>\\n<li>수명이 끝난 access_token으로 API를 호출하게 되면 invalid 한 응답을 주게 됩니다.</li>\\n<li>access<em>token이 수명이 다하면 Authorization Server에 전달하면 access</em>token을 다시 발급해 주게 됩니다.</li>\\n<li>예를 들어 구글의 경우에는 구글 API의 post 방식으로 <code>client_id</code>,<code>client_secret</code>,<code>refresh_token</code>,<code>grant_type=refresh_token</code> 정보를 넘겨주면 다시 access_token을 발급 해 주게 됩니다.</li>\\n</ul>\\n<h2>API 활용</h2>\\n<ul>\\n<li>쿼리 스트링 : &#x3C;API주소>/?access<em>token=&#x3C;access</em>token></li>\\n<li>request header : Authorization: Bearer &#x3C;access_token></li>\\n</ul>\\n<h2>참고</h2>\\n<p><a href=\\\"https://www.youtube.com/playlist?list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-\\\">https://www.youtube.com/playlist?list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-</a></p>\",\"frontmatter\":{\"title\":\"OAuth 2.0\",\"date\":\"March 16, 2020\"}}},\"pathContext\":{\"slug\":\"/hello-OAuth/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---hello-o-auth-1ded8c89a6d0d6d8d0ee.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Merlin Tec Blog\",\"author\":\"merlin.ho\"}},\"markdownRemark\":{\"id\":\"/Users/merlin.ho/Documents/workspace/ho_blog/gatsby-blog/src/pages/hello-OAuth/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2>동기</h2>\\n<p>OAuth 2.0의 절차를 글로 정리해 두자.\\n다음 글은 생활코딩 에서 알려주신 OAuth 2.0 을 정리한 것입니다.</p>\\n<h2>역할</h2>\\n<ul>\\n<li>Resource Owner : User 사용자 - 우리의 서비스를 이용하는 사용자 및 구글,페이스북 등의 서비스도 함께 이용하는 사용자.</li>\\n<li>Client : 우리의 서비스</li>\\n<li>Resource Server(Authorization Server) : 우리의 서비스가 제어하고자 하는 자원, 우리의 서비스가 연동하려는 User의 서비스들 (ex. google, facebook)</li>\\n</ul>\\n<h2>Resource Server 등록</h2>\\n<ul>\\n<li>Client는 Resource Server에 우리 Client를 등록하게 됩니다. 이때 service 이름과 redirect<em>url을 입력 후 등록을 하면 Resource Server는 client</em>id, client<em>secret, redirect</em>url을 알려줍니다.</li>\\n</ul>\\n<h2>Access Token의 발급</h2>\\n<ol>\\n<li>\\n<p>Resource Owner 는 Client 인 우리 서비스에 접속합니다. (이때, 우리 서비스는 Resource Server를 연동하는 서비스입니다.)\\n사용자가 나의 서비스에 와서 글을 남겼다. -> 구글 캘린더에 표시를 하던가 페이스북에 “글을 썼다” 또는 “글을 보았다” 등을 공유</p>\\n</li>\\n<li>\\n<p>Client 는 “Login with Facebook, Login with Google” 등의 버튼을 보여줍니다. 이때, Resource Server의 B,C 기능을 이용하겠다고 가정합니다. 이 버튼의 링크는 다음과 같습니다.\\n<code>https://resource.server/?client_id=1&#x26;scope=B,C&#x26;redirect_url=http://slient/callback</code> 여기서 redirect_url은 Client 에서 미리 구축해두고 있어야 합니다.</p>\\n</li>\\n<li>\\n<p>위 버튼을 눌러 Resource Server에 접속이 되면 Resource Server은 Resource Owner에게 로그인 하라는 페이지를 보여주게 됩니다.</p>\\n</li>\\n<li>\\n<p>Resource Owner가 로그인을 하게 됩니다.</p>\\n</li>\\n<li>\\n<p>Resource Server는 이제 아까 url의 쿼리스트링과 Resource Server가 보유한 client<em>id와 redirect</em>url이 같은지 비교합니다.</p>\\n</li>\\n<li>\\n<p>같다면 다시 Resource Server는 Resource Owner 에게 해당 Client 서비스에게 B,C 기능을 열어주겠냐는 페이지를 보여줍니다.</p>\\n</li>\\n<li>\\n<p>Resource Owner가 허용을 하게 되면 Resource Server는 authorization code(3 이라 칩시다)를 만들어 Resource Owner의 브라우저에게 다음과 같은 주소로 redirection 합니다.\\n<code>https://client/callback?code=3</code></p>\\n</li>\\n<li>\\n<p>Client에서 <code>code=3</code> 이라는 정보를 받게 되면 authorization code = 3 을 생성하게 됩니다.</p>\\n</li>\\n<li>\\n<p>Client에서는 다음과 같은 url로 Resource Server에 Access Token 을 요청 하게 됩니다.\\n<code>https://resource.server/token?grant_type=authorization_code&#x26;code=3&#x26;redirect_url=https://client/callback&#x26;client_id=1&#x26;client_secret=2</code></p>\\n</li>\\n<li>\\n<p>Resource Server는 임시 비밀번호인 authorization code 와 client<em>id, client</em>secret, redirect<em>url을 확인해서 accesss</em>token을 만들어서 Client에 발급시켜 줍니다.</p>\\n</li>\\n</ol>\\n<h2>Refresh Token의 발급</h2>\\n<ul>\\n<li>access<em>token 에게는 수명이 있습니다. 이때 손쉽게 access</em>token을 다시 발급 받을 수 있는 방법이 refresh_token 입니다.</li>\\n<li>보통은 access<em>token을 발급할때, refresh</em>token을 발급해 줍니다.</li>\\n<li>수명이 끝난 access_token으로 API를 호출하게 되면 invalid 한 응답을 주게 됩니다.</li>\\n<li>access<em>token이 수명이 다하면 Authorization Server에 전달하면 access</em>token을 다시 발급해 주게 됩니다.</li>\\n<li>예를 들어 구글의 경우에는 구글 API의 post 방식으로 <code>client_id</code>,<code>client_secret</code>,<code>refresh_token</code>,<code>grant_type=refresh_token</code> 정보를 넘겨주면 다시 access_token을 발급 해 주게 됩니다.</li>\\n</ul>\\n<h2>API 활용</h2>\\n<ul>\\n<li>쿼리 스트링 : &#x3C;API주소>/?access<em>token=&#x3C;access</em>token></li>\\n<li>request header : Authorization: Bearer &#x3C;access_token></li>\\n</ul>\\n<h2>참고</h2>\\n<p><a href=\\\"https://www.youtube.com/playlist?list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-\\\">https://www.youtube.com/playlist?list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-</a></p>\",\"frontmatter\":{\"title\":\"OAuth 2.0\",\"date\":\"March 16, 2020\"}}},\"pathContext\":{\"slug\":\"/hello-OAuth/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/hello-o-auth.json\n// module id = 494\n// module chunks = 217151528944653"],"sourceRoot":""}