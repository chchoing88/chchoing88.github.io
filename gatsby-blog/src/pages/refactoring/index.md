---
title: (리팩토링) 코드의 구린내
date: "2019-05-10T10:00:03.284Z"
---

## 중복 코드

중복 코드의 가장 단순한 예는 한 클래스의 두 메서드 안에 같은 코드가 들어 있는 경우 이다.
이럴땐 `메서드 추출` 기법을 적용해서 겹치는 코드를 빼내어 별도의 메서드로 만들고 그 메서드를 두곳에서 호출하면 된다.

또 다른 상황은 한 클래스의 두 하위클래스에 같은 코드가 들어있는 경우다.
이럴 때는 `메서드 추출` 기법을 적용해서 중복을 없앤 후 `메서드 상향` 기법을 적용하면 된다.

코드가 똑같지 않고 비슷하다면 `메서드 추출`기법을 적용해서 같은 부분과 다른 부분을 분리해야 한다.
그런다음, 경우에 따라 템플릿 메서드 형성 기법을 적용해야 할 수도 있다.

두 메서드가 알고리즘만 다르고 기능이 같다면 개발자는 그 두 알고리즘 중에서 더 간단한 것을 택해서 `알고리즘 전환`을 적용하면 된다.
중복코드가 가운데에 있다면 주변 `메서드 추출`을 적용하면 된다.

서로 상관없는 두 클래스 안에 중복 코드가 있을 때는 한 클래스 안의 중복코드를 `클래스 추출`이나 `모듈 추출`을 적용해제 3 의 클래스나 모듈로 떼어낸 후 그것을 다른 클래스에서 호출하는 방법이 있다. 아니면 중복 코드를 빼서 메서드로 만든 후 그 메서드를 두 클래스 중 하나에 넣고 다른 클래스에서 그 메서드를 호출하거나, 코드를 빼내어 만든 메서드를 제 3 의 클래스에 넣고 그걸 두 클래스에서 호출하는 방법도 있다.

## 장황한 메서드

최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메서드 길이가 짧다.
주석을 달아야 할 것 같은 부분에 주석을 넣는 대신 메서드를 작성한다. 메서드 안에 주석을 단 코드를 넣고, 그 메서드 명은 기능 수행 방식이 아니라 목적(즉, 기능자체)을 나타내는 이름으로 정한다.

메서드를 줄이려면 십중팔구는 `메서드 추출` 기법을 적용해야 한다. 메서드에서 하나로 묶으면 좋을 만한 부분들을 찾아내어 메서드로 만드는 것이다.

메서드에 매개변수와 임시변수가 많으면 `메서드 추출`을 실시하기가 까다롭다.
메서드 추출을 하려면 수많은 매개변수와 임시변수를 새로 만든 메서드의 매개변수로 넘겨야 하는데, 그렇게 되면 가독성에서 원래의 코드와 별 다를게 없어진다. 웬만한 경우에는 `임시변수를 메서드 호출 전환`기법이나 `임시변수를 메서드 체인으로 전환` 기법을 적용하면 임시변수가 제거된다.
길게 열거된 매개변수는 `매개변수 세트를 객체로 전환` 기법과 `객체를 통째로 전달` 기법을 적용하면 간결해진다.

이런 노력에도 불구하고 임시변수와 매개변수가 너무 많을 때는 `메서드를 메서드 객체로 전환` 기법을 적용하면 된다.

조건문을 추출하려면 `조건문 쪼개기` 기법을 사용해야 한다.
루프를 `컬렉션 클로저 메서드로 전환`을 실시한 후 그 클로저 메서드 호출과 클로저 자체에 `메서드 추출`을 실시하면 된다.

## 방대한 클래스

기능이 지나치게 많은 클래스는 보통 엄청난 수의 인스턴스 변수가 들어 있다.
클래스에 인스턴스 변수가 너무 많으면 중복 코드가 반드시 존재하게 마련이다.

`클래스 추출`을 실시하면 수 많은 인스턴스 변수를 하나로 묶을 수 있다. 쉽게 말해 한 클래스 안의 일부 변수가 접두어나 접미어가 같다면 하나의 클래스로 추출하는게 좋다. `하위클래스로 추출`하는 것이 적합할 것 같으면 `하위클래스 추출`을 실시하는 것이 더 간단하다.
만약 추출할 클래스가 대리자로 부적절할 것 같으면 `모듈 추출`을 실시하면 된다.

인스턴스 변수를 계속해서 모두 사용하지 않는 클래스도 간혹 있다. 그런 경우에는 `클래스 추출`, `모듈 추출`, `하위클래스 추출` 중 하나를 여러번 적용하는 방법도 있다.
만약 100 줄짜리 메서드 5 개가 있다면 그것들을 원래 메서드에서 추출한 2 줄짜리 메서드 10 개가 들어있는 10 줄짜리 메서드 5 개로 바꾸는 방법도 있다.

클라이언트가 그 클래스를 어떻게 사용하게 할지 결정하고, 그러한 각 사용방법마다 `인터페이스 추출`을 실시하는 편법도 자주 쓰인다.

만약 방대한 클래스가 GUI 클래스라면 데이터와 기능을 서로 다른 도메인 객체로 옮겨야 할 수도 있다. 이를 위해 두 곳에 있는 일부 중복 데이터는 놔두고그 데이터와 싱크를 유지해야할 수도 있다. 이것은 `관측 데이터 복제` 기법을 실시하면 해결된다.

## 과다한 매개변수

초보 시절 루틴에 필요한 모든 걸 매개변수를 사용해 전달하라고 배웠지만, 객체의 등장으로 인해 상황은 달라졌다.
필요한 데이터가 없을 때는 그것을 가져오도록 항상 다른 객체에 요청하면 되기 때문이다. 그래서 객체를 사용할 때는 메서드에 필요한 모든 데이터를 전달하는 게 아니라 *그 모든 데이터를 가져올 수 있는 메서드만 전달*하면 된다. 메서드가 필요로 하는 각종 데이터는 그 메서드가 속한 클래스에 들어 있다.

매개변수 세트가 간결하다는 것은 장점이다.

이미 알고 있는 객체에 요청하여 한 매개변수에 들어있는 데이터를 가져올 수 있을 때는 `매개변수 세트를 메서드로 전환`을 적용하면 된다. 이 객체는 인스턴스 변수일 수도 있고 다른 매개변수일 수도 있다.
객체에 있는 데이터 세트를 가져온 후, 데이터 세트를 그 객체 자체로 전환하려면 `객체를 통째로 전달`을 적용하면 된다.
여러 데이터항목에 논리적 객체가 없다면 `매개변수 세트를 객체로 전환`을 적용하면 된다.

이 기법들이 적용할 때 예외가 하나 있는데, 그것은 바로 호출되는 객체가 호출 객체에 의존하면 안 될 때다. 이럴 때는 데이터를 개별적으로 빼서 매개변수로 전달하는 것이 바람직하지만, 그렇게 하려면 어려움이 따른다. 나열된 매개변수 세트가 너무 길거나 자주 바뀐다면 불가피하게 종속 구조를 유지하는 것도 생각해야 한다.

## 수정의 산발

어떤 클래스를 보던 중 '새 데이터베이스를 생성할 때마다 이 3 개의 메서드를 수정해야 하고, 새 금융 상품을 추가할 때마다 이 4 개의 메서드를 수정해야 하네!' 하는 생각이 들면 그 하나의 클래스를 여러 개의 변형 객체로 분리하는 것이 좋다. 그러면 각 객체는 한 종류의 수정에 의해서만 변경된다.
이렇게 변경할 때는 한 개의 클래스나 모듈만 변경해야 하며, 새 클래스나 모듈 안에는 반드시 그 변경사항을 표시해야 한다.
이것을 정리하려면 특정 원인으로 인해 변하는 모든 부분을 찾은 후 `클래스 추출`을 적용해서 그 부분들을 합쳐 한 클래스로 빼내야 한다.

## 기능의 산재

기능의 산재는 수정의 산발과 비슷하지만 정 반대다. 수정할 때마다 여러 클래스에서 수많은 자잘한 부분을 고쳐야 한다면 이 문제를 의심할 수 있다. 수정할 부분이 여기저기에 있다면 찾기도 힘들 뿐더러 꼭 수정해야 하는 부분을 놓치기 쉽다.

이럴 때는 `메서드 이동`과 `필드 이동`을 적용해서 수정할 부분들을 전부 하나의 클래스 안에 넣어야 한다.
기존의 클래스 중 어느 것에 넣기에도 부적절해 보일 때는 새 클래스를 만들어야 한다. 대게는 `클래스 내용 직접 삽입`을 적용해서 별도 클래스에 분산되어 있던 모든 기능을 한 곳으로 가져와도 된다.

## 잘못된 소속

객체의 핵심은 데이터와 그 데이터에 사용되는 프로세스를 한 데 묶는 기술이라는 점이다. 전통적으로 어떤 메서드가 자신이 속하지 않은 클래스에 더 많이 접근한다면 잘못된 소속의 구린내가 풍길 것이다.

소속이 잘못된 메서드는 더 많이 접근하는 클래스에 들어가는 것이 마땅하니, `메서드 이동`기법을 실시해서 더 자주 접근하는 클래스로 옮겨야 한다. 간혹 메서드의 일부분만 소속이 잘못된 경우도 있는데, 이럴 때는 그 부분에 `메서드 추출`을 적용한 후 `메서드 이동`을 적용해서 적절한 클래스로 옮기면 된다.

이 규칙을 따르지 않는 복잡한 패턴도 일부 있다. `전략 패턴`과 `방문자 패턴`, `자가 위임 패턴`이 그렇다. 이 패턴들은 수정의 산발이 의심될 때 해결책으로 쓰인다. 기본 규칙은 함께 수정되는 것들을 하나로 뭉치는 것이다. 데이터와 그 데이터를 참조하는 기능은 대체로 함께 수정되지만 예외도 있다.
그런 예외가 발생하는 기능은 옮겨서 한 곳에서 수정해야 한다. `전략 패턴`과 `방문자 패턴`은 재정의가 필요한 일부 기능을 따로 빼내기 때문에 기능을 수정하기는 쉬워지지만, 대신 인다이렉션이 늘어나는 단점이 있다.

> 인다이렉션 (indirection, 간접접근) 은 코드에 있는 값을 바로 사용 하지 말고 그 값을 가리키는 포인터를 사용한라는 뜻의 단어.

> 방문자 패턴은 각각의 Element 에 로직이 다른 visitor 가 들어가면(방문하면) Element 가 자기 자신을 넘기면서 visitor 가 공통으로 정해놓은 함수를 실행하게 된다. visitor.visit(this: Element), 자동차를 예를 들면 왼쪽 바퀴, 오른쪽 바퀴 하나 하나가 Element 로 생각하면 되고, visitor 는 만드는사람, 정비공 등등.. 이라고 생각하면 된다. 각각의 Element 들이 만드는 사람을 만나면 A 를 수행하게 될것이고 정비공을 만나면 B 를 수행하게 될것이다.

## 데이터 뭉치

두 클래스에 들어 있는 인스턴스 변수나 여러 메서드 시그니처에 들어 있는 매개변수처럼, 동일한 3~4 개의 데이터 항목이 여러 위치에 몰려 있는 경우가 많다. 이렇게 _몰려 있는 데이터 뭉치는 객체로 만들어야 한다._

우선 데이터 뭉치가 필드처럼 보이는 부분을 찾아야 한다. 이 뭉치를 객체로 전환하려면 그 필드들을 대상으로 `클래스 추출` 기법을 사용해야 한다. 그러고 나서 메서드 시그니처를 대상으로 `매개변수 세트를 객체로 전환` 기법과 `객체를 통째로 전달` 기법을 적용하여 간결하게 만들어야 한다. 이렇게 하면 매개변수가 적어져서 부수적으로 메서드 호출 코드가 간결해지는 효과도 누릴 수 있다. 새로 생긴 객체의 속성들 중 일부만 이용하는 데이터 뭉치라 해도 이 방법으로 효과를 볼 수 있다. 둘 이상의 필드를 객체로 전환하면 코드가 개선된다.

그러한 효과는 여러 데이터 값 중 하나를 삭제해보면 확실히 알 수 있다. 그렇게 했을 때 나머지 데이터 값들이 제대로 돌아가지 않는다면 그 객체를 없애고 새로 만들어야 한다.

인스턴스 변수 세트와 매개변수 세트를 줄이면 분명히 의심되는 문제점도 없어지지만, 일단 객체로 전환하고 나면 전체적 성능이 개선될 여지도 있다. 이렇게 하고 나면 `잘못된 소속`의 구린내가 풍기는 부분들을 찾을 수 있는데, 이런 부분의 기능은 새 클래스로 빼내야 한다.

## 강박적 기본 타입 사용

대개의 프로그래밍 환경을 구성하는 데이터는 두 종류다. 하나는 레코드 타입인데, 이것을 사용해서 데이터를 의미 있는 그룹들로 묶어 구조화할 수 있다. 기본 타입은 한마디로 초석이라고 할 수 있다. 레코드에는 항상 일정 양의 오버헤드가 따른다. 여기서 레코드란 데이터베이스 테이블일 수도 있지만, 그 외의 것이라면 한두 가지 목적만을 위해 생성하기엔 어중간할 수도 있다.

객체의 주요 장점 중 하나가 바로 기본 타입 클래스와 응용 클래스 간의 경계를 허문다는 점이다. 언어에 내장된 기본 타입과 구별하기 힘든 작은 클래스를 손쉽게 작성할 수 있다.

객체를 처음 접하는 사람은 보통 숫자와 통화를 연동하는 돈 관련 클래스나 전화번호와 우편번호 같은 특수 문자열 클래스등의 사소한 작업에는 작은 객체를 잘 사용하지 않으려는 경향이 있다. 이러한 우물 안 개구리를 벗어나려면 `데이터 값을 객체로 전환(값 객체로 전환)`을 실시하면 된다. 데이터 값이 분류 부호일 땐 그 값이 기능에 영향을 주지 않는다면 `분류 부호를 클래스로 전환`을 실시하자. 그리고 조건문에 분류 부호가 사용될 땐 `분류 부호를 하위클래스로 전환` 기법이나 `분류 부호를 상태/전략 패턴`으로 전환 기법을 적용하자.

뭉쳐 다녀야 할 여러 개의 필드가 있다면 `클래스 추출` 기법을 적용해야 한다. 이런 기본 타입이 매개변수 세트에 들어 있다면 `매개변수 세트를 객체로 전환` 기법을 적용하면 된다. 배열 때문에 불편하다면 `배열을 객체로 전환` 기법을 적용하면 된다.

## switch 문

## 평행 상속 계층

## 직무유기 클래스

## 막연한 범용 코드

## 임시 필드

## 메시지 체인

## 과잉 중개 메서드

## 지나친 관여

## 인터페이스가 다른 대용 클래스

## 미흡한 라이브러리 클래스

## 데이터 클래스

## 방치된 상속물

## 불필요한 주석
