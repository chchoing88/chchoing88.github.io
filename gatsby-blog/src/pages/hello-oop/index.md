---
title: hello OOP
date: "2018-04-25T10:00:03.284Z"
---

# 객체지향 이란?
  * 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법
  * 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체
  * 객체는 시스템의 행위를 구현하기 위해 다른객체와 협력, 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.
  * 객체는 다른 객체와 협력하기 위해 메세지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는데 적합한 메서드를 자율적으로 선택한다.
  * 메시지는 곧 책임이다.

## 역할, 책임, 협력
  * 객체는 협력을 위해 특정할 역할을 맡고 적합한 책임을 수행한다.
  * 여기서 역할은 대체 가능성을 의미한다. 
  * 각 객체는 책임을 수행하는 방법을 자율적으로 선택 하고 다른 객체와 협력한다.
  * 객체는 다른 객체가 '무엇(what)'을 수행하는지는 알수 있지만 '어떻게(how)' 수행하는지에 대해서는 알 수 없다.
  * 객체지향 세계에서는 오직 '메시지' 라는 의사소통만이 존재한다.

### 협력

  * 협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작된다.
  * 요청 받은 사람은 응답을 한다.
  * 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의하게 된다.

### 책임

  * 적절한 행동을 한 의무가 있는 경우에 해당 객체가 책임을 가진다고 할 수 있다.
  * 책임은 주로 하는것(doing)과 아는것(knowing)으로 분류된다.
    * 하는 것 
      * 객체를 생성하거나 계산을 하는 등의 스스로 하는것
      * 다른 객체의 행동을 시작시키는 것
      * 다른 객체의 활동을 제어하고 조절하는 것
    * 아는 것
      * 개인적인 정보에 관해 아는 것
      * 관련된 객체에 관해 아는 것
      * 자신이 유도하거나 계산할 수 있는 것에 관해 아는것
  * 즉, 책임은 객체의 외부에 제공해 줄 수 있는 정보(아는것의 측면)와 외부에 제공해 줄 수 있는 서비스(하는 것의 측면)의 목록이고 이 책임은 객체의 공용 인터페이스를 구성하게 된다. 

### 역할

  * 어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다. 
  * 역할은 재사용이 가능하고 유연한 객체지향 설계를 낳는 매우 중요한 구성요소이다.
  * 역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다. 즉, "이 자리는 나 대신 이 역할을 수행할수 있다면 누구라도 대체할 수 있어" 라고 말하는것과 같다.
  * 역할은 객체지향 설계의 "단순성" , "유연성" , "재사용성" 을 뒷바침 하는 핵심 개념이다.
  * 역할을 사용하면 협력을 추상화 시킬 수 있다.


## 타입과 추상화

### 추상화

  * 추상화란 실제의 사물에서 자신이 원하는 특성만 취하고 필요 없는 부분을 추려 핵심만 표현하는 행위이다.
  * 추상화는 어떤양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법.
  * 구체적인 사물 간의 공통점은 취하고 차이점을 버리자.
  * 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거해 단순화 하자.
  

### 개념

  * 공통점을 기반으로 객체를 묶기 위한 그릇을 개념(concept) 라고 한다.
  * 개념의 관점 : 심볼(symbol), 내연(intension), 외연(extension)
  * symbol : 개념을 가리키는 이름이나 명칭
  * intension : 개념의 완전한 정의 이 의미로 인해 객체가 개념에 속하는지 여부를 확인할 수 있다.
  * extension : 개념에 속하는 모든 객체의 집합.
  * 개념을 이용해 객체의 복잡성을 극복하고 분류하자.

### 타입

  * 타입은 개념이다. 
  * 타입은 공통점을 기반으로 객체들을 묶기 위한 틀이다. 
  * 타입은 개념과 마찬가지로 심볼, 내연, 외연을 이용해 서술할 수 있으며 타입에 속하는 객체 역시 타입의 인스턴스라고 한다. 
  * '타입이 없다' 라는 말은 메모리 안의 데이터를 다룰 수 있는 단 하나의 타입만이 존재한다는 것을 의미. 사실 메모리 세상엔 타입이라는 질서가 없다.
  * 타입이 없는 체계에서는 메모리 안의 값이 어떤 의미인지 말할수 있는 사람은 없다. '1001001'만 보고 숫자인지 문자열인지 해석할 수 있는가?
  * 데이터 타입이란 메모리 안의 데이터에 특정한 의미를 부여한 것이다. 사람들은 자신이 다뤄야 하는 데이터의 용도와 행동에 따라 그것들을 분류한것이다.
  * 타입 시스템의 목적은 메모리 안의 모든 데이터가 비트열로 보임으로 그 혼란을 막기 위함이다. 메미로 안에 저장된 0과 1에 대해서 수행 가능한 작업과 불가능 작업을 구분함으로써 데이터가 잘못 사용되는것을 방지한다. 


### 객체와 타입
  
  * 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 새로운 데이터 타입을 선언하는것과 같다.
  * 객체가 어떤 타입에 속하는지는 객체가 수행하는 행동이다. 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.
  * 내부적인 표현은 외부로부터 철저하게 감춰진다. 
  * 객체를 결정하는 것은 행동이다. 데이터는 단지 행동을 따를 뿐이다. 
  * 객체가 외부에 제공해야 하는 행동을 먼저 생각하자.
  * 객체는 시시각각 변할 수 있기 때문에 타입을 사용하면 시간과 무관한 정적인 모습으로 다룰수 있게 해준다. 즉, 타입은 추상화이다. 객체의 상태 변경이라는 복잡성을 단순화 할수 있는 방법이다.

### 일반화/특수화 ( 슈퍼타입/서브타입 )
  
  * 일반화 / 특수화의 적절한 예는 고양이과 동물 / 사자 를 들수 있을 것이다.
  * 일반화 / 특수화 관계를 결정짓는 것은 객체의 상태가 아닌 행동이다. 
  * 여기서 일반적인 타입은 특수적인 타입의 모든 행동중에서 일부 행동만 가진다.
  * 특수한 타입이란 일반적인 타입이 가진 모든 타입을 포함하지만 거기에 자신만의 행동을 추가하는 타입을 가리킨다. 

### 클래스
  
  * 클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나이다.
  * 자바스크립트의 경우에는 프로토타입 기반의 언어라 클래스가 존재하지 않는다. 

## 상태, 행동, 식별자
  
### 상태
  * 상태를 이용하면 과거의 행동 이력을 설명하지 않아도 행동의 결과를 쉽게 예측 하고 설명할 수 있다. 
  * 즉, 상태는 특정시점에 객체가 가지고 있는 정보의 집합이다.
  * 객체는 상태를 스스로 관리하는 자율적인 존재다.
  * 상태를 외부에 노출시키지 않고 캡슐화 하는것은 객체의 자율성을 높인다.

### 행동
  * 객체의 상태를 변경하는 것은 객체의 자발적인 행동이다.
  * 객체의 행동은 상태에 영향을 받는다. 
  * 행동이란 외보의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동
  * 행동의 결과로는 객체의 자신의 상태를 변경하거나 다른 객체에 메시지를 전달할 수 있다. 
  * 행동은 다른객체와의 협력에 참여하므로 외부에 가시적이다.
  * drinkBeverage() -> 나 객체 -> drunken(quantity) -> 음료객체

### 식별자
  * 서로를 구별할 수 있는 특정한 프로퍼티가 식별자라고 한다.
  * 값의 상태는 변하지 않기에 immutable state를 가진다.
  * 객체의 상태는 행동에 의해 변할수 있기에 mutable state라고 한다.
  * 동등성 : 상태를 기반으로 비교 , 동일성: 식별자를 기반으로 비교
  * 객체의 경우 상태가 가변적이기에 상태 변경에 독립적인 별도의 식별자를 이용해서 두 인스턴스를 비교할 수 있다.
  
### 은유와 객체 
  * 현실속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다. 예를 들면 소프트웨어에선 상품이 가격계산을 스스로 수행할수 있다는 것이다.
  * 객체를 창조할때 현실 객체를 모방하려 하지말고 현실 속의 객체에 대한 은유를 쓰자. 은유란 하나의 의미를 다른 것을 이용해 전달한다는 의미를 가지고 있다.
  * "A라는 객체는 전화기 같아요" 라고 했을때 A라는 객체는 전화를 걸 수 있다는 사실을 알 수 있다. 
  * 은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 차이를 줄여 소프트웨어의 구조를 쉽게 예측할 수 있다. 그래서 유지보수가 용이한 소프트웨어를 만들 수 있다.

### 객체지향 설계 기법

#### 책임-주도 설계
  
  * 객체지향 설계란 app의 기능을 구현하기 위한 협력 관계를 고안하고, 협력에 필요한 역할과 책임을 식별한 후 이를 수행할 수 있는 적절한 객체를 식별해 나가는 과정.
  * 이 설계는 객체의 책임을 중심으로 시스템을 국축하는 설계 방법
  * 시스템은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 적절한 객체에게 할당된다. 객체가 책임을 수행하는 도중에 필요하다면 적절한 객체를 찾아 필요한 작업을 요청한다. 만약 책임을 여러 종류의 객체가 수행할 수 있다면 협력자는 객체가 아니라 추상적인 역할로 대체된다.
  * 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
  * 시스템 책임을 더 작은 책임으로 나눈다.
  * 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
  * 객체가 책임을 수행하는 중에 다른객체의 도움이 필요한 경우 이를 책임질 적절한 객체를 찾는다.
  * 해당 객체에게 책임을 할당함으로써 두 객체가 협력하게 된다.

#### 디자인패턴
  
  * 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍
  * 패턴으로 해결하는 문제가 무엇인지를 명확하게 파악하고 패턴을 적용할수 있는 상황과 적용할 수 없는 상황을 인지하자.
  * COMPOSITE 패턴은 전체와 부분을 하나의 단위로 추상화해야하는 경우에 사용된다.
  * 위 예로는 사용자 관점에서 대상이 파일인지 폴더인지 상관없이 파일의 경로를 바꿀수도 있지만 폴더의 경로를 바꾸게 되면 그 안에 있는 파일까지도 한번에 변경 할수도 있어야 한다. 사용자는 단지 대상을 선택한 후 경로를 바꾸기만 하면 된다. 
  * 즉, 메시지 수신자가 부분(파일) 인지 전체(폴더) 인지에 상관 없이 동일한 메시지(경로변경)을 이용해 동일한 방식으로 대상과 상호작용하고 싶을때 이용한다.
