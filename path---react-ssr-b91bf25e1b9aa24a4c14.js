webpackJsonp([0xa24d448f778d],{544:function(e,o){e.exports={data:{site:{siteMetadata:{title:"Merlin Tec Blog",author:"merlin.ho"}},markdownRemark:{id:"/Users/merlin.ho/Documents/workspace/ho_blog/gatsby-blog/src/pages/react-ssr/index.md absPath of file >>> MarkdownRemark",html:"<p>이 글은 벨로퍼트님의 <code>리액트를 다루는 기술</code> 책의 SSR 부분을 핵심만 요약한 글입니다.\nSSR의 흐름을 알기 쉽게 보기 위해서 정리합니다.</p>\n<h2>정의</h2>\n<p>SSR은 <code>Server Side Rendering</code> 으로 서버에서 HTML 코드를 만들어서 응답으로 보내주는 형식을 말합니다.\n기존의 SPA의 경우에는 <code>Client Side Rendering</code> 을 사용하고 있고 SSR과 CSR은 장단점을 지니고 있습니다.</p>\n<h2>기본 요약</h2>\n<ol>\n<li><code>index.server.js</code> 를 만들어 <code>ReactDOMServer.rednerToString</code> 으로 JSX를 마크업으로 만들어 줍니다.</li>\n<li>서버 코드에서 응답으로 만들어진 마크업을 전달합니다.</li>\n<li>빌드 된 JS, CSS 파일은 파일명이 매번 바뀌기 때문에 <code>asset-manifest.json</code> 파일을 참고해서 만들 마크업에 link, script 태그를 이어줍니다.</li>\n<li><code>Router</code> 는 <code>StaticRouter</code>의 <code>location props</code>를 가지고 라우팅 처리를 합니다.</li>\n</ol>\n<h2>데이터 로딩 요약</h2>\n<p>SSR에서는 라이프 사이클 메서드가 동작하지 않고, 데이터가 바뀐다고 해도 re-Rendering이 되지 않으므로\n마크업을 만들어서 응답하기 전에 필요한 API 데이터를 미리 다 불러와야 합니다.</p>\n<h3>redux-thunk</h3>\n<ul>\n<li>\n<p>불려져야 하는 API 함수 (<code>promise</code>) 들을 Preload 컴포넌트를 이용해 <code>React Context</code>에 하나하나 쌓아 둡니다.</p>\n</li>\n<li>\n<p>마크업을 만들기 전에 해당 <code>Promise.all</code> 을 이용해서 promise 들을 실행시키며 이 <code>promise</code> 들은 <code>redux reduce</code> 에서 api 호출 및 저장이 됩니다.</p>\n</li>\n<li>\n<p>최종 마크업을 만들어 줍니다.</p>\n</li>\n<li>\n<p><code>redux thunk</code>(액션함수)를 <code>dispatch</code> 의 인자로 넘기면 <code>promise</code>가 반환됩니다.</p>\n</li>\n<li>\n<p><code>PreloadContext</code> 를 만들어 줍니다.</p>\n</li>\n<li>\n<p><code>Preload</code> 컴포넌트는 초기 데이터를 받아야 할 리턴이 <code>promise</code>인 함수를 <code>props</code>로 받아 해당 <code>Context state</code>에 넣어두는 로직을 구성합니다.</p>\n</li>\n<li>\n<p>각 컨테이너 컴포넌트에서 <code>Preload</code>가 필요한 곳에 넣어줍니다.</p>\n</li>\n<li>\n<p>이때, 라이프 사이클에서 마운트 에서 호출하던 (<code>useEffect, componentDidMount</code>) API 호출은 데이터가 유효하면 호출하지 않도록 분기를 쳐 둡니다.</p>\n</li>\n<li>\n<p>JSX를 만들고 나서 <code>ReactDOMServer.renderToStaticMarkup()</code> 메서드를 활용해서 초기 데이터를 불러오게끔 하는 렌더링을 진행합니다.</p>\n</li>\n<li>\n<p><code>Promise.all()</code>로 <code>PreLoadContext</code>의 <code>promise list</code> 들을 실행합니다.</p>\n</li>\n<li>\n<p>마지막으로 <code>ReactDOMServer.renderToString()</code>으로 마지막 최종 렌더링을 진행해서 응답해줍니다.</p>\n</li>\n</ul>\n<h3>redux-saga</h3>\n<ul>\n<li>saga도 똑같이 <code>Preload</code> 컴포넌트를 사용합니다.</li>\n<li>유효성 검사 후 에 null 처리 할 곳에 <code>Preload</code> 컴포넌트를 사용합니다.</li>\n<li>서버 코드 내에서 <code>sagaMiddleware.run(rootSaga).toPromise()</code> 를 이용해서 saga Task들을 promise로 만들어줍니다.</li>\n<li>서버 코드 내에서 <code>store.dispatch(END)</code> 코드를 넣어서 saga가 액션을 모니터링 하는것을 방지합니다.</li>\n<li><code>thunk</code> 에서 <code>Promise.all()</code> 하는 곳 바로 위에 <code>await sagaMiddleware.run(rootSaga).toPromise()</code> 넣어주고 진행 중이던 사가들이 모두 끝날때 까지 기다려줍니다.</li>\n</ul>\n<h2>서버 사이드 렌더링과 코드 스플리팅</h2>\n<p>이 부분이 중요한 이유는 서버 사이드 렌더링해서 전부 렌더링이 진행 된 이후 클라이언트 사이드에서 js가 다 불러져 온 뒤로 다시 비동기로 컴포넌트를 불러올때 깜빡임이 발생 하기 때문입니다.</p>\n<ul>\n<li><code>Loadable Components</code>를 사용할 것을 권장하고 있습니다.</li>\n<li>서버 유틸 함수, 웹팩 플러그인, babel 플러그인을 제공합니다.</li>\n<li>페이지 컴포넌트를 <code>loadable()</code> 메서드로 감싸서 Route에 적용합니다.</li>\n<li>웹팩과 바벨을 설정하면 <code>loadable-stats.json</code> 이라는 파일이 만들어 집니다.</li>\n<li><code>loadable-stats.json</code> 이 파일은 각 컴포넌트 코드가 어떤 청크파일에 들어가 있는지에 대한 정보를 가지고 있다고 보면 됩니다.</li>\n<li>서버 사이드 렌더링을 할 때 이 파일을 참고하여 어떤 컴포넌트가 렌더링 되었는지에 따라 어떤 파일들을 사전에 불러와야 할지 설정할 수 있습니다.</li>\n</ul>\n<h2>loadableReady &#x26; hydrate</h2>\n<ul>\n<li><code>Loadable Component</code>를 사용하면 성능 최적화를 위해 js 파일을 모두 불러오는데 이때 모든 js 파일이 로딩되고 나서 렌더링을 할 수있도록 하는 것이 <code>loadableReady</code> 입니다.</li>\n<li>추가로 <code>render()</code> 메서드가 아닌 <code>hydrate()</code> 메서드가 존재하는데 이것은 기존에 존재하는 UI에 이벤트만 연동하여 성능을 최적화 시켜줍니다. 하지만 기존에 존재하는 UI 와 <code>hydrate()</code> 메서드에서 비교하려는 컴포넌트랑 다르면 에러가 뜬다는 사실이 있습니다.</li>\n</ul>",frontmatter:{title:"react SSR",date:"April 23, 2020"}}},pathContext:{slug:"/react-ssr/"}}}});
//# sourceMappingURL=path---react-ssr-b91bf25e1b9aa24a4c14.js.map